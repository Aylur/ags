
/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 */

import './gio-2.0-import.d.ts';
/**
 * Gio-2.0
 */

import type GObject from './gobject-2.0.js';
import type GLib from './glib-2.0.js';

export namespace Gio {

/**
 * An enumeration for well-known message buses.
 */
enum BusType {
    /**
     * An alias for the message bus that activated the process, if any.
     */
    STARTER,
    /**
     * Not a message bus.
     */
    NONE,
    /**
     * The system-wide message bus.
     */
    SYSTEM,
    /**
     * The login session message bus.
     */
    SESSION,
}
/**
 * Results returned from g_converter_convert().
 */
enum ConverterResult {
    /**
     * There was an error during conversion.
     */
    ERROR,
    /**
     * Some data was consumed or produced
     */
    CONVERTED,
    /**
     * The conversion is finished
     */
    FINISHED,
    /**
     * Flushing is finished
     */
    FLUSHED,
}
/**
 * Enumeration describing different kinds of native credential types.
 */
enum CredentialsType {
    /**
     * Indicates an invalid native credential type.
     */
    INVALID,
    /**
     * The native credentials type is a `struct ucred`.
     */
    LINUX_UCRED,
    /**
     * The native credentials type is a `struct cmsgcred`.
     */
    FREEBSD_CMSGCRED,
    /**
     * The native credentials type is a `struct sockpeercred`. Added in 2.30.
     */
    OPENBSD_SOCKPEERCRED,
    /**
     * The native credentials type is a `ucred_t`. Added in 2.40.
     */
    SOLARIS_UCRED,
    /**
     * The native credentials type is a `struct unpcbid`. Added in 2.42.
     */
    NETBSD_UNPCBID,
    /**
     * The native credentials type is a `struct xucred`. Added in 2.66.
     */
    APPLE_XUCRED,
    /**
     * The native credentials type is a PID `DWORD`. Added in 2.72.
     */
    WIN32_PID,
}
/**
 * Error codes for the %G_DBUS_ERROR error domain.
 */
enum DBusError {
    /**
     * A generic error; "something went wrong" - see the error message for
     * more.
     */
    FAILED,
    /**
     * There was not enough memory to complete an operation.
     */
    NO_MEMORY,
    /**
     * The bus doesn't know how to launch a service to supply the bus name
     * you wanted.
     */
    SERVICE_UNKNOWN,
    /**
     * The bus name you referenced doesn't exist (i.e. no application owns
     * it).
     */
    NAME_HAS_NO_OWNER,
    /**
     * No reply to a message expecting one, usually means a timeout occurred.
     */
    NO_REPLY,
    /**
     * Something went wrong reading or writing to a socket, for example.
     */
    IO_ERROR,
    /**
     * A D-Bus bus address was malformed.
     */
    BAD_ADDRESS,
    /**
     * Requested operation isn't supported (like ENOSYS on UNIX).
     */
    NOT_SUPPORTED,
    /**
     * Some limited resource is exhausted.
     */
    LIMITS_EXCEEDED,
    /**
     * Security restrictions don't allow doing what you're trying to do.
     */
    ACCESS_DENIED,
    /**
     * Authentication didn't work.
     */
    AUTH_FAILED,
    /**
     * Unable to connect to server (probably caused by ECONNREFUSED on a
     * socket).
     */
    NO_SERVER,
    /**
     * Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
     * %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
     * this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
     * exists. We can't fix it for compatibility reasons so just be
     * careful.
     */
    TIMEOUT,
    /**
     * No network access (probably ENETUNREACH on a socket).
     */
    NO_NETWORK,
    /**
     * Can't bind a socket since its address is in use (i.e. EADDRINUSE).
     */
    ADDRESS_IN_USE,
    /**
     * The connection is disconnected and you're trying to use it.
     */
    DISCONNECTED,
    /**
     * Invalid arguments passed to a method call.
     */
    INVALID_ARGS,
    /**
     * Missing file.
     */
    FILE_NOT_FOUND,
    /**
     * Existing file and the operation you're using does not silently overwrite.
     */
    FILE_EXISTS,
    /**
     * Method name you invoked isn't known by the object you invoked it on.
     */
    UNKNOWN_METHOD,
    /**
     * Certain timeout errors, e.g. while starting a service. Warning: this is
     * confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
     * can't fix it for compatibility reasons so just be careful.
     */
    TIMED_OUT,
    /**
     * Tried to remove or modify a match rule that didn't exist.
     */
    MATCH_RULE_NOT_FOUND,
    /**
     * The match rule isn't syntactically valid.
     */
    MATCH_RULE_INVALID,
    /**
     * While starting a new process, the exec() call failed.
     */
    SPAWN_EXEC_FAILED,
    /**
     * While starting a new process, the fork() call failed.
     */
    SPAWN_FORK_FAILED,
    /**
     * While starting a new process, the child exited with a status code.
     */
    SPAWN_CHILD_EXITED,
    /**
     * While starting a new process, the child exited on a signal.
     */
    SPAWN_CHILD_SIGNALED,
    /**
     * While starting a new process, something went wrong.
     */
    SPAWN_FAILED,
    /**
     * We failed to setup the environment correctly.
     */
    SPAWN_SETUP_FAILED,
    /**
     * We failed to setup the config parser correctly.
     */
    SPAWN_CONFIG_INVALID,
    /**
     * Bus name was not valid.
     */
    SPAWN_SERVICE_INVALID,
    /**
     * Service file not found in system-services directory.
     */
    SPAWN_SERVICE_NOT_FOUND,
    /**
     * Permissions are incorrect on the setuid helper.
     */
    SPAWN_PERMISSIONS_INVALID,
    /**
     * Service file invalid (Name, User or Exec missing).
     */
    SPAWN_FILE_INVALID,
    /**
     * Tried to get a UNIX process ID and it wasn't available.
     */
    SPAWN_NO_MEMORY,
    /**
     * Tried to get a UNIX process ID and it wasn't available.
     */
    UNIX_PROCESS_ID_UNKNOWN,
    /**
     * A type signature is not valid.
     */
    INVALID_SIGNATURE,
    /**
     * A file contains invalid syntax or is otherwise broken.
     */
    INVALID_FILE_CONTENT,
    /**
     * Asked for SELinux security context and it wasn't available.
     */
    SELINUX_SECURITY_CONTEXT_UNKNOWN,
    /**
     * Asked for ADT audit data and it wasn't available.
     */
    ADT_AUDIT_DATA_UNKNOWN,
    /**
     * There's already an object with the requested object path.
     */
    OBJECT_PATH_IN_USE,
    /**
     * Object you invoked a method on isn't known. Since 2.42
     */
    UNKNOWN_OBJECT,
    /**
     * Interface you invoked a method on isn't known by the object. Since 2.42
     */
    UNKNOWN_INTERFACE,
    /**
     * Property you tried to access isn't known by the object. Since 2.42
     */
    UNKNOWN_PROPERTY,
    /**
     * Property you tried to set is read-only. Since 2.42
     */
    PROPERTY_READ_ONLY,
}
/**
 * Enumeration used to describe the byte order of a D-Bus message.
 */
enum DBusMessageByteOrder {
    /**
     * The byte order is big endian.
     */
    BIG_ENDIAN,
    /**
     * The byte order is little endian.
     */
    LITTLE_ENDIAN,
}
/**
 * Header fields used in #GDBusMessage.
 */
enum DBusMessageHeaderField {
    /**
     * Not a valid header field.
     */
    INVALID,
    /**
     * The object path.
     */
    PATH,
    /**
     * The interface name.
     */
    INTERFACE,
    /**
     * The method or signal name.
     */
    MEMBER,
    /**
     * The name of the error that occurred.
     */
    ERROR_NAME,
    /**
     * The serial number the message is a reply to.
     */
    REPLY_SERIAL,
    /**
     * The name the message is intended for.
     */
    DESTINATION,
    /**
     * Unique name of the sender of the message (filled in by the bus).
     */
    SENDER,
    /**
     * The signature of the message body.
     */
    SIGNATURE,
    /**
     * The number of UNIX file descriptors that accompany the message.
     */
    NUM_UNIX_FDS,
}
/**
 * Message types used in #GDBusMessage.
 */
enum DBusMessageType {
    /**
     * Message is of invalid type.
     */
    INVALID,
    /**
     * Method call.
     */
    METHOD_CALL,
    /**
     * Method reply.
     */
    METHOD_RETURN,
    /**
     * Error reply.
     */
    ERROR,
    /**
     * Signal emission.
     */
    SIGNAL,
}
/**
 * #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
 * across various machine architectures.
 */
enum DataStreamByteOrder {
    /**
     * Selects Big Endian byte order.
     */
    BIG_ENDIAN,
    /**
     * Selects Little Endian byte order.
     */
    LITTLE_ENDIAN,
    /**
     * Selects endianness based on host machine's architecture.
     */
    HOST_ENDIAN,
}
/**
 * #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
 */
enum DataStreamNewlineType {
    /**
     * Selects "LF" line endings, common on most modern UNIX platforms.
     */
    LF,
    /**
     * Selects "CR" line endings.
     */
    CR,
    /**
     * Selects "CR, LF" line ending, common on Microsoft Windows.
     */
    CR_LF,
    /**
     * Automatically try to handle any line ending type.
     */
    ANY,
}
/**
 * Enumeration describing how a drive can be started/stopped.
 */
enum DriveStartStopType {
    /**
     * Unknown or drive doesn't support
     *    start/stop.
     */
    UNKNOWN,
    /**
     * The stop method will physically
     *    shut down the drive and e.g. power down the port the drive is
     *    attached to.
     */
    SHUTDOWN,
    /**
     * The start/stop methods are used
     *    for connecting/disconnect to the drive over the network.
     */
    NETWORK,
    /**
     * The start/stop methods will
     *    assemble/disassemble a virtual drive from several physical
     *    drives.
     */
    MULTIDISK,
    /**
     * The start/stop methods will
     *    unlock/lock the disk (for example using the ATA <quote>SECURITY
     *    UNLOCK DEVICE</quote> command)
     */
    PASSWORD,
}
/**
 * GEmblemOrigin is used to add information about the origin of the emblem
 * to #GEmblem.
 */
enum EmblemOrigin {
    /**
     * Emblem of unknown origin
     */
    UNKNOWN,
    /**
     * Emblem adds device-specific information
     */
    DEVICE,
    /**
     * Emblem depicts live metadata, such as "readonly"
     */
    LIVEMETADATA,
    /**
     * Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
     */
    TAG,
}
/**
 * Used by g_file_set_attributes_from_info() when setting file attributes.
 */
enum FileAttributeStatus {
    /**
     * Attribute value is unset (empty).
     */
    UNSET,
    /**
     * Attribute value is set.
     */
    SET,
    /**
     * Indicates an error in setting the value.
     */
    ERROR_SETTING,
}
/**
 * The data types for file attributes.
 */
enum FileAttributeType {
    /**
     * indicates an invalid or uninitialized type.
     */
    INVALID,
    /**
     * a null terminated UTF8 string.
     */
    STRING,
    /**
     * a zero terminated string of non-zero bytes.
     */
    BYTE_STRING,
    /**
     * a boolean value.
     */
    BOOLEAN,
    /**
     * an unsigned 4-byte/32-bit integer.
     */
    UINT32,
    /**
     * a signed 4-byte/32-bit integer.
     */
    INT32,
    /**
     * an unsigned 8-byte/64-bit integer.
     */
    UINT64,
    /**
     * a signed 8-byte/64-bit integer.
     */
    INT64,
    /**
     * a #GObject.
     */
    OBJECT,
    /**
     * a %NULL terminated char **. Since 2.22
     */
    STRINGV,
}
/**
 * Specifies what type of event a monitor event is.
 */
enum FileMonitorEvent {
    /**
     * a file changed.
     */
    CHANGED,
    /**
     * a hint that this was probably the last change in a set of changes.
     */
    CHANGES_DONE_HINT,
    /**
     * a file was deleted.
     */
    DELETED,
    /**
     * a file was created.
     */
    CREATED,
    /**
     * a file attribute was changed.
     */
    ATTRIBUTE_CHANGED,
    /**
     * the file location will soon be unmounted.
     */
    PRE_UNMOUNT,
    /**
     * the file location was unmounted.
     */
    UNMOUNTED,
    /**
     * the file was moved -- only sent if the
     *   (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
     */
    MOVED,
    /**
     * the file was renamed within the
     *   current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
     *   flag is set.  Since: 2.46.
     */
    RENAMED,
    /**
     * the file was moved into the
     *   monitored directory from another location -- only sent if the
     *   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
     */
    MOVED_IN,
    /**
     * the file was moved out of the
     *   monitored directory to another location -- only sent if the
     *   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
     */
    MOVED_OUT,
}
/**
 * Indicates the file's on-disk type.
 * 
 * On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
 * use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
 * whether a file is a symlink or not. This is due to the fact that NTFS does
 * not have a single filesystem object type for symbolic links - it has
 * files that symlink to files, and directories that symlink to directories.
 * #GFileType enumeration cannot precisely represent this important distinction,
 * which is why all Windows symlinks will continue to be reported as
 * %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.
 */
enum FileType {
    /**
     * File's type is unknown.
     */
    UNKNOWN,
    /**
     * File handle represents a regular file.
     */
    REGULAR,
    /**
     * File handle represents a directory.
     */
    DIRECTORY,
    /**
     * File handle represents a symbolic link
     *    (Unix systems).
     */
    SYMBOLIC_LINK,
    /**
     * File is a "special" file, such as a socket, fifo,
     *    block device, or character device.
     */
    SPECIAL,
    /**
     * File is a shortcut (Windows systems).
     */
    SHORTCUT,
    /**
     * File is a mountable location.
     */
    MOUNTABLE,
}
/**
 * Indicates a hint from the file system whether files should be
 * previewed in a file manager. Returned as the value of the key
 * %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
 */
enum FilesystemPreviewType {
    /**
     * Only preview files if user has explicitly requested it.
     */
    IF_ALWAYS,
    /**
     * Preview files if user has requested preview of "local" files.
     */
    IF_LOCAL,
    /**
     * Never preview files.
     */
    NEVER,
}
/**
 * Error codes returned by GIO functions.
 * 
 * Note that this domain may be extended in future GLib releases. In
 * general, new error codes either only apply to new APIs, or else
 * replace %G_IO_ERROR_FAILED in cases that were not explicitly
 * distinguished before. You should therefore avoid writing code like
 * 
 * ```c
 * if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
 *   {
 *     // Assume that this is EPRINTERONFIRE
 *     ...
 *   }
 * ```
 * 
 * but should instead treat all unrecognized error codes the same as
 * %G_IO_ERROR_FAILED.
 * 
 * See also #GPollableReturn for a cheaper way of returning
 * %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError.
 */
enum IOErrorEnum {
    /**
     * Generic error condition for when an operation fails
     *     and no more specific #GIOErrorEnum value is defined.
     */
    FAILED,
    /**
     * File not found.
     */
    NOT_FOUND,
    /**
     * File already exists.
     */
    EXISTS,
    /**
     * File is a directory.
     */
    IS_DIRECTORY,
    /**
     * File is not a directory.
     */
    NOT_DIRECTORY,
    /**
     * File is a directory that isn't empty.
     */
    NOT_EMPTY,
    /**
     * File is not a regular file.
     */
    NOT_REGULAR_FILE,
    /**
     * File is not a symbolic link.
     */
    NOT_SYMBOLIC_LINK,
    /**
     * File cannot be mounted.
     */
    NOT_MOUNTABLE_FILE,
    /**
     * Filename is too many characters.
     */
    FILENAME_TOO_LONG,
    /**
     * Filename is invalid or contains invalid characters.
     */
    INVALID_FILENAME,
    /**
     * File contains too many symbolic links.
     */
    TOO_MANY_LINKS,
    /**
     * No space left on drive.
     */
    NO_SPACE,
    /**
     * Invalid argument.
     */
    INVALID_ARGUMENT,
    /**
     * Permission denied.
     */
    PERMISSION_DENIED,
    /**
     * Operation (or one of its parameters) not supported
     */
    NOT_SUPPORTED,
    /**
     * File isn't mounted.
     */
    NOT_MOUNTED,
    /**
     * File is already mounted.
     */
    ALREADY_MOUNTED,
    /**
     * File was closed.
     */
    CLOSED,
    /**
     * Operation was cancelled. See #GCancellable.
     */
    CANCELLED,
    /**
     * Operations are still pending.
     */
    PENDING,
    /**
     * File is read only.
     */
    READ_ONLY,
    /**
     * Backup couldn't be created.
     */
    CANT_CREATE_BACKUP,
    /**
     * File's Entity Tag was incorrect.
     */
    WRONG_ETAG,
    /**
     * Operation timed out.
     */
    TIMED_OUT,
    /**
     * Operation would be recursive.
     */
    WOULD_RECURSE,
    /**
     * File is busy.
     */
    BUSY,
    /**
     * Operation would block.
     */
    WOULD_BLOCK,
    /**
     * Host couldn't be found (remote operations).
     */
    HOST_NOT_FOUND,
    /**
     * Operation would merge files.
     */
    WOULD_MERGE,
    /**
     * Operation failed and a helper program has
     *     already interacted with the user. Do not display any error dialog.
     */
    FAILED_HANDLED,
    /**
     * The current process has too many files
     *     open and can't open any more. Duplicate descriptors do count toward
     *     this limit. Since 2.20
     */
    TOO_MANY_OPEN_FILES,
    /**
     * The object has not been initialized. Since 2.22
     */
    NOT_INITIALIZED,
    /**
     * The requested address is already in use. Since 2.22
     */
    ADDRESS_IN_USE,
    /**
     * Need more input to finish operation. Since 2.24
     */
    PARTIAL_INPUT,
    /**
     * The input data was invalid. Since 2.24
     */
    INVALID_DATA,
    /**
     * A remote object generated an error that
     *     doesn't correspond to a locally registered #GError error
     *     domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
     *     error name and g_dbus_error_strip_remote_error() to fix up the
     *     message so it matches what was received on the wire. Since 2.26.
     */
    DBUS_ERROR,
    /**
     * Host unreachable. Since 2.26
     */
    HOST_UNREACHABLE,
    /**
     * Network unreachable. Since 2.26
     */
    NETWORK_UNREACHABLE,
    /**
     * Connection refused. Since 2.26
     */
    CONNECTION_REFUSED,
    /**
     * Connection to proxy server failed. Since 2.26
     */
    PROXY_FAILED,
    /**
     * Proxy authentication failed. Since 2.26
     */
    PROXY_AUTH_FAILED,
    /**
     * Proxy server needs authentication. Since 2.26
     */
    PROXY_NEED_AUTH,
    /**
     * Proxy connection is not allowed by ruleset.
     *     Since 2.26
     */
    PROXY_NOT_ALLOWED,
    /**
     * Broken pipe. Since 2.36
     */
    BROKEN_PIPE,
    /**
     * Connection closed by peer. Note that this
     *     is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
     *     "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
     *     returned %G_IO_ERROR_FAILED. Now they should all return the same
     *     value, which has this more logical name. Since 2.44.
     */
    CONNECTION_CLOSED,
    /**
     * Transport endpoint is not connected. Since 2.44
     */
    NOT_CONNECTED,
    /**
     * Message too large. Since 2.48.
     */
    MESSAGE_TOO_LARGE,
    /**
     * No such device found. Since 2.74
     */
    NO_SUCH_DEVICE,
}
/**
 * Flags for use with g_io_module_scope_new().
 */
enum IOModuleScopeFlags {
    /**
     * No module scan flags
     */
    NONE,
    /**
     * When using this scope to load or
     *     scan modules, automatically block a modules which has the same base
     *     basename as previously loaded module.
     */
    BLOCK_DUPLICATES,
}
/**
 * Memory availability warning levels.
 * 
 * Note that because new values might be added, it is recommended that applications check
 * #GMemoryMonitorWarningLevel as ranges, for example:
 * 
 * ```c
 * if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
 *   drop_caches ();
 * ```
 * 
 */
enum MemoryMonitorWarningLevel {
    /**
     * Memory on the device is low, processes
     *   should free up unneeded resources (for example, in-memory caches) so they can
     *   be used elsewhere.
     */
    LOW,
    /**
     * Same as `G_MEMORY_MONITOR_WARNING_LEVEL_LOW`
     *   but the device has even less free memory, so processes should try harder to free
     *   up unneeded resources. If your process does not need to stay running, it is a
     *   good time for it to quit.
     */
    MEDIUM,
    /**
     * The system will soon start terminating
     *   processes to reclaim memory, including background processes.
     */
    CRITICAL,
}
/**
 * #GMountOperationResult is returned as a result when a request for
 * information is send by the mounting operation.
 */
enum MountOperationResult {
    /**
     * The request was fulfilled and the
     *     user specified data is now available
     */
    HANDLED,
    /**
     * The user requested the mount operation
     *     to be aborted
     */
    ABORTED,
    /**
     * The request was unhandled (i.e. not
     *     implemented)
     */
    UNHANDLED,
}
/**
 * The host's network connectivity state, as reported by #GNetworkMonitor.
 */
enum NetworkConnectivity {
    /**
     * The host is not configured with a
     *   route to the Internet; it may or may not be connected to a local
     *   network.
     */
    LOCAL,
    /**
     * The host is connected to a network, but
     *   does not appear to be able to reach the full Internet, perhaps
     *   due to upstream network problems.
     */
    LIMITED,
    /**
     * The host is behind a captive portal and
     *   cannot reach the full Internet.
     */
    PORTAL,
    /**
     * The host is connected to a network, and
     *   appears to be able to reach the full Internet.
     */
    FULL,
}
/**
 * Priority levels for #GNotifications.
 */
enum NotificationPriority {
    /**
     * the default priority, to be used for the
     *   majority of notifications (for example email messages, software updates,
     *   completed download/sync operations)
     */
    NORMAL,
    /**
     * for notifications that do not require
     *   immediate attention - typically used for contextual background
     *   information, such as contact birthdays or local weather
     */
    LOW,
    /**
     * for events that require more attention,
     *   usually because responses are time-sensitive (for example chat and SMS
     *   messages or alarms)
     */
    HIGH,
    /**
     * for urgent notifications, or notifications
     *   that require a response in a short space of time (for example phone calls
     *   or emergency warnings)
     */
    URGENT,
}
/**
 * #GPasswordSave is used to indicate the lifespan of a saved password.
 * 
 * #Gvfs stores passwords in the Gnome keyring when this flag allows it
 * to, and later retrieves it again from there.
 */
enum PasswordSave {
    /**
     * never save a password.
     */
    NEVER,
    /**
     * save a password for the session.
     */
    FOR_SESSION,
    /**
     * save a password permanently.
     */
    PERMANENTLY,
}
/**
 * Return value for various IO operations that signal errors via the
 * return value and not necessarily via a #GError.
 * 
 * This enum exists to be able to return errors to callers without having to
 * allocate a #GError. Allocating #GErrors can be quite expensive for
 * regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
 * 
 * In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
 * operation to give details about the error that happened.
 */
enum PollableReturn {
    /**
     * Generic error condition for when an operation fails.
     */
    FAILED,
    /**
     * The operation was successfully finished.
     */
    OK,
    /**
     * The operation would block.
     */
    WOULD_BLOCK,
}
/**
 * An error code used with %G_RESOLVER_ERROR in a #GError returned
 * from a #GResolver routine.
 */
enum ResolverError {
    /**
     * the requested name/address/service was not
     *     found
     */
    NOT_FOUND,
    /**
     * the requested information could not
     *     be looked up due to a network error or similar problem
     */
    TEMPORARY_FAILURE,
    /**
     * unknown error
     */
    INTERNAL,
}
/**
 * The type of record that g_resolver_lookup_records() or
 * g_resolver_lookup_records_async() should retrieve. The records are returned
 * as lists of #GVariant tuples. Each record type has different values in
 * the variant tuples returned.
 * 
 * %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
 * `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
 * weight, a `guint16` with the port, and a string of the hostname.
 * 
 * %G_RESOLVER_RECORD_MX records are returned as variants with the signature
 * `(qs)`, representing a `guint16` with the preference, and a string containing
 * the mail exchanger hostname.
 * 
 * %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
 * `(as)`, representing an array of the strings in the text record. Note: Most TXT
 * records only contain a single string, but
 * [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
 * record to contain multiple strings. The RFC which defines the interpretation
 * of a specific TXT record will likely require concatenation of multiple
 * strings if they are present, as with
 * [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
 * 
 * %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
 * `(ssuuuuu)`, representing a string containing the primary name server, a
 * string containing the administrator, the serial as a `guint32`, the refresh
 * interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
 * as a `guint32`, and the TTL as a `guint32`.
 * 
 * %G_RESOLVER_RECORD_NS records are returned as variants with the signature
 * `(s)`, representing a string of the hostname of the name server.
 */
enum ResolverRecordType {
    /**
     * look up DNS SRV records for a domain
     */
    SRV,
    /**
     * look up DNS MX records for a domain
     */
    MX,
    /**
     * look up DNS TXT records for a name
     */
    TXT,
    /**
     * look up DNS SOA records for a zone
     */
    SOA,
    /**
     * look up DNS NS records for a domain
     */
    NS,
}
/**
 * An error code used with %G_RESOURCE_ERROR in a #GError returned
 * from a #GResource routine.
 */
enum ResourceError {
    /**
     * no file was found at the requested path
     */
    NOT_FOUND,
    /**
     * unknown error
     */
    INTERNAL,
}
/**
 * Describes an event occurring on a #GSocketClient. See the
 * #GSocketClient::event signal for more details.
 * 
 * Additional values may be added to this type in the future.
 */
enum SocketClientEvent {
    /**
     * The client is doing a DNS lookup.
     */
    RESOLVING,
    /**
     * The client has completed a DNS lookup.
     */
    RESOLVED,
    /**
     * The client is connecting to a remote
     *   host (either a proxy or the destination server).
     */
    CONNECTING,
    /**
     * The client has connected to a remote
     *   host.
     */
    CONNECTED,
    /**
     * The client is negotiating
     *   with a proxy to connect to the destination server.
     */
    PROXY_NEGOTIATING,
    /**
     * The client has negotiated
     *   with the proxy server.
     */
    PROXY_NEGOTIATED,
    /**
     * The client is performing a
     *   TLS handshake.
     */
    TLS_HANDSHAKING,
    /**
     * The client has performed a
     *   TLS handshake.
     */
    TLS_HANDSHAKED,
    /**
     * The client is done with a particular
     *   #GSocketConnectable.
     */
    COMPLETE,
}
/**
 * The protocol family of a #GSocketAddress. (These values are
 * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
 * if available.)
 */
enum SocketFamily {
    /**
     * no address family
     */
    INVALID,
    /**
     * the UNIX domain family
     */
    UNIX,
    /**
     * the IPv4 family
     */
    IPV4,
    /**
     * the IPv6 family
     */
    IPV6,
}
/**
 * Describes an event occurring on a #GSocketListener. See the
 * #GSocketListener::event signal for more details.
 * 
 * Additional values may be added to this type in the future.
 */
enum SocketListenerEvent {
    /**
     * The listener is about to bind a socket.
     */
    BINDING,
    /**
     * The listener has bound a socket.
     */
    BOUND,
    /**
     * The listener is about to start
     *    listening on this socket.
     */
    LISTENING,
    /**
     * The listener is now listening on
     *   this socket.
     */
    LISTENED,
}
/**
 * A protocol identifier is specified when creating a #GSocket, which is a
 * family/type specific identifier, where 0 means the default protocol for
 * the particular family/type.
 * 
 * This enum contains a set of commonly available and used protocols. You
 * can also pass any other identifiers handled by the platform in order to
 * use protocols not listed here.
 */
enum SocketProtocol {
    /**
     * The protocol type is unknown
     */
    UNKNOWN,
    /**
     * The default protocol for the family/type
     */
    DEFAULT,
    /**
     * TCP over IP
     */
    TCP,
    /**
     * UDP over IP
     */
    UDP,
    /**
     * SCTP over IP
     */
    SCTP,
}
/**
 * Flags used when creating a #GSocket. Some protocols may not implement
 * all the socket types.
 */
enum SocketType {
    /**
     * Type unknown or wrong
     */
    INVALID,
    /**
     * Reliable connection-based byte streams (e.g. TCP).
     */
    STREAM,
    /**
     * Connectionless, unreliable datagram passing.
     *     (e.g. UDP)
     */
    DATAGRAM,
    /**
     * Reliable connection-based passing of datagrams
     *     of fixed maximum length (e.g. SCTP).
     */
    SEQPACKET,
}
/**
 * The client authentication mode for a #GTlsServerConnection.
 */
enum TlsAuthenticationMode {
    /**
     * client authentication not required
     */
    NONE,
    /**
     * client authentication is requested
     */
    REQUESTED,
    /**
     * client authentication is required
     */
    REQUIRED,
}
/**
 * Flags for g_tls_interaction_request_certificate(),
 * g_tls_interaction_request_certificate_async(), and
 * g_tls_interaction_invoke_request_certificate().
 */
enum TlsCertificateRequestFlags {
    /**
     * No flags
     */
    NONE,
}
/**
 * An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to
 * indicate a TLS channel binding retrieval error.
 */
enum TlsChannelBindingError {
    /**
     * Either entire binding
     *    retrieval facility or specific binding type is not implemented in the
     *    TLS backend.
     */
    NOT_IMPLEMENTED,
    /**
     * The handshake is not yet
     *    complete on the connection which is a strong requirement for any existing
     *    binding type.
     */
    INVALID_STATE,
    /**
     * Handshake is complete but
     *    binding data is not available. That normally indicates the TLS
     *    implementation failed to provide the binding data. For example, some
     *    implementations do not provide a peer certificate for resumed connections.
     */
    NOT_AVAILABLE,
    /**
     * Binding type is not supported
     *    on the current connection. This error could be triggered when requesting
     *    `tls-server-end-point` binding data for a certificate which has no hash
     *    function or uses multiple hash functions.
     */
    NOT_SUPPORTED,
    /**
     * Any other backend error
     *    preventing binding data retrieval.
     */
    GENERAL_ERROR,
}
/**
 * The type of TLS channel binding data to retrieve from #GTlsConnection
 * or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
 * [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
 * binding type is not currently implemented.
 */
enum TlsChannelBindingType {
    /**
     * [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
     *    type
     */
    UNIQUE,
    /**
     * [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
     *    binding type
     */
    SERVER_END_POINT,
    /**
     * [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding
     *    type. Since: 2.74
     */
    EXPORTER,
}
/**
 * Flags for g_tls_database_lookup_certificate_for_handle(),
 * g_tls_database_lookup_certificate_issuer(),
 * and g_tls_database_lookup_certificates_issued_by().
 */
enum TlsDatabaseLookupFlags {
    /**
     * No lookup flags
     */
    NONE,
    /**
     * Restrict lookup to certificates that have
     *     a private key.
     */
    KEYPAIR,
}
/**
 * An error code used with %G_TLS_ERROR in a #GError returned from a
 * TLS-related routine.
 */
enum TlsError {
    /**
     * No TLS provider is available
     */
    UNAVAILABLE,
    /**
     * Miscellaneous TLS error
     */
    MISC,
    /**
     * The certificate presented could not
     *   be parsed or failed validation.
     */
    BAD_CERTIFICATE,
    /**
     * The TLS handshake failed because the
     *   peer does not seem to be a TLS server.
     */
    NOT_TLS,
    /**
     * The TLS handshake failed because the
     *   peer's certificate was not acceptable.
     */
    HANDSHAKE,
    /**
     * The TLS handshake failed because
     *   the server requested a client-side certificate, but none was
     *   provided. See g_tls_connection_set_certificate().
     */
    CERTIFICATE_REQUIRED,
    /**
     * The TLS connection was closed without proper
     *   notice, which may indicate an attack. See
     *   g_tls_connection_set_require_close_notify().
     */
    EOF,
    /**
     * The TLS handshake failed
     *   because the client sent the fallback SCSV, indicating a protocol
     *   downgrade attack. Since: 2.60
     */
    INAPPROPRIATE_FALLBACK,
    /**
     * The certificate failed
     *   to load because a password was incorrect. Since: 2.72
     */
    BAD_CERTIFICATE_PASSWORD,
}
/**
 * #GTlsInteractionResult is returned by various functions in #GTlsInteraction
 * when finishing an interaction request.
 */
enum TlsInteractionResult {
    /**
     * The interaction was unhandled (i.e. not
     *     implemented).
     */
    UNHANDLED,
    /**
     * The interaction completed, and resulting data
     *     is available.
     */
    HANDLED,
    /**
     * The interaction has failed, or was cancelled.
     *     and the operation should be aborted.
     */
    FAILED,
}
/**
 * The TLS or DTLS protocol version used by a #GTlsConnection or
 * #GDtlsConnection. The integer values of these versions are sequential
 * to ensure newer known protocol versions compare greater than older
 * known versions. Any known DTLS protocol version will compare greater
 * than any SSL or TLS protocol version. The protocol version may be
 * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
 * protocol version that GLib does not yet know about. This means that
 * it's possible for an unknown DTLS protocol version to compare less
 * than the TLS protocol versions.
 */
enum TlsProtocolVersion {
    /**
     * No protocol version or unknown protocol version
     */
    UNKNOWN,
    /**
     * SSL 3.0, which is insecure and should not be used
     */
    SSL_3_0,
    /**
     * TLS 1.0, which is insecure and should not be used
     */
    TLS_1_0,
    /**
     * TLS 1.1, which is insecure and should not be used
     */
    TLS_1_1,
    /**
     * TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
     */
    TLS_1_2,
    /**
     * TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
     */
    TLS_1_3,
    /**
     * DTLS 1.0, which is insecure and should not be used
     */
    DTLS_1_0,
    /**
     * DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
     */
    DTLS_1_2,
}
/**
 * When to allow rehandshaking. See
 * g_tls_connection_set_rehandshake_mode().
 */
enum TlsRehandshakeMode {
    /**
     * Never allow rehandshaking
     */
    NEVER,
    /**
     * Allow safe rehandshaking only
     */
    SAFELY,
    /**
     * Allow unsafe rehandshaking
     */
    UNSAFELY,
}
/**
 * The type of name used by a #GUnixSocketAddress.
 * %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
 * socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
 * indicates a socket not bound to any name (eg, a client-side socket,
 * or a socket created with socketpair()).
 * 
 * For abstract sockets, there are two incompatible ways of naming
 * them; the man pages suggest using the entire `struct sockaddr_un`
 * as the name, padding the unused parts of the %sun_path field with
 * zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
 * However, many programs instead just use a portion of %sun_path, and
 * pass an appropriate smaller length to bind() or connect(). This is
 * %G_UNIX_SOCKET_ADDRESS_ABSTRACT.
 */
enum UnixSocketAddressType {
    /**
     * invalid
     */
    INVALID,
    /**
     * anonymous
     */
    ANONYMOUS,
    /**
     * a filesystem path
     */
    PATH,
    /**
     * an abstract name
     */
    ABSTRACT,
    /**
     * an abstract name, 0-padded
     *   to the full length of a unix socket name
     */
    ABSTRACT_PADDED,
}
/**
 * Used to select the type of data format to use for #GZlibDecompressor
 * and #GZlibCompressor.
 */
enum ZlibCompressorFormat {
    /**
     * deflate compression with zlib header
     */
    ZLIB,
    /**
     * gzip file format
     */
    GZIP,
    /**
     * deflate compression with no header
     */
    RAW,
}
/**
 * Flags used when creating a #GAppInfo.
 * @bitfield 
 */
enum AppInfoCreateFlags {
    /**
     * No flags.
     */
    NONE,
    /**
     * Application opens in a terminal window.
     */
    NEEDS_TERMINAL,
    /**
     * Application supports URI arguments.
     */
    SUPPORTS_URIS,
    /**
     * Application supports startup notification. Since 2.26
     */
    SUPPORTS_STARTUP_NOTIFICATION,
}
/**
 * Flags used to define the behaviour of a #GApplication.
 * @bitfield 
 */
enum ApplicationFlags {
    /**
     * Default. Deprecated in 2.74, use
     *   %G_APPLICATION_DEFAULT_FLAGS instead
     */
    FLAGS_NONE,
    /**
     * Default flags. Since: 2.74
     */
    DEFAULT_FLAGS,
    /**
     * Run as a service. In this mode, registration
     *      fails if the service is already running, and the application
     *      will initially wait up to 10 seconds for an initial activation
     *      message to arrive.
     */
    IS_SERVICE,
    /**
     * Don't try to become the primary instance.
     */
    IS_LAUNCHER,
    /**
     * This application handles opening files (in
     *     the primary instance). Note that this flag only affects the default
     *     implementation of local_command_line(), and has no effect if
     *     %G_APPLICATION_HANDLES_COMMAND_LINE is given.
     *     See g_application_run() for details.
     */
    HANDLES_OPEN,
    /**
     * This application handles command line
     *     arguments (in the primary instance). Note that this flag only affect
     *     the default implementation of local_command_line().
     *     See g_application_run() for details.
     */
    HANDLES_COMMAND_LINE,
    /**
     * Send the environment of the
     *     launching process to the primary instance. Set this flag if your
     *     application is expected to behave differently depending on certain
     *     environment variables. For instance, an editor might be expected
     *     to use the `GIT_COMMITTER_NAME` environment variable
     *     when editing a git commit message. The environment is available
     *     to the #GApplication::command-line signal handler, via
     *     g_application_command_line_getenv().
     */
    SEND_ENVIRONMENT,
    /**
     * Make no attempts to do any of the typical
     *     single-instance application negotiation, even if the application
     *     ID is given.  The application neither attempts to become the
     *     owner of the application ID nor does it check if an existing
     *     owner already exists.  Everything occurs in the local process.
     *     Since: 2.30.
     */
    NON_UNIQUE,
    /**
     * Allow users to override the
     *     application ID from the command line with `--gapplication-app-id`.
     *     Since: 2.48
     */
    CAN_OVERRIDE_APP_ID,
    /**
     * Allow another instance to take over
     *     the bus name. Since: 2.60
     */
    ALLOW_REPLACEMENT,
    /**
     * Take over from another instance. This flag is
     *     usually set by passing `--gapplication-replace` on the commandline.
     *     Since: 2.60
     */
    REPLACE,
}
/**
 * #GAskPasswordFlags are used to request specific information from the
 * user, or to notify the user of their choices in an authentication
 * situation.
 * @bitfield 
 */
enum AskPasswordFlags {
    /**
     * operation requires a password.
     */
    NEED_PASSWORD,
    /**
     * operation requires a username.
     */
    NEED_USERNAME,
    /**
     * operation requires a domain.
     */
    NEED_DOMAIN,
    /**
     * operation supports saving settings.
     */
    SAVING_SUPPORTED,
    /**
     * operation supports anonymous users.
     */
    ANONYMOUS_SUPPORTED,
    /**
     * operation takes TCRYPT parameters (Since: 2.58)
     */
    TCRYPT,
}
/**
 * Flags used in g_bus_own_name().
 * @bitfield 
 */
enum BusNameOwnerFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Allow another message bus connection to claim the name.
     */
    ALLOW_REPLACEMENT,
    /**
     * If another message bus connection owns the name and have
     * specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
     */
    REPLACE,
    /**
     * If another message bus connection owns the name, immediately
     * return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)
     */
    DO_NOT_QUEUE,
}
/**
 * Flags used in g_bus_watch_name().
 * @bitfield 
 */
enum BusNameWatcherFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * If no-one owns the name when
     * beginning to watch the name, ask the bus to launch an owner for the
     * name.
     */
    AUTO_START,
}
/**
 * Flags used when calling a g_converter_convert().
 * @bitfield 
 */
enum ConverterFlags {
    /**
     * No flags.
     */
    NONE,
    /**
     * At end of input data
     */
    INPUT_AT_END,
    /**
     * Flush data
     */
    FLUSH,
}
/**
 * Flags used in g_dbus_connection_call() and similar APIs.
 * @bitfield 
 */
enum DBusCallFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * The bus must not launch
     * an owner for the destination name in response to this method
     * invocation.
     */
    NO_AUTO_START,
    /**
     * the caller is prepared to
     * wait for interactive authorization. Since 2.46.
     */
    ALLOW_INTERACTIVE_AUTHORIZATION,
}
/**
 * Capabilities negotiated with the remote peer.
 * @bitfield 
 */
enum DBusCapabilityFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * The connection
     * supports exchanging UNIX file descriptors with the remote peer.
     */
    UNIX_FD_PASSING,
}
/**
 * Flags used when creating a new #GDBusConnection.
 * @bitfield 
 */
enum DBusConnectionFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Perform authentication against server.
     */
    AUTHENTICATION_CLIENT,
    /**
     * Perform authentication against client.
     */
    AUTHENTICATION_SERVER,
    /**
     * When
     * authenticating as a server, allow the anonymous authentication
     * method.
     */
    AUTHENTICATION_ALLOW_ANONYMOUS,
    /**
     * Pass this flag if connecting to a peer that is a
     * message bus. This means that the Hello() method will be invoked as part of the connection setup.
     */
    MESSAGE_BUS_CONNECTION,
    /**
     * If set, processing of D-Bus messages is
     * delayed until g_dbus_connection_start_message_processing() is called.
     */
    DELAY_MESSAGE_PROCESSING,
    /**
     * When authenticating
     * as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)
     */
    AUTHENTICATION_REQUIRE_SAME_USER,
    /**
     * When authenticating, try to use
     *  protocols that work across a Linux user namespace boundary, even if this
     *  reduces interoperability with older D-Bus implementations. This currently
     *  affects client-side `EXTERNAL` authentication, for which this flag makes
     *  connections to a server in another user namespace succeed, but causes
     *  a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74
     */
    CROSS_NAMESPACE,
}
/**
 * Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
 * @bitfield 
 */
enum DBusInterfaceSkeletonFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Each method invocation is handled in
     *   a thread dedicated to the invocation. This means that the method implementation can use blocking IO
     *   without blocking any other part of the process. It also means that the method implementation must
     *   use locking to access data structures used by other threads.
     */
    HANDLE_METHOD_INVOCATIONS_IN_THREAD,
}
/**
 * Message flags used in #GDBusMessage.
 * @bitfield 
 */
enum DBusMessageFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * A reply is not expected.
     */
    NO_REPLY_EXPECTED,
    /**
     * The bus must not launch an
     * owner for the destination name in response to this message.
     */
    NO_AUTO_START,
    /**
     * If set on a method
     * call, this flag means that the caller is prepared to wait for interactive
     * authorization. Since 2.46.
     */
    ALLOW_INTERACTIVE_AUTHORIZATION,
}
/**
 * Flags used when constructing a #GDBusObjectManagerClient.
 * @bitfield 
 */
enum DBusObjectManagerClientFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * If not set and the
     *   manager is for a well-known name, then request the bus to launch
     *   an owner for the name if no-one owns the name. This flag can only
     *   be used in managers for well-known names.
     */
    DO_NOT_AUTO_START,
}
/**
 * Flags describing the access control of a D-Bus property.
 * @bitfield 
 */
enum DBusPropertyInfoFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Property is readable.
     */
    READABLE,
    /**
     * Property is writable.
     */
    WRITABLE,
}
/**
 * Flags used when constructing an instance of a #GDBusProxy derived class.
 * @bitfield 
 */
enum DBusProxyFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Don't load properties.
     */
    DO_NOT_LOAD_PROPERTIES,
    /**
     * Don't connect to signals on the remote object.
     */
    DO_NOT_CONNECT_SIGNALS,
    /**
     * If the proxy is for a well-known name,
     * do not ask the bus to launch an owner during proxy initialization or a method call.
     * This flag is only meaningful in proxies for well-known names.
     */
    DO_NOT_AUTO_START,
    /**
     * If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
     */
    GET_INVALIDATED_PROPERTIES,
    /**
     * If the proxy is for a well-known name,
     * do not ask the bus to launch an owner during proxy initialization, but allow it to be
     * autostarted by a method call. This flag is only meaningful in proxies for well-known names,
     * and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
     */
    DO_NOT_AUTO_START_AT_CONSTRUCTION,
    /**
     * Don't actually send the AddMatch D-Bus
     *    call for this signal subscription. This gives you more control
     *    over which match rules you add (but you must add them manually). (Since: 2.72)
     */
    NO_MATCH_RULE,
}
/**
 * Flags used when sending #GDBusMessages on a #GDBusConnection.
 * @bitfield 
 */
enum DBusSendMessageFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Do not automatically
     * assign a serial number from the #GDBusConnection object when
     * sending a message.
     */
    PRESERVE_SERIAL,
}
/**
 * Flags used when creating a #GDBusServer.
 * @bitfield 
 */
enum DBusServerFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * All #GDBusServer::new-connection
     * signals will run in separated dedicated threads (see signal for
     * details).
     */
    RUN_IN_THREAD,
    /**
     * Allow the anonymous
     * authentication method.
     */
    AUTHENTICATION_ALLOW_ANONYMOUS,
    /**
     * Require the UID of the
     * peer to be the same as the UID of the server when authenticating. (Since: 2.68)
     */
    AUTHENTICATION_REQUIRE_SAME_USER,
}
/**
 * Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().
 * @bitfield 
 */
enum DBusSignalFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Don't actually send the AddMatch
     * D-Bus call for this signal subscription.  This gives you more control
     * over which match rules you add (but you must add them manually).
     */
    NO_MATCH_RULE,
    /**
     * Match first arguments that
     * contain a bus or interface name with the given namespace.
     */
    MATCH_ARG0_NAMESPACE,
    /**
     * Match first arguments that
     * contain an object path that is either equivalent to the given path,
     * or one of the paths is a subpath of the other.
     */
    MATCH_ARG0_PATH,
}
/**
 * Flags passed to g_dbus_connection_register_subtree().
 * @bitfield 
 */
enum DBusSubtreeFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Method calls to objects not in the enumerated range
     *                                                       will still be dispatched. This is useful if you want
     *                                                       to dynamically spawn objects in the subtree.
     */
    DISPATCH_TO_UNENUMERATED_NODES,
}
/**
 * Flags used when starting a drive.
 * @bitfield 
 */
enum DriveStartFlags {
    /**
     * No flags set.
     */
    NONE,
}
/**
 * Flags specifying the behaviour of an attribute.
 * @bitfield 
 */
enum FileAttributeInfoFlags {
    /**
     * no flags set.
     */
    NONE,
    /**
     * copy the attribute values when the file is copied.
     */
    COPY_WITH_FILE,
    /**
     * copy the attribute values when the file is moved.
     */
    COPY_WHEN_MOVED,
}
/**
 * Flags used when copying or moving files.
 * @bitfield 
 */
enum FileCopyFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Overwrite any existing files
     */
    OVERWRITE,
    /**
     * Make a backup of any existing files.
     */
    BACKUP,
    /**
     * Don't follow symlinks.
     */
    NOFOLLOW_SYMLINKS,
    /**
     * Copy all file metadata instead of just default set used for copy (see #GFileInfo).
     */
    ALL_METADATA,
    /**
     * Don't use copy and delete fallback if native move not supported.
     */
    NO_FALLBACK_FOR_MOVE,
    /**
     * Leaves target file with default perms, instead of setting the source file perms.
     */
    TARGET_DEFAULT_PERMS,
}
/**
 * Flags used when an operation may create a file.
 * @bitfield 
 */
enum FileCreateFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Create a file that can only be
     *    accessed by the current user.
     */
    PRIVATE,
    /**
     * Replace the destination
     *    as if it didn't exist before. Don't try to keep any old
     *    permissions, replace instead of following links. This
     *    is generally useful if you're doing a "copy over"
     *    rather than a "save new version of" replace operation.
     *    You can think of it as "unlink destination" before
     *    writing to it, although the implementation may not
     *    be exactly like that. This flag can only be used with
     *    g_file_replace() and its variants, including g_file_replace_contents().
     *    Since 2.20
     */
    REPLACE_DESTINATION,
}
/**
 * Flags that can be used with g_file_measure_disk_usage().
 * @bitfield 
 */
enum FileMeasureFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Report any error encountered
     *   while traversing the directory tree.  Normally errors are only
     *   reported for the toplevel file.
     */
    REPORT_ANY_ERROR,
    /**
     * Tally usage based on apparent file
     *   sizes.  Normally, the block-size is used, if available, as this is a
     *   more accurate representation of disk space used.
     *   Compare with `du --apparent-size`.
     */
    APPARENT_SIZE,
    /**
     * Do not cross mount point boundaries.
     *   Compare with `du -x`.
     */
    NO_XDEV,
}
/**
 * Flags used to set what a #GFileMonitor will watch for.
 * @bitfield 
 */
enum FileMonitorFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Watch for mount events.
     */
    WATCH_MOUNTS,
    /**
     * Pair DELETED and CREATED events caused
     *   by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
     *   event instead (NB: not supported on all backends; the default
     *   behaviour -without specifying this flag- is to send single DELETED
     *   and CREATED events).  Deprecated since 2.46: use
     *   %G_FILE_MONITOR_WATCH_MOVES instead.
     */
    SEND_MOVED,
    /**
     * Watch for changes to the file made
     *   via another hard link. Since 2.36.
     */
    WATCH_HARD_LINKS,
    /**
     * Watch for rename operations on a
     *   monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
     *   %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
     *   events to be emitted when possible.  Since: 2.46.
     */
    WATCH_MOVES,
}
/**
 * Flags used when querying a #GFileInfo.
 * @bitfield 
 */
enum FileQueryInfoFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Don't follow symlinks.
     */
    NOFOLLOW_SYMLINKS,
}
/**
 * GIOStreamSpliceFlags determine how streams should be spliced.
 * @bitfield 
 */
enum IOStreamSpliceFlags {
    /**
     * Do not close either stream.
     */
    NONE,
    /**
     * Close the first stream after
     *     the splice.
     */
    CLOSE_STREAM1,
    /**
     * Close the second stream after
     *     the splice.
     */
    CLOSE_STREAM2,
    /**
     * Wait for both splice operations to finish
     *     before calling the callback.
     */
    WAIT_FOR_BOTH,
}
/**
 * Flags used when mounting a mount.
 * @bitfield 
 */
enum MountMountFlags {
    /**
     * No flags set.
     */
    NONE,
}
/**
 * Flags used when an unmounting a mount.
 * @bitfield 
 */
enum MountUnmountFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * Unmount even if there are outstanding
     *  file operations on the mount.
     */
    FORCE,
}
/**
 * GOutputStreamSpliceFlags determine how streams should be spliced.
 * @bitfield 
 */
enum OutputStreamSpliceFlags {
    /**
     * Do not close either stream.
     */
    NONE,
    /**
     * Close the source stream after
     *     the splice.
     */
    CLOSE_SOURCE,
    /**
     * Close the target stream after
     *     the splice.
     */
    CLOSE_TARGET,
}
/**
 * Flags to modify lookup behavior.
 * @bitfield 
 */
enum ResolverNameLookupFlags {
    /**
     * default behavior (same as g_resolver_lookup_by_name())
     */
    DEFAULT,
    /**
     * only resolve ipv4 addresses
     */
    IPV4_ONLY,
    /**
     * only resolve ipv6 addresses
     */
    IPV6_ONLY,
}
/**
 * GResourceFlags give information about a particular file inside a resource
 * bundle.
 * @bitfield 
 */
enum ResourceFlags {
    /**
     * No flags set.
     */
    NONE,
    /**
     * The file is compressed.
     */
    COMPRESSED,
}
/**
 * GResourceLookupFlags determine how resource path lookups are handled.
 * @bitfield 
 */
enum ResourceLookupFlags {
    /**
     * No flags set.
     */
    NONE,
}
/**
 * Flags used when creating a binding. These flags determine in which
 * direction the binding works. The default is to synchronize in both
 * directions.
 * @bitfield 
 */
enum SettingsBindFlags {
    /**
     * Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
     */
    DEFAULT,
    /**
     * Update the #GObject property when the setting changes.
     *     It is an error to use this flag if the property is not writable.
     */
    GET,
    /**
     * Update the setting when the #GObject property changes.
     *     It is an error to use this flag if the property is not readable.
     */
    SET,
    /**
     * Do not try to bind a "sensitivity" property to the writability of the setting
     */
    NO_SENSITIVITY,
    /**
     * When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property
     *     value initially from the setting, but do not listen for changes of the setting
     */
    GET_NO_CHANGES,
    /**
     * When passed to g_settings_bind(), uses a pair of mapping functions that invert
     *     the boolean value when mapping between the setting and the property.  The setting and property must both
     *     be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().
     */
    INVERT_BOOLEAN,
}
/**
 * Flags used in g_socket_receive_message() and g_socket_send_message().
 * The flags listed in the enum are some commonly available flags, but the
 * values used for them are the same as on the platform, and any other flags
 * are passed in/out as is. So to use a platform specific flag, just include
 * the right system header and pass in the flag.
 * @bitfield 
 */
enum SocketMsgFlags {
    /**
     * No flags.
     */
    NONE,
    /**
     * Request to send/receive out of band data.
     */
    OOB,
    /**
     * Read data from the socket without removing it from
     *     the queue.
     */
    PEEK,
    /**
     * Don't use a gateway to send out the packet,
     *     only send to hosts on directly connected networks.
     */
    DONTROUTE,
}
/**
 * Flags to define the behaviour of a #GSubprocess.
 * 
 * Note that the default for stdin is to redirect from `/dev/null`.  For
 * stdout and stderr the default are for them to inherit the
 * corresponding descriptor from the calling process.
 * 
 * Note that it is a programmer error to mix 'incompatible' flags.  For
 * example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
 * %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
 * @bitfield 
 */
enum SubprocessFlags {
    /**
     * No flags.
     */
    NONE,
    /**
     * create a pipe for the stdin of the
     *   spawned process that can be accessed with
     *   g_subprocess_get_stdin_pipe().
     */
    STDIN_PIPE,
    /**
     * stdin is inherited from the
     *   calling process.
     */
    STDIN_INHERIT,
    /**
     * create a pipe for the stdout of the
     *   spawned process that can be accessed with
     *   g_subprocess_get_stdout_pipe().
     */
    STDOUT_PIPE,
    /**
     * silence the stdout of the spawned
     *   process (ie: redirect to `/dev/null`).
     */
    STDOUT_SILENCE,
    /**
     * create a pipe for the stderr of the
     *   spawned process that can be accessed with
     *   g_subprocess_get_stderr_pipe().
     */
    STDERR_PIPE,
    /**
     * silence the stderr of the spawned
     *   process (ie: redirect to `/dev/null`).
     */
    STDERR_SILENCE,
    /**
     * merge the stderr of the spawned
     *   process with whatever the stdout happens to be.  This is a good way
     *   of directing both streams to a common log file, for example.
     */
    STDERR_MERGE,
    /**
     * spawned processes will inherit the
     *   file descriptors of their parent, unless those descriptors have
     *   been explicitly marked as close-on-exec.  This flag has no effect
     *   over the "standard" file descriptors (stdin, stdout, stderr).
     */
    INHERIT_FDS,
    /**
     * if path searching is
     *   needed when spawning the subprocess, use the `PATH` in the launcher
     *   environment. (Since: 2.72)
     */
    SEARCH_PATH_FROM_ENVP,
}
/**
 * Flags to define future #GTestDBus behaviour.
 * @bitfield 
 */
enum TestDBusFlags {
    /**
     * No flags.
     */
    NONE,
}
/**
 * A set of flags describing TLS certification validation. This can be
 * used to describe why a particular certificate was rejected (for
 * example, in #GTlsConnection::accept-certificate).
 * 
 * GLib guarantees that if certificate verification fails, at least one
 * flag will be set, but it does not guarantee that all possible flags
 * will be set. Accordingly, you may not safely decide to ignore any
 * particular type of error. For example, it would be incorrect to mask
 * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
 * because this could potentially be the only error flag set even if
 * other problems exist with the certificate.
 * @bitfield 
 */
enum TlsCertificateFlags {
    /**
     * No flags set. Since: 2.74
     */
    NO_FLAGS,
    /**
     * The signing certificate authority is
     *   not known.
     */
    UNKNOWN_CA,
    /**
     * The certificate does not match the
     *   expected identity of the site that it was retrieved from.
     */
    BAD_IDENTITY,
    /**
     * The certificate's activation time
     *   is still in the future
     */
    NOT_ACTIVATED,
    /**
     * The certificate has expired
     */
    EXPIRED,
    /**
     * The certificate has been revoked
     *   according to the #GTlsConnection's certificate revocation list.
     */
    REVOKED,
    /**
     * The certificate's algorithm is
     *   considered insecure.
     */
    INSECURE,
    /**
     * Some other error occurred validating
     *   the certificate
     */
    GENERIC_ERROR,
    /**
     * the combination of all of the above
     *   flags
     */
    VALIDATE_ALL,
}
/**
 * Flags for g_tls_database_verify_chain().
 * @bitfield 
 */
enum TlsDatabaseVerifyFlags {
    /**
     * No verification flags
     */
    NONE,
}
/**
 * Various flags for the password.
 * @bitfield 
 */
enum TlsPasswordFlags {
    /**
     * No flags
     */
    NONE,
    /**
     * The password was wrong, and the user should retry.
     */
    RETRY,
    /**
     * Hint to the user that the password has been
     *    wrong many times, and the user may not have many chances left.
     */
    MANY_TRIES,
    /**
     * Hint to the user that this is the last try to get
     *    this password right.
     */
    FINAL_TRY,
    /**
     * For PKCS #11, the user PIN is required.
     *    Since: 2.70.
     */
    PKCS11_USER,
    /**
     * For PKCS #11, the security officer
     *    PIN is required. Since: 2.70.
     */
    PKCS11_SECURITY_OFFICER,
    /**
     * For PKCS #11, the context-specific
     *    PIN is required. Since: 2.70.
     */
    PKCS11_CONTEXT_SPECIFIC,
}
/**
 * The value returned by handlers of the signals generated by
 * the `gdbus-codegen` tool to indicate that a method call has been
 * handled by an implementation. It is equal to %TRUE, but using
 * this macro is sometimes more readable.
 * 
 * In code that needs to be backwards-compatible with older GLib,
 * use %TRUE instead, often written like this:
 * 
 * 
 * ```
 *   g_dbus_method_invocation_return_error (invocation, ...);
 *   return TRUE;    // handled
 * ```
 * 
 */
const DBUS_METHOD_INVOCATION_HANDLED: boolean
/**
 * The value returned by handlers of the signals generated by
 * the `gdbus-codegen` tool to indicate that a method call has not been
 * handled by an implementation. It is equal to %FALSE, but using
 * this macro is sometimes more readable.
 * 
 * In code that needs to be backwards-compatible with older GLib,
 * use %FALSE instead.
 */
const DBUS_METHOD_INVOCATION_UNHANDLED: boolean
/**
 * Extension point for debug control functionality.
 * See [Extending GIO][extending-gio].
 */
const DEBUG_CONTROLLER_EXTENSION_POINT_NAME: string | null
/**
 * Extension point for default handler to URI association. See
 * [Extending GIO][extending-gio].
 */
const DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: string | null
/**
 * The string used to obtain a Unix device path with g_drive_get_identifier().
 */
const DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: string | null
/**
 * A key in the "access" namespace for checking deletion privileges.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 * 
 * This attribute will be %TRUE if the user is able to delete the file.
 */
const FILE_ATTRIBUTE_ACCESS_CAN_DELETE: string | null
/**
 * A key in the "access" namespace for getting execution privileges.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 * 
 * This attribute will be %TRUE if the user is able to execute the file.
 */
const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: string | null
/**
 * A key in the "access" namespace for getting read privileges.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 * 
 * This attribute will be %TRUE if the user is able to read the file.
 */
const FILE_ATTRIBUTE_ACCESS_CAN_READ: string | null
/**
 * A key in the "access" namespace for checking renaming privileges.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 * 
 * This attribute will be %TRUE if the user is able to rename the file.
 */
const FILE_ATTRIBUTE_ACCESS_CAN_RENAME: string | null
/**
 * A key in the "access" namespace for checking trashing privileges.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 * 
 * This attribute will be %TRUE if the user is able to move the file to
 * the trash.
 */
const FILE_ATTRIBUTE_ACCESS_CAN_TRASH: string | null
/**
 * A key in the "access" namespace for getting write privileges.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 * 
 * This attribute will be %TRUE if the user is able to write to the file.
 */
const FILE_ATTRIBUTE_ACCESS_CAN_WRITE: string | null
/**
 * A key in the "dos" namespace for checking if the file's archive flag
 * is set.
 * 
 * This attribute is %TRUE if the archive flag is set.
 * 
 * This attribute is only available for DOS file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_DOS_IS_ARCHIVE: string | null
/**
 * A key in the "dos" namespace for checking if the file is a NTFS mount point
 * (a volume mount or a junction point).
 * 
 * This attribute is %TRUE if file is a reparse point of type
 * [IO_REPARSE_TAG_MOUNT_POINT](https://msdn.microsoft.com/en-us/library/dd541667.aspx).
 * 
 * This attribute is only available for DOS file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: string | null
/**
 * A key in the "dos" namespace for checking if the file's backup flag
 * is set.
 * 
 * This attribute is %TRUE if the backup flag is set.
 * 
 * This attribute is only available for DOS file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_DOS_IS_SYSTEM: string | null
/**
 * A key in the "dos" namespace for getting the file NTFS reparse tag.
 * 
 * This value is 0 for files that are not reparse points.
 * 
 * See the [Reparse Tags](https://msdn.microsoft.com/en-us/library/dd541667.aspx)
 * page for possible reparse tag values.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: string | null
/**
 * A key in the "etag" namespace for getting the value of the file's
 * entity tag.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_ETAG_VALUE: string | null
/**
 * A key in the "filesystem" namespace for getting the number of bytes
 * of free space left on the file system.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
 */
const FILE_ATTRIBUTE_FILESYSTEM_FREE: string | null
/**
 * A key in the "filesystem" namespace for checking if the file system
 * is read only.
 * 
 * Is set to %TRUE if the file system is read only.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_FILESYSTEM_READONLY: string | null
/**
 * A key in the "filesystem" namespace for checking if the file system
 * is remote.
 * 
 * Is set to %TRUE if the file system is remote.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_FILESYSTEM_REMOTE: string | null
/**
 * A key in the "filesystem" namespace for getting the total size (in
 * bytes) of the file system, used in g_file_query_filesystem_info().
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
 */
const FILE_ATTRIBUTE_FILESYSTEM_SIZE: string | null
/**
 * A key in the "filesystem" namespace for getting the file system's type.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_FILESYSTEM_TYPE: string | null
/**
 * A key in the "filesystem" namespace for getting the number of bytes
 * used by data on the file system.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
 */
const FILE_ATTRIBUTE_FILESYSTEM_USED: string | null
/**
 * A key in the "filesystem" namespace for hinting a file manager
 * application whether it should preview (e.g. thumbnail) files on the
 * file system.
 * 
 * The value for this key contain a #GFilesystemPreviewType.
 */
const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: string | null
/**
 * A key in the "gvfs" namespace that gets the name of the current
 * GVFS backend in use.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_GVFS_BACKEND: string | null
/**
 * A key in the "id" namespace for getting a file identifier.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 * 
 * An example use would be during listing files, to avoid recursive
 * directory scanning.
 */
const FILE_ATTRIBUTE_ID_FILE: string | null
/**
 * A key in the "id" namespace for getting the file system identifier.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 * 
 * An example use would be during drag and drop to see if the source
 * and target are on the same filesystem (default to move) or not (default
 * to copy).
 */
const FILE_ATTRIBUTE_ID_FILESYSTEM: string | null
/**
 * A key in the "mountable" namespace for checking if a file (of
 * type G_FILE_TYPE_MOUNTABLE) can be ejected.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: string | null
/**
 * A key in the "mountable" namespace for checking if a file (of
 * type G_FILE_TYPE_MOUNTABLE) is mountable.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: string | null
/**
 * A key in the "mountable" namespace for checking if a file (of
 * type G_FILE_TYPE_MOUNTABLE) can be polled.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: string | null
/**
 * A key in the "mountable" namespace for checking if a file (of
 * type G_FILE_TYPE_MOUNTABLE) can be started.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START: string | null
/**
 * A key in the "mountable" namespace for checking if a file (of
 * type G_FILE_TYPE_MOUNTABLE) can be started degraded.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: string | null
/**
 * A key in the "mountable" namespace for checking if a file (of
 * type G_FILE_TYPE_MOUNTABLE) can be stopped.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: string | null
/**
 * A key in the "mountable" namespace for checking if a file (of
 * type G_FILE_TYPE_MOUNTABLE)  is unmountable.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: string | null
/**
 * A key in the "mountable" namespace for getting the HAL UDI for the mountable
 * file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: string | null
/**
 * A key in the "mountable" namespace for checking if a file (of
 * type G_FILE_TYPE_MOUNTABLE) is automatically polled for media.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: string | null
/**
 * A key in the "mountable" namespace for getting the #GDriveStartStopType.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: string | null
/**
 * A key in the "mountable" namespace for getting the unix device.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: string | null
/**
 * A key in the "mountable" namespace for getting the unix device file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: string | null
/**
 * A key in the "owner" namespace for getting the file owner's group.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_OWNER_GROUP: string | null
/**
 * A key in the "owner" namespace for getting the user name of the
 * file's owner.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_OWNER_USER: string | null
/**
 * A key in the "owner" namespace for getting the real name of the
 * user that owns the file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_OWNER_USER_REAL: string | null
/**
 * A key in the "preview" namespace for getting a #GIcon that can be
 * used to get preview of the file.
 * 
 * For example, it may be a low resolution thumbnail without metadata.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
 * 
 * The value for this key should contain a #GIcon.
 */
const FILE_ATTRIBUTE_PREVIEW_ICON: string | null
/**
 * A key in the "recent" namespace for getting time, when the metadata for the
 * file in `recent:///` was last changed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT64.
 */
const FILE_ATTRIBUTE_RECENT_MODIFIED: string | null
/**
 * A key in the "selinux" namespace for getting the file's SELinux
 * context.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 * 
 * Note that this attribute is only available if GLib has been built
 * with SELinux support.
 */
const FILE_ATTRIBUTE_SELINUX_CONTEXT: string | null
/**
 * A key in the "standard" namespace for getting the amount of disk space
 * that is consumed by the file (in bytes).
 * 
 * This will generally be larger than the file size (due to block size
 * overhead) but can occasionally be smaller (for example, for sparse files).
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
 */
const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: string | null
/**
 * A key in the "standard" namespace for getting the content type of the file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 * 
 * The value for this key should contain a valid content type.
 */
const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: string | null
/**
 * A key in the "standard" namespace for getting the copy name of the file.
 * 
 * The copy name is an optional version of the name. If available it's always
 * in UTF8, and corresponds directly to the original filename (only transcoded to
 * UTF8). This is useful if you want to copy the file to another filesystem that
 * might have a different encoding. If the filename is not a valid string in the
 * encoding selected for the filesystem it is in then the copy name will not be set.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_STANDARD_COPY_NAME: string | null
/**
 * A key in the "standard" namespace for getting the description of the file.
 * 
 * The description is a utf8 string that describes the file, generally containing
 * the filename, but can also contain further information. Example descriptions
 * could be "filename (on hostname)" for a remote file or "filename (in trash)"
 * for a file in the trash. This is useful for instance as the window title
 * when displaying a directory or for a bookmarks menu.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_STANDARD_DESCRIPTION: string | null
/**
 * A key in the "standard" namespace for getting the display name of the file.
 * 
 * A display name is guaranteed to be in UTF-8 and can thus be displayed in
 * the UI. It is guaranteed to be set on every file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: string | null
/**
 * A key in the "standard" namespace for edit name of the file.
 * 
 * An edit name is similar to the display name, but it is meant to be
 * used when you want to rename the file in the UI. The display name
 * might contain information you don't want in the new filename (such as
 * "(invalid unicode)" if the filename was in an invalid encoding).
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_STANDARD_EDIT_NAME: string | null
/**
 * A key in the "standard" namespace for getting the fast content type.
 * 
 * The fast content type isn't as reliable as the regular one, as it
 * only uses the filename to guess it, but it is faster to calculate than the
 * regular content type.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: string | null
/**
 * A key in the "standard" namespace for getting the icon for the file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
 * 
 * The value for this key should contain a #GIcon.
 */
const FILE_ATTRIBUTE_STANDARD_ICON: string | null
/**
 * A key in the "standard" namespace for checking if a file is a backup file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_STANDARD_IS_BACKUP: string | null
/**
 * A key in the "standard" namespace for checking if a file is hidden.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: string | null
/**
 * A key in the "standard" namespace for checking if the file is a symlink.
 * Typically the actual type is something else, if we followed the symlink
 * to get the type.
 * 
 * On Windows NTFS mountpoints are considered to be symlinks as well.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: string | null
/**
 * A key in the "standard" namespace for checking if a file is virtual.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: string | null
/**
 * A key in the "standard" namespace for checking if a file is
 * volatile. This is meant for opaque, non-POSIX-like backends to
 * indicate that the URI is not persistent. Applications should look
 * at %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: string | null
/**
 * A key in the "standard" namespace for getting the name of the file.
 * 
 * The name is the on-disk filename which may not be in any known encoding,
 * and can thus not be generally displayed as is. It is guaranteed to be set on
 * every file.
 * 
 * Use %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the
 * name in a user interface.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
 */
const FILE_ATTRIBUTE_STANDARD_NAME: string | null
/**
 * A key in the "standard" namespace for getting the file's size (in bytes).
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
 */
const FILE_ATTRIBUTE_STANDARD_SIZE: string | null
/**
 * A key in the "standard" namespace for setting the sort order of a file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT32.
 * 
 * An example use would be in file managers, which would use this key
 * to set the order files are displayed. Files with smaller sort order
 * should be sorted first, and files without sort order as if sort order
 * was zero.
 */
const FILE_ATTRIBUTE_STANDARD_SORT_ORDER: string | null
/**
 * A key in the "standard" namespace for getting the symbolic icon for the file.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
 * 
 * The value for this key should contain a #GIcon.
 */
const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: string | null
/**
 * A key in the "standard" namespace for getting the symlink target, if the file
 * is a symlink.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
 */
const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: string | null
/**
 * A key in the "standard" namespace for getting the target URI for the file, in
 * the case of %G_FILE_TYPE_SHORTCUT or %G_FILE_TYPE_MOUNTABLE files.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_STANDARD_TARGET_URI: string | null
/**
 * A key in the "standard" namespace for storing file types.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 * 
 * The value for this key should contain a #GFileType.
 */
const FILE_ATTRIBUTE_STANDARD_TYPE: string | null
/**
 * A key in the "thumbnail" namespace for checking if thumbnailing failed.
 * 
 * This attribute is %TRUE if thumbnailing failed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAILING_FAILED: string | null
/**
 * A key in the "thumbnail" namespace for checking if thumbnailing failed
 * for the large image.
 * 
 * This attribute is %TRUE if thumbnailing failed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: string | null
/**
 * A key in the "thumbnail" namespace for checking if thumbnailing failed
 * for the normal image.
 * 
 * This attribute is %TRUE if thumbnailing failed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: string | null
/**
 * A key in the "thumbnail" namespace for checking if thumbnailing failed
 * for the x-large image.
 * 
 * This attribute is %TRUE if thumbnailing failed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: string | null
/**
 * A key in the "thumbnail" namespace for checking if thumbnailing failed
 * for the xx-large image.
 * 
 * This attribute is %TRUE if thumbnailing failed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: string | null
/**
 * A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
 * 
 * This attribute is %TRUE if the thumbnail is up-to-date with the file it represents,
 * and %FALSE if the file has been modified since the thumbnail was generated.
 * 
 * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is %TRUE and this attribute is %FALSE,
 * it indicates that thumbnailing may be attempted again and may succeed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: string | null
/**
 * A key in the "thumbnail" namespace for checking whether the large
 * thumbnail is outdated.
 * 
 * This attribute is %TRUE if the large thumbnail is up-to-date with the file
 * it represents, and %FALSE if the file has been modified since the thumbnail
 * was generated.
 * 
 * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE is %TRUE and this attribute
 * is %FALSE, it indicates that thumbnailing may be attempted again and may
 * succeed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: string | null
/**
 * A key in the "thumbnail" namespace for checking whether the normal
 * thumbnail is outdated.
 * 
 * This attribute is %TRUE if the normal thumbnail is up-to-date with the file
 * it represents, and %FALSE if the file has been modified since the thumbnail
 * was generated.
 * 
 * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL is %TRUE and this attribute
 * is %FALSE, it indicates that thumbnailing may be attempted again and may
 * succeed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: string | null
/**
 * A key in the "thumbnail" namespace for checking whether the x-large
 * thumbnail is outdated.
 * 
 * This attribute is %TRUE if the x-large thumbnail is up-to-date with the file
 * it represents, and %FALSE if the file has been modified since the thumbnail
 * was generated.
 * 
 * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE is %TRUE and this attribute
 * is %FALSE, it indicates that thumbnailing may be attempted again and may
 * succeed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: string | null
/**
 * A key in the "thumbnail" namespace for checking whether the xx-large
 * thumbnail is outdated.
 * 
 * This attribute is %TRUE if the x-large thumbnail is up-to-date with the file
 * it represents, and %FALSE if the file has been modified since the thumbnail
 * was generated.
 * 
 * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE is %TRUE and this attribute
 * is %FALSE, it indicates that thumbnailing may be attempted again and may
 * succeed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: string | null
/**
 * A key in the "thumbnail" namespace for getting the path to the thumbnail
 * image with the biggest size available.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
 */
const FILE_ATTRIBUTE_THUMBNAIL_PATH: string | null
/**
 * A key in the "thumbnail" namespace for getting the path to the large
 * thumbnail image.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
 */
const FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: string | null
/**
 * A key in the "thumbnail" namespace for getting the path to the normal
 * thumbnail image.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
 */
const FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: string | null
/**
 * A key in the "thumbnail" namespace for getting the path to the x-large
 * thumbnail image.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
 */
const FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: string | null
/**
 * A key in the "thumbnail" namespace for getting the path to the xx-large
 * thumbnail image.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
 */
const FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: string | null
/**
 * A key in the "time" namespace for getting the time the file was last
 * accessed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
 * contains the time since the file was last accessed, in seconds since the
 * UNIX epoch.
 */
const FILE_ATTRIBUTE_TIME_ACCESS: string | null
/**
 * A key in the "time" namespace for getting the nanoseconds of the time
 * the file was last accessed. This should be used in conjunction with
 * #G_FILE_ATTRIBUTE_TIME_ACCESS. Corresponding #GFileAttributeType is
 * %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TIME_ACCESS_NSEC: string | null
/**
 * A key in the "time" namespace for getting the microseconds of the time
 * the file was last accessed.
 * 
 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_ACCESS.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TIME_ACCESS_USEC: string | null
/**
 * A key in the "time" namespace for getting the time the file was last
 * changed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
 * and contains the time since the file was last changed, in seconds since
 * the UNIX epoch.
 * 
 * This corresponds to the traditional UNIX ctime.
 */
const FILE_ATTRIBUTE_TIME_CHANGED: string | null
/**
 * A key in the "time" namespace for getting the nanoseconds of the time
 * the file was last changed. This should be used in conjunction with
 * #G_FILE_ATTRIBUTE_TIME_CHANGED. Corresponding #GFileAttributeType is
 * %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TIME_CHANGED_NSEC: string | null
/**
 * A key in the "time" namespace for getting the microseconds of the time
 * the file was last changed.
 * 
 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CHANGED.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TIME_CHANGED_USEC: string | null
/**
 * A key in the "time" namespace for getting the time the file was created.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
 * and contains the time since the file was created, in seconds since the UNIX
 * epoch.
 * 
 * This may correspond to Linux `stx_btime`, FreeBSD `st_birthtim`, NetBSD
 * `st_birthtime` or NTFS `ctime`.
 */
const FILE_ATTRIBUTE_TIME_CREATED: string | null
/**
 * A key in the "time" namespace for getting the nanoseconds of the time
 * the file was created. This should be used in conjunction with
 * #G_FILE_ATTRIBUTE_TIME_CREATED. Corresponding #GFileAttributeType is
 * %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TIME_CREATED_NSEC: string | null
/**
 * A key in the "time" namespace for getting the microseconds of the time
 * the file was created.
 * 
 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CREATED.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TIME_CREATED_USEC: string | null
/**
 * A key in the "time" namespace for getting the time the file was last
 * modified.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
 * contains the time since the file was modified, in seconds since the UNIX
 * epoch.
 */
const FILE_ATTRIBUTE_TIME_MODIFIED: string | null
/**
 * A key in the "time" namespace for getting the nanoseconds of the time
 * the file was last modified. This should be used in conjunction with
 * #G_FILE_ATTRIBUTE_TIME_MODIFIED. Corresponding #GFileAttributeType is
 * %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: string | null
/**
 * A key in the "time" namespace for getting the microseconds of the time
 * the file was last modified.
 * 
 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_MODIFIED.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TIME_MODIFIED_USEC: string | null
/**
 * A key in the "trash" namespace for getting the deletion date and time
 * of a file inside the `trash:///` folder.
 * 
 * The format of the returned string is `YYYY-MM-DDThh:mm:ss`.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
 */
const FILE_ATTRIBUTE_TRASH_DELETION_DATE: string | null
/**
 * A key in the "trash" namespace for getting the number of (toplevel) items
 * that are present in the `trash:///` folder.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_TRASH_ITEM_COUNT: string | null
/**
 * A key in the "trash" namespace for getting the original path of a file
 * inside the `trash:///` folder before it was trashed.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
 */
const FILE_ATTRIBUTE_TRASH_ORIG_PATH: string | null
/**
 * A key in the "unix" namespace for getting the number of blocks allocated
 * for the file.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
 */
const FILE_ATTRIBUTE_UNIX_BLOCKS: string | null
/**
 * A key in the "unix" namespace for getting the block size for the file
 * system.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: string | null
/**
 * A key in the "unix" namespace for getting the device id of the device the
 * file is located on (see stat() documentation).
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_UNIX_DEVICE: string | null
/**
 * A key in the "unix" namespace for getting the group ID for the file.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_UNIX_GID: string | null
/**
 * A key in the "unix" namespace for getting the inode of the file.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
 */
const FILE_ATTRIBUTE_UNIX_INODE: string | null
/**
 * A key in the "unix" namespace for checking if the file represents a
 * UNIX mount point.
 * 
 * This attribute is %TRUE if the file is a UNIX mount point.
 * 
 * Since 2.58, `/` is considered to be a mount point.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
 */
const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: string | null
/**
 * A key in the "unix" namespace for getting the mode of the file
 * (e.g. whether the file is a regular file, symlink, etc).
 * 
 * See the documentation for `lstat()`: this attribute is equivalent to
 * the `st_mode` member of `struct stat`, and includes both the file type
 * and permissions.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_UNIX_MODE: string | null
/**
 * A key in the "unix" namespace for getting the number of hard links
 * for a file.
 * 
 * See the documentation for `lstat()`.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_UNIX_NLINK: string | null
/**
 * A key in the "unix" namespace for getting the device ID for the file
 * (if it is a special file).
 * 
 * See the documentation for `lstat()`.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_UNIX_RDEV: string | null
/**
 * A key in the "unix" namespace for getting the user ID for the file.
 * 
 * This attribute is only available for UNIX file systems.
 * 
 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
 */
const FILE_ATTRIBUTE_UNIX_UID: string | null
/**
 * Extension point for memory usage monitoring functionality.
 * See [Extending GIO][extending-gio].
 */
const MEMORY_MONITOR_EXTENSION_POINT_NAME: string | null
/**
 * The menu item attribute which holds the action name of the item.  Action
 * names are namespaced with an identifier for the action group in which the
 * action resides. For example, "win." for window-specific actions and "app."
 * for application-wide actions.
 * 
 * See also g_menu_model_get_item_attribute() and g_menu_item_set_attribute().
 */
const MENU_ATTRIBUTE_ACTION: string | null
/**
 * The menu item attribute that holds the namespace for all action names in
 * menus that are linked from this item.
 */
const MENU_ATTRIBUTE_ACTION_NAMESPACE: string | null
/**
 * The menu item attribute which holds the icon of the item.
 * 
 * The icon is stored in the format returned by g_icon_serialize().
 * 
 * This attribute is intended only to represent 'noun' icons such as
 * favicons for a webpage, or application icons.  It should not be used
 * for 'verbs' (ie: stock icons).
 */
const MENU_ATTRIBUTE_ICON: string | null
/**
 * The menu item attribute which holds the label of the item.
 */
const MENU_ATTRIBUTE_LABEL: string | null
/**
 * The menu item attribute which holds the target with which the item's action
 * will be activated.
 * 
 * See also g_menu_item_set_action_and_target()
 */
const MENU_ATTRIBUTE_TARGET: string | null
/**
 * The maximum number of entries in a menu section supported by
 * g_dbus_connection_export_menu_model().
 * 
 * The exact value of the limit may change in future GLib versions.
 */
const MENU_EXPORTER_MAX_SECTION_SIZE: number
/**
 * The name of the link that associates a menu item with a section.  The linked
 * menu will usually be shown in place of the menu item, using the item's label
 * as a header.
 * 
 * See also g_menu_item_set_link().
 */
const MENU_LINK_SECTION: string | null
/**
 * The name of the link that associates a menu item with a submenu.
 * 
 * See also g_menu_item_set_link().
 */
const MENU_LINK_SUBMENU: string | null
const NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: string | null
/**
 * Extension point for network status monitoring functionality.
 * See [Extending GIO][extending-gio].
 */
const NETWORK_MONITOR_EXTENSION_POINT_NAME: string | null
/**
 * Extension point for power profile usage monitoring functionality.
 * See [Extending GIO][extending-gio].
 */
const POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: string | null
/**
 * Extension point for proxy functionality.
 * See [Extending GIO][extending-gio].
 */
const PROXY_EXTENSION_POINT_NAME: string | null
/**
 * Extension point for proxy resolving functionality.
 * See [Extending GIO][extending-gio].
 */
const PROXY_RESOLVER_EXTENSION_POINT_NAME: string | null
/**
 * Extension point for #GSettingsBackend functionality.
 */
const SETTINGS_BACKEND_EXTENSION_POINT_NAME: string | null
/**
 * Extension point for TLS functionality via #GTlsBackend.
 * See [Extending GIO][extending-gio].
 */
const TLS_BACKEND_EXTENSION_POINT_NAME: string | null
/**
 * The purpose used to verify the client certificate in a TLS connection.
 * Used by TLS servers.
 */
const TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: string | null
/**
 * The purpose used to verify the server certificate in a TLS connection. This
 * is the most common purpose in use. Used by TLS clients.
 */
const TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: string | null
/**
 * Extension point for #GVfs functionality.
 * See [Extending GIO][extending-gio].
 */
const VFS_EXTENSION_POINT_NAME: string | null
/**
 * The string used to obtain the volume class with g_volume_get_identifier().
 * 
 * Known volume classes include `device`, `network`, and `loop`. Other
 * classes may be added in the future.
 * 
 * This is intended to be used by applications to classify #GVolume
 * instances into different sections - for example a file manager or
 * file chooser can use this information to show `network` volumes under
 * a "Network" heading and `device` volumes under a "Devices" heading.
 */
const VOLUME_IDENTIFIER_KIND_CLASS: string | null
/**
 * The string used to obtain a Hal UDI with g_volume_get_identifier().
 */
const VOLUME_IDENTIFIER_KIND_HAL_UDI: string | null
/**
 * The string used to obtain a filesystem label with g_volume_get_identifier().
 */
const VOLUME_IDENTIFIER_KIND_LABEL: string | null
/**
 * The string used to obtain a NFS mount with g_volume_get_identifier().
 */
const VOLUME_IDENTIFIER_KIND_NFS_MOUNT: string | null
/**
 * The string used to obtain a Unix device path with g_volume_get_identifier().
 */
const VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: string | null
/**
 * The string used to obtain a UUID with g_volume_get_identifier().
 */
const VOLUME_IDENTIFIER_KIND_UUID: string | null
/**
 * Extension point for volume monitor functionality.
 * See [Extending GIO][extending-gio].
 */
const VOLUME_MONITOR_EXTENSION_POINT_NAME: string | null
/**
 * Checks if `action_name` is valid.
 * 
 * `action_name` is valid if it consists only of alphanumeric characters,
 * plus '-' and '.'.  The empty string is not a valid action name.
 * 
 * It is an error to call this function with a non-utf8 `action_name`.
 * `action_name` must not be %NULL.
 * @param action_name a potential action name
 * @returns %TRUE if @action_name is valid
 */
function action_name_is_valid(action_name: string | null): boolean
/**
 * Parses a detailed action name into its separate name and target
 * components.
 * 
 * Detailed action names can have three formats.
 * 
 * The first format is used to represent an action name with no target
 * value and consists of just an action name containing no whitespace
 * nor the characters `:`, `(` or `)`.  For example: `app.action`.
 * 
 * The second format is used to represent an action with a target value
 * that is a non-empty string consisting only of alphanumerics, plus `-`
 * and `.`.  In that case, the action name and target value are
 * separated by a double colon (`::`).  For example:
 * `app.action::target`.
 * 
 * The third format is used to represent an action with any type of
 * target value, including strings.  The target value follows the action
 * name, surrounded in parens.  For example: `app.action(42)`.  The
 * target value is parsed using g_variant_parse().  If a tuple-typed
 * value is desired, it must be specified in the same way, resulting in
 * two sets of parens, for example: `app.action((1,2,3))`.  A string
 * target can be specified this way as well: `app.action('target')`.
 * For strings, this third format must be used if target value is
 * empty or contains characters other than alphanumerics, `-` and `.`.
 * 
 * If this function returns %TRUE, a non-%NULL value is guaranteed to be returned
 * in `action_name` (if a pointer is passed in). A %NULL value may still be
 * returned in `target_value,` as the `detailed_name` may not contain a target.
 * 
 * If returned, the #GVariant in `target_value` is guaranteed to not be floating.
 * @param detailed_name a detailed action name
 * @returns %TRUE if successful, else %FALSE with @error set
 */
function action_parse_detailed_name(detailed_name: string | null): [ /* returnType */ boolean, /* action_name */ string | null, /* target_value */ GLib.Variant | null ]
/**
 * Formats a detailed action name from `action_name` and `target_value`.
 * 
 * It is an error to call this function with an invalid action name.
 * 
 * This function is the opposite of g_action_parse_detailed_name().
 * It will produce a string that can be parsed back to the `action_name`
 * and `target_value` by that function.
 * 
 * See that function for the types of strings that will be printed by
 * this function.
 * @param action_name a valid action name
 * @param target_value a #GVariant target value, or %NULL
 * @returns a detailed format string
 */
function action_print_detailed_name(action_name: string | null, target_value: GLib.Variant | null): string | null
/**
 * Creates a new #GAppInfo from the given information.
 * 
 * Note that for `commandline,` the quoting rules of the Exec key of the
 * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
 * are applied. For example, if the `commandline` contains
 * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
 * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
 * @param commandline the commandline to use
 * @param application_name the application name, or %NULL to use `commandline`
 * @param flags flags that can specify details of the created #GAppInfo
 * @returns new #GAppInfo for given command.
 */
function app_info_create_from_commandline(commandline: string, application_name: string | null, flags: AppInfoCreateFlags): AppInfo
/**
 * Gets a list of all of the applications currently registered
 * on this system.
 * 
 * For desktop files, this includes applications that have
 * `NoDisplay=true` set or are excluded from display by means
 * of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
 * The returned list does not include applications which have
 * the `Hidden` key set.
 * @returns a newly allocated #GList of references to #GAppInfos.
 */
function app_info_get_all(): AppInfo[]
/**
 * Gets a list of all #GAppInfos for a given content type,
 * including the recommended and fallback #GAppInfos. See
 * g_app_info_get_recommended_for_type() and
 * g_app_info_get_fallback_for_type().
 * @param content_type the content type to find a #GAppInfo for
 * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
 */
function app_info_get_all_for_type(content_type: string | null): AppInfo[]
/**
 * Gets the default #GAppInfo for a given content type.
 * @param content_type the content type to find a #GAppInfo for
 * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
 * @returns #GAppInfo for given @content_type or     %NULL on error.
 */
function app_info_get_default_for_type(content_type: string | null, must_support_uris: boolean): AppInfo | null
/**
 * Asynchronously gets the default #GAppInfo for a given content type.
 * @param content_type the content type to find a #GAppInfo for
 * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
 * @param cancellable optional #GCancellable object, %NULL to ignore
 * @param callback a #GAsyncReadyCallback to call when the request is done
 */
function app_info_get_default_for_type_async<Z = unknown>(content_type: string | null, must_support_uris: boolean, cancellable: Cancellable | null, callback: AsyncReadyCallback<Z> | null): void

// Overloads of app_info_get_default_for_type_async

/**
 * Promisified version of {@link app_info_get_default_for_type_async}
 * 
 * Asynchronously gets the default #GAppInfo for a given content type.
 * @param content_type the content type to find a #GAppInfo for
 * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
 * @param cancellable optional #GCancellable object, %NULL to ignore
 * @returns A Promise of: #GAppInfo for given @content_type or     %NULL on error.
 */
function app_info_get_default_for_type_async<Z = unknown>(content_type: string | null, must_support_uris: boolean, cancellable: Cancellable | null): globalThis.Promise<AppInfo>
/**
 * Finishes a default #GAppInfo lookup started by
 * g_app_info_get_default_for_type_async().
 * 
 * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
 * @param result a #GAsyncResult
 * @returns #GAppInfo for given @content_type or     %NULL on error.
 */
function app_info_get_default_for_type_finish(result: AsyncResult): AppInfo
/**
 * Gets the default application for handling URIs with
 * the given URI scheme. A URI scheme is the initial part
 * of the URI, up to but not including the ':', e.g. "http",
 * "ftp" or "sip".
 * @param uri_scheme a string containing a URI scheme.
 * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
 */
function app_info_get_default_for_uri_scheme(uri_scheme: string | null): AppInfo | null
/**
 * Asynchronously gets the default application for handling URIs with
 * the given URI scheme. A URI scheme is the initial part
 * of the URI, up to but not including the ':', e.g. "http",
 * "ftp" or "sip".
 * @param uri_scheme a string containing a URI scheme.
 * @param cancellable optional #GCancellable object, %NULL to ignore
 * @param callback a #GAsyncReadyCallback to call when the request is done
 */
function app_info_get_default_for_uri_scheme_async<Z = unknown>(uri_scheme: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<Z> | null): void

// Overloads of app_info_get_default_for_uri_scheme_async

/**
 * Promisified version of {@link app_info_get_default_for_uri_scheme_async}
 * 
 * Asynchronously gets the default application for handling URIs with
 * the given URI scheme. A URI scheme is the initial part
 * of the URI, up to but not including the ':', e.g. "http",
 * "ftp" or "sip".
 * @param uri_scheme a string containing a URI scheme.
 * @param cancellable optional #GCancellable object, %NULL to ignore
 * @returns A Promise of: #GAppInfo for given @uri_scheme or     %NULL on error.
 */
function app_info_get_default_for_uri_scheme_async<Z = unknown>(uri_scheme: string | null, cancellable: Cancellable | null): globalThis.Promise<AppInfo>
/**
 * Finishes a default #GAppInfo lookup started by
 * g_app_info_get_default_for_uri_scheme_async().
 * 
 * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
 * @param result a #GAsyncResult
 * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
 */
function app_info_get_default_for_uri_scheme_finish(result: AsyncResult): AppInfo
/**
 * Gets a list of fallback #GAppInfos for a given content type, i.e.
 * those applications which claim to support the given content type
 * by MIME type subclassing and not directly.
 * @param content_type the content type to find a #GAppInfo for
 * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
 */
function app_info_get_fallback_for_type(content_type: string | null): AppInfo[]
/**
 * Gets a list of recommended #GAppInfos for a given content type, i.e.
 * those applications which claim to support the given content type exactly,
 * and not by MIME type subclassing.
 * Note that the first application of the list is the last used one, i.e.
 * the last one for which g_app_info_set_as_last_used_for_type() has been
 * called.
 * @param content_type the content type to find a #GAppInfo for
 * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
 */
function app_info_get_recommended_for_type(content_type: string | null): AppInfo[]
/**
 * Utility function that launches the default application
 * registered to handle the specified uri. Synchronous I/O
 * is done on the uri to detect the type of the file if
 * required.
 * 
 * The D-Bus–activated applications don't have to be started if your application
 * terminates too soon after this function. To prevent this, use
 * g_app_info_launch_default_for_uri_async() instead.
 * @param uri the uri to show
 * @param context an optional #GAppLaunchContext
 * @returns %TRUE on success, %FALSE on error.
 */
function app_info_launch_default_for_uri(uri: string | null, context: AppLaunchContext | null): boolean
/**
 * Async version of g_app_info_launch_default_for_uri().
 * 
 * This version is useful if you are interested in receiving
 * error information in the case where the application is
 * sandboxed and the portal may present an application chooser
 * dialog to the user.
 * 
 * This is also useful if you want to be sure that the D-Bus–activated
 * applications are really started before termination and if you are interested
 * in receiving error information from their activation.
 * @param uri the uri to show
 * @param context an optional #GAppLaunchContext
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the request is done
 */
function app_info_launch_default_for_uri_async<Z = unknown>(uri: string | null, context: AppLaunchContext | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<Z> | null): void

// Overloads of app_info_launch_default_for_uri_async

/**
 * Promisified version of {@link app_info_launch_default_for_uri_async}
 * 
 * Async version of g_app_info_launch_default_for_uri().
 * 
 * This version is useful if you are interested in receiving
 * error information in the case where the application is
 * sandboxed and the portal may present an application chooser
 * dialog to the user.
 * 
 * This is also useful if you want to be sure that the D-Bus–activated
 * applications are really started before termination and if you are interested
 * in receiving error information from their activation.
 * @param uri the uri to show
 * @param context an optional #GAppLaunchContext
 * @param cancellable a #GCancellable
 * @returns A Promise of: %TRUE if the launch was successful, %FALSE if @error is set
 */
function app_info_launch_default_for_uri_async<Z = unknown>(uri: string | null, context: AppLaunchContext | null, cancellable: Cancellable | null): globalThis.Promise<boolean>
/**
 * Finishes an asynchronous launch-default-for-uri operation.
 * @param result a #GAsyncResult
 * @returns %TRUE if the launch was successful, %FALSE if @error is set
 */
function app_info_launch_default_for_uri_finish(result: AsyncResult): boolean
/**
 * Removes all changes to the type associations done by
 * g_app_info_set_as_default_for_type(),
 * g_app_info_set_as_default_for_extension(),
 * g_app_info_add_supports_type() or
 * g_app_info_remove_supports_type().
 * @param content_type a content type
 */
function app_info_reset_type_associations(content_type: string | null): void
/**
 * Helper function for constructing #GAsyncInitable object. This is
 * similar to g_object_newv() but also initializes the object asynchronously.
 * 
 * When the initialization is finished, `callback` will be called. You can
 * then call g_async_initable_new_finish() to get the new object and check
 * for any errors.
 * @param object_type a #GType supporting #GAsyncInitable.
 * @param n_parameters the number of parameters in `parameters`
 * @param parameters the parameters to use to construct the object
 * @param io_priority the [I/O priority][io-priority] of the operation
 * @param cancellable optional #GCancellable object, %NULL to ignore.
 * @param callback a #GAsyncReadyCallback to call when the initialization is     finished
 */
function async_initable_newv_async<Z = unknown>(object_type: GObject.GType, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<Z> | null): void
/**
 * Asynchronously connects to the message bus specified by `bus_type`.
 * 
 * When the operation is finished, `callback` will be invoked. You can
 * then call g_bus_get_finish() to get the result of the operation.
 * 
 * This is an asynchronous failable function. See g_bus_get_sync() for
 * the synchronous version.
 * @param bus_type a #GBusType
 * @param cancellable a #GCancellable or %NULL
 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
 */
function bus_get<Z = unknown>(bus_type: BusType, cancellable: Cancellable | null, callback: AsyncReadyCallback<Z> | null): void
/**
 * Finishes an operation started with g_bus_get().
 * 
 * The returned object is a singleton, that is, shared with other
 * callers of g_bus_get() and g_bus_get_sync() for `bus_type`. In the
 * event that you need a private message bus connection, use
 * g_dbus_address_get_for_bus_sync() and
 * g_dbus_connection_new_for_address() with
 * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
 * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
 * 
 * Note that the returned #GDBusConnection object will (usually) have
 * the #GDBusConnection:exit-on-close property set to %TRUE.
 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_bus_get()
 * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
 */
function bus_get_finish(res: AsyncResult): DBusConnection
/**
 * Synchronously connects to the message bus specified by `bus_type`.
 * Note that the returned object may shared with other callers,
 * e.g. if two separate parts of a process calls this function with
 * the same `bus_type,` they will share the same object.
 * 
 * This is a synchronous failable function. See g_bus_get() and
 * g_bus_get_finish() for the asynchronous version.
 * 
 * The returned object is a singleton, that is, shared with other
 * callers of g_bus_get() and g_bus_get_sync() for `bus_type`. In the
 * event that you need a private message bus connection, use
 * g_dbus_address_get_for_bus_sync() and
 * g_dbus_connection_new_for_address() with
 * G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT and
 * G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION flags.
 * 
 * Note that the returned #GDBusConnection object will (usually) have
 * the #GDBusConnection:exit-on-close property set to %TRUE.
 * @param bus_type a #GBusType
 * @param cancellable a #GCancellable or %NULL
 * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
 */
function bus_get_sync(bus_type: BusType, cancellable: Cancellable | null): DBusConnection
/**
 * Version of g_bus_own_name_on_connection() using closures instead of
 * callbacks for easier binding in other languages.
 * @param connection a #GDBusConnection
 * @param name the well-known name to own
 * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
 * @param name_acquired_closure #GClosure to invoke when `name` is     acquired or %NULL
 * @param name_lost_closure #GClosure to invoke when `name` is lost     or %NULL
 * @returns an identifier (never 0) that can be used with     g_bus_unown_name() to stop owning the name.
 */
function bus_own_name_on_connection(connection: DBusConnection, name: string | null, flags: BusNameOwnerFlags, name_acquired_closure: GObject.TClosure | null, name_lost_closure: GObject.TClosure | null): number
/**
 * Version of g_bus_own_name() using closures instead of callbacks for
 * easier binding in other languages.
 * @param bus_type the type of bus to own a name on
 * @param name the well-known name to own
 * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
 * @param bus_acquired_closure #GClosure to invoke when connected to     the bus of type `bus_type` or %NULL
 * @param name_acquired_closure #GClosure to invoke when `name` is     acquired or %NULL
 * @param name_lost_closure #GClosure to invoke when `name` is lost or     %NULL
 * @returns an identifier (never 0) that can be used with     g_bus_unown_name() to stop owning the name.
 */
function bus_own_name(bus_type: BusType, name: string | null, flags: BusNameOwnerFlags, bus_acquired_closure: GObject.TClosure | null, name_acquired_closure: GObject.TClosure | null, name_lost_closure: GObject.TClosure | null): number
/**
 * Stops owning a name.
 * 
 * Note that there may still be D-Bus traffic to process (relating to owning
 * and unowning the name) in the current thread-default #GMainContext after
 * this function has returned. You should continue to iterate the #GMainContext
 * until the #GDestroyNotify function passed to g_bus_own_name() is called, in
 * order to avoid memory leaks through callbacks queued on the #GMainContext
 * after it’s stopped being iterated.
 * @param owner_id an identifier obtained from g_bus_own_name()
 */
function bus_unown_name(owner_id: number): void
/**
 * Stops watching a name.
 * 
 * Note that there may still be D-Bus traffic to process (relating to watching
 * and unwatching the name) in the current thread-default #GMainContext after
 * this function has returned. You should continue to iterate the #GMainContext
 * until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
 * order to avoid memory leaks through callbacks queued on the #GMainContext
 * after it’s stopped being iterated.
 * @param watcher_id An identifier obtained from g_bus_watch_name()
 */
function bus_unwatch_name(watcher_id: number): void
/**
 * Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
 * easier binding in other languages.
 * @param connection A #GDBusConnection.
 * @param name The name (well-known or unique) to watch.
 * @param flags Flags from the #GBusNameWatcherFlags enumeration.
 * @param name_appeared_closure #GClosure to invoke when `name` is known to exist or %NULL.
 * @param name_vanished_closure #GClosure to invoke when `name` is known to not exist or %NULL.
 * @returns An identifier (never 0) that can be used with g_bus_unwatch_name() to stop watching the name.
 */
function bus_watch_name_on_connection(connection: DBusConnection, name: string | null, flags: BusNameWatcherFlags, name_appeared_closure: GObject.TClosure | null, name_vanished_closure: GObject.TClosure | null): number
/**
 * Version of g_bus_watch_name() using closures instead of callbacks for
 * easier binding in other languages.
 * @param bus_type The type of bus to watch a name on.
 * @param name The name (well-known or unique) to watch.
 * @param flags Flags from the #GBusNameWatcherFlags enumeration.
 * @param name_appeared_closure #GClosure to invoke when `name` is known to exist or %NULL.
 * @param name_vanished_closure #GClosure to invoke when `name` is known to not exist or %NULL.
 * @returns An identifier (never 0) that can be used with g_bus_unwatch_name() to stop watching the name.
 */
function bus_watch_name(bus_type: BusType, name: string | null, flags: BusNameWatcherFlags, name_appeared_closure: GObject.TClosure | null, name_vanished_closure: GObject.TClosure | null): number
/**
 * Checks if a content type can be executable. Note that for instance
 * things like text files can be executables (i.e. scripts and batch files).
 * @param type a content type string
 * @returns %TRUE if the file type corresponds to a type that     can be executable, %FALSE otherwise.
 */
function content_type_can_be_executable(type: string | null): boolean
/**
 * Compares two content types for equality.
 * @param type1 a content type string
 * @param type2 a content type string
 * @returns %TRUE if the two strings are identical or equivalent,     %FALSE otherwise.
 */
function content_type_equals(type1: string | null, type2: string | null): boolean
/**
 * Tries to find a content type based on the mime type name.
 * @param mime_type a mime type string
 * @returns Newly allocated string with content type or     %NULL. Free with g_free()
 */
function content_type_from_mime_type(mime_type: string | null): string | null
/**
 * Gets the human readable description of the content type.
 * @param type a content type string
 * @returns a short description of the content type @type. Free the     returned string with g_free()
 */
function content_type_get_description(type: string | null): string | null
/**
 * Gets the generic icon name for a content type.
 * 
 * See the
 * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
 * specification for more on the generic icon name.
 * @param type a content type string
 * @returns the registered generic icon name for the given @type,     or %NULL if unknown. Free with g_free()
 */
function content_type_get_generic_icon_name(type: string | null): string | null
/**
 * Gets the icon for a content type.
 * @param type a content type string
 * @returns #GIcon corresponding to the content type. Free the returned     object with g_object_unref()
 */
function content_type_get_icon(type: string | null): Icon
/**
 * Get the list of directories which MIME data is loaded from. See
 * g_content_type_set_mime_dirs() for details.
 * @returns %NULL-terminated list of    directories to load MIME data from, including any `mime/` subdirectory,    and with the first directory to try listed first
 */
function content_type_get_mime_dirs(): string[]
/**
 * Gets the mime type for the content type, if one is registered.
 * @param type a content type string
 * @returns the registered mime type for the     given @type, or %NULL if unknown; free with g_free().
 */
function content_type_get_mime_type(type: string | null): string | null
/**
 * Gets the symbolic icon for a content type.
 * @param type a content type string
 * @returns symbolic #GIcon corresponding to the content type.     Free the returned object with g_object_unref()
 */
function content_type_get_symbolic_icon(type: string | null): Icon
/**
 * Guesses the content type based on example data. If the function is
 * uncertain, `result_uncertain` will be set to %TRUE. Either `filename`
 * or `data` may be %NULL, in which case the guess will be based solely
 * on the other argument.
 * @param filename a path, or %NULL
 * @param data a stream of data, or %NULL
 * @returns a string indicating a guessed content type for the     given data. Free with g_free()
 */
function content_type_guess(filename: string | null, data: Uint8Array | null): [ /* returnType */ string | null, /* result_uncertain */ boolean ]
/**
 * Tries to guess the type of the tree with root `root,` by
 * looking at the files it contains. The result is an array
 * of content types, with the best guess coming first.
 * 
 * The types returned all have the form x-content/foo, e.g.
 * x-content/audio-cdda (for audio CDs) or x-content/image-dcf
 * (for a camera memory card). See the
 * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
 * specification for more on x-content types.
 * 
 * This function is useful in the implementation of
 * g_mount_guess_content_type().
 * @param root the root of the tree to guess a type for
 * @returns an %NULL-terminated     array of zero or more content types. Free with g_strfreev()
 */
function content_type_guess_for_tree(root: File): string[]
/**
 * Determines if `type` is a subset of `supertype`.
 * @param type a content type string
 * @param supertype a content type string
 * @returns %TRUE if @type is a kind of @supertype,     %FALSE otherwise.
 */
function content_type_is_a(type: string | null, supertype: string | null): boolean
/**
 * Determines if `type` is a subset of `mime_type`.
 * Convenience wrapper around g_content_type_is_a().
 * @param type a content type string
 * @param mime_type a mime type string
 * @returns %TRUE if @type is a kind of @mime_type,     %FALSE otherwise.
 */
function content_type_is_mime_type(type: string | null, mime_type: string | null): boolean
/**
 * Checks if the content type is the generic "unknown" type.
 * On UNIX this is the "application/octet-stream" mimetype,
 * while on win32 it is "*" and on OSX it is a dynamic type
 * or octet-stream.
 * @param type a content type string
 * @returns %TRUE if the type is the unknown type.
 */
function content_type_is_unknown(type: string | null): boolean
/**
 * Set the list of directories used by GIO to load the MIME database.
 * If `dirs` is %NULL, the directories used are the default:
 * 
 *  - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
 *  - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
 * 
 * This function is intended to be used when writing tests that depend on
 * information stored in the MIME database, in order to control the data.
 * 
 * Typically, in case your tests use %G_TEST_OPTION_ISOLATE_DIRS, but they
 * depend on the system’s MIME database, you should call this function
 * with `dirs` set to %NULL before calling g_test_init(), for instance:
 * 
 * 
 * ```c
 *   // Load MIME data from the system
 *   g_content_type_set_mime_dirs (NULL);
 *   // Isolate the environment
 *   g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
 * 
 *   …
 * 
 *   return g_test_run ();
 * ```
 * 
 * @param dirs %NULL-terminated list of    directories to load MIME data from, including any `mime/` subdirectory,    and with the first directory to try listed first
 */
function content_type_set_mime_dirs(dirs: string[] | null): void
/**
 * Gets a list of strings containing all the registered content types
 * known to the system. The list and its data should be freed using
 * `g_list_free_full (list, g_free)`.
 * @returns list of the registered     content types
 */
function content_types_get_registered(): string[]
/**
 * Escape `string` so it can appear in a D-Bus address as the value
 * part of a key-value pair.
 * 
 * For instance, if `string` is `/run/bus-for-:0`,
 * this function would return `/run/bus-for-%3A0`,
 * which could be used in a D-Bus address like
 * `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.
 * @param string an unescaped string to be included in a D-Bus address     as the value in a key-value pair
 * @returns a copy of @string with all     non-optionally-escaped bytes escaped
 */
function dbus_address_escape_value(string: string | null): string | null
/**
 * Synchronously looks up the D-Bus address for the well-known message
 * bus instance specified by `bus_type`. This may involve using various
 * platform specific mechanisms.
 * 
 * The returned address will be in the
 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
 * @param bus_type a #GBusType
 * @param cancellable a #GCancellable or %NULL
 * @returns a valid D-Bus address string for @bus_type or     %NULL if @error is set
 */
function dbus_address_get_for_bus_sync(bus_type: BusType, cancellable: Cancellable | null): string | null
/**
 * Asynchronously connects to an endpoint specified by `address` and
 * sets up the connection so it is in a state to run the client-side
 * of the D-Bus authentication conversation. `address` must be in the
 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
 * 
 * When the operation is finished, `callback` will be invoked. You can
 * then call g_dbus_address_get_stream_finish() to get the result of
 * the operation.
 * 
 * This is an asynchronous failable function. See
 * g_dbus_address_get_stream_sync() for the synchronous version.
 * @param address A valid D-Bus address.
 * @param cancellable A #GCancellable or %NULL.
 * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
 */
function dbus_address_get_stream<Z = unknown>(address: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<Z> | null): void
/**
 * Finishes an operation started with g_dbus_address_get_stream().
 * 
 * A server is not required to set a GUID, so `out_guid` may be set to %NULL
 * even on success.
 * @param res A #GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_address_get_stream().
 * @returns A #GIOStream or %NULL if @error is set.
 */
function dbus_address_get_stream_finish(res: AsyncResult): [ /* returnType */ IOStream, /* out_guid */ string | null ]
/**
 * Synchronously connects to an endpoint specified by `address` and
 * sets up the connection so it is in a state to run the client-side
 * of the D-Bus authentication conversation. `address` must be in the
 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
 * 
 * A server is not required to set a GUID, so `out_guid` may be set to %NULL
 * even on success.
 * 
 * This is a synchronous failable function. See
 * g_dbus_address_get_stream() for the asynchronous version.
 * @param address A valid D-Bus address.
 * @param cancellable A #GCancellable or %NULL.
 * @returns A #GIOStream or %NULL if @error is set.
 */
function dbus_address_get_stream_sync(address: string | null, cancellable: Cancellable | null): [ /* returnType */ IOStream, /* out_guid */ string | null ]
/**
 * Looks up the value of an annotation.
 * 
 * The cost of this function is O(n) in number of annotations.
 * @param annotations A %NULL-terminated array of annotations or %NULL.
 * @param name The name of the annotation to look up.
 * @returns The value or %NULL if not found. Do not free, it is owned by @annotations.
 */
function dbus_annotation_info_lookup(annotations: DBusAnnotationInfo[] | null, name: string | null): string | null
/**
 * Creates a D-Bus error name to use for `error`. If `error` matches
 * a registered error (cf. g_dbus_error_register_error()), the corresponding
 * D-Bus error name will be returned.
 * 
 * Otherwise the a name of the form
 * `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
 * will be used. This allows other GDBus applications to map the error
 * on the wire back to a #GError using g_dbus_error_new_for_dbus_error().
 * 
 * This function is typically only used in object mappings to put a
 * #GError on the wire. Regular applications should not use it.
 * @param error A #GError.
 * @returns A D-Bus error name (never %NULL).     Free with g_free().
 */
function dbus_error_encode_gerror(error: GLib.Error): string | null
/**
 * Gets the D-Bus error name used for `error,` if any.
 * 
 * This function is guaranteed to return a D-Bus error name for all
 * #GErrors returned from functions handling remote method calls
 * (e.g. g_dbus_connection_call_finish()) unless
 * g_dbus_error_strip_remote_error() has been used on `error`.
 * @param error a #GError
 * @returns an allocated string or %NULL if the     D-Bus error name could not be found. Free with g_free().
 */
function dbus_error_get_remote_error(error: GLib.Error): string | null
/**
 * Checks if `error` represents an error received via D-Bus from a remote peer. If so,
 * use g_dbus_error_get_remote_error() to get the name of the error.
 * @param error A #GError.
 * @returns %TRUE if @error represents an error from a remote peer, %FALSE otherwise.
 */
function dbus_error_is_remote_error(error: GLib.Error): boolean
/**
 * Creates a #GError based on the contents of `dbus_error_name` and
 * `dbus_error_message`.
 * 
 * Errors registered with g_dbus_error_register_error() will be looked
 * up using `dbus_error_name` and if a match is found, the error domain
 * and code is used. Applications can use g_dbus_error_get_remote_error()
 * to recover `dbus_error_name`.
 * 
 * If a match against a registered error is not found and the D-Bus
 * error name is in a form as returned by g_dbus_error_encode_gerror()
 * the error domain and code encoded in the name is used to
 * create the #GError. Also, `dbus_error_name` is added to the error message
 * such that it can be recovered with g_dbus_error_get_remote_error().
 * 
 * Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
 * in the %G_IO_ERROR error domain is returned. Also, `dbus_error_name` is
 * added to the error message such that it can be recovered with
 * g_dbus_error_get_remote_error().
 * 
 * In all three cases, `dbus_error_name` can always be recovered from the
 * returned #GError using the g_dbus_error_get_remote_error() function
 * (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
 * 
 * This function is typically only used in object mappings to prepare
 * #GError instances for applications. Regular applications should not use
 * it.
 * @param dbus_error_name D-Bus error name.
 * @param dbus_error_message D-Bus error message.
 * @returns An allocated #GError. Free with g_error_free().
 */
function dbus_error_new_for_dbus_error(dbus_error_name: string | null, dbus_error_message: string | null): GLib.Error
function dbus_error_quark(): GLib.Quark
/**
 * Creates an association to map between `dbus_error_name` and
 * #GErrors specified by `error_domain` and `error_code`.
 * 
 * This is typically done in the routine that returns the #GQuark for
 * an error domain.
 * @param error_domain A #GQuark for an error domain.
 * @param error_code An error code.
 * @param dbus_error_name A D-Bus error name.
 * @returns %TRUE if the association was created, %FALSE if it already exists.
 */
function dbus_error_register_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string | null): boolean
/**
 * Helper function for associating a #GError error domain with D-Bus error names.
 * 
 * While `quark_volatile` has a `volatile` qualifier, this is a historical
 * artifact and the argument passed to it should not be `volatile`.
 * @param error_domain_quark_name The error domain name.
 * @param quark_volatile A pointer where to store the #GQuark.
 * @param entries A pointer to `num_entries` #GDBusErrorEntry struct items.
 */
function dbus_error_register_error_domain(error_domain_quark_name: string | null, quark_volatile: number, entries: DBusErrorEntry[]): void
/**
 * Looks for extra information in the error message used to recover
 * the D-Bus error name and strips it if found. If stripped, the
 * message field in `error` will correspond exactly to what was
 * received on the wire.
 * 
 * This is typically used when presenting errors to the end user.
 * @param error A #GError.
 * @returns %TRUE if information was stripped, %FALSE otherwise.
 */
function dbus_error_strip_remote_error(error: GLib.Error): boolean
/**
 * Destroys an association previously set up with g_dbus_error_register_error().
 * @param error_domain A #GQuark for an error domain.
 * @param error_code An error code.
 * @param dbus_error_name A D-Bus error name.
 * @returns %TRUE if the association was destroyed, %FALSE if it wasn't found.
 */
function dbus_error_unregister_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string | null): boolean
/**
 * This is a language binding friendly version of g_dbus_escape_object_path_bytestring().
 * @param s the string to escape
 * @returns an escaped version of @s. Free with g_free().
 */
function dbus_escape_object_path(s: string | null): string | null
/**
 * Escapes `bytes` for use in a D-Bus object path component.
 * `bytes` is an array of zero or more nonzero bytes in an
 * unspecified encoding, followed by a single zero byte.
 * 
 * The escaping method consists of replacing all non-alphanumeric
 * characters (see g_ascii_isalnum()) with their hexadecimal value
 * preceded by an underscore (`_`). For example:
 * `foo.bar.baz` will become `foo_2ebar_2ebaz`.
 * 
 * This method is appropriate to use when the input is nearly
 * a valid object path component but is not when your input
 * is far from being a valid object path component.
 * Other escaping algorithms are also valid to use with
 * D-Bus object paths.
 * 
 * This can be reversed with g_dbus_unescape_object_path().
 * @param bytes the string of bytes to escape
 * @returns an escaped version of @bytes. Free with g_free().
 */
function dbus_escape_object_path_bytestring(bytes: Uint8Array): string | null
/**
 * Generate a D-Bus GUID that can be used with
 * e.g. g_dbus_connection_new().
 * 
 * See the
 * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
 * regarding what strings are valid D-Bus GUIDs. The specification refers to
 * these as ‘UUIDs’ whereas GLib (for historical reasons) refers to them as
 * ‘GUIDs’. The terms are interchangeable.
 * 
 * Note that D-Bus GUIDs do not follow
 * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
 * @returns A valid D-Bus GUID. Free with g_free().
 */
function dbus_generate_guid(): string | null
/**
 * Converts a #GValue to a #GVariant of the type indicated by the `type`
 * parameter.
 * 
 * The conversion is using the following rules:
 * 
 * - `G_TYPE_STRING`: 's', 'o', 'g' or 'ay'
 * - `G_TYPE_STRV`: 'as', 'ao' or 'aay'
 * - `G_TYPE_BOOLEAN`: 'b'
 * - `G_TYPE_UCHAR`: 'y'
 * - `G_TYPE_INT`: 'i', 'n'
 * - `G_TYPE_UINT`: 'u', 'q'
 * - `G_TYPE_INT64`: 'x'
 * - `G_TYPE_UINT64`: 't'
 * - `G_TYPE_DOUBLE`: 'd'
 * - `G_TYPE_VARIANT`: Any #GVariantType
 * 
 * This can fail if e.g. `gvalue` is of type %G_TYPE_STRING and `type`
 * is 'i', i.e. %G_VARIANT_TYPE_INT32. It will also fail for any #GType
 * (including e.g. %G_TYPE_OBJECT and %G_TYPE_BOXED derived-types) not
 * in the table above.
 * 
 * Note that if `gvalue` is of type %G_TYPE_VARIANT and its value is
 * %NULL, the empty #GVariant instance (never %NULL) for `type` is
 * returned (e.g. 0 for scalar types, the empty string for string types,
 * '/' for object path types, the empty array for any array type and so on).
 * 
 * See the g_dbus_gvariant_to_gvalue() function for how to convert a
 * #GVariant to a #GValue.
 * @param gvalue A #GValue to convert to a #GVariant
 * @param type A #GVariantType
 * @returns A #GVariant (never floating) of     #GVariantType @type holding the data from @gvalue or an empty #GVariant     in case of failure. Free with g_variant_unref().
 */
function dbus_gvalue_to_gvariant(gvalue: any, type: GLib.VariantType): GLib.Variant
/**
 * Converts a #GVariant to a #GValue. If `value` is floating, it is consumed.
 * 
 * The rules specified in the g_dbus_gvalue_to_gvariant() function are
 * used - this function is essentially its reverse form. So, a #GVariant
 * containing any basic or string array type will be converted to a #GValue
 * containing a basic value or string array. Any other #GVariant (handle,
 * variant, tuple, dict entry) will be converted to a #GValue containing that
 * #GVariant.
 * 
 * The conversion never fails - a valid #GValue is always returned in
 * `out_gvalue`.
 * @param value A #GVariant.
 */
function dbus_gvariant_to_gvalue(value: GLib.Variant): /* out_gvalue */ any
/**
 * Checks if `string` is a
 * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
 * 
 * This doesn't check if `string` is actually supported by #GDBusServer
 * or #GDBusConnection - use g_dbus_is_supported_address() to do more
 * checks.
 * @param string A string.
 * @returns %TRUE if @string is a valid D-Bus address, %FALSE otherwise.
 */
function dbus_is_address(string: string | null): boolean
/**
 * Check whether `string` is a valid D-Bus error name.
 * 
 * This function returns the same result as g_dbus_is_interface_name(),
 * because D-Bus error names are defined to have exactly the
 * same syntax as interface names.
 * @param string The string to check.
 * @returns %TRUE if valid, %FALSE otherwise.
 */
function dbus_is_error_name(string: string | null): boolean
/**
 * Checks if `string` is a D-Bus GUID.
 * 
 * See the documentation for g_dbus_generate_guid() for more information about
 * the format of a GUID.
 * @param string The string to check.
 * @returns %TRUE if @string is a GUID, %FALSE otherwise.
 */
function dbus_is_guid(string: string | null): boolean
/**
 * Checks if `string` is a valid D-Bus interface name.
 * @param string The string to check.
 * @returns %TRUE if valid, %FALSE otherwise.
 */
function dbus_is_interface_name(string: string | null): boolean
/**
 * Checks if `string` is a valid D-Bus member (e.g. signal or method) name.
 * @param string The string to check.
 * @returns %TRUE if valid, %FALSE otherwise.
 */
function dbus_is_member_name(string: string | null): boolean
/**
 * Checks if `string` is a valid D-Bus bus name (either unique or well-known).
 * @param string The string to check.
 * @returns %TRUE if valid, %FALSE otherwise.
 */
function dbus_is_name(string: string | null): boolean
/**
 * Like g_dbus_is_address() but also checks if the library supports the
 * transports in `string` and that key/value pairs for each transport
 * are valid. See the specification of the
 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
 * @param string A string.
 * @returns %TRUE if @string is a valid D-Bus address that is supported by this library, %FALSE if @error is set.
 */
function dbus_is_supported_address(string: string | null): boolean
/**
 * Checks if `string` is a valid D-Bus unique bus name.
 * @param string The string to check.
 * @returns %TRUE if valid, %FALSE otherwise.
 */
function dbus_is_unique_name(string: string | null): boolean
/**
 * Unescapes an string that was previously escaped with
 * g_dbus_escape_object_path(). If the string is in a format that could
 * not have been returned by g_dbus_escape_object_path(), this function
 * returns %NULL.
 * 
 * Encoding alphanumeric characters which do not need to be
 * encoded is not allowed (e.g `_63` is not valid, the string
 * should contain `c` instead).
 * @param s the string to unescape
 * @returns an   unescaped version of @s, or %NULL if @s is not a string returned   from g_dbus_escape_object_path(). Free with g_free().
 */
function dbus_unescape_object_path(s: string | null): Uint8Array | null
/**
 * Creates a new #GDtlsClientConnection wrapping `base_socket` which is
 * assumed to communicate with the server identified by `server_identity`.
 * @param base_socket the #GDatagramBased to wrap
 * @param server_identity the expected identity of the server
 * @returns the new   #GDtlsClientConnection, or %NULL on error
 */
function dtls_client_connection_new(base_socket: DatagramBased, server_identity: SocketConnectable | null): DtlsClientConnection
/**
 * Creates a new #GDtlsServerConnection wrapping `base_socket`.
 * @param base_socket the #GDatagramBased to wrap
 * @param certificate the default server certificate, or %NULL
 * @returns the new   #GDtlsServerConnection, or %NULL on error
 */
function dtls_server_connection_new(base_socket: DatagramBased, certificate: TlsCertificate | null): DtlsServerConnection
/**
 * Creates a #GFile with the given argument from the command line.
 * The value of `arg` can be either a URI, an absolute path or a
 * relative path resolved relative to the current working directory.
 * This operation never fails, but the returned object might not
 * support any I/O operation if `arg` points to a malformed path.
 * 
 * Note that on Windows, this function expects its argument to be in
 * UTF-8 -- not the system code page.  This means that you
 * should not use this function with string from argv as it is passed
 * to main().  g_win32_get_command_line() will return a UTF-8 version of
 * the commandline.  #GApplication also uses UTF-8 but
 * g_application_command_line_create_file_for_arg() may be more useful
 * for you there.  It is also always possible to use this function with
 * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
 * @param arg a command line string
 * @returns a new #GFile.   Free the returned object with g_object_unref().
 */
function file_new_for_commandline_arg(arg: string): File
/**
 * Creates a #GFile with the given argument from the command line.
 * 
 * This function is similar to g_file_new_for_commandline_arg() except
 * that it allows for passing the current working directory as an
 * argument instead of using the current working directory of the
 * process.
 * 
 * This is useful if the commandline argument was given in a context
 * other than the invocation of the current process.
 * 
 * See also g_application_command_line_create_file_for_arg().
 * @param arg a command line string
 * @param cwd the current working directory of the commandline
 * @returns a new #GFile
 */
function file_new_for_commandline_arg_and_cwd(arg: string, cwd: string): File
/**
 * Constructs a #GFile for a given path. This operation never
 * fails, but the returned object might not support any I/O
 * operation if `path` is malformed.
 * @param path a string containing a relative or absolute path.   The string must be encoded in the glib filename encoding.
 * @returns a new #GFile for the given @path.   Free the returned object with g_object_unref().
 */
function file_new_for_path(path: string): File
/**
 * Constructs a #GFile for a given URI. This operation never
 * fails, but the returned object might not support any I/O
 * operation if `uri` is malformed or if the uri type is
 * not supported.
 * @param uri a UTF-8 string containing a URI
 * @returns a new #GFile for the given @uri.   Free the returned object with g_object_unref().
 */
function file_new_for_uri(uri: string | null): File
/**
 * Opens a file in the preferred directory for temporary files (as
 * returned by g_get_tmp_dir()) and returns a #GFile and
 * #GFileIOStream pointing to it.
 * 
 * `tmpl` should be a string in the GLib file name encoding
 * containing a sequence of six 'X' characters, and containing no
 * directory components. If it is %NULL, a default template is used.
 * 
 * Unlike the other #GFile constructors, this will return %NULL if
 * a temporary file could not be created.
 * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
 * @returns a new #GFile.   Free the returned object with g_object_unref().
 */
function file_new_tmp(tmpl: string | null): [ /* returnType */ File, /* iostream */ FileIOStream ]
/**
 * Asynchronously opens a file in the preferred directory for temporary files
 *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
 * 
 * `tmpl` should be a string in the GLib file name encoding
 * containing a sequence of six 'X' characters, and containing no
 * directory components. If it is %NULL, a default template is used.
 * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
 * @param io_priority the [I/O priority][io-priority] of the request
 * @param cancellable optional #GCancellable object, %NULL to ignore
 * @param callback a #GAsyncReadyCallback to call when the request is done
 */
function file_new_tmp_async<Z = unknown>(tmpl: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<Z> | null): void

// Overloads of file_new_tmp_async

/**
 * Promisified version of {@link file_new_tmp_async}
 * 
 * Asynchronously opens a file in the preferred directory for temporary files
 *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
 * 
 * `tmpl` should be a string in the GLib file name encoding
 * containing a sequence of six 'X' characters, and containing no
 * directory components. If it is %NULL, a default template is used.
 * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
 * @param io_priority the [I/O priority][io-priority] of the request
 * @param cancellable optional #GCancellable object, %NULL to ignore
 * @returns A Promise of: a new #GFile.   Free the returned object with g_object_unref().
 */
function file_new_tmp_async<Z = unknown>(tmpl: string | null, io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* iostream */ FileIOStream>
/**
 * Asynchronously creates a directory in the preferred directory for
 * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
 * 
 * `tmpl` should be a string in the GLib file name encoding
 * containing a sequence of six 'X' characters, and containing no
 * directory components. If it is %NULL, a default template is used.
 * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
 * @param io_priority the [I/O priority][io-priority] of the request
 * @param cancellable optional #GCancellable object, %NULL to ignore
 * @param callback a #GAsyncReadyCallback to call when the request is done
 */
function file_new_tmp_dir_async<Z = unknown>(tmpl: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<Z> | null): void

// Overloads of file_new_tmp_dir_async

/**
 * Promisified version of {@link file_new_tmp_dir_async}
 * 
 * Asynchronously creates a directory in the preferred directory for
 * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
 * 
 * `tmpl` should be a string in the GLib file name encoding
 * containing a sequence of six 'X' characters, and containing no
 * directory components. If it is %NULL, a default template is used.
 * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
 * @param io_priority the [I/O priority][io-priority] of the request
 * @param cancellable optional #GCancellable object, %NULL to ignore
 * @returns A Promise of: a new #GFile.   Free the returned object with g_object_unref().
 */
function file_new_tmp_dir_async<Z = unknown>(tmpl: string | null, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<File>
/**
 * Finishes a temporary directory creation started by
 * g_file_new_tmp_dir_async().
 * @param result a #GAsyncResult
 * @returns a new #GFile.   Free the returned object with g_object_unref().
 */
function file_new_tmp_dir_finish(result: AsyncResult): File
/**
 * Finishes a temporary file creation started by g_file_new_tmp_async().
 * @param result a #GAsyncResult
 * @returns a new #GFile.   Free the returned object with g_object_unref().
 */
function file_new_tmp_finish(result: AsyncResult): [ /* returnType */ File, /* iostream */ FileIOStream ]
/**
 * Constructs a #GFile with the given `parse_name` (i.e. something
 * given by g_file_get_parse_name()). This operation never fails,
 * but the returned object might not support any I/O operation if
 * the `parse_name` cannot be parsed.
 * @param parse_name a file name or path to be parsed
 * @returns a new #GFile.
 */
function file_parse_name(parse_name: string | null): File
/**
 * Deserializes a #GIcon previously serialized using g_icon_serialize().
 * @param value a #GVariant created with g_icon_serialize()
 * @returns a #GIcon, or %NULL when deserialization fails.
 */
function icon_deserialize(value: GLib.Variant): Icon | null
/**
 * Generate a #GIcon instance from `str`. This function can fail if
 * `str` is not valid - see g_icon_to_string() for discussion.
 * 
 * If your application or library provides one or more #GIcon
 * implementations you need to ensure that each #GType is registered
 * with the type system prior to calling g_icon_new_for_string().
 * @param str A string obtained via g_icon_to_string().
 * @returns An object implementing the #GIcon          interface or %NULL if @error is set.
 */
function icon_new_for_string(str: string | null): Icon
/**
 * Helper function for constructing #GInitable object. This is
 * similar to g_object_newv() but also initializes the object
 * and returns %NULL, setting an error on failure.
 * @param object_type a #GType supporting #GInitable.
 * @param parameters the parameters to use to construct the object
 * @param cancellable optional #GCancellable object, %NULL to ignore.
 * @returns a newly allocated      #GObject, or %NULL on error
 */
function initable_newv(object_type: GObject.GType, parameters: GObject.Parameter[], cancellable: Cancellable | null): GObject.Object
/**
 * Converts errno.h error codes into GIO error codes. The fallback
 * value %G_IO_ERROR_FAILED is returned for error codes not currently
 * handled (but note that future GLib releases may return a more
 * specific value instead).
 * 
 * As %errno is global and may be modified by intermediate function
 * calls, you should save its value as soon as the call which sets it
 * @param err_no Error number as defined in errno.h.
 * @returns #GIOErrorEnum value for the given errno.h error number.
 */
function io_error_from_errno(err_no: number): IOErrorEnum
/**
 * Converts #GFileError error codes into GIO error codes.
 * @param file_error a #GFileError.
 * @returns #GIOErrorEnum value for the given #GFileError error value.
 */
function io_error_from_file_error(file_error: GLib.FileError): IOErrorEnum
/**
 * Gets the GIO Error Quark.
 * @returns a #GQuark.
 */
function io_error_quark(): GLib.Quark
/**
 * Registers `type` as extension for the extension point with name
 * `extension_point_name`.
 * 
 * If `type` has already been registered as an extension for this
 * extension point, the existing #GIOExtension object is returned.
 * @param extension_point_name the name of the extension point
 * @param type the #GType to register as extension
 * @param extension_name the name for the extension
 * @param priority the priority for the extension
 * @returns a #GIOExtension object for #GType
 */
function io_extension_point_implement(extension_point_name: string | null, type: GObject.GType, extension_name: string | null, priority: number): IOExtension
/**
 * Looks up an existing extension point.
 * @param name the name of the extension point
 * @returns the #GIOExtensionPoint, or %NULL if there    is no registered extension point with the given name.
 */
function io_extension_point_lookup(name: string | null): IOExtensionPoint
/**
 * Registers an extension point.
 * @param name The name of the extension point
 * @returns the new #GIOExtensionPoint. This object is    owned by GIO and should not be freed.
 */
function io_extension_point_register(name: string | null): IOExtensionPoint
/**
 * Loads all the modules in the specified directory.
 * 
 * If don't require all modules to be initialized (and thus registering
 * all gtypes) then you can use g_io_modules_scan_all_in_directory()
 * which allows delayed/lazy loading of modules.
 * @param dirname pathname for a directory containing modules     to load.
 * @returns a list of #GIOModules loaded      from the directory,      All the modules are loaded into memory, if you want to      unload them (enabling on-demand loading) you must call      g_type_module_unuse() on all the modules. Free the list      with g_list_free().
 */
function io_modules_load_all_in_directory(dirname: string): IOModule[]
/**
 * Loads all the modules in the specified directory.
 * 
 * If don't require all modules to be initialized (and thus registering
 * all gtypes) then you can use g_io_modules_scan_all_in_directory()
 * which allows delayed/lazy loading of modules.
 * @param dirname pathname for a directory containing modules     to load.
 * @param scope a scope to use when scanning the modules.
 * @returns a list of #GIOModules loaded      from the directory,      All the modules are loaded into memory, if you want to      unload them (enabling on-demand loading) you must call      g_type_module_unuse() on all the modules. Free the list      with g_list_free().
 */
function io_modules_load_all_in_directory_with_scope(dirname: string, scope: IOModuleScope): IOModule[]
/**
 * Scans all the modules in the specified directory, ensuring that
 * any extension point implemented by a module is registered.
 * 
 * This may not actually load and initialize all the types in each
 * module, some modules may be lazily loaded and initialized when
 * an extension point it implements is used with e.g.
 * g_io_extension_point_get_extensions() or
 * g_io_extension_point_get_extension_by_name().
 * 
 * If you need to guarantee that all types are loaded in all the modules,
 * use g_io_modules_load_all_in_directory().
 * @param dirname pathname for a directory containing modules     to scan.
 */
function io_modules_scan_all_in_directory(dirname: string): void
/**
 * Scans all the modules in the specified directory, ensuring that
 * any extension point implemented by a module is registered.
 * 
 * This may not actually load and initialize all the types in each
 * module, some modules may be lazily loaded and initialized when
 * an extension point it implements is used with e.g.
 * g_io_extension_point_get_extensions() or
 * g_io_extension_point_get_extension_by_name().
 * 
 * If you need to guarantee that all types are loaded in all the modules,
 * use g_io_modules_load_all_in_directory().
 * @param dirname pathname for a directory containing modules     to scan.
 * @param scope a scope to use when scanning the modules
 */
function io_modules_scan_all_in_directory_with_scope(dirname: string, scope: IOModuleScope): void
/**
 * Cancels all cancellable I/O jobs.
 * 
 * A job is cancellable if a #GCancellable was passed into
 * g_io_scheduler_push_job().
 */
function io_scheduler_cancel_all_jobs(): void
/**
 * Schedules the I/O job to run in another thread.
 * 
 * `notify` will be called on `user_data` after `job_func` has returned,
 * regardless whether the job was cancelled or has run to completion.
 * 
 * If `cancellable` is not %NULL, it can be used to cancel the I/O job
 * by calling g_cancellable_cancel() or by calling
 * g_io_scheduler_cancel_all_jobs().
 * @param job_func a #GIOSchedulerJobFunc.
 * @param io_priority the [I/O priority][io-priority] of the request.
 * @param cancellable optional #GCancellable object, %NULL to ignore.
 */
function io_scheduler_push_job(job_func: IOSchedulerJobFunc, io_priority: number, cancellable: Cancellable | null): void
/**
 * Creates a keyfile-backed #GSettingsBackend.
 * 
 * The filename of the keyfile to use is given by `filename`.
 * 
 * All settings read to or written from the backend must fall under the
 * path given in `root_path` (which must start and end with a slash and
 * not contain two consecutive slashes).  `root_path` may be "/".
 * 
 * If `root_group` is non-%NULL then it specifies the name of the keyfile
 * group used for keys that are written directly below `root_path`.  For
 * example, if `root_path` is "/apps/example/" and `root_group` is
 * "toplevel", then settings the key "/apps/example/enabled" to a value
 * of %TRUE will cause the following to appear in the keyfile:
 * 
 * 
 * ```
 *   [toplevel]
 *   enabled=true
 * ```
 * 
 * 
 * If `root_group` is %NULL then it is not permitted to store keys
 * directly below the `root_path`.
 * 
 * For keys not stored directly below `root_path` (ie: in a sub-path),
 * the name of the subpath (with the final slash stripped) is used as
 * the name of the keyfile group.  To continue the example, if
 * "/apps/example/profiles/default/font-size" were set to
 * 12 then the following would appear in the keyfile:
 * 
 * 
 * ```
 *   [profiles/default]
 *   font-size=12
 * ```
 * 
 * 
 * The backend will refuse writes (and return writability as being
 * %FALSE) for keys outside of `root_path` and, in the event that
 * `root_group` is %NULL, also for keys directly under `root_path`.
 * Writes will also be refused if the backend detects that it has the
 * inability to rewrite the keyfile (ie: the containing directory is not
 * writable).
 * 
 * There is no checking done for your key namespace clashing with the
 * syntax of the key file format.  For example, if you have '[' or ']'
 * characters in your path names or '=' in your key names you may be in
 * trouble.
 * 
 * The backend reads default values from a keyfile called `defaults` in
 * the directory specified by the #GKeyfileSettingsBackend:defaults-dir property,
 * and a list of locked keys from a text file with the name `locks` in
 * the same location.
 * @param filename the filename of the keyfile
 * @param root_path the path under which all settings keys appear
 * @param root_group the group name corresponding to              `root_path,` or %NULL
 * @returns a keyfile-backed #GSettingsBackend
 */
function keyfile_settings_backend_new(filename: string | null, root_path: string | null, root_group: string | null): SettingsBackend
/**
 * Gets a reference to the default #GMemoryMonitor for the system.
 * @returns a new reference to the default #GMemoryMonitor
 */
function memory_monitor_dup_default(): MemoryMonitor
/**
 * Creates a memory-backed #GSettingsBackend.
 * 
 * This backend allows changes to settings, but does not write them
 * to any backing storage, so the next time you run your application,
 * the memory backend will start out with the default values again.
 * @returns a newly created #GSettingsBackend
 */
function memory_settings_backend_new(): SettingsBackend
/**
 * Gets the default #GNetworkMonitor for the system.
 * @returns a #GNetworkMonitor, which will be     a dummy object if no network monitor is available
 */
function network_monitor_get_default(): NetworkMonitor
/**
 * Initializes the platform networking libraries (eg, on Windows, this
 * calls WSAStartup()). GLib will call this itself if it is needed, so
 * you only need to call it if you directly call system networking
 * functions (without calling any GLib networking functions first).
 */
function networking_init(): void
/**
 * Creates a readonly #GSettingsBackend.
 * 
 * This backend does not allow changes to settings, so all settings
 * will always have their default values.
 * @returns a newly created #GSettingsBackend
 */
function null_settings_backend_new(): SettingsBackend
/**
 * Utility method for #GPollableInputStream and #GPollableOutputStream
 * implementations. Creates a new #GSource that expects a callback of
 * type #GPollableSourceFunc. The new source does not actually do
 * anything on its own; use g_source_add_child_source() to add other
 * sources to it to cause it to trigger.
 * @param pollable_stream the stream associated with the new source
 * @returns the new #GSource.
 */
function pollable_source_new(pollable_stream: GObject.Object): GLib.Source
/**
 * Utility method for #GPollableInputStream and #GPollableOutputStream
 * implementations. Creates a new #GSource, as with
 * g_pollable_source_new(), but also attaching `child_source` (with a
 * dummy callback), and `cancellable,` if they are non-%NULL.
 * @param pollable_stream the stream associated with the   new source
 * @param child_source optional child source to attach
 * @param cancellable optional #GCancellable to attach
 * @returns the new #GSource.
 */
function pollable_source_new_full(pollable_stream: GObject.Object, child_source: GLib.Source | null, cancellable: Cancellable | null): GLib.Source
/**
 * Tries to read from `stream,` as with g_input_stream_read() (if
 * `blocking` is %TRUE) or g_pollable_input_stream_read_nonblocking()
 * (if `blocking` is %FALSE). This can be used to more easily share
 * code between blocking and non-blocking implementations of a method.
 * 
 * If `blocking` is %FALSE, then `stream` must be a
 * #GPollableInputStream for which g_pollable_input_stream_can_poll()
 * returns %TRUE, or else the behavior is undefined. If `blocking` is
 * %TRUE, then `stream` does not need to be a #GPollableInputStream.
 * @param stream a #GInputStream
 * @param buffer a buffer to   read data into
 * @param blocking whether to do blocking I/O
 * @param cancellable optional #GCancellable object, %NULL to ignore.
 * @returns the number of bytes read, or -1 on error.
 */
function pollable_stream_read(stream: InputStream, buffer: Uint8Array, blocking: boolean, cancellable: Cancellable | null): number
/**
 * Tries to write to `stream,` as with g_output_stream_write() (if
 * `blocking` is %TRUE) or g_pollable_output_stream_write_nonblocking()
 * (if `blocking` is %FALSE). This can be used to more easily share
 * code between blocking and non-blocking implementations of a method.
 * 
 * If `blocking` is %FALSE, then `stream` must be a
 * #GPollableOutputStream for which
 * g_pollable_output_stream_can_poll() returns %TRUE or else the
 * behavior is undefined. If `blocking` is %TRUE, then `stream` does not
 * need to be a #GPollableOutputStream.
 * @param stream a #GOutputStream.
 * @param buffer the buffer   containing the data to write.
 * @param blocking whether to do blocking I/O
 * @param cancellable optional #GCancellable object, %NULL to ignore.
 * @returns the number of bytes written, or -1 on error.
 */
function pollable_stream_write(stream: OutputStream, buffer: Uint8Array, blocking: boolean, cancellable: Cancellable | null): number
/**
 * Tries to write `count` bytes to `stream,` as with
 * g_output_stream_write_all(), but using g_pollable_stream_write()
 * rather than g_output_stream_write().
 * 
 * On a successful write of `count` bytes, %TRUE is returned, and
 * `bytes_written` is set to `count`.
 * 
 * If there is an error during the operation (including
 * %G_IO_ERROR_WOULD_BLOCK in the non-blocking case), %FALSE is
 * returned and `error` is set to indicate the error status,
 * `bytes_written` is updated to contain the number of bytes written
 * into the stream before the error occurred.
 * 
 * As with g_pollable_stream_write(), if `blocking` is %FALSE, then
 * `stream` must be a #GPollableOutputStream for which
 * g_pollable_output_stream_can_poll() returns %TRUE or else the
 * behavior is undefined. If `blocking` is %TRUE, then `stream` does not
 * need to be a #GPollableOutputStream.
 * @param stream a #GOutputStream.
 * @param buffer the buffer   containing the data to write.
 * @param blocking whether to do blocking I/O
 * @param cancellable optional #GCancellable object, %NULL to ignore.
 * @returns %TRUE on success, %FALSE if there was an error
 */
function pollable_stream_write_all(stream: OutputStream, buffer: Uint8Array, blocking: boolean, cancellable: Cancellable | null): [ /* returnType */ boolean, /* bytes_written */ number ]
/**
 * Gets a reference to the default #GPowerProfileMonitor for the system.
 * @returns a new reference to the default #GPowerProfileMonitor
 */
function power_profile_monitor_dup_default(): PowerProfileMonitor
/**
 * Find the `gio-proxy` extension point for a proxy implementation that supports
 * the specified protocol.
 * @param protocol the proxy protocol name (e.g. http, socks, etc)
 * @returns return a #GProxy or NULL if protocol               is not supported.
 */
function proxy_get_default_for_protocol(protocol: string | null): Proxy | null
/**
 * Gets the default #GProxyResolver for the system.
 * @returns the default #GProxyResolver, which     will be a dummy object if no proxy resolver is available
 */
function proxy_resolver_get_default(): ProxyResolver
/**
 * Gets the #GResolver Error Quark.
 * @returns a #GQuark.
 */
function resolver_error_quark(): GLib.Quark
/**
 * Gets the #GResource Error Quark.
 * @returns a #GQuark
 */
function resource_error_quark(): GLib.Quark
/**
 * Loads a binary resource bundle and creates a #GResource representation of it, allowing
 * you to query it for data.
 * 
 * If you want to use this resource in the global resource namespace you need
 * to register it with g_resources_register().
 * 
 * If `filename` is empty or the data in it is corrupt,
 * %G_RESOURCE_ERROR_INTERNAL will be returned. If `filename` doesn’t exist, or
 * there is an error in reading it, an error from g_mapped_file_new() will be
 * returned.
 * @param filename the path of a filename to load, in the GLib filename encoding
 * @returns a new #GResource, or %NULL on error
 */
function resource_load(filename: string): Resource
/**
 * Returns all the names of children at the specified `path` in the set of
 * globally registered resources.
 * The return result is a %NULL terminated list of strings which should
 * be released with g_strfreev().
 * 
 * `lookup_flags` controls the behaviour of the lookup.
 * @param path A pathname inside the resource
 * @param lookup_flags A #GResourceLookupFlags
 * @returns an array of constant strings
 */
function resources_enumerate_children(path: string | null, lookup_flags: ResourceLookupFlags): string[]
/**
 * Looks for a file at the specified `path` in the set of
 * globally registered resources and if found returns information about it.
 * 
 * `lookup_flags` controls the behaviour of the lookup.
 * @param path A pathname inside the resource
 * @param lookup_flags A #GResourceLookupFlags
 * @returns %TRUE if the file was found. %FALSE if there were errors
 */
function resources_get_info(path: string | null, lookup_flags: ResourceLookupFlags): [ /* returnType */ boolean, /* size */ number, /* flags */ number ]
/**
 * Looks for a file at the specified `path` in the set of
 * globally registered resources and returns a #GBytes that
 * lets you directly access the data in memory.
 * 
 * The data is always followed by a zero byte, so you
 * can safely use the data as a C string. However, that byte
 * is not included in the size of the GBytes.
 * 
 * For uncompressed resource files this is a pointer directly into
 * the resource bundle, which is typically in some readonly data section
 * in the program binary. For compressed files we allocate memory on
 * the heap and automatically uncompress the data.
 * 
 * `lookup_flags` controls the behaviour of the lookup.
 * @param path A pathname inside the resource
 * @param lookup_flags A #GResourceLookupFlags
 * @returns #GBytes or %NULL on error.     Free the returned object with g_bytes_unref()
 */
function resources_lookup_data(path: string | null, lookup_flags: ResourceLookupFlags): GLib.Bytes
/**
 * Looks for a file at the specified `path` in the set of
 * globally registered resources and returns a #GInputStream
 * that lets you read the data.
 * 
 * `lookup_flags` controls the behaviour of the lookup.
 * @param path A pathname inside the resource
 * @param lookup_flags A #GResourceLookupFlags
 * @returns #GInputStream or %NULL on error.     Free the returned object with g_object_unref()
 */
function resources_open_stream(path: string | null, lookup_flags: ResourceLookupFlags): InputStream
/**
 * Registers the resource with the process-global set of resources.
 * Once a resource is registered the files in it can be accessed
 * with the global resource lookup functions like g_resources_lookup_data().
 * @param resource A #GResource
 */
function resources_register(resource: Resource): void
/**
 * Unregisters the resource from the process-global set of resources.
 * @param resource A #GResource
 */
function resources_unregister(resource: Resource): void
/**
 * Gets the default system schema source.
 * 
 * This function is not required for normal uses of #GSettings but it
 * may be useful to authors of plugin management systems or to those who
 * want to introspect the content of schemas.
 * 
 * If no schemas are installed, %NULL will be returned.
 * 
 * The returned source may actually consist of multiple schema sources
 * from different directories, depending on which directories were given
 * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
 * lookups performed against the default source should probably be done
 * recursively.
 * @returns the default schema source
 */
function settings_schema_source_get_default(): SettingsSchemaSource | null
/**
 * Reports an error in an idle function. Similar to
 * g_simple_async_report_error_in_idle(), but takes a #GError rather
 * than building a new one.
 * @param object a #GObject, or %NULL
 * @param callback a #GAsyncReadyCallback.
 * @param error the #GError to report
 */
function simple_async_report_gerror_in_idle<Z = unknown>(object: GObject.Object | null, callback: AsyncReadyCallback<Z> | null, error: GLib.Error): void
/**
 * Gets the default #GTlsBackend for the system.
 * @returns a #GTlsBackend, which will be a     dummy object if no TLS backend is available
 */
function tls_backend_get_default(): TlsBackend
/**
 * Gets the TLS channel binding error quark.
 * @returns a #GQuark.
 */
function tls_channel_binding_error_quark(): GLib.Quark
/**
 * Creates a new #GTlsClientConnection wrapping `base_io_stream` (which
 * must have pollable input and output streams) which is assumed to
 * communicate with the server identified by `server_identity`.
 * 
 * See the documentation for #GTlsConnection:base-io-stream for restrictions
 * on when application code can run operations on the `base_io_stream` after
 * this function has returned.
 * @param base_io_stream the #GIOStream to wrap
 * @param server_identity the expected identity of the server
 * @returns the new #GTlsClientConnection, or %NULL on error
 */
function tls_client_connection_new(base_io_stream: IOStream, server_identity: SocketConnectable | null): TlsClientConnection
/**
 * Gets the TLS error quark.
 * @returns a #GQuark.
 */
function tls_error_quark(): GLib.Quark
/**
 * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
 * in `anchors` to verify certificate chains.
 * 
 * The certificates in `anchors` must be PEM encoded.
 * @param anchors filename of anchor certificate authorities.
 * @returns the new #GTlsFileDatabase, or %NULL on error
 */
function tls_file_database_new(anchors: string): TlsFileDatabase
/**
 * Creates a new #GTlsServerConnection wrapping `base_io_stream` (which
 * must have pollable input and output streams).
 * 
 * See the documentation for #GTlsConnection:base-io-stream for restrictions
 * on when application code can run operations on the `base_io_stream` after
 * this function has returned.
 * @param base_io_stream the #GIOStream to wrap
 * @param certificate the default server certificate, or %NULL
 * @returns the new #GTlsServerConnection, or %NULL on error
 */
function tls_server_connection_new(base_io_stream: IOStream, certificate: TlsCertificate | null): TlsServerConnection
/**
 * Determines if `mount_path` is considered an implementation of the
 * OS. This is primarily used for hiding mountable and mounted volumes
 * that only are used in the OS and has little to no relevance to the
 * casual user.
 * @param mount_path a mount path, e.g. `/media/disk` or `/usr`
 * @returns %TRUE if @mount_path is considered an implementation detail     of the OS.
 */
function unix_is_mount_path_system_internal(mount_path: string): boolean
/**
 * Determines if `device_path` is considered a block device path which is only
 * used in implementation of the OS. This is primarily used for hiding
 * mounted volumes that are intended as APIs for programs to read, and system
 * administrators at a shell; rather than something that should, for example,
 * appear in a GUI. For example, the Linux `/proc` filesystem.
 * 
 * The list of device paths considered ‘system’ ones may change over time.
 * @param device_path a device path, e.g. `/dev/loop0` or `nfsd`
 * @returns %TRUE if @device_path is considered an implementation detail of    the OS.
 */
function unix_is_system_device_path(device_path: string | null): boolean
/**
 * Determines if `fs_type` is considered a type of file system which is only
 * used in implementation of the OS. This is primarily used for hiding
 * mounted volumes that are intended as APIs for programs to read, and system
 * administrators at a shell; rather than something that should, for example,
 * appear in a GUI. For example, the Linux `/proc` filesystem.
 * 
 * The list of file system types considered ‘system’ ones may change over time.
 * @param fs_type a file system type, e.g. `procfs` or `tmpfs`
 * @returns %TRUE if @fs_type is considered an implementation detail of the OS.
 */
function unix_is_system_fs_type(fs_type: string | null): boolean
/**
 * Gets a #GUnixMountEntry for a given mount path. If `time_read`
 * is set, it will be filled with a unix timestamp for checking
 * if the mounts have changed since with g_unix_mounts_changed_since().
 * 
 * If more mounts have the same mount path, the last matching mount
 * is returned.
 * 
 * This will return %NULL if there is no mount point at `mount_path`.
 * @param mount_path path for a possible unix mount.
 * @returns a #GUnixMountEntry.
 */
function unix_mount_at(mount_path: string): [ /* returnType */ UnixMountEntry | null, /* time_read */ number ]
/**
 * Compares two unix mounts.
 * @param mount1 first #GUnixMountEntry to compare.
 * @param mount2 second #GUnixMountEntry to compare.
 * @returns 1, 0 or -1 if @mount1 is greater than, equal to, or less than @mount2, respectively.
 */
function unix_mount_compare(mount1: UnixMountEntry, mount2: UnixMountEntry): number
/**
 * Makes a copy of `mount_entry`.
 * @param mount_entry a #GUnixMountEntry.
 * @returns a new #GUnixMountEntry
 */
function unix_mount_copy(mount_entry: UnixMountEntry): UnixMountEntry
/**
 * Gets a #GUnixMountEntry for a given file path. If `time_read`
 * is set, it will be filled with a unix timestamp for checking
 * if the mounts have changed since with g_unix_mounts_changed_since().
 * 
 * If more mounts have the same mount path, the last matching mount
 * is returned.
 * 
 * This will return %NULL if looking up the mount entry fails, if
 * `file_path` doesn’t exist or there is an I/O error.
 * @param file_path file path on some unix mount.
 * @returns a #GUnixMountEntry.
 */
function unix_mount_for(file_path: string): [ /* returnType */ UnixMountEntry | null, /* time_read */ number ]
/**
 * Frees a unix mount.
 * @param mount_entry a #GUnixMountEntry.
 */
function unix_mount_free(mount_entry: UnixMountEntry): void
/**
 * Gets the device path for a unix mount.
 * @param mount_entry a #GUnixMount.
 * @returns a string containing the device path.
 */
function unix_mount_get_device_path(mount_entry: UnixMountEntry): string
/**
 * Gets the filesystem type for the unix mount.
 * @param mount_entry a #GUnixMount.
 * @returns a string containing the file system type.
 */
function unix_mount_get_fs_type(mount_entry: UnixMountEntry): string | null
/**
 * Gets the mount path for a unix mount.
 * @param mount_entry input #GUnixMountEntry to get the mount path for.
 * @returns the mount path for @mount_entry.
 */
function unix_mount_get_mount_path(mount_entry: UnixMountEntry): string
/**
 * Gets a comma-separated list of mount options for the unix mount. For example,
 * `rw,relatime,seclabel,data=ordered`.
 * 
 * This is similar to g_unix_mount_point_get_options(), but it takes
 * a #GUnixMountEntry as an argument.
 * @param mount_entry a #GUnixMountEntry.
 * @returns a string containing the options, or %NULL if not available.
 */
function unix_mount_get_options(mount_entry: UnixMountEntry): string | null
/**
 * Gets the root of the mount within the filesystem. This is useful e.g. for
 * mounts created by bind operation, or btrfs subvolumes.
 * 
 * For example, the root path is equal to "/" for mount created by
 * "mount /dev/sda1 /mnt/foo" and "/bar" for
 * "mount --bind /mnt/foo/bar /mnt/bar".
 * @param mount_entry a #GUnixMountEntry.
 * @returns a string containing the root, or %NULL if not supported.
 */
function unix_mount_get_root_path(mount_entry: UnixMountEntry): string | null
/**
 * Guesses whether a Unix mount can be ejected.
 * @param mount_entry a #GUnixMountEntry
 * @returns %TRUE if @mount_entry is deemed to be ejectable.
 */
function unix_mount_guess_can_eject(mount_entry: UnixMountEntry): boolean
/**
 * Guesses the icon of a Unix mount.
 * @param mount_entry a #GUnixMountEntry
 * @returns a #GIcon
 */
function unix_mount_guess_icon(mount_entry: UnixMountEntry): Icon
/**
 * Guesses the name of a Unix mount.
 * The result is a translated string.
 * @param mount_entry a #GUnixMountEntry
 * @returns A newly allocated string that must     be freed with g_free()
 */
function unix_mount_guess_name(mount_entry: UnixMountEntry): string | null
/**
 * Guesses whether a Unix mount should be displayed in the UI.
 * @param mount_entry a #GUnixMountEntry
 * @returns %TRUE if @mount_entry is deemed to be displayable.
 */
function unix_mount_guess_should_display(mount_entry: UnixMountEntry): boolean
/**
 * Guesses the symbolic icon of a Unix mount.
 * @param mount_entry a #GUnixMountEntry
 * @returns a #GIcon
 */
function unix_mount_guess_symbolic_icon(mount_entry: UnixMountEntry): Icon
/**
 * Checks if a unix mount is mounted read only.
 * @param mount_entry a #GUnixMount.
 * @returns %TRUE if @mount_entry is read only.
 */
function unix_mount_is_readonly(mount_entry: UnixMountEntry): boolean
/**
 * Checks if a Unix mount is a system mount. This is the Boolean OR of
 * g_unix_is_system_fs_type(), g_unix_is_system_device_path() and
 * g_unix_is_mount_path_system_internal() on `mount_entry’`s properties.
 * 
 * The definition of what a ‘system’ mount entry is may change over time as new
 * file system types and device paths are ignored.
 * @param mount_entry a #GUnixMount.
 * @returns %TRUE if the unix mount is for a system path.
 */
function unix_mount_is_system_internal(mount_entry: UnixMountEntry): boolean
/**
 * Gets a #GUnixMountPoint for a given mount path. If `time_read` is set, it
 * will be filled with a unix timestamp for checking if the mount points have
 * changed since with g_unix_mount_points_changed_since().
 * 
 * If more mount points have the same mount path, the last matching mount point
 * is returned.
 * @param mount_path path for a possible unix mount point.
 * @returns a #GUnixMountPoint, or %NULL if no match is found.
 */
function unix_mount_point_at(mount_path: string): [ /* returnType */ UnixMountPoint | null, /* time_read */ number ]
/**
 * Checks if the unix mount points have changed since a given unix time.
 * @param time guint64 to contain a timestamp.
 * @returns %TRUE if the mount points have changed since @time.
 */
function unix_mount_points_changed_since(time: number): boolean
/**
 * Gets a #GList of #GUnixMountPoint containing the unix mount points.
 * If `time_read` is set, it will be filled with the mount timestamp,
 * allowing for checking if the mounts have changed with
 * g_unix_mount_points_changed_since().
 * @returns      a #GList of the UNIX mountpoints.
 */
function unix_mount_points_get(): [ /* returnType */ UnixMountPoint[], /* time_read */ number ]
/**
 * Checks if the unix mounts have changed since a given unix time.
 * @param time guint64 to contain a timestamp.
 * @returns %TRUE if the mounts have changed since @time.
 */
function unix_mounts_changed_since(time: number): boolean
/**
 * Gets a #GList of #GUnixMountEntry containing the unix mounts.
 * If `time_read` is set, it will be filled with the mount
 * timestamp, allowing for checking if the mounts have changed
 * with g_unix_mounts_changed_since().
 * @returns      a #GList of the UNIX mounts.
 */
function unix_mounts_get(): [ /* returnType */ UnixMountEntry[], /* time_read */ number ]
/**
 * Type definition for a function that will be called back when an asynchronous
 * operation within GIO has been completed. #GAsyncReadyCallback
 * callbacks from #GTask are guaranteed to be invoked in a later
 * iteration of the
 * [thread-default main context][g-main-context-push-thread-default]
 * where the #GTask was created. All other users of
 * #GAsyncReadyCallback must likewise call it asynchronously in a
 * later iteration of the main context.
 * 
 * The asynchronous operation is guaranteed to have held a reference to
 * `source_object` from the time when the `*_async()` function was called, until
 * after this callback returns.
 * @callback 
 * @param source_object the object the asynchronous operation was started with.
 * @param res a #GAsyncResult.
 * @param data user data passed to the callback.
 */
interface AsyncReadyCallback<T = GObject.Object> {
    (source_object: T, res: AsyncResult, data: any | null): void
}
/**
 * Invoked when a connection to a message bus has been obtained.
 * @callback 
 * @param connection The #GDBusConnection to a message bus.
 * @param name The name that is requested to be owned.
 */
interface BusAcquiredCallback {
    (connection: DBusConnection, name: string | null): void
}
/**
 * Invoked when the name is acquired.
 * @callback 
 * @param connection The #GDBusConnection on which to acquired the name.
 * @param name The name being owned.
 */
interface BusNameAcquiredCallback {
    (connection: DBusConnection, name: string | null): void
}
/**
 * Invoked when the name being watched is known to have to have an owner.
 * @callback 
 * @param connection The #GDBusConnection the name is being watched on.
 * @param name The name being watched.
 * @param name_owner Unique name of the owner of the name being watched.
 */
interface BusNameAppearedCallback {
    (connection: DBusConnection, name: string | null, name_owner: string | null): void
}
/**
 * Invoked when the name is lost or `connection` has been closed.
 * @callback 
 * @param connection The #GDBusConnection on which to acquire the name or %NULL if the connection was disconnected.
 * @param name The name being owned.
 */
interface BusNameLostCallback {
    (connection: DBusConnection, name: string | null): void
}
/**
 * Invoked when the name being watched is known not to have to have an owner.
 * 
 * This is also invoked when the #GDBusConnection on which the watch was
 * established has been closed.  In that case, `connection` will be
 * %NULL.
 * @callback 
 * @param connection The #GDBusConnection the name is being watched on, or     %NULL.
 * @param name The name being watched.
 */
interface BusNameVanishedCallback {
    (connection: DBusConnection, name: string | null): void
}
/**
 * This is the function type of the callback used for the #GSource
 * returned by g_cancellable_source_new().
 * @callback 
 * @param cancellable the #GCancellable
 * @param data data passed in by the user.
 * @returns it should return %FALSE if the source should be removed.
 */
interface CancellableSourceFunc {
    (cancellable: Cancellable | null, data: any | null): boolean
}
/**
 * The type of the `get_property` function in #GDBusInterfaceVTable.
 * @callback 
 * @param connection A #GDBusConnection.
 * @param sender The unique bus name of the remote caller.
 * @param object_path The object path that the method was invoked on.
 * @param interface_name The D-Bus interface name for the property.
 * @param property_name The name of the property to get the value of.
 * @param error Return location for error.
 * @returns A #GVariant with the value for @property_name or %NULL if     @error is set. If the returned #GVariant is floating, it is     consumed - otherwise its reference count is decreased by one.
 */
interface DBusInterfaceGetPropertyFunc {
    (connection: DBusConnection, sender: string | null, object_path: string | null, interface_name: string | null, property_name: string | null, error: GLib.Error): GLib.Variant
}
/**
 * The type of the `method_call` function in #GDBusInterfaceVTable.
 * @callback 
 * @param connection A #GDBusConnection.
 * @param sender The unique bus name of the remote caller.
 * @param object_path The object path that the method was invoked on.
 * @param interface_name The D-Bus interface name the method was invoked on.
 * @param method_name The name of the method that was invoked.
 * @param parameters A #GVariant tuple with parameters.
 * @param invocation A #GDBusMethodInvocation object that must be used to return a value or error.
 */
interface DBusInterfaceMethodCallFunc {
    (connection: DBusConnection, sender: string | null, object_path: string | null, interface_name: string | null, method_name: string | null, parameters: GLib.Variant, invocation: DBusMethodInvocation): void
}
/**
 * The type of the `set_property` function in #GDBusInterfaceVTable.
 * @callback 
 * @param connection A #GDBusConnection.
 * @param sender The unique bus name of the remote caller.
 * @param object_path The object path that the method was invoked on.
 * @param interface_name The D-Bus interface name for the property.
 * @param property_name The name of the property to get the value of.
 * @param value The value to set the property to.
 * @param error Return location for error.
 * @returns %TRUE if the property was set to @value, %FALSE if @error is set.
 */
interface DBusInterfaceSetPropertyFunc {
    (connection: DBusConnection, sender: string | null, object_path: string | null, interface_name: string | null, property_name: string | null, value: GLib.Variant, error: GLib.Error): boolean
}
/**
 * Signature for function used in g_dbus_connection_add_filter().
 * 
 * A filter function is passed a #GDBusMessage and expected to return
 * a #GDBusMessage too. Passive filter functions that don't modify the
 * message can simply return the `message` object:
 * 
 * ```
 * static GDBusMessage *
 * passive_filter (GDBusConnection *connection
 *                 GDBusMessage    *message,
 *                 gboolean         incoming,
 *                 gpointer         user_data)
 * {
 *   // inspect `message`
 *   return message;
 * }
 * ```
 * 
 * Filter functions that wants to drop a message can simply return %NULL:
 * 
 * ```
 * static GDBusMessage *
 * drop_filter (GDBusConnection *connection
 *              GDBusMessage    *message,
 *              gboolean         incoming,
 *              gpointer         user_data)
 * {
 *   if (should_drop_message)
 *     {
 *       g_object_unref (message);
 *       message = NULL;
 *     }
 *   return message;
 * }
 * ```
 * 
 * Finally, a filter function may modify a message by copying it:
 * 
 * ```
 * static GDBusMessage *
 * modifying_filter (GDBusConnection *connection
 *                   GDBusMessage    *message,
 *                   gboolean         incoming,
 *                   gpointer         user_data)
 * {
 *   GDBusMessage *copy;
 *   GError *error;
 * 
 *   error = NULL;
 *   copy = g_dbus_message_copy (message, &error);
 *   // handle `error` being set
 *   g_object_unref (message);
 * 
 *   // modify `copy`
 * 
 *   return copy;
 * }
 * ```
 * 
 * If the returned #GDBusMessage is different from `message` and cannot
 * be sent on `connection` (it could use features, such as file
 * descriptors, not compatible with `connection)`, then a warning is
 * logged to standard error. Applications can
 * check this ahead of time using g_dbus_message_to_blob() passing a
 * #GDBusCapabilityFlags value obtained from `connection`.
 * @callback 
 * @param connection A #GDBusConnection.
 * @param message A locked #GDBusMessage that the filter function takes ownership of.
 * @param incoming %TRUE if it is a message received from the other peer, %FALSE if it is a message to be sent to the other peer.
 * @returns A #GDBusMessage that will be freed with g_object_unref() or %NULL to drop the message. Passive filter functions can simply return the passed @message object.
 */
interface DBusMessageFilterFunction {
    (connection: DBusConnection, message: DBusMessage, incoming: boolean): DBusMessage | null
}
/**
 * Function signature for a function used to determine the #GType to
 * use for an interface proxy (if `interface_name` is not %NULL) or
 * object proxy (if `interface_name` is %NULL).
 * 
 * This function is called in the
 * [thread-default main loop][g-main-context-push-thread-default]
 * that `manager` was constructed in.
 * @callback 
 * @param manager A #GDBusObjectManagerClient.
 * @param object_path The object path of the remote object.
 * @param interface_name The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.
 * @param data data passed in by the user.
 * @returns A #GType to use for the remote object. The returned type   must be a #GDBusProxy or #GDBusObjectProxy -derived   type.
 */
interface DBusProxyTypeFunc {
    (manager: DBusObjectManagerClient, object_path: string | null, interface_name: string | null, data: any | null): GObject.GType
}
/**
 * Signature for callback function used in g_dbus_connection_signal_subscribe().
 * @callback 
 * @param connection A #GDBusConnection.
 * @param sender_name The unique bus name of the sender of the signal,    or %NULL on a peer-to-peer D-Bus connection.
 * @param object_path The object path that the signal was emitted on.
 * @param interface_name The name of the interface.
 * @param signal_name The name of the signal.
 * @param parameters A #GVariant tuple with parameters for the signal.
 */
interface DBusSignalCallback {
    (connection: DBusConnection, sender_name: string | null, object_path: string | null, interface_name: string | null, signal_name: string | null, parameters: GLib.Variant): void
}
/**
 * The type of the `dispatch` function in #GDBusSubtreeVTable.
 * 
 * Subtrees are flat.  `node,` if non-%NULL, is always exactly one
 * segment of the object path (ie: it never contains a slash).
 * @callback 
 * @param connection A #GDBusConnection.
 * @param sender The unique bus name of the remote caller.
 * @param object_path The object path that was registered with g_dbus_connection_register_subtree().
 * @param interface_name The D-Bus interface name that the method call or property access is for.
 * @param node A node that is a child of `object_path` (relative to `object_path)` or %NULL for the root of the subtree.
 * @param out_user_data Return location for user data to pass to functions in the returned #GDBusInterfaceVTable.
 * @returns A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.
 */
interface DBusSubtreeDispatchFunc {
    (connection: DBusConnection, sender: string | null, object_path: string | null, interface_name: string | null, node: string | null, out_user_data: any): DBusInterfaceVTable | null
}
/**
 * The type of the `enumerate` function in #GDBusSubtreeVTable.
 * 
 * This function is called when generating introspection data and also
 * when preparing to dispatch incoming messages in the event that the
 * %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
 * specified (ie: to verify that the object path is valid).
 * 
 * Hierarchies are not supported; the items that you return should not
 * contain the `/` character.
 * 
 * The return value will be freed with g_strfreev().
 * @callback 
 * @param connection A #GDBusConnection.
 * @param sender The unique bus name of the remote caller.
 * @param object_path The object path that was registered with g_dbus_connection_register_subtree().
 * @returns A newly allocated array of strings for node names that are children of @object_path.
 */
interface DBusSubtreeEnumerateFunc {
    (connection: DBusConnection, sender: string | null, object_path: string | null): string[]
}
/**
 * The type of the `introspect` function in #GDBusSubtreeVTable.
 * 
 * Subtrees are flat.  `node,` if non-%NULL, is always exactly one
 * segment of the object path (ie: it never contains a slash).
 * 
 * This function should return %NULL to indicate that there is no object
 * at this node.
 * 
 * If this function returns non-%NULL, the return value is expected to
 * be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
 * structures describing the interfaces implemented by `node`.  This
 * array will have g_dbus_interface_info_unref() called on each item
 * before being freed with g_free().
 * 
 * The difference between returning %NULL and an array containing zero
 * items is that the standard DBus interfaces will returned to the
 * remote introspector in the empty array case, but not in the %NULL
 * case.
 * @callback 
 * @param connection A #GDBusConnection.
 * @param sender The unique bus name of the remote caller.
 * @param object_path The object path that was registered with g_dbus_connection_register_subtree().
 * @param node A node that is a child of `object_path` (relative to `object_path)` or %NULL for the root of the subtree.
 * @returns A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.
 */
interface DBusSubtreeIntrospectFunc {
    (connection: DBusConnection, sender: string | null, object_path: string | null, node: string | null): DBusInterfaceInfo[] | null
}
/**
 * This is the function type of the callback used for the #GSource
 * returned by g_datagram_based_create_source().
 * @callback 
 * @param datagram_based the #GDatagramBased
 * @param condition the current condition at the source fired
 * @param data data passed in by the user
 * @returns %G_SOURCE_REMOVE if the source should be removed,   %G_SOURCE_CONTINUE otherwise
 */
interface DatagramBasedSourceFunc {
    (datagram_based: DatagramBased, condition: GLib.IOCondition, data: any | null): boolean
}
/**
 * During invocation, g_desktop_app_info_launch_uris_as_manager() may
 * create one or more child processes.  This callback is invoked once
 * for each, providing the process ID.
 * @callback 
 * @param appinfo a #GDesktopAppInfo
 * @param pid Process identifier
 */
interface DesktopAppLaunchCallback {
    (appinfo: DesktopAppInfo, pid: GLib.Pid): void
}
/**
 * This callback type is used by g_file_measure_disk_usage() to make
 * periodic progress reports when measuring the amount of disk spaced
 * used by a directory.
 * 
 * These calls are made on a best-effort basis and not all types of
 * #GFile will support them.  At the minimum, however, one call will
 * always be made immediately.
 * 
 * In the case that there is no support, `reporting` will be set to
 * %FALSE (and the other values undefined) and no further calls will be
 * made.  Otherwise, the `reporting` will be %TRUE and the other values
 * all-zeros during the first (immediate) call.  In this way, you can
 * know which type of progress UI to show without a delay.
 * 
 * For g_file_measure_disk_usage() the callback is made directly.  For
 * g_file_measure_disk_usage_async() the callback is made via the
 * default main context of the calling thread (ie: the same way that the
 * final async result would be reported).
 * 
 * `current_size` is in the same units as requested by the operation (see
 * %G_FILE_MEASURE_APPARENT_SIZE).
 * 
 * The frequency of the updates is implementation defined, but is
 * ideally about once every 200ms.
 * 
 * The last progress callback may or may not be equal to the final
 * result.  Always check the async result to get the final value.
 * @callback 
 * @param reporting %TRUE if more reports will come
 * @param current_size the current cumulative size measurement
 * @param num_dirs the number of directories visited so far
 * @param num_files the number of non-directory files encountered
 * @param data the data passed to the original request for this callback
 */
interface FileMeasureProgressCallback {
    (reporting: boolean, current_size: number, num_dirs: number, num_files: number, data: any | null): void
}
/**
 * When doing file operations that may take a while, such as moving
 * a file or copying a file, a progress callback is used to pass how
 * far along that operation is to the application.
 * @callback 
 * @param current_num_bytes the current number of bytes in the operation.
 * @param total_num_bytes the total number of bytes in the operation.
 * @param data user data passed to the callback.
 */
interface FileProgressCallback {
    (current_num_bytes: number, total_num_bytes: number, data: any | null): void
}
/**
 * When loading the partial contents of a file with g_file_load_partial_contents_async(),
 * it may become necessary to determine if any more data from the file should be loaded.
 * A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
 * should be read, or %FALSE otherwise.
 * @callback 
 * @param file_contents the data as currently read.
 * @param file_size the size of the data currently read.
 * @param callback_data data passed to the callback.
 * @returns %TRUE if more data should be read back. %FALSE otherwise.
 */
interface FileReadMoreCallback {
    (file_contents: string | null, file_size: number, callback_data: any | null): boolean
}
/**
 * I/O Job function.
 * 
 * Long-running jobs should periodically check the `cancellable`
 * to see if they have been cancelled.
 * @callback 
 * @param job a #GIOSchedulerJob.
 * @param cancellable optional #GCancellable object, %NULL to ignore.
 * @param data data passed to the callback function
 * @returns %TRUE if this function should be called again to    complete the job, %FALSE if the job is complete (or cancelled)
 */
interface IOSchedulerJobFunc {
    (job: IOSchedulerJob, cancellable: Cancellable | null, data: any | null): boolean
}
/**
 * This is the function type of the callback used for the #GSource
 * returned by g_pollable_input_stream_create_source() and
 * g_pollable_output_stream_create_source().
 * @callback 
 * @param pollable_stream the #GPollableInputStream or #GPollableOutputStream
 * @param data data passed in by the user.
 * @returns it should return %FALSE if the source should be removed.
 */
interface PollableSourceFunc {
    (pollable_stream: GObject.Object, data: any | null): boolean
}
/**
 * Changes the size of the memory block pointed to by `data` to
 * `size` bytes.
 * 
 * The function should have the same semantics as realloc().
 * @callback 
 * @param data memory block to reallocate
 * @param size size to reallocate `data` to
 * @returns a pointer to the reallocated memory
 */
interface ReallocFunc {
    (data: any | null, size: number): any | null
}
/**
 * The type for the function that is used to convert from #GSettings to
 * an object property. The `value` is already initialized to hold values
 * of the appropriate type.
 * @callback 
 * @param value return location for the property value
 * @param variant the #GVariant
 * @returns %TRUE if the conversion succeeded, %FALSE in case of an error
 */
interface SettingsBindGetMapping {
    (value: any, variant: GLib.Variant): boolean
}
/**
 * The type for the function that is used to convert an object property
 * value to a #GVariant for storing it in #GSettings.
 * @callback 
 * @param value a #GValue containing the property value to map
 * @param expected_type the #GVariantType to create
 * @returns a new #GVariant holding the data from @value,     or %NULL in case of an error
 */
interface SettingsBindSetMapping {
    (value: any, expected_type: GLib.VariantType): GLib.Variant
}
/**
 * The type of the function that is used to convert from a value stored
 * in a #GSettings to a value that is useful to the application.
 * 
 * If the value is successfully mapped, the result should be stored at
 * `result` and %TRUE returned.  If mapping fails (for example, if `value`
 * is not in the right format) then %FALSE should be returned.
 * 
 * If `value` is %NULL then it means that the mapping function is being
 * given a "last chance" to successfully return a valid value.  %TRUE
 * must be returned in this case.
 * @callback 
 * @param value the #GVariant to map, or %NULL
 * @returns %TRUE if the conversion succeeded, %FALSE in case of an error
 */
interface SettingsGetMapping {
    (value: GLib.Variant): boolean
}
/**
 * Simple thread function that runs an asynchronous operation and
 * checks for cancellation.
 * @callback 
 * @param res a #GSimpleAsyncResult.
 * @param object a #GObject.
 * @param cancellable optional #GCancellable object, %NULL to ignore.
 */
interface SimpleAsyncThreadFunc {
    (res: SimpleAsyncResult, object: GObject.Object, cancellable: Cancellable | null): void
}
/**
 * This is the function type of the callback used for the #GSource
 * returned by g_socket_create_source().
 * @callback 
 * @param socket the #GSocket
 * @param condition the current condition at the source fired.
 * @param data data passed in by the user.
 * @returns it should return %FALSE if the source should be removed.
 */
interface SocketSourceFunc {
    (socket: Socket, condition: GLib.IOCondition, data: any | null): boolean
}
/**
 * The prototype for a task function to be run in a thread via
 * g_task_run_in_thread() or g_task_run_in_thread_sync().
 * 
 * If the return-on-cancel flag is set on `task,` and `cancellable` gets
 * cancelled, then the #GTask will be completed immediately (as though
 * g_task_return_error_if_cancelled() had been called), without
 * waiting for the task function to complete. However, the task
 * function will continue running in its thread in the background. The
 * function therefore needs to be careful about how it uses
 * externally-visible state in this case. See
 * g_task_set_return_on_cancel() for more details.
 * 
 * Other than in that case, `task` will be completed when the
 * #GTaskThreadFunc returns, not when it calls a
 * `g_task_return_` function.
 * @callback 
 * @param task the #GTask
 * @param source_object `task'`s source object
 * @param task_data `task'`s task data
 * @param cancellable `task'`s #GCancellable, or %NULL
 */
interface TaskThreadFunc {
    (task: Task, source_object: GObject.Object, task_data: any | null, cancellable: Cancellable | null): void
}
/**
 * This function type is used by g_vfs_register_uri_scheme() to make it
 * possible for a client to associate an URI scheme to a different #GFile
 * implementation.
 * 
 * The client should return a reference to the new file that has been
 * created for `uri,` or %NULL to continue with the default implementation.
 * @callback 
 * @param vfs a #GVfs
 * @param identifier the identifier to look up a #GFile for. This can either     be an URI or a parse name as returned by g_file_get_parse_name()
 * @returns a #GFile for @identifier.
 */
interface VfsFileLookupFunc {
    (vfs: Vfs, identifier: string | null): File
}
module Action {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Action {

    // Own properties of Gio-2.0.Gio.Action

    /**
     * If `action` is currently enabled.
     * 
     * If the action is disabled then calls to g_action_activate() and
     * g_action_change_state() have no effect.
     */
    readonly enabled: boolean
    /**
     * The name of the action.  This is mostly meaningful for identifying
     * the action once it has been added to a #GActionGroup. It is immutable.
     */
    readonly name: string | null
    /**
     * The type of the parameter that must be given when activating the
     * action. This is immutable, and may be %NULL if no parameter is needed when
     * activating the action.
     */
    readonly parameter_type: GLib.VariantType
    /**
     * The state of the action, or %NULL if the action is stateless.
     */
    readonly state: GLib.Variant
    /**
     * The #GVariantType of the state that the action has, or %NULL if the
     * action is stateless. This is immutable.
     */
    readonly state_type: GLib.VariantType

    // Owm methods of Gio-2.0.Gio.Action

    /**
     * Activates the action.
     * 
     * `parameter` must be the correct type of parameter for the action (ie:
     * the parameter type given at construction time).  If the parameter
     * type was %NULL then `parameter` must also be %NULL.
     * 
     * If the `parameter` GVariant is floating, it is consumed.
     * @param parameter the parameter to the activation
     */
    activate(parameter: GLib.Variant | null): void
    /**
     * Request for the state of `action` to be changed to `value`.
     * 
     * The action must be stateful and `value` must be of the correct type.
     * See g_action_get_state_type().
     * 
     * This call merely requests a change.  The action may refuse to change
     * its state or may change its state to something other than `value`.
     * See g_action_get_state_hint().
     * 
     * If the `value` GVariant is floating, it is consumed.
     * @param value the new state
     */
    change_state(value: GLib.Variant): void
    /**
     * Checks if `action` is currently enabled.
     * 
     * An action must be enabled in order to be activated or in order to
     * have its state changed from outside callers.
     * @returns whether the action is enabled
     */
    get_enabled(): boolean
    /**
     * Queries the name of `action`.
     * @returns the name of the action
     */
    get_name(): string | null
    /**
     * Queries the type of the parameter that must be given when activating
     * `action`.
     * 
     * When activating the action using g_action_activate(), the #GVariant
     * given to that function must be of the type returned by this function.
     * 
     * In the case that this function returns %NULL, you must not give any
     * #GVariant, but %NULL instead.
     * @returns the parameter type
     */
    get_parameter_type(): GLib.VariantType | null
    /**
     * Queries the current state of `action`.
     * 
     * If the action is not stateful then %NULL will be returned.  If the
     * action is stateful then the type of the return value is the type
     * given by g_action_get_state_type().
     * 
     * The return value (if non-%NULL) should be freed with
     * g_variant_unref() when it is no longer required.
     * @returns the current state of the action
     */
    get_state(): GLib.Variant | null
    /**
     * Requests a hint about the valid range of values for the state of
     * `action`.
     * 
     * If %NULL is returned it either means that the action is not stateful
     * or that there is no hint about the valid range of values for the
     * state of the action.
     * 
     * If a #GVariant array is returned then each item in the array is a
     * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
     * returned then the tuple specifies the inclusive lower and upper bound
     * of valid values for the state.
     * 
     * In any case, the information is merely a hint.  It may be possible to
     * have a state value outside of the hinted range and setting a value
     * within the range may fail.
     * 
     * The return value (if non-%NULL) should be freed with
     * g_variant_unref() when it is no longer required.
     * @returns the state range hint
     */
    get_state_hint(): GLib.Variant | null
    /**
     * Queries the type of the state of `action`.
     * 
     * If the action is stateful (e.g. created with
     * g_simple_action_new_stateful()) then this function returns the
     * #GVariantType of the state.  This is the type of the initial value
     * given as the state. All calls to g_action_change_state() must give a
     * #GVariant of this type and g_action_get_state() will return a
     * #GVariant of the same type.
     * 
     * If the action is not stateful (e.g. created with g_simple_action_new())
     * then this function will return %NULL. In that case, g_action_get_state()
     * will return %NULL and you must not call g_action_change_state().
     * @returns the state type, if the action is stateful
     */
    get_state_type(): GLib.VariantType | null

    // Own virtual methods of Gio-2.0.Gio.Action

    /**
     * Activates the action.
     * 
     * `parameter` must be the correct type of parameter for the action (ie:
     * the parameter type given at construction time).  If the parameter
     * type was %NULL then `parameter` must also be %NULL.
     * 
     * If the `parameter` GVariant is floating, it is consumed.
     * @virtual 
     * @param parameter the parameter to the activation
     */
    vfunc_activate(parameter: GLib.Variant | null): void
    /**
     * Request for the state of `action` to be changed to `value`.
     * 
     * The action must be stateful and `value` must be of the correct type.
     * See g_action_get_state_type().
     * 
     * This call merely requests a change.  The action may refuse to change
     * its state or may change its state to something other than `value`.
     * See g_action_get_state_hint().
     * 
     * If the `value` GVariant is floating, it is consumed.
     * @virtual 
     * @param value the new state
     */
    vfunc_change_state(value: GLib.Variant): void
    /**
     * Checks if `action` is currently enabled.
     * 
     * An action must be enabled in order to be activated or in order to
     * have its state changed from outside callers.
     * @virtual 
     * @returns whether the action is enabled
     */
    vfunc_get_enabled(): boolean
    /**
     * Queries the name of `action`.
     * @virtual 
     * @returns the name of the action
     */
    vfunc_get_name(): string | null
    /**
     * Queries the type of the parameter that must be given when activating
     * `action`.
     * 
     * When activating the action using g_action_activate(), the #GVariant
     * given to that function must be of the type returned by this function.
     * 
     * In the case that this function returns %NULL, you must not give any
     * #GVariant, but %NULL instead.
     * @virtual 
     * @returns the parameter type
     */
    vfunc_get_parameter_type(): GLib.VariantType | null
    /**
     * Queries the current state of `action`.
     * 
     * If the action is not stateful then %NULL will be returned.  If the
     * action is stateful then the type of the return value is the type
     * given by g_action_get_state_type().
     * 
     * The return value (if non-%NULL) should be freed with
     * g_variant_unref() when it is no longer required.
     * @virtual 
     * @returns the current state of the action
     */
    vfunc_get_state(): GLib.Variant | null
    /**
     * Requests a hint about the valid range of values for the state of
     * `action`.
     * 
     * If %NULL is returned it either means that the action is not stateful
     * or that there is no hint about the valid range of values for the
     * state of the action.
     * 
     * If a #GVariant array is returned then each item in the array is a
     * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
     * returned then the tuple specifies the inclusive lower and upper bound
     * of valid values for the state.
     * 
     * In any case, the information is merely a hint.  It may be possible to
     * have a state value outside of the hinted range and setting a value
     * within the range may fail.
     * 
     * The return value (if non-%NULL) should be freed with
     * g_variant_unref() when it is no longer required.
     * @virtual 
     * @returns the state range hint
     */
    vfunc_get_state_hint(): GLib.Variant | null
    /**
     * Queries the type of the state of `action`.
     * 
     * If the action is stateful (e.g. created with
     * g_simple_action_new_stateful()) then this function returns the
     * #GVariantType of the state.  This is the type of the initial value
     * given as the state. All calls to g_action_change_state() must give a
     * #GVariant of this type and g_action_get_state() will return a
     * #GVariant of the same type.
     * 
     * If the action is not stateful (e.g. created with g_simple_action_new())
     * then this function will return %NULL. In that case, g_action_get_state()
     * will return %NULL and you must not call g_action_change_state().
     * @virtual 
     * @returns the state type, if the action is stateful
     */
    vfunc_get_state_type(): GLib.VariantType | null

    // Class property signals of Gio-2.0.Gio.Action

    connect(sigName: "notify::enabled", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::enabled", ...args: any[]): void
    connect(sigName: "notify::name", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::name", ...args: any[]): void
    connect(sigName: "notify::parameter-type", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameter-type", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parameter-type", ...args: any[]): void
    connect(sigName: "notify::state", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-type", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-type", callback: (($obj: Action, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::state-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GAction represents a single named action.
 * 
 * The main interface to an action is that it can be activated with
 * g_action_activate().  This results in the 'activate' signal being
 * emitted.  An activation has a #GVariant parameter (which may be
 * %NULL).  The correct type for the parameter is determined by a static
 * parameter type (which is given at construction time).
 * 
 * An action may optionally have a state, in which case the state may be
 * set with g_action_change_state().  This call takes a #GVariant.  The
 * correct type for the state is determined by a static state type
 * (which is given at construction time).
 * 
 * The state may have a hint associated with it, specifying its valid
 * range.
 * 
 * #GAction is merely the interface to the concept of an action, as
 * described above.  Various implementations of actions exist, including
 * #GSimpleAction.
 * 
 * In all cases, the implementing class is responsible for storing the
 * name of the action, the parameter type, the enabled state, the
 * optional state type and the state and emitting the appropriate
 * signals when these change.  The implementor is responsible for filtering
 * calls to g_action_activate() and g_action_change_state() for type
 * safety and for the state being enabled.
 * 
 * Probably the only useful thing to do with a #GAction is to put it
 * inside of a #GSimpleActionGroup.
 * @interface 
 */
class Action extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Action

    static name: string
    static $gtype: GObject.GType<Action>

    // Constructors of Gio-2.0.Gio.Action

    constructor(config?: Action.ConstructorProperties) 
    _init(config?: Action.ConstructorProperties): void
    /**
     * Checks if `action_name` is valid.
     * 
     * `action_name` is valid if it consists only of alphanumeric characters,
     * plus '-' and '.'.  The empty string is not a valid action name.
     * 
     * It is an error to call this function with a non-utf8 `action_name`.
     * `action_name` must not be %NULL.
     * @param action_name a potential action name
     * @returns %TRUE if @action_name is valid
     */
    static name_is_valid(action_name: string | null): boolean
    /**
     * Parses a detailed action name into its separate name and target
     * components.
     * 
     * Detailed action names can have three formats.
     * 
     * The first format is used to represent an action name with no target
     * value and consists of just an action name containing no whitespace
     * nor the characters `:`, `(` or `)`.  For example: `app.action`.
     * 
     * The second format is used to represent an action with a target value
     * that is a non-empty string consisting only of alphanumerics, plus `-`
     * and `.`.  In that case, the action name and target value are
     * separated by a double colon (`::`).  For example:
     * `app.action::target`.
     * 
     * The third format is used to represent an action with any type of
     * target value, including strings.  The target value follows the action
     * name, surrounded in parens.  For example: `app.action(42)`.  The
     * target value is parsed using g_variant_parse().  If a tuple-typed
     * value is desired, it must be specified in the same way, resulting in
     * two sets of parens, for example: `app.action((1,2,3))`.  A string
     * target can be specified this way as well: `app.action('target')`.
     * For strings, this third format must be used if target value is
     * empty or contains characters other than alphanumerics, `-` and `.`.
     * 
     * If this function returns %TRUE, a non-%NULL value is guaranteed to be returned
     * in `action_name` (if a pointer is passed in). A %NULL value may still be
     * returned in `target_value,` as the `detailed_name` may not contain a target.
     * 
     * If returned, the #GVariant in `target_value` is guaranteed to not be floating.
     * @param detailed_name a detailed action name
     * @returns %TRUE if successful, else %FALSE with @error set
     */
    static parse_detailed_name(detailed_name: string | null): [ /* returnType */ boolean, /* action_name */ string | null, /* target_value */ GLib.Variant | null ]
    /**
     * Formats a detailed action name from `action_name` and `target_value`.
     * 
     * It is an error to call this function with an invalid action name.
     * 
     * This function is the opposite of g_action_parse_detailed_name().
     * It will produce a string that can be parsed back to the `action_name`
     * and `target_value` by that function.
     * 
     * See that function for the types of strings that will be printed by
     * this function.
     * @param action_name a valid action name
     * @param target_value a #GVariant target value, or %NULL
     * @returns a detailed format string
     */
    static print_detailed_name(action_name: string | null, target_value: GLib.Variant | null): string | null
}

module ActionGroup {

    // Signal callback interfaces

    /**
     * Signal callback interface for `action-added`
     */
    interface ActionAddedSignalCallback {
        ($obj: ActionGroup, action_name: string | null): void
    }

    /**
     * Signal callback interface for `action-enabled-changed`
     */
    interface ActionEnabledChangedSignalCallback {
        ($obj: ActionGroup, action_name: string | null, enabled: boolean): void
    }

    /**
     * Signal callback interface for `action-removed`
     */
    interface ActionRemovedSignalCallback {
        ($obj: ActionGroup, action_name: string | null): void
    }

    /**
     * Signal callback interface for `action-state-changed`
     */
    interface ActionStateChangedSignalCallback {
        ($obj: ActionGroup, action_name: string | null, value: GLib.Variant): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface ActionGroup {

    // Owm methods of Gio-2.0.Gio.ActionGroup

    /**
     * Emits the #GActionGroup::action-added signal on `action_group`.
     * 
     * This function should only be called by #GActionGroup implementations.
     * @param action_name the name of an action in the group
     */
    action_added(action_name: string | null): void
    /**
     * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
     * 
     * This function should only be called by #GActionGroup implementations.
     * @param action_name the name of an action in the group
     * @param enabled whether or not the action is now enabled
     */
    action_enabled_changed(action_name: string | null, enabled: boolean): void
    /**
     * Emits the #GActionGroup::action-removed signal on `action_group`.
     * 
     * This function should only be called by #GActionGroup implementations.
     * @param action_name the name of an action in the group
     */
    action_removed(action_name: string | null): void
    /**
     * Emits the #GActionGroup::action-state-changed signal on `action_group`.
     * 
     * This function should only be called by #GActionGroup implementations.
     * @param action_name the name of an action in the group
     * @param state the new state of the named action
     */
    action_state_changed(action_name: string | null, state: GLib.Variant): void
    /**
     * Activate the named action within `action_group`.
     * 
     * If the action is expecting a parameter, then the correct type of
     * parameter must be given as `parameter`.  If the action is expecting no
     * parameters then `parameter` must be %NULL.  See
     * g_action_group_get_action_parameter_type().
     * 
     * If the #GActionGroup implementation supports asynchronous remote
     * activation over D-Bus, this call may return before the relevant
     * D-Bus traffic has been sent, or any replies have been received. In
     * order to block on such asynchronous activation calls,
     * g_dbus_connection_flush() should be called prior to the code, which
     * depends on the result of the action activation. Without flushing
     * the D-Bus connection, there is no guarantee that the action would
     * have been activated.
     * 
     * The following code which runs in a remote app instance, shows an
     * example of a "quit" action being activated on the primary app
     * instance over D-Bus. Here g_dbus_connection_flush() is called
     * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
     * may fail to be activated on the primary instance.
     * 
     * 
     * ```c
     * // call "quit" action on primary instance
     * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
     * 
     * // make sure the action is activated now
     * g_dbus_connection_flush (...);
     * 
     * g_debug ("application has been terminated. exiting.");
     * 
     * exit (0);
     * ```
     * 
     * @param action_name the name of the action to activate
     * @param parameter parameters to the activation
     */
    activate_action(action_name: string | null, parameter: GLib.Variant | null): void
    /**
     * Request for the state of the named action within `action_group` to be
     * changed to `value`.
     * 
     * The action must be stateful and `value` must be of the correct type.
     * See g_action_group_get_action_state_type().
     * 
     * This call merely requests a change.  The action may refuse to change
     * its state or may change its state to something other than `value`.
     * See g_action_group_get_action_state_hint().
     * 
     * If the `value` GVariant is floating, it is consumed.
     * @param action_name the name of the action to request the change on
     * @param value the new state
     */
    change_action_state(action_name: string | null, value: GLib.Variant): void
    /**
     * Checks if the named action within `action_group` is currently enabled.
     * 
     * An action must be enabled in order to be activated or in order to
     * have its state changed from outside callers.
     * @param action_name the name of the action to query
     * @returns whether or not the action is currently enabled
     */
    get_action_enabled(action_name: string | null): boolean
    /**
     * Queries the type of the parameter that must be given when activating
     * the named action within `action_group`.
     * 
     * When activating the action using g_action_group_activate_action(),
     * the #GVariant given to that function must be of the type returned
     * by this function.
     * 
     * In the case that this function returns %NULL, you must not give any
     * #GVariant, but %NULL instead.
     * 
     * The parameter type of a particular action will never change but it is
     * possible for an action to be removed and for a new action to be added
     * with the same name but a different parameter type.
     * @param action_name the name of the action to query
     * @returns the parameter type
     */
    get_action_parameter_type(action_name: string | null): GLib.VariantType | null
    /**
     * Queries the current state of the named action within `action_group`.
     * 
     * If the action is not stateful then %NULL will be returned.  If the
     * action is stateful then the type of the return value is the type
     * given by g_action_group_get_action_state_type().
     * 
     * The return value (if non-%NULL) should be freed with
     * g_variant_unref() when it is no longer required.
     * @param action_name the name of the action to query
     * @returns the current state of the action
     */
    get_action_state(action_name: string | null): GLib.Variant | null
    /**
     * Requests a hint about the valid range of values for the state of the
     * named action within `action_group`.
     * 
     * If %NULL is returned it either means that the action is not stateful
     * or that there is no hint about the valid range of values for the
     * state of the action.
     * 
     * If a #GVariant array is returned then each item in the array is a
     * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
     * returned then the tuple specifies the inclusive lower and upper bound
     * of valid values for the state.
     * 
     * In any case, the information is merely a hint.  It may be possible to
     * have a state value outside of the hinted range and setting a value
     * within the range may fail.
     * 
     * The return value (if non-%NULL) should be freed with
     * g_variant_unref() when it is no longer required.
     * @param action_name the name of the action to query
     * @returns the state range hint
     */
    get_action_state_hint(action_name: string | null): GLib.Variant | null
    /**
     * Queries the type of the state of the named action within
     * `action_group`.
     * 
     * If the action is stateful then this function returns the
     * #GVariantType of the state.  All calls to
     * g_action_group_change_action_state() must give a #GVariant of this
     * type and g_action_group_get_action_state() will return a #GVariant
     * of the same type.
     * 
     * If the action is not stateful then this function will return %NULL.
     * In that case, g_action_group_get_action_state() will return %NULL
     * and you must not call g_action_group_change_action_state().
     * 
     * The state type of a particular action will never change but it is
     * possible for an action to be removed and for a new action to be added
     * with the same name but a different state type.
     * @param action_name the name of the action to query
     * @returns the state type, if the action is stateful
     */
    get_action_state_type(action_name: string | null): GLib.VariantType | null
    /**
     * Checks if the named action exists within `action_group`.
     * @param action_name the name of the action to check for
     * @returns whether the named action exists
     */
    has_action(action_name: string | null): boolean
    /**
     * Lists the actions contained within `action_group`.
     * 
     * The caller is responsible for freeing the list with g_strfreev() when
     * it is no longer required.
     * @returns a %NULL-terminated array of the names of the actions in the group
     */
    list_actions(): string[]
    /**
     * Queries all aspects of the named action within an `action_group`.
     * 
     * This function acquires the information available from
     * g_action_group_has_action(), g_action_group_get_action_enabled(),
     * g_action_group_get_action_parameter_type(),
     * g_action_group_get_action_state_type(),
     * g_action_group_get_action_state_hint() and
     * g_action_group_get_action_state() with a single function call.
     * 
     * This provides two main benefits.
     * 
     * The first is the improvement in efficiency that comes with not having
     * to perform repeated lookups of the action in order to discover
     * different things about it.  The second is that implementing
     * #GActionGroup can now be done by only overriding this one virtual
     * function.
     * 
     * The interface provides a default implementation of this function that
     * calls the individual functions, as required, to fetch the
     * information.  The interface also provides default implementations of
     * those functions that call this function.  All implementations,
     * therefore, must override either this function or all of the others.
     * 
     * If the action exists, %TRUE is returned and any of the requested
     * fields (as indicated by having a non-%NULL reference passed in) are
     * filled.  If the action doesn't exist, %FALSE is returned and the
     * fields may or may not have been modified.
     * @param action_name the name of an action in the group
     * @returns %TRUE if the action exists, else %FALSE
     */
    query_action(action_name: string | null): [ /* returnType */ boolean, /* enabled */ boolean, /* parameter_type */ GLib.VariantType, /* state_type */ GLib.VariantType, /* state_hint */ GLib.Variant, /* state */ GLib.Variant ]

    // Own virtual methods of Gio-2.0.Gio.ActionGroup

    /**
     * Emits the #GActionGroup::action-added signal on `action_group`.
     * 
     * This function should only be called by #GActionGroup implementations.
     * @virtual 
     * @param action_name the name of an action in the group
     */
    vfunc_action_added(action_name: string | null): void
    /**
     * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
     * 
     * This function should only be called by #GActionGroup implementations.
     * @virtual 
     * @param action_name the name of an action in the group
     * @param enabled whether or not the action is now enabled
     */
    vfunc_action_enabled_changed(action_name: string | null, enabled: boolean): void
    /**
     * Emits the #GActionGroup::action-removed signal on `action_group`.
     * 
     * This function should only be called by #GActionGroup implementations.
     * @virtual 
     * @param action_name the name of an action in the group
     */
    vfunc_action_removed(action_name: string | null): void
    /**
     * Emits the #GActionGroup::action-state-changed signal on `action_group`.
     * 
     * This function should only be called by #GActionGroup implementations.
     * @virtual 
     * @param action_name the name of an action in the group
     * @param state the new state of the named action
     */
    vfunc_action_state_changed(action_name: string | null, state: GLib.Variant): void
    /**
     * Activate the named action within `action_group`.
     * 
     * If the action is expecting a parameter, then the correct type of
     * parameter must be given as `parameter`.  If the action is expecting no
     * parameters then `parameter` must be %NULL.  See
     * g_action_group_get_action_parameter_type().
     * 
     * If the #GActionGroup implementation supports asynchronous remote
     * activation over D-Bus, this call may return before the relevant
     * D-Bus traffic has been sent, or any replies have been received. In
     * order to block on such asynchronous activation calls,
     * g_dbus_connection_flush() should be called prior to the code, which
     * depends on the result of the action activation. Without flushing
     * the D-Bus connection, there is no guarantee that the action would
     * have been activated.
     * 
     * The following code which runs in a remote app instance, shows an
     * example of a "quit" action being activated on the primary app
     * instance over D-Bus. Here g_dbus_connection_flush() is called
     * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
     * may fail to be activated on the primary instance.
     * 
     * 
     * ```c
     * // call "quit" action on primary instance
     * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
     * 
     * // make sure the action is activated now
     * g_dbus_connection_flush (...);
     * 
     * g_debug ("application has been terminated. exiting.");
     * 
     * exit (0);
     * ```
     * 
     * @virtual 
     * @param action_name the name of the action to activate
     * @param parameter parameters to the activation
     */
    vfunc_activate_action(action_name: string | null, parameter: GLib.Variant | null): void
    /**
     * Request for the state of the named action within `action_group` to be
     * changed to `value`.
     * 
     * The action must be stateful and `value` must be of the correct type.
     * See g_action_group_get_action_state_type().
     * 
     * This call merely requests a change.  The action may refuse to change
     * its state or may change its state to something other than `value`.
     * See g_action_group_get_action_state_hint().
     * 
     * If the `value` GVariant is floating, it is consumed.
     * @virtual 
     * @param action_name the name of the action to request the change on
     * @param value the new state
     */
    vfunc_change_action_state(action_name: string | null, value: GLib.Variant): void
    /**
     * Checks if the named action within `action_group` is currently enabled.
     * 
     * An action must be enabled in order to be activated or in order to
     * have its state changed from outside callers.
     * @virtual 
     * @param action_name the name of the action to query
     * @returns whether or not the action is currently enabled
     */
    vfunc_get_action_enabled(action_name: string | null): boolean
    /**
     * Queries the type of the parameter that must be given when activating
     * the named action within `action_group`.
     * 
     * When activating the action using g_action_group_activate_action(),
     * the #GVariant given to that function must be of the type returned
     * by this function.
     * 
     * In the case that this function returns %NULL, you must not give any
     * #GVariant, but %NULL instead.
     * 
     * The parameter type of a particular action will never change but it is
     * possible for an action to be removed and for a new action to be added
     * with the same name but a different parameter type.
     * @virtual 
     * @param action_name the name of the action to query
     * @returns the parameter type
     */
    vfunc_get_action_parameter_type(action_name: string | null): GLib.VariantType | null
    /**
     * Queries the current state of the named action within `action_group`.
     * 
     * If the action is not stateful then %NULL will be returned.  If the
     * action is stateful then the type of the return value is the type
     * given by g_action_group_get_action_state_type().
     * 
     * The return value (if non-%NULL) should be freed with
     * g_variant_unref() when it is no longer required.
     * @virtual 
     * @param action_name the name of the action to query
     * @returns the current state of the action
     */
    vfunc_get_action_state(action_name: string | null): GLib.Variant | null
    /**
     * Requests a hint about the valid range of values for the state of the
     * named action within `action_group`.
     * 
     * If %NULL is returned it either means that the action is not stateful
     * or that there is no hint about the valid range of values for the
     * state of the action.
     * 
     * If a #GVariant array is returned then each item in the array is a
     * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
     * returned then the tuple specifies the inclusive lower and upper bound
     * of valid values for the state.
     * 
     * In any case, the information is merely a hint.  It may be possible to
     * have a state value outside of the hinted range and setting a value
     * within the range may fail.
     * 
     * The return value (if non-%NULL) should be freed with
     * g_variant_unref() when it is no longer required.
     * @virtual 
     * @param action_name the name of the action to query
     * @returns the state range hint
     */
    vfunc_get_action_state_hint(action_name: string | null): GLib.Variant | null
    /**
     * Queries the type of the state of the named action within
     * `action_group`.
     * 
     * If the action is stateful then this function returns the
     * #GVariantType of the state.  All calls to
     * g_action_group_change_action_state() must give a #GVariant of this
     * type and g_action_group_get_action_state() will return a #GVariant
     * of the same type.
     * 
     * If the action is not stateful then this function will return %NULL.
     * In that case, g_action_group_get_action_state() will return %NULL
     * and you must not call g_action_group_change_action_state().
     * 
     * The state type of a particular action will never change but it is
     * possible for an action to be removed and for a new action to be added
     * with the same name but a different state type.
     * @virtual 
     * @param action_name the name of the action to query
     * @returns the state type, if the action is stateful
     */
    vfunc_get_action_state_type(action_name: string | null): GLib.VariantType | null
    /**
     * Checks if the named action exists within `action_group`.
     * @virtual 
     * @param action_name the name of the action to check for
     * @returns whether the named action exists
     */
    vfunc_has_action(action_name: string | null): boolean
    /**
     * Lists the actions contained within `action_group`.
     * 
     * The caller is responsible for freeing the list with g_strfreev() when
     * it is no longer required.
     * @virtual 
     * @returns a %NULL-terminated array of the names of the actions in the group
     */
    vfunc_list_actions(): string[]
    /**
     * Queries all aspects of the named action within an `action_group`.
     * 
     * This function acquires the information available from
     * g_action_group_has_action(), g_action_group_get_action_enabled(),
     * g_action_group_get_action_parameter_type(),
     * g_action_group_get_action_state_type(),
     * g_action_group_get_action_state_hint() and
     * g_action_group_get_action_state() with a single function call.
     * 
     * This provides two main benefits.
     * 
     * The first is the improvement in efficiency that comes with not having
     * to perform repeated lookups of the action in order to discover
     * different things about it.  The second is that implementing
     * #GActionGroup can now be done by only overriding this one virtual
     * function.
     * 
     * The interface provides a default implementation of this function that
     * calls the individual functions, as required, to fetch the
     * information.  The interface also provides default implementations of
     * those functions that call this function.  All implementations,
     * therefore, must override either this function or all of the others.
     * 
     * If the action exists, %TRUE is returned and any of the requested
     * fields (as indicated by having a non-%NULL reference passed in) are
     * filled.  If the action doesn't exist, %FALSE is returned and the
     * fields may or may not have been modified.
     * @virtual 
     * @param action_name the name of an action in the group
     * @returns %TRUE if the action exists, else %FALSE
     */
    vfunc_query_action(action_name: string | null): [ /* returnType */ boolean, /* enabled */ boolean, /* parameter_type */ GLib.VariantType, /* state_type */ GLib.VariantType, /* state_hint */ GLib.Variant, /* state */ GLib.Variant ]

    // Own signals of Gio-2.0.Gio.ActionGroup

    connect(sigName: "action-added", callback: ActionGroup.ActionAddedSignalCallback): number
    connect_after(sigName: "action-added", callback: ActionGroup.ActionAddedSignalCallback): number
    emit(sigName: "action-added", action_name: string | null, ...args: any[]): void
    connect(sigName: "action-enabled-changed", callback: ActionGroup.ActionEnabledChangedSignalCallback): number
    connect_after(sigName: "action-enabled-changed", callback: ActionGroup.ActionEnabledChangedSignalCallback): number
    emit(sigName: "action-enabled-changed", action_name: string | null, enabled: boolean, ...args: any[]): void
    connect(sigName: "action-removed", callback: ActionGroup.ActionRemovedSignalCallback): number
    connect_after(sigName: "action-removed", callback: ActionGroup.ActionRemovedSignalCallback): number
    emit(sigName: "action-removed", action_name: string | null, ...args: any[]): void
    connect(sigName: "action-state-changed", callback: ActionGroup.ActionStateChangedSignalCallback): number
    connect_after(sigName: "action-state-changed", callback: ActionGroup.ActionStateChangedSignalCallback): number
    emit(sigName: "action-state-changed", action_name: string | null, value: GLib.Variant, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.ActionGroup

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GActionGroup represents a group of actions. Actions can be used to
 * expose functionality in a structured way, either from one part of a
 * program to another, or to the outside world. Action groups are often
 * used together with a #GMenuModel that provides additional
 * representation data for displaying the actions to the user, e.g. in
 * a menu.
 * 
 * The main way to interact with the actions in a GActionGroup is to
 * activate them with g_action_group_activate_action(). Activating an
 * action may require a #GVariant parameter. The required type of the
 * parameter can be inquired with g_action_group_get_action_parameter_type().
 * Actions may be disabled, see g_action_group_get_action_enabled().
 * Activating a disabled action has no effect.
 * 
 * Actions may optionally have a state in the form of a #GVariant. The
 * current state of an action can be inquired with
 * g_action_group_get_action_state(). Activating a stateful action may
 * change its state, but it is also possible to set the state by calling
 * g_action_group_change_action_state().
 * 
 * As typical example, consider a text editing application which has an
 * option to change the current font to 'bold'. A good way to represent
 * this would be a stateful action, with a boolean state. Activating the
 * action would toggle the state.
 * 
 * Each action in the group has a unique name (which is a string).  All
 * method calls, except g_action_group_list_actions() take the name of
 * an action as an argument.
 * 
 * The #GActionGroup API is meant to be the 'public' API to the action
 * group.  The calls here are exactly the interaction that 'external
 * forces' (eg: UI, incoming D-Bus messages, etc.) are supposed to have
 * with actions.  'Internal' APIs (ie: ones meant only to be accessed by
 * the action group implementation) are found on subclasses.  This is
 * why you will find - for example - g_action_group_get_action_enabled()
 * but not an equivalent set() call.
 * 
 * Signals are emitted on the action group in response to state changes
 * on individual actions.
 * 
 * Implementations of #GActionGroup should provide implementations for
 * the virtual functions g_action_group_list_actions() and
 * g_action_group_query_action().  The other virtual functions should
 * not be implemented - their "wrappers" are actually implemented with
 * calls to g_action_group_query_action().
 * @interface 
 */
class ActionGroup extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ActionGroup

    static name: string
    static $gtype: GObject.GType<ActionGroup>

    // Constructors of Gio-2.0.Gio.ActionGroup

    constructor(config?: ActionGroup.ConstructorProperties) 
    _init(config?: ActionGroup.ConstructorProperties): void
}

module ActionMap {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface ActionMap {

    // Owm methods of Gio-2.0.Gio.ActionMap

    /**
     * Adds an action to the `action_map`.
     * 
     * If the action map already contains an action with the same name
     * as `action` then the old action is dropped from the action map.
     * 
     * The action map takes its own reference on `action`.
     * @param action a #GAction
     */
    add_action(action: Action): void
    /**
     * A convenience function for creating multiple #GSimpleAction instances
     * and adding them to a #GActionMap.
     * 
     * Each action is constructed as per one #GActionEntry.
     * 
     * 
     * ```c
     * static void
     * activate_quit (GSimpleAction *simple,
     *                GVariant      *parameter,
     *                gpointer       user_data)
     * {
     *   exit (0);
     * }
     * 
     * static void
     * activate_print_string (GSimpleAction *simple,
     *                        GVariant      *parameter,
     *                        gpointer       user_data)
     * {
     *   g_print ("%s\n", g_variant_get_string (parameter, NULL));
     * }
     * 
     * static GActionGroup *
     * create_action_group (void)
     * {
     *   const GActionEntry entries[] = {
     *     { "quit",         activate_quit              },
     *     { "print-string", activate_print_string, "s" }
     *   };
     *   GSimpleActionGroup *group;
     * 
     *   group = g_simple_action_group_new ();
     *   g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
     * 
     *   return G_ACTION_GROUP (group);
     * }
     * ```
     * 
     * @param entries a pointer to           the first item in an array of #GActionEntry structs
     * @param user_data the user data for signal connections
     */
    add_action_entries(entries: ActionEntry[], user_data: any | null): void
    /**
     * Looks up the action with the name `action_name` in `action_map`.
     * 
     * If no such action exists, returns %NULL.
     * @param action_name the name of an action
     * @returns a #GAction, or %NULL
     */
    lookup_action(action_name: string | null): Action | null
    /**
     * Removes the named action from the action map.
     * 
     * If no action of this name is in the map then nothing happens.
     * @param action_name the name of the action
     */
    remove_action(action_name: string | null): void

    // Own virtual methods of Gio-2.0.Gio.ActionMap

    /**
     * Adds an action to the `action_map`.
     * 
     * If the action map already contains an action with the same name
     * as `action` then the old action is dropped from the action map.
     * 
     * The action map takes its own reference on `action`.
     * @virtual 
     * @param action a #GAction
     */
    vfunc_add_action(action: Action): void
    /**
     * Looks up the action with the name `action_name` in `action_map`.
     * 
     * If no such action exists, returns %NULL.
     * @virtual 
     * @param action_name the name of an action
     * @returns a #GAction, or %NULL
     */
    vfunc_lookup_action(action_name: string | null): Action | null
    /**
     * Removes the named action from the action map.
     * 
     * If no action of this name is in the map then nothing happens.
     * @virtual 
     * @param action_name the name of the action
     */
    vfunc_remove_action(action_name: string | null): void

    // Class property signals of Gio-2.0.Gio.ActionMap

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The GActionMap interface is implemented by #GActionGroup
 * implementations that operate by containing a number of
 * named #GAction instances, such as #GSimpleActionGroup.
 * 
 * One useful application of this interface is to map the
 * names of actions from various action groups to unique,
 * prefixed names (e.g. by prepending "app." or "win.").
 * This is the motivation for the 'Map' part of the interface
 * name.
 * @interface 
 */
class ActionMap extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ActionMap

    static name: string
    static $gtype: GObject.GType<ActionMap>

    // Constructors of Gio-2.0.Gio.ActionMap

    constructor(config?: ActionMap.ConstructorProperties) 
    _init(config?: ActionMap.ConstructorProperties): void
}

module AppInfo {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface AppInfo {

    // Owm methods of Gio-2.0.Gio.AppInfo

    /**
     * Adds a content type to the application information to indicate the
     * application is capable of opening files with the given content type.
     * @param content_type a string.
     * @returns %TRUE on success, %FALSE on error.
     */
    add_supports_type(content_type: string | null): boolean
    /**
     * Obtains the information whether the #GAppInfo can be deleted.
     * See g_app_info_delete().
     * @returns %TRUE if @appinfo can be deleted
     */
    can_delete(): boolean
    /**
     * Checks if a supported content type can be removed from an application.
     * @returns %TRUE if it is possible to remove supported     content types from a given @appinfo, %FALSE if not.
     */
    can_remove_supports_type(): boolean
    /**
     * Tries to delete a #GAppInfo.
     * 
     * On some platforms, there may be a difference between user-defined
     * #GAppInfos which can be deleted, and system-wide ones which cannot.
     * See g_app_info_can_delete().
     * @returns %TRUE if @appinfo has been deleted
     */
    delete(): boolean
    /**
     * Creates a duplicate of a #GAppInfo.
     * @returns a duplicate of @appinfo.
     */
    dup(): AppInfo
    /**
     * Checks if two #GAppInfos are equal.
     * 
     * Note that the check *may not* compare each individual
     * field, and only does an identity check. In case detecting changes in the
     * contents is needed, program code must additionally compare relevant fields.
     * @param appinfo2 the second #GAppInfo.
     * @returns %TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.
     */
    equal(appinfo2: AppInfo): boolean
    /**
     * Gets the commandline with which the application will be
     * started.
     * @returns a string containing the @appinfo's commandline,     or %NULL if this information is not available
     */
    get_commandline(): string | null
    /**
     * Gets a human-readable description of an installed application.
     * @returns a string containing a description of the application @appinfo, or %NULL if none.
     */
    get_description(): string | null
    /**
     * Gets the display name of the application. The display name is often more
     * descriptive to the user than the name itself.
     * @returns the display name of the application for @appinfo, or the name if no display name is available.
     */
    get_display_name(): string | null
    /**
     * Gets the executable's name for the installed application.
     * 
     * This is intended to be used for debugging or labelling what program is going
     * to be run. To launch the executable, use g_app_info_launch() and related
     * functions, rather than spawning the return value from this function.
     * @returns a string containing the @appinfo's application binaries name
     */
    get_executable(): string
    /**
     * Gets the icon for the application.
     * @returns the default #GIcon for @appinfo or %NULL if there is no default icon.
     */
    get_icon(): Icon | null
    /**
     * Gets the ID of an application. An id is a string that
     * identifies the application. The exact format of the id is
     * platform dependent. For instance, on Unix this is the
     * desktop file id from the xdg menu specification.
     * 
     * Note that the returned ID may be %NULL, depending on how
     * the `appinfo` has been constructed.
     * @returns a string containing the application's ID.
     */
    get_id(): string | null
    /**
     * Gets the installed name of the application.
     * @returns the name of the application for @appinfo.
     */
    get_name(): string | null
    /**
     * Retrieves the list of content types that `app_info` claims to support.
     * If this information is not provided by the environment, this function
     * will return %NULL.
     * This function does not take in consideration associations added with
     * g_app_info_add_supports_type(), but only those exported directly by
     * the application.
     * @returns     a list of content types.
     */
    get_supported_types(): string[]
    /**
     * Launches the application. Passes `files` to the launched application
     * as arguments, using the optional `context` to get information
     * about the details of the launcher (like what screen it is on).
     * On error, `error` will be set accordingly.
     * 
     * To launch the application without arguments pass a %NULL `files` list.
     * 
     * Note that even if the launch is successful the application launched
     * can fail to start if it runs into problems during startup. There is
     * no way to detect this.
     * 
     * Some URIs can be changed when passed through a GFile (for instance
     * unsupported URIs with strange formats like mailto:), so if you have
     * a textual URI you want to pass in as argument, consider using
     * g_app_info_launch_uris() instead.
     * 
     * The launched application inherits the environment of the launching
     * process, but it can be modified with g_app_launch_context_setenv()
     * and g_app_launch_context_unsetenv().
     * 
     * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
     * environment variable with the path of the launched desktop file and
     * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
     * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
     * should it be inherited by further processes. The `DISPLAY`,
     * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
     * variables are also set, based on information provided in `context`.
     * @param files a #GList of #GFile objects
     * @param context a #GAppLaunchContext or %NULL
     * @returns %TRUE on successful launch, %FALSE otherwise.
     */
    launch(files: File[] | null, context: AppLaunchContext | null): boolean
    /**
     * Launches the application. This passes the `uris` to the launched application
     * as arguments, using the optional `context` to get information
     * about the details of the launcher (like what screen it is on).
     * On error, `error` will be set accordingly. If the application only supports
     * one URI per invocation as part of their command-line, multiple instances
     * of the application will be spawned.
     * 
     * To launch the application without arguments pass a %NULL `uris` list.
     * 
     * Note that even if the launch is successful the application launched
     * can fail to start if it runs into problems during startup. There is
     * no way to detect this.
     * @param uris a #GList containing URIs to launch.
     * @param context a #GAppLaunchContext or %NULL
     * @returns %TRUE on successful launch, %FALSE otherwise.
     */
    launch_uris(uris: string[] | null, context: AppLaunchContext | null): boolean
    /**
     * Async version of g_app_info_launch_uris().
     * 
     * The `callback` is invoked immediately after the application launch, but it
     * waits for activation in case of D-Bus–activated applications and also provides
     * extended error information for sandboxed applications, see notes for
     * g_app_info_launch_default_for_uri_async().
     * @param uris a #GList containing URIs to launch.
     * @param context a #GAppLaunchContext or %NULL
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    launch_uris_async(uris: string[] | null, context: AppLaunchContext | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of launch_uris_async

    /**
     * Promisified version of {@link launch_uris_async}
     * 
     * Async version of g_app_info_launch_uris().
     * 
     * The `callback` is invoked immediately after the application launch, but it
     * waits for activation in case of D-Bus–activated applications and also provides
     * extended error information for sandboxed applications, see notes for
     * g_app_info_launch_default_for_uri_async().
     * @param uris a #GList containing URIs to launch.
     * @param context a #GAppLaunchContext or %NULL
     * @param cancellable a #GCancellable
     * @returns A Promise of: %TRUE on successful launch, %FALSE otherwise.
     */
    launch_uris_async(uris: string[] | null, context: AppLaunchContext | null, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes a g_app_info_launch_uris_async() operation.
     * @param result a #GAsyncResult
     * @returns %TRUE on successful launch, %FALSE otherwise.
     */
    launch_uris_finish(result: AsyncResult): boolean
    /**
     * Removes a supported type from an application, if possible.
     * @param content_type a string.
     * @returns %TRUE on success, %FALSE on error.
     */
    remove_supports_type(content_type: string | null): boolean
    /**
     * Sets the application as the default handler for the given file extension.
     * @param extension a string containing the file extension     (without the dot).
     * @returns %TRUE on success, %FALSE on error.
     */
    set_as_default_for_extension(extension: string): boolean
    /**
     * Sets the application as the default handler for a given type.
     * @param content_type the content type.
     * @returns %TRUE on success, %FALSE on error.
     */
    set_as_default_for_type(content_type: string | null): boolean
    /**
     * Sets the application as the last used application for a given type.
     * This will make the application appear as first in the list returned
     * by g_app_info_get_recommended_for_type(), regardless of the default
     * application for that content type.
     * @param content_type the content type.
     * @returns %TRUE on success, %FALSE on error.
     */
    set_as_last_used_for_type(content_type: string | null): boolean
    /**
     * Checks if the application info should be shown in menus that
     * list available applications.
     * @returns %TRUE if the @appinfo should be shown, %FALSE otherwise.
     */
    should_show(): boolean
    /**
     * Checks if the application accepts files as arguments.
     * @returns %TRUE if the @appinfo supports files.
     */
    supports_files(): boolean
    /**
     * Checks if the application supports reading files and directories from URIs.
     * @returns %TRUE if the @appinfo supports URIs.
     */
    supports_uris(): boolean

    // Own virtual methods of Gio-2.0.Gio.AppInfo

    /**
     * Adds a content type to the application information to indicate the
     * application is capable of opening files with the given content type.
     * @virtual 
     * @param content_type a string.
     * @returns %TRUE on success, %FALSE on error.
     */
    vfunc_add_supports_type(content_type: string | null): boolean
    /**
     * Obtains the information whether the #GAppInfo can be deleted.
     * See g_app_info_delete().
     * @virtual 
     * @returns %TRUE if @appinfo can be deleted
     */
    vfunc_can_delete(): boolean
    /**
     * Checks if a supported content type can be removed from an application.
     * @virtual 
     * @returns %TRUE if it is possible to remove supported     content types from a given @appinfo, %FALSE if not.
     */
    vfunc_can_remove_supports_type(): boolean
    /**
     * Tries to delete a #GAppInfo.
     * 
     * On some platforms, there may be a difference between user-defined
     * #GAppInfos which can be deleted, and system-wide ones which cannot.
     * See g_app_info_can_delete().
     * @virtual 
     * @returns %TRUE if @appinfo has been deleted
     */
    vfunc_do_delete(): boolean
    /**
     * Creates a duplicate of a #GAppInfo.
     * @virtual 
     * @returns a duplicate of @appinfo.
     */
    vfunc_dup(): AppInfo
    /**
     * Checks if two #GAppInfos are equal.
     * 
     * Note that the check *may not* compare each individual
     * field, and only does an identity check. In case detecting changes in the
     * contents is needed, program code must additionally compare relevant fields.
     * @virtual 
     * @param appinfo2 the second #GAppInfo.
     * @returns %TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.
     */
    vfunc_equal(appinfo2: AppInfo): boolean
    /**
     * Gets the commandline with which the application will be
     * started.
     * @virtual 
     * @returns a string containing the @appinfo's commandline,     or %NULL if this information is not available
     */
    vfunc_get_commandline(): string | null
    /**
     * Gets a human-readable description of an installed application.
     * @virtual 
     * @returns a string containing a description of the application @appinfo, or %NULL if none.
     */
    vfunc_get_description(): string | null
    /**
     * Gets the display name of the application. The display name is often more
     * descriptive to the user than the name itself.
     * @virtual 
     * @returns the display name of the application for @appinfo, or the name if no display name is available.
     */
    vfunc_get_display_name(): string | null
    /**
     * Gets the executable's name for the installed application.
     * 
     * This is intended to be used for debugging or labelling what program is going
     * to be run. To launch the executable, use g_app_info_launch() and related
     * functions, rather than spawning the return value from this function.
     * @virtual 
     * @returns a string containing the @appinfo's application binaries name
     */
    vfunc_get_executable(): string
    /**
     * Gets the icon for the application.
     * @virtual 
     * @returns the default #GIcon for @appinfo or %NULL if there is no default icon.
     */
    vfunc_get_icon(): Icon | null
    /**
     * Gets the ID of an application. An id is a string that
     * identifies the application. The exact format of the id is
     * platform dependent. For instance, on Unix this is the
     * desktop file id from the xdg menu specification.
     * 
     * Note that the returned ID may be %NULL, depending on how
     * the `appinfo` has been constructed.
     * @virtual 
     * @returns a string containing the application's ID.
     */
    vfunc_get_id(): string | null
    /**
     * Gets the installed name of the application.
     * @virtual 
     * @returns the name of the application for @appinfo.
     */
    vfunc_get_name(): string | null
    /**
     * Retrieves the list of content types that `app_info` claims to support.
     * If this information is not provided by the environment, this function
     * will return %NULL.
     * This function does not take in consideration associations added with
     * g_app_info_add_supports_type(), but only those exported directly by
     * the application.
     * @virtual 
     * @returns     a list of content types.
     */
    vfunc_get_supported_types(): string[]
    /**
     * Launches the application. Passes `files` to the launched application
     * as arguments, using the optional `context` to get information
     * about the details of the launcher (like what screen it is on).
     * On error, `error` will be set accordingly.
     * 
     * To launch the application without arguments pass a %NULL `files` list.
     * 
     * Note that even if the launch is successful the application launched
     * can fail to start if it runs into problems during startup. There is
     * no way to detect this.
     * 
     * Some URIs can be changed when passed through a GFile (for instance
     * unsupported URIs with strange formats like mailto:), so if you have
     * a textual URI you want to pass in as argument, consider using
     * g_app_info_launch_uris() instead.
     * 
     * The launched application inherits the environment of the launching
     * process, but it can be modified with g_app_launch_context_setenv()
     * and g_app_launch_context_unsetenv().
     * 
     * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
     * environment variable with the path of the launched desktop file and
     * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
     * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
     * should it be inherited by further processes. The `DISPLAY`,
     * `XDG_ACTIVATION_TOKEN` and `DESKTOP_STARTUP_ID` environment
     * variables are also set, based on information provided in `context`.
     * @virtual 
     * @param files a #GList of #GFile objects
     * @param context a #GAppLaunchContext or %NULL
     * @returns %TRUE on successful launch, %FALSE otherwise.
     */
    vfunc_launch(files: File[] | null, context: AppLaunchContext | null): boolean
    /**
     * Launches the application. This passes the `uris` to the launched application
     * as arguments, using the optional `context` to get information
     * about the details of the launcher (like what screen it is on).
     * On error, `error` will be set accordingly. If the application only supports
     * one URI per invocation as part of their command-line, multiple instances
     * of the application will be spawned.
     * 
     * To launch the application without arguments pass a %NULL `uris` list.
     * 
     * Note that even if the launch is successful the application launched
     * can fail to start if it runs into problems during startup. There is
     * no way to detect this.
     * @virtual 
     * @param uris a #GList containing URIs to launch.
     * @param context a #GAppLaunchContext or %NULL
     * @returns %TRUE on successful launch, %FALSE otherwise.
     */
    vfunc_launch_uris(uris: string[] | null, context: AppLaunchContext | null): boolean
    /**
     * Async version of g_app_info_launch_uris().
     * 
     * The `callback` is invoked immediately after the application launch, but it
     * waits for activation in case of D-Bus–activated applications and also provides
     * extended error information for sandboxed applications, see notes for
     * g_app_info_launch_default_for_uri_async().
     * @virtual 
     * @param uris a #GList containing URIs to launch.
     * @param context a #GAppLaunchContext or %NULL
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    vfunc_launch_uris_async(uris: string[] | null, context: AppLaunchContext | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a g_app_info_launch_uris_async() operation.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE on successful launch, %FALSE otherwise.
     */
    vfunc_launch_uris_finish(result: AsyncResult): boolean
    /**
     * Removes a supported type from an application, if possible.
     * @virtual 
     * @param content_type a string.
     * @returns %TRUE on success, %FALSE on error.
     */
    vfunc_remove_supports_type(content_type: string | null): boolean
    /**
     * Sets the application as the default handler for the given file extension.
     * @virtual 
     * @param extension a string containing the file extension     (without the dot).
     * @returns %TRUE on success, %FALSE on error.
     */
    vfunc_set_as_default_for_extension(extension: string): boolean
    /**
     * Sets the application as the default handler for a given type.
     * @virtual 
     * @param content_type the content type.
     * @returns %TRUE on success, %FALSE on error.
     */
    vfunc_set_as_default_for_type(content_type: string | null): boolean
    /**
     * Sets the application as the last used application for a given type.
     * This will make the application appear as first in the list returned
     * by g_app_info_get_recommended_for_type(), regardless of the default
     * application for that content type.
     * @virtual 
     * @param content_type the content type.
     * @returns %TRUE on success, %FALSE on error.
     */
    vfunc_set_as_last_used_for_type(content_type: string | null): boolean
    /**
     * Checks if the application info should be shown in menus that
     * list available applications.
     * @virtual 
     * @returns %TRUE if the @appinfo should be shown, %FALSE otherwise.
     */
    vfunc_should_show(): boolean
    /**
     * Checks if the application accepts files as arguments.
     * @virtual 
     * @returns %TRUE if the @appinfo supports files.
     */
    vfunc_supports_files(): boolean
    /**
     * Checks if the application supports reading files and directories from URIs.
     * @virtual 
     * @returns %TRUE if the @appinfo supports URIs.
     */
    vfunc_supports_uris(): boolean

    // Class property signals of Gio-2.0.Gio.AppInfo

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GAppInfo and #GAppLaunchContext are used for describing and launching
 * applications installed on the system.
 * 
 * As of GLib 2.20, URIs will always be converted to POSIX paths
 * (using g_file_get_path()) when using g_app_info_launch() even if
 * the application requested an URI and not a POSIX path. For example
 * for a desktop-file based application with Exec key `totem
 * %U` and a single URI, `sftp://foo/file.avi`, then
 * `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will
 * only work if a set of suitable GIO extensions (such as gvfs 2.26
 * compiled with FUSE support), is available and operational; if this
 * is not the case, the URI will be passed unmodified to the application.
 * Some URIs, such as `mailto:`, of course cannot be mapped to a POSIX
 * path (in gvfs there's no FUSE mount for it); such URIs will be
 * passed unmodified to the application.
 * 
 * Specifically for gvfs 2.26 and later, the POSIX URI will be mapped
 * back to the GIO URI in the #GFile constructors (since gvfs
 * implements the #GVfs extension point). As such, if the application
 * needs to examine the URI, it needs to use g_file_get_uri() or
 * similar on #GFile. In other words, an application cannot assume
 * that the URI passed to e.g. g_file_new_for_commandline_arg() is
 * equal to the result of g_file_get_uri(). The following snippet
 * illustrates this:
 * 
 * 
 * ```
 * GFile *f;
 * char *uri;
 * 
 * file = g_file_new_for_commandline_arg (uri_from_commandline);
 * 
 * uri = g_file_get_uri (file);
 * strcmp (uri, uri_from_commandline) == 0;
 * g_free (uri);
 * 
 * if (g_file_has_uri_scheme (file, "cdda"))
 *   {
 *     // do something special with uri
 *   }
 * g_object_unref (file);
 * ```
 * 
 * 
 * This code will work when both `cdda://sr0/Track 1.wav` and
 * `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
 * application. It should be noted that it's generally not safe
 * for applications to rely on the format of a particular URIs.
 * Different launcher applications (e.g. file managers) may have
 * different ideas of what a given URI means.
 * @interface 
 */
class AppInfo extends GObject.Object {

    // Own properties of Gio-2.0.Gio.AppInfo

    static name: string
    static $gtype: GObject.GType<AppInfo>

    // Constructors of Gio-2.0.Gio.AppInfo

    constructor(config?: AppInfo.ConstructorProperties) 
    _init(config?: AppInfo.ConstructorProperties): void
    /**
     * Creates a new #GAppInfo from the given information.
     * 
     * Note that for `commandline,` the quoting rules of the Exec key of the
     * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
     * are applied. For example, if the `commandline` contains
     * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
     * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
     * @param commandline the commandline to use
     * @param application_name the application name, or %NULL to use `commandline`
     * @param flags flags that can specify details of the created #GAppInfo
     * @returns new #GAppInfo for given command.
     */
    static create_from_commandline(commandline: string, application_name: string | null, flags: AppInfoCreateFlags): AppInfo
    /**
     * Gets a list of all of the applications currently registered
     * on this system.
     * 
     * For desktop files, this includes applications that have
     * `NoDisplay=true` set or are excluded from display by means
     * of `OnlyShowIn` or `NotShowIn`. See g_app_info_should_show().
     * The returned list does not include applications which have
     * the `Hidden` key set.
     * @returns a newly allocated #GList of references to #GAppInfos.
     */
    static get_all(): AppInfo[]
    /**
     * Gets a list of all #GAppInfos for a given content type,
     * including the recommended and fallback #GAppInfos. See
     * g_app_info_get_recommended_for_type() and
     * g_app_info_get_fallback_for_type().
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    static get_all_for_type(content_type: string | null): AppInfo[]
    /**
     * Gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @returns #GAppInfo for given @content_type or     %NULL on error.
     */
    static get_default_for_type(content_type: string | null, must_support_uris: boolean): AppInfo | null
    /**
     * Asynchronously gets the default #GAppInfo for a given content type.
     * @param content_type the content type to find a #GAppInfo for
     * @param must_support_uris if %TRUE, the #GAppInfo is expected to     support URIs
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    static get_default_for_type_async(content_type: string | null, must_support_uris: boolean, cancellable: Cancellable | null, callback: AsyncReadyCallback<AppInfo> | null): void
    /**
     * Finishes a default #GAppInfo lookup started by
     * g_app_info_get_default_for_type_async().
     * 
     * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
     * @param result a #GAsyncResult
     * @returns #GAppInfo for given @content_type or     %NULL on error.
     */
    static get_default_for_type_finish(result: AsyncResult): AppInfo
    /**
     * Gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
     */
    static get_default_for_uri_scheme(uri_scheme: string | null): AppInfo | null
    /**
     * Asynchronously gets the default application for handling URIs with
     * the given URI scheme. A URI scheme is the initial part
     * of the URI, up to but not including the ':', e.g. "http",
     * "ftp" or "sip".
     * @param uri_scheme a string containing a URI scheme.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    static get_default_for_uri_scheme_async(uri_scheme: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<AppInfo> | null): void
    /**
     * Finishes a default #GAppInfo lookup started by
     * g_app_info_get_default_for_uri_scheme_async().
     * 
     * If no #GAppInfo is found, then `error` will be set to %G_IO_ERROR_NOT_FOUND.
     * @param result a #GAsyncResult
     * @returns #GAppInfo for given @uri_scheme or     %NULL on error.
     */
    static get_default_for_uri_scheme_finish(result: AsyncResult): AppInfo
    /**
     * Gets a list of fallback #GAppInfos for a given content type, i.e.
     * those applications which claim to support the given content type
     * by MIME type subclassing and not directly.
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    static get_fallback_for_type(content_type: string | null): AppInfo[]
    /**
     * Gets a list of recommended #GAppInfos for a given content type, i.e.
     * those applications which claim to support the given content type exactly,
     * and not by MIME type subclassing.
     * Note that the first application of the list is the last used one, i.e.
     * the last one for which g_app_info_set_as_last_used_for_type() has been
     * called.
     * @param content_type the content type to find a #GAppInfo for
     * @returns #GList of #GAppInfos     for given @content_type or %NULL on error.
     */
    static get_recommended_for_type(content_type: string | null): AppInfo[]
    /**
     * Utility function that launches the default application
     * registered to handle the specified uri. Synchronous I/O
     * is done on the uri to detect the type of the file if
     * required.
     * 
     * The D-Bus–activated applications don't have to be started if your application
     * terminates too soon after this function. To prevent this, use
     * g_app_info_launch_default_for_uri_async() instead.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @returns %TRUE on success, %FALSE on error.
     */
    static launch_default_for_uri(uri: string | null, context: AppLaunchContext | null): boolean
    /**
     * Async version of g_app_info_launch_default_for_uri().
     * 
     * This version is useful if you are interested in receiving
     * error information in the case where the application is
     * sandboxed and the portal may present an application chooser
     * dialog to the user.
     * 
     * This is also useful if you want to be sure that the D-Bus–activated
     * applications are really started before termination and if you are interested
     * in receiving error information from their activation.
     * @param uri the uri to show
     * @param context an optional #GAppLaunchContext
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    static launch_default_for_uri_async(uri: string | null, context: AppLaunchContext | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<AppInfo> | null): void
    /**
     * Finishes an asynchronous launch-default-for-uri operation.
     * @param result a #GAsyncResult
     * @returns %TRUE if the launch was successful, %FALSE if @error is set
     */
    static launch_default_for_uri_finish(result: AsyncResult): boolean
    /**
     * Removes all changes to the type associations done by
     * g_app_info_set_as_default_for_type(),
     * g_app_info_set_as_default_for_extension(),
     * g_app_info_add_supports_type() or
     * g_app_info_remove_supports_type().
     * @param content_type a content type
     */
    static reset_type_associations(content_type: string | null): void
}

module AsyncInitable {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface AsyncInitable {

    // Owm methods of Gio-2.0.Gio.AsyncInitable

    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    init_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of init_async

    /**
     * Promisified version of {@link init_async}
     * 
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
     */
    init_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     * @param res a #GAsyncResult.
     * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
     */
    init_finish(res: AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     * @param res the #GAsyncResult from the callback
     * @returns a newly created #GObject,      or %NULL on error. Free with g_object_unref().
     */
    new_finish(res: AsyncResult): GObject.Object

    // Own virtual methods of Gio-2.0.Gio.AsyncInitable

    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    vfunc_init_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     * @virtual 
     * @param res a #GAsyncResult.
     * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
     */
    vfunc_init_finish(res: AsyncResult): boolean

    // Class property signals of Gio-2.0.Gio.AsyncInitable

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This is the asynchronous version of #GInitable; it behaves the same
 * in all ways except that initialization is asynchronous. For more details
 * see the descriptions on #GInitable.
 * 
 * A class may implement both the #GInitable and #GAsyncInitable interfaces.
 * 
 * Users of objects implementing this are not intended to use the interface
 * method directly; instead it will be used automatically in various ways.
 * For C applications you generally just call g_async_initable_new_async()
 * directly, or indirectly via a foo_thing_new_async() wrapper. This will call
 * g_async_initable_init_async() under the cover, calling back with %NULL and
 * a set %GError on failure.
 * 
 * A typical implementation might look something like this:
 * 
 * 
 * ```c
 * enum {
 *    NOT_INITIALIZED,
 *    INITIALIZING,
 *    INITIALIZED
 * };
 * 
 * static void
 * _foo_ready_cb (Foo *self)
 * {
 *   GList *l;
 * 
 *   self->priv->state = INITIALIZED;
 * 
 *   for (l = self->priv->init_results; l != NULL; l = l->next)
 *     {
 *       GTask *task = l->data;
 * 
 *       if (self->priv->success)
 *         g_task_return_boolean (task, TRUE);
 *       else
 *         g_task_return_new_error (task, ...);
 *       g_object_unref (task);
 *     }
 * 
 *   g_list_free (self->priv->init_results);
 *   self->priv->init_results = NULL;
 * }
 * 
 * static void
 * foo_init_async (GAsyncInitable       *initable,
 *                 int                   io_priority,
 *                 GCancellable         *cancellable,
 *                 GAsyncReadyCallback   callback,
 *                 gpointer              user_data)
 * {
 *   Foo *self = FOO (initable);
 *   GTask *task;
 * 
 *   task = g_task_new (initable, cancellable, callback, user_data);
 *   g_task_set_name (task, G_STRFUNC);
 * 
 *   switch (self->priv->state)
 *     {
 *       case NOT_INITIALIZED:
 *         _foo_get_ready (self);
 *         self->priv->init_results = g_list_append (self->priv->init_results,
 *                                                   task);
 *         self->priv->state = INITIALIZING;
 *         break;
 *       case INITIALIZING:
 *         self->priv->init_results = g_list_append (self->priv->init_results,
 *                                                   task);
 *         break;
 *       case INITIALIZED:
 *         if (!self->priv->success)
 *           g_task_return_new_error (task, ...);
 *         else
 *           g_task_return_boolean (task, TRUE);
 *         g_object_unref (task);
 *         break;
 *     }
 * }
 * 
 * static gboolean
 * foo_init_finish (GAsyncInitable       *initable,
 *                  GAsyncResult         *result,
 *                  GError              **error)
 * {
 *   g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
 * 
 *   return g_task_propagate_boolean (G_TASK (result), error);
 * }
 * 
 * static void
 * foo_async_initable_iface_init (gpointer g_iface,
 *                                gpointer data)
 * {
 *   GAsyncInitableIface *iface = g_iface;
 * 
 *   iface->init_async = foo_init_async;
 *   iface->init_finish = foo_init_finish;
 * }
 * ```
 * 
 * @interface 
 */
class AsyncInitable extends GObject.Object {

    // Own properties of Gio-2.0.Gio.AsyncInitable

    static name: string
    static $gtype: GObject.GType<AsyncInitable>

    // Constructors of Gio-2.0.Gio.AsyncInitable

    constructor(config?: AsyncInitable.ConstructorProperties) 
    _init(config?: AsyncInitable.ConstructorProperties): void
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     * @param object_type a #GType supporting #GAsyncInitable.
     * @param n_parameters the number of parameters in `parameters`
     * @param parameters the parameters to use to construct the object
     * @param io_priority the [I/O priority][io-priority] of the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the initialization is     finished
     */
    static newv_async(object_type: GObject.GType, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<AsyncInitable> | null): void
}

module AsyncResult {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface AsyncResult {

    // Owm methods of Gio-2.0.Gio.AsyncResult

    /**
     * Gets the source object from a #GAsyncResult.
     * @returns a new reference to the source    object for the @res, or %NULL if there is none.
     */
    get_source_object(): GObject.Object | null
    /**
     * Gets the user data from a #GAsyncResult.
     * @returns the user data for @res.
     */
    get_user_data(): any | null
    /**
     * Checks if `res` has the given `source_tag` (generally a function
     * pointer indicating the function `res` was created by).
     * @param source_tag an application-defined tag
     * @returns %TRUE if @res has the indicated @source_tag, %FALSE if   not.
     */
    is_tagged(source_tag: any | null): boolean
    /**
     * If `res` is a #GSimpleAsyncResult, this is equivalent to
     * g_simple_async_result_propagate_error(). Otherwise it returns
     * %FALSE.
     * 
     * This can be used for legacy error handling in async *_finish()
     * wrapper functions that traditionally handled #GSimpleAsyncResult
     * error returns themselves rather than calling into the virtual method.
     * This should not be used in new code; #GAsyncResult errors that are
     * set by virtual methods should also be extracted by virtual methods,
     * to enable subclasses to chain up correctly.
     * @returns %TRUE if @error is has been filled in with an error from   @res, %FALSE if not.
     */
    legacy_propagate_error(): boolean

    // Own virtual methods of Gio-2.0.Gio.AsyncResult

    /**
     * Gets the source object from a #GAsyncResult.
     * @virtual 
     * @returns a new reference to the source    object for the @res, or %NULL if there is none.
     */
    vfunc_get_source_object(): GObject.Object | null
    /**
     * Gets the user data from a #GAsyncResult.
     * @virtual 
     * @returns the user data for @res.
     */
    vfunc_get_user_data(): any | null
    /**
     * Checks if `res` has the given `source_tag` (generally a function
     * pointer indicating the function `res` was created by).
     * @virtual 
     * @param source_tag an application-defined tag
     * @returns %TRUE if @res has the indicated @source_tag, %FALSE if   not.
     */
    vfunc_is_tagged(source_tag: any | null): boolean

    // Class property signals of Gio-2.0.Gio.AsyncResult

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Provides a base class for implementing asynchronous function results.
 * 
 * Asynchronous operations are broken up into two separate operations
 * which are chained together by a #GAsyncReadyCallback. To begin
 * an asynchronous operation, provide a #GAsyncReadyCallback to the
 * asynchronous function. This callback will be triggered when the
 * operation has completed, and must be run in a later iteration of
 * the [thread-default main context][g-main-context-push-thread-default]
 * from where the operation was initiated. It will be passed a
 * #GAsyncResult instance filled with the details of the operation's
 * success or failure, the object the asynchronous function was
 * started for and any error codes returned. The asynchronous callback
 * function is then expected to call the corresponding "_finish()"
 * function, passing the object the function was called for, the
 * #GAsyncResult instance, and (optionally) an `error` to grab any
 * error conditions that may have occurred.
 * 
 * The "_finish()" function for an operation takes the generic result
 * (of type #GAsyncResult) and returns the specific result that the
 * operation in question yields (e.g. a #GFileEnumerator for a
 * "enumerate children" operation). If the result or error status of the
 * operation is not needed, there is no need to call the "_finish()"
 * function; GIO will take care of cleaning up the result and error
 * information after the #GAsyncReadyCallback returns. You can pass
 * %NULL for the #GAsyncReadyCallback if you don't need to take any
 * action at all after the operation completes. Applications may also
 * take a reference to the #GAsyncResult and call "_finish()" later;
 * however, the "_finish()" function may be called at most once.
 * 
 * Example of a typical asynchronous operation flow:
 * 
 * ```c
 * void _theoretical_frobnitz_async (Theoretical         *t,
 *                                   GCancellable        *c,
 *                                   GAsyncReadyCallback  cb,
 *                                   gpointer             u);
 * 
 * gboolean _theoretical_frobnitz_finish (Theoretical   *t,
 *                                        GAsyncResult  *res,
 *                                        GError       **e);
 * 
 * static void
 * frobnitz_result_func (GObject      *source_object,
 * 		 GAsyncResult *res,
 * 		 gpointer      user_data)
 * {
 *   gboolean success = FALSE;
 * 
 *   success = _theoretical_frobnitz_finish (source_object, res, NULL);
 * 
 *   if (success)
 *     g_printf ("Hurray!\n");
 *   else
 *     g_printf ("Uh oh!\n");
 * 
 *   ...
 * 
 * }
 * 
 * int main (int argc, void *argv[])
 * {
 *    ...
 * 
 *    _theoretical_frobnitz_async (theoretical_data,
 *                                 NULL,
 *                                 frobnitz_result_func,
 *                                 NULL);
 * 
 *    ...
 * }
 * ```
 * 
 * 
 * The callback for an asynchronous operation is called only once, and is
 * always called, even in the case of a cancelled operation. On cancellation
 * the result is a %G_IO_ERROR_CANCELLED error.
 * 
 * ## I/O Priority # {#io-priority}
 * 
 * Many I/O-related asynchronous operations have a priority parameter,
 * which is used in certain cases to determine the order in which
 * operations are executed. They are not used to determine system-wide
 * I/O scheduling. Priorities are integers, with lower numbers indicating
 * higher priority. It is recommended to choose priorities between
 * %G_PRIORITY_LOW and %G_PRIORITY_HIGH, with %G_PRIORITY_DEFAULT
 * as a default.
 * @interface 
 */
class AsyncResult extends GObject.Object {

    // Own properties of Gio-2.0.Gio.AsyncResult

    static name: string
    static $gtype: GObject.GType<AsyncResult>

    // Constructors of Gio-2.0.Gio.AsyncResult

    constructor(config?: AsyncResult.ConstructorProperties) 
    _init(config?: AsyncResult.ConstructorProperties): void
}

module Converter {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Converter {

    // Owm methods of Gio-2.0.Gio.Converter

    /**
     * This is the main operation used when converting data. It is to be called
     * multiple times in a loop, and each time it will do some work, i.e.
     * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
     * both. If its not possible to do any work an error is returned.
     * 
     * Note that a single call may not consume all input (or any input at all).
     * Also a call may produce output even if given no input, due to state stored
     * in the converter producing output.
     * 
     * If any data was either produced or consumed, and then an error happens, then
     * only the successful conversion is reported and the error is returned on the
     * next call.
     * 
     * A full conversion loop involves calling this method repeatedly, each time
     * giving it new input and space output space. When there is no more input
     * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
     * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
     * each time until all data is consumed and all output is produced, then
     * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
     * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
     * in a decompression converter where the end of data is detectable from the
     * data (and there might even be other data after the end of the compressed data).
     * 
     * When some data has successfully been converted `bytes_read` and is set to
     * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
     * how many bytes was written to `outbuf`. If there are more data to output
     * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
     * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
     * then %G_CONVERTER_FINISHED is returned.
     * 
     * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
     * Some errors need special handling:
     * 
     * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
     * to write the resulting converted data, the application should
     * call the function again with a larger `outbuf` to continue.
     * 
     * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
     * input to fully determine what the conversion should produce,
     * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
     * example with an incomplete multibyte sequence when converting text,
     * or when a regexp matches up to the end of the input (and may match
     * further input). It may also happen when `inbuf_size` is zero and
     * there is no more data to produce.
     * 
     * When this happens the application should read more input and then
     * call the function again. If further input shows that there is no
     * more data call the function again with the same data but with
     * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
     * to finish as e.g. in the regexp match case (or, to fail again with
     * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
     * input is actually partial).
     * 
     * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
     * converter object is in an invalid state where its not allowed
     * to call g_converter_convert() anymore. At this time you can only
     * free the object or call g_converter_reset() to reset it to the
     * initial state.
     * 
     * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
     * to try to write out all internal state to the output. The application
     * has to call the function multiple times with the flag set, and when
     * the available input has been consumed and all internal state has
     * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
     * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
     * This is somewhat similar to what happens at the end of the input stream,
     * but done in the middle of the data.
     * 
     * This has different meanings for different conversions. For instance
     * in a compression converter it would mean that we flush all the
     * compression state into output such that if you uncompress the
     * compressed data you get back all the input data. Doing this may
     * make the final file larger due to padding though. Another example
     * is a regexp conversion, where if you at the end of the flushed data
     * have a match, but there is also a potential longer match. In the
     * non-flushed case we would ask for more input, but when flushing we
     * treat this as the end of input and do the match.
     * 
     * Flushing is not always possible (like if a charset converter flushes
     * at a partial multibyte sequence). Converters are supposed to try
     * to produce as much output as possible and then return an error
     * (typically %G_IO_ERROR_PARTIAL_INPUT).
     * @param inbuf the buffer         containing the data to convert.
     * @param outbuf a    buffer to write converted data in.
     * @param flags a #GConverterFlags controlling the conversion details
     * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
     */
    convert(inbuf: Uint8Array, outbuf: Uint8Array, flags: ConverterFlags): [ /* returnType */ ConverterResult, /* bytes_read */ number, /* bytes_written */ number ]
    /**
     * Resets all internal state in the converter, making it behave
     * as if it was just created. If the converter has any internal
     * state that would produce output then that output is lost.
     */
    reset(): void

    // Own virtual methods of Gio-2.0.Gio.Converter

    /**
     * This is the main operation used when converting data. It is to be called
     * multiple times in a loop, and each time it will do some work, i.e.
     * producing some output (in `outbuf)` or consuming some input (from `inbuf)` or
     * both. If its not possible to do any work an error is returned.
     * 
     * Note that a single call may not consume all input (or any input at all).
     * Also a call may produce output even if given no input, due to state stored
     * in the converter producing output.
     * 
     * If any data was either produced or consumed, and then an error happens, then
     * only the successful conversion is reported and the error is returned on the
     * next call.
     * 
     * A full conversion loop involves calling this method repeatedly, each time
     * giving it new input and space output space. When there is no more input
     * data after the data in `inbuf,` the flag %G_CONVERTER_INPUT_AT_END must be set.
     * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
     * each time until all data is consumed and all output is produced, then
     * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
     * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
     * in a decompression converter where the end of data is detectable from the
     * data (and there might even be other data after the end of the compressed data).
     * 
     * When some data has successfully been converted `bytes_read` and is set to
     * the number of bytes read from `inbuf,` and `bytes_written` is set to indicate
     * how many bytes was written to `outbuf`. If there are more data to output
     * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
     * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
     * then %G_CONVERTER_FINISHED is returned.
     * 
     * On error %G_CONVERTER_ERROR is returned and `error` is set accordingly.
     * Some errors need special handling:
     * 
     * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
     * to write the resulting converted data, the application should
     * call the function again with a larger `outbuf` to continue.
     * 
     * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
     * input to fully determine what the conversion should produce,
     * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
     * example with an incomplete multibyte sequence when converting text,
     * or when a regexp matches up to the end of the input (and may match
     * further input). It may also happen when `inbuf_size` is zero and
     * there is no more data to produce.
     * 
     * When this happens the application should read more input and then
     * call the function again. If further input shows that there is no
     * more data call the function again with the same data but with
     * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
     * to finish as e.g. in the regexp match case (or, to fail again with
     * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
     * input is actually partial).
     * 
     * After g_converter_convert() has returned %G_CONVERTER_FINISHED the
     * converter object is in an invalid state where its not allowed
     * to call g_converter_convert() anymore. At this time you can only
     * free the object or call g_converter_reset() to reset it to the
     * initial state.
     * 
     * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
     * to try to write out all internal state to the output. The application
     * has to call the function multiple times with the flag set, and when
     * the available input has been consumed and all internal state has
     * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
     * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
     * This is somewhat similar to what happens at the end of the input stream,
     * but done in the middle of the data.
     * 
     * This has different meanings for different conversions. For instance
     * in a compression converter it would mean that we flush all the
     * compression state into output such that if you uncompress the
     * compressed data you get back all the input data. Doing this may
     * make the final file larger due to padding though. Another example
     * is a regexp conversion, where if you at the end of the flushed data
     * have a match, but there is also a potential longer match. In the
     * non-flushed case we would ask for more input, but when flushing we
     * treat this as the end of input and do the match.
     * 
     * Flushing is not always possible (like if a charset converter flushes
     * at a partial multibyte sequence). Converters are supposed to try
     * to produce as much output as possible and then return an error
     * (typically %G_IO_ERROR_PARTIAL_INPUT).
     * @virtual 
     * @param inbuf the buffer         containing the data to convert.
     * @param outbuf a    buffer to write converted data in.
     * @param flags a #GConverterFlags controlling the conversion details
     * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
     */
    vfunc_convert(inbuf: Uint8Array | null, outbuf: Uint8Array, flags: ConverterFlags): [ /* returnType */ ConverterResult, /* bytes_read */ number, /* bytes_written */ number ]
    /**
     * Resets all internal state in the converter, making it behave
     * as if it was just created. If the converter has any internal
     * state that would produce output then that output is lost.
     * @virtual 
     */
    vfunc_reset(): void

    // Class property signals of Gio-2.0.Gio.Converter

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GConverter is implemented by objects that convert
 * binary data in various ways. The conversion can be
 * stateful and may fail at any place.
 * 
 * Some example conversions are: character set conversion,
 * compression, decompression and regular expression
 * replace.
 * @interface 
 */
class Converter extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Converter

    static name: string
    static $gtype: GObject.GType<Converter>

    // Constructors of Gio-2.0.Gio.Converter

    constructor(config?: Converter.ConstructorProperties) 
    _init(config?: Converter.ConstructorProperties): void
}

module DBusInterface {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface DBusInterface {

    // Owm methods of Gio-2.0.Gio.DBusInterface

    /**
     * Gets the #GDBusObject that `interface_` belongs to, if any.
     * @returns A #GDBusObject or %NULL. The returned reference should be freed with g_object_unref().
     */
    get_object(): DBusObject | null
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    get_info(): DBusInterfaceInfo
    /**
     * Sets the #GDBusObject for `interface_` to `object`.
     * 
     * Note that `interface_` will hold a weak reference to `object`.
     * @param object A #GDBusObject or %NULL.
     */
    set_object(object: DBusObject | null): void

    // Own virtual methods of Gio-2.0.Gio.DBusInterface

    /**
     * Gets the #GDBusObject that `interface_` belongs to, if any.
     * @virtual 
     * @returns A #GDBusObject or %NULL. The returned reference should be freed with g_object_unref().
     */
    vfunc_dup_object(): DBusObject | null
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    vfunc_get_info(): DBusInterfaceInfo
    /**
     * Sets the #GDBusObject for `interface_` to `object`.
     * 
     * Note that `interface_` will hold a weak reference to `object`.
     * @virtual 
     * @param object A #GDBusObject or %NULL.
     */
    vfunc_set_object(object: DBusObject | null): void

    // Class property signals of Gio-2.0.Gio.DBusInterface

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GDBusInterface type is the base type for D-Bus interfaces both
 * on the service side (see #GDBusInterfaceSkeleton) and client side
 * (see #GDBusProxy).
 * @interface 
 */
class DBusInterface extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusInterface

    static name: string
    static $gtype: GObject.GType<DBusInterface>

    // Constructors of Gio-2.0.Gio.DBusInterface

    constructor(config?: DBusInterface.ConstructorProperties) 
    _init(config?: DBusInterface.ConstructorProperties): void
}

module DBusObject {

    // Signal callback interfaces

    /**
     * Signal callback interface for `interface-added`
     */
    interface InterfaceAddedSignalCallback {
        ($obj: DBusObject, interface: DBusInterface): void
    }

    /**
     * Signal callback interface for `interface-removed`
     */
    interface InterfaceRemovedSignalCallback {
        ($obj: DBusObject, interface: DBusInterface): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface DBusObject {

    // Owm methods of Gio-2.0.Gio.DBusObject

    /**
     * Gets the D-Bus interface with name `interface_name` associated with
     * `object,` if any.
     * @param interface_name A D-Bus interface name.
     * @returns %NULL if not found, otherwise a   #GDBusInterface that must be freed with g_object_unref().
     */
    get_interface(interface_name: string | null): DBusInterface | null
    /**
     * Gets the D-Bus interfaces associated with `object`.
     * @returns A list of #GDBusInterface instances.   The returned list must be freed by g_list_free() after each element has been freed   with g_object_unref().
     */
    get_interfaces(): DBusInterface[]
    /**
     * Gets the object path for `object`.
     * @returns A string owned by @object. Do not free.
     */
    get_object_path(): string | null

    // Own virtual methods of Gio-2.0.Gio.DBusObject

    /**
     * Gets the D-Bus interface with name `interface_name` associated with
     * `object,` if any.
     * @virtual 
     * @param interface_name A D-Bus interface name.
     * @returns %NULL if not found, otherwise a   #GDBusInterface that must be freed with g_object_unref().
     */
    vfunc_get_interface(interface_name: string | null): DBusInterface | null
    /**
     * Gets the D-Bus interfaces associated with `object`.
     * @virtual 
     * @returns A list of #GDBusInterface instances.   The returned list must be freed by g_list_free() after each element has been freed   with g_object_unref().
     */
    vfunc_get_interfaces(): DBusInterface[]
    /**
     * Gets the object path for `object`.
     * @virtual 
     * @returns A string owned by @object. Do not free.
     */
    vfunc_get_object_path(): string | null
    vfunc_interface_added(interface_: DBusInterface): void
    vfunc_interface_removed(interface_: DBusInterface): void

    // Own signals of Gio-2.0.Gio.DBusObject

    connect(sigName: "interface-added", callback: DBusObject.InterfaceAddedSignalCallback): number
    connect_after(sigName: "interface-added", callback: DBusObject.InterfaceAddedSignalCallback): number
    emit(sigName: "interface-added", interface: DBusInterface, ...args: any[]): void
    connect(sigName: "interface-removed", callback: DBusObject.InterfaceRemovedSignalCallback): number
    connect_after(sigName: "interface-removed", callback: DBusObject.InterfaceRemovedSignalCallback): number
    emit(sigName: "interface-removed", interface: DBusInterface, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusObject

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GDBusObject type is the base type for D-Bus objects on both
 * the service side (see #GDBusObjectSkeleton) and the client side
 * (see #GDBusObjectProxy). It is essentially just a container of
 * interfaces.
 * @interface 
 */
class DBusObject extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusObject

    static name: string
    static $gtype: GObject.GType<DBusObject>

    // Constructors of Gio-2.0.Gio.DBusObject

    constructor(config?: DBusObject.ConstructorProperties) 
    _init(config?: DBusObject.ConstructorProperties): void
}

module DBusObjectManager {

    // Signal callback interfaces

    /**
     * Signal callback interface for `interface-added`
     */
    interface InterfaceAddedSignalCallback {
        ($obj: DBusObjectManager, object: DBusObject, interface: DBusInterface): void
    }

    /**
     * Signal callback interface for `interface-removed`
     */
    interface InterfaceRemovedSignalCallback {
        ($obj: DBusObjectManager, object: DBusObject, interface: DBusInterface): void
    }

    /**
     * Signal callback interface for `object-added`
     */
    interface ObjectAddedSignalCallback {
        ($obj: DBusObjectManager, object: DBusObject): void
    }

    /**
     * Signal callback interface for `object-removed`
     */
    interface ObjectRemovedSignalCallback {
        ($obj: DBusObjectManager, object: DBusObject): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface DBusObjectManager {

    // Owm methods of Gio-2.0.Gio.DBusObjectManager

    /**
     * Gets the interface proxy for `interface_name` at `object_path,` if
     * any.
     * @param object_path Object path to look up.
     * @param interface_name D-Bus interface name to look up.
     * @returns A #GDBusInterface instance or %NULL. Free   with g_object_unref().
     */
    get_interface(object_path: string | null, interface_name: string | null): DBusInterface | null
    /**
     * Gets the #GDBusObject at `object_path,` if any.
     * @param object_path Object path to look up.
     * @returns A #GDBusObject or %NULL. Free with   g_object_unref().
     */
    get_object(object_path: string | null): DBusObject | null
    /**
     * Gets the object path that `manager` is for.
     * @returns A string owned by @manager. Do not free.
     */
    get_object_path(): string | null
    /**
     * Gets all #GDBusObject objects known to `manager`.
     * @returns A list of   #GDBusObject objects. The returned list should be freed with   g_list_free() after each element has been freed with   g_object_unref().
     */
    get_objects(): DBusObject[]

    // Own virtual methods of Gio-2.0.Gio.DBusObjectManager

    /**
     * Gets the interface proxy for `interface_name` at `object_path,` if
     * any.
     * @virtual 
     * @param object_path Object path to look up.
     * @param interface_name D-Bus interface name to look up.
     * @returns A #GDBusInterface instance or %NULL. Free   with g_object_unref().
     */
    vfunc_get_interface(object_path: string | null, interface_name: string | null): DBusInterface | null
    /**
     * Gets the #GDBusObject at `object_path,` if any.
     * @virtual 
     * @param object_path Object path to look up.
     * @returns A #GDBusObject or %NULL. Free with   g_object_unref().
     */
    vfunc_get_object(object_path: string | null): DBusObject | null
    /**
     * Gets the object path that `manager` is for.
     * @virtual 
     * @returns A string owned by @manager. Do not free.
     */
    vfunc_get_object_path(): string | null
    /**
     * Gets all #GDBusObject objects known to `manager`.
     * @virtual 
     * @returns A list of   #GDBusObject objects. The returned list should be freed with   g_list_free() after each element has been freed with   g_object_unref().
     */
    vfunc_get_objects(): DBusObject[]
    vfunc_interface_added(object: DBusObject, interface_: DBusInterface): void
    vfunc_interface_removed(object: DBusObject, interface_: DBusInterface): void
    vfunc_object_added(object: DBusObject): void
    vfunc_object_removed(object: DBusObject): void

    // Own signals of Gio-2.0.Gio.DBusObjectManager

    connect(sigName: "interface-added", callback: DBusObjectManager.InterfaceAddedSignalCallback): number
    connect_after(sigName: "interface-added", callback: DBusObjectManager.InterfaceAddedSignalCallback): number
    emit(sigName: "interface-added", object: DBusObject, interface: DBusInterface, ...args: any[]): void
    connect(sigName: "interface-removed", callback: DBusObjectManager.InterfaceRemovedSignalCallback): number
    connect_after(sigName: "interface-removed", callback: DBusObjectManager.InterfaceRemovedSignalCallback): number
    emit(sigName: "interface-removed", object: DBusObject, interface: DBusInterface, ...args: any[]): void
    connect(sigName: "object-added", callback: DBusObjectManager.ObjectAddedSignalCallback): number
    connect_after(sigName: "object-added", callback: DBusObjectManager.ObjectAddedSignalCallback): number
    emit(sigName: "object-added", object: DBusObject, ...args: any[]): void
    connect(sigName: "object-removed", callback: DBusObjectManager.ObjectRemovedSignalCallback): number
    connect_after(sigName: "object-removed", callback: DBusObjectManager.ObjectRemovedSignalCallback): number
    emit(sigName: "object-removed", object: DBusObject, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusObjectManager

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GDBusObjectManager type is the base type for service- and
 * client-side implementations of the standardized
 * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
 * interface.
 * 
 * See #GDBusObjectManagerClient for the client-side implementation
 * and #GDBusObjectManagerServer for the service-side implementation.
 * @interface 
 */
class DBusObjectManager extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusObjectManager

    static name: string
    static $gtype: GObject.GType<DBusObjectManager>

    // Constructors of Gio-2.0.Gio.DBusObjectManager

    constructor(config?: DBusObjectManager.ConstructorProperties) 
    _init(config?: DBusObjectManager.ConstructorProperties): void
}

module DatagramBased {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface DatagramBased {

    // Owm methods of Gio-2.0.Gio.DatagramBased

    /**
     * Checks on the readiness of `datagram_based` to perform operations. The
     * operations specified in `condition` are checked for and masked against the
     * currently-satisfied conditions on `datagram_based`. The result is returned.
     * 
     * %G_IO_IN will be set in the return value if data is available to read with
     * g_datagram_based_receive_messages(), or if the connection is closed remotely
     * (EOS); and if the datagram_based has not been closed locally using some
     * implementation-specific method (such as g_socket_close() or
     * g_socket_shutdown() with `shutdown_read` set, if it’s a #GSocket).
     * 
     * If the connection is shut down or closed (by calling g_socket_close() or
     * g_socket_shutdown() with `shutdown_read` set, if it’s a #GSocket, for
     * example), all calls to this function will return %G_IO_ERROR_CLOSED.
     * 
     * %G_IO_OUT will be set if it is expected that at least one byte can be sent
     * using g_datagram_based_send_messages() without blocking. It will not be set
     * if the datagram_based has been closed locally.
     * 
     * %G_IO_HUP will be set if the connection has been closed locally.
     * 
     * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
     * previously enqueued using g_datagram_based_send_messages().
     * 
     * Note that on Windows, it is possible for an operation to return
     * %G_IO_ERROR_WOULD_BLOCK even immediately after
     * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
     * ready for writing. Rather than calling g_datagram_based_condition_check() and
     * then writing to the #GDatagramBased if it succeeds, it is generally better to
     * simply try writing right away, and try again later if the initial attempt
     * returns %G_IO_ERROR_WOULD_BLOCK.
     * 
     * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
     * conditions will always be set in the output if they are true. Apart from
     * these flags, the output is guaranteed to be masked by `condition`.
     * 
     * This call never blocks.
     * @param condition a #GIOCondition mask to check
     * @returns the #GIOCondition mask of the current state
     */
    condition_check(condition: GLib.IOCondition): GLib.IOCondition
    /**
     * Waits for up to `timeout` microseconds for condition to become true on
     * `datagram_based`. If the condition is met, %TRUE is returned.
     * 
     * If `cancellable` is cancelled before the condition is met, or if `timeout` is
     * reached before the condition is met, then %FALSE is returned and `error` is
     * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
     * @param condition a #GIOCondition mask to wait for
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a #GCancellable
     * @returns %TRUE if the condition was met, %FALSE otherwise
     */
    condition_wait(condition: GLib.IOCondition, timeout: number, cancellable: Cancellable | null): boolean
    /**
     * Creates a #GSource that can be attached to a #GMainContext to monitor for
     * the availability of the specified `condition` on the #GDatagramBased. The
     * #GSource keeps a reference to the `datagram_based`.
     * 
     * The callback on the source is of the #GDatagramBasedSourceFunc type.
     * 
     * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
     * conditions will always be reported in the callback if they are true.
     * 
     * If non-%NULL, `cancellable` can be used to cancel the source, which will
     * cause the source to trigger, reporting the current condition (which is
     * likely 0 unless cancellation happened at the same time as a condition
     * change). You can check for this in the callback using
     * g_cancellable_is_cancelled().
     * @param condition a #GIOCondition mask to monitor
     * @param cancellable a #GCancellable
     * @returns a newly allocated #GSource
     */
    create_source(condition: GLib.IOCondition, cancellable: Cancellable | null): GLib.Source
    /**
     * Receive one or more data messages from `datagram_based` in one go.
     * 
     * `messages` must point to an array of #GInputMessage structs and
     * `num_messages` must be the length of this array. Each #GInputMessage
     * contains a pointer to an array of #GInputVector structs describing the
     * buffers that the data received in each message will be written to.
     * 
     * `flags` modify how all messages are received. The commonly available
     * arguments for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too. These
     * flags affect the overall receive operation. Flags affecting individual
     * messages are returned in #GInputMessage.flags.
     * 
     * The other members of #GInputMessage are treated as described in its
     * documentation.
     * 
     * If `timeout` is negative the call will block until `num_messages` have been
     * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
     * or an error occurs.
     * 
     * If `timeout` is 0 the call will return up to `num_messages` without blocking,
     * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
     * to be received.
     * 
     * If `timeout` is positive the call will block on the same conditions as if
     * `timeout` were negative. If the timeout is reached
     * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
     * otherwise it will return the number of messages received before timing out.
     * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
     * recvmmsg().)
     * 
     * To be notified when messages are available, wait for the %G_IO_IN condition.
     * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
     * g_datagram_based_receive_messages() even if you were previously notified of a
     * %G_IO_IN condition.
     * 
     * If the remote peer closes the connection, any messages queued in the
     * underlying receive buffer will be returned, and subsequent calls to
     * g_datagram_based_receive_messages() will return 0 (with no error set).
     * 
     * If the connection is shut down or closed (by calling g_socket_close() or
     * g_socket_shutdown() with `shutdown_read` set, if it’s a #GSocket, for
     * example), all calls to this function will return %G_IO_ERROR_CLOSED.
     * 
     * On error -1 is returned and `error` is set accordingly. An error will only
     * be returned if zero messages could be received; otherwise the number of
     * messages successfully received before the error will be returned. If
     * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
     * other error.
     * @param messages an array of #GInputMessage structs
     * @param flags an int containing #GSocketMsgFlags flags for the overall operation
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a %GCancellable
     * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if @timeout is     zero or positive, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
     */
    receive_messages(messages: InputMessage[], flags: number, timeout: number, cancellable: Cancellable | null): number
    /**
     * Send one or more data messages from `datagram_based` in one go.
     * 
     * `messages` must point to an array of #GOutputMessage structs and
     * `num_messages` must be the length of this array. Each #GOutputMessage
     * contains an address to send the data to, and a pointer to an array of
     * #GOutputVector structs to describe the buffers that the data to be sent
     * for each message will be gathered from.
     * 
     * `flags` modify how the message is sent. The commonly available arguments
     * for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too.
     * 
     * The other members of #GOutputMessage are treated as described in its
     * documentation.
     * 
     * If `timeout` is negative the call will block until `num_messages` have been
     * sent, `cancellable` is cancelled, or an error occurs.
     * 
     * If `timeout` is 0 the call will send up to `num_messages` without blocking,
     * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
     * 
     * If `timeout` is positive the call will block on the same conditions as if
     * `timeout` were negative. If the timeout is reached before any messages are
     * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
     * of messages sent before timing out.
     * 
     * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
     * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
     * g_datagram_based_send_messages() even if you were previously notified of a
     * %G_IO_OUT condition. (On Windows in particular, this is very common due to
     * the way the underlying APIs work.)
     * 
     * If the connection is shut down or closed (by calling g_socket_close() or
     * g_socket_shutdown() with `shutdown_write` set, if it’s a #GSocket, for
     * example), all calls to this function will return %G_IO_ERROR_CLOSED.
     * 
     * On error -1 is returned and `error` is set accordingly. An error will only
     * be returned if zero messages could be sent; otherwise the number of messages
     * successfully sent before the error will be returned. If `cancellable` is
     * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
     * @param messages an array of #GOutputMessage structs
     * @param flags an int containing #GSocketMsgFlags flags
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a %GCancellable
     * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if @timeout is zero     or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in     which case the caller may re-try to send the remaining messages.
     */
    send_messages(messages: OutputMessage[], flags: number, timeout: number, cancellable: Cancellable | null): number

    // Own virtual methods of Gio-2.0.Gio.DatagramBased

    /**
     * Checks on the readiness of `datagram_based` to perform operations. The
     * operations specified in `condition` are checked for and masked against the
     * currently-satisfied conditions on `datagram_based`. The result is returned.
     * 
     * %G_IO_IN will be set in the return value if data is available to read with
     * g_datagram_based_receive_messages(), or if the connection is closed remotely
     * (EOS); and if the datagram_based has not been closed locally using some
     * implementation-specific method (such as g_socket_close() or
     * g_socket_shutdown() with `shutdown_read` set, if it’s a #GSocket).
     * 
     * If the connection is shut down or closed (by calling g_socket_close() or
     * g_socket_shutdown() with `shutdown_read` set, if it’s a #GSocket, for
     * example), all calls to this function will return %G_IO_ERROR_CLOSED.
     * 
     * %G_IO_OUT will be set if it is expected that at least one byte can be sent
     * using g_datagram_based_send_messages() without blocking. It will not be set
     * if the datagram_based has been closed locally.
     * 
     * %G_IO_HUP will be set if the connection has been closed locally.
     * 
     * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
     * previously enqueued using g_datagram_based_send_messages().
     * 
     * Note that on Windows, it is possible for an operation to return
     * %G_IO_ERROR_WOULD_BLOCK even immediately after
     * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
     * ready for writing. Rather than calling g_datagram_based_condition_check() and
     * then writing to the #GDatagramBased if it succeeds, it is generally better to
     * simply try writing right away, and try again later if the initial attempt
     * returns %G_IO_ERROR_WOULD_BLOCK.
     * 
     * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
     * conditions will always be set in the output if they are true. Apart from
     * these flags, the output is guaranteed to be masked by `condition`.
     * 
     * This call never blocks.
     * @virtual 
     * @param condition a #GIOCondition mask to check
     * @returns the #GIOCondition mask of the current state
     */
    vfunc_condition_check(condition: GLib.IOCondition): GLib.IOCondition
    /**
     * Waits for up to `timeout` microseconds for condition to become true on
     * `datagram_based`. If the condition is met, %TRUE is returned.
     * 
     * If `cancellable` is cancelled before the condition is met, or if `timeout` is
     * reached before the condition is met, then %FALSE is returned and `error` is
     * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
     * @virtual 
     * @param condition a #GIOCondition mask to wait for
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a #GCancellable
     * @returns %TRUE if the condition was met, %FALSE otherwise
     */
    vfunc_condition_wait(condition: GLib.IOCondition, timeout: number, cancellable: Cancellable | null): boolean
    /**
     * Creates a #GSource that can be attached to a #GMainContext to monitor for
     * the availability of the specified `condition` on the #GDatagramBased. The
     * #GSource keeps a reference to the `datagram_based`.
     * 
     * The callback on the source is of the #GDatagramBasedSourceFunc type.
     * 
     * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in `condition;` these
     * conditions will always be reported in the callback if they are true.
     * 
     * If non-%NULL, `cancellable` can be used to cancel the source, which will
     * cause the source to trigger, reporting the current condition (which is
     * likely 0 unless cancellation happened at the same time as a condition
     * change). You can check for this in the callback using
     * g_cancellable_is_cancelled().
     * @virtual 
     * @param condition a #GIOCondition mask to monitor
     * @param cancellable a #GCancellable
     * @returns a newly allocated #GSource
     */
    vfunc_create_source(condition: GLib.IOCondition, cancellable: Cancellable | null): GLib.Source
    /**
     * Receive one or more data messages from `datagram_based` in one go.
     * 
     * `messages` must point to an array of #GInputMessage structs and
     * `num_messages` must be the length of this array. Each #GInputMessage
     * contains a pointer to an array of #GInputVector structs describing the
     * buffers that the data received in each message will be written to.
     * 
     * `flags` modify how all messages are received. The commonly available
     * arguments for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too. These
     * flags affect the overall receive operation. Flags affecting individual
     * messages are returned in #GInputMessage.flags.
     * 
     * The other members of #GInputMessage are treated as described in its
     * documentation.
     * 
     * If `timeout` is negative the call will block until `num_messages` have been
     * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
     * or an error occurs.
     * 
     * If `timeout` is 0 the call will return up to `num_messages` without blocking,
     * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
     * to be received.
     * 
     * If `timeout` is positive the call will block on the same conditions as if
     * `timeout` were negative. If the timeout is reached
     * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
     * otherwise it will return the number of messages received before timing out.
     * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
     * recvmmsg().)
     * 
     * To be notified when messages are available, wait for the %G_IO_IN condition.
     * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
     * g_datagram_based_receive_messages() even if you were previously notified of a
     * %G_IO_IN condition.
     * 
     * If the remote peer closes the connection, any messages queued in the
     * underlying receive buffer will be returned, and subsequent calls to
     * g_datagram_based_receive_messages() will return 0 (with no error set).
     * 
     * If the connection is shut down or closed (by calling g_socket_close() or
     * g_socket_shutdown() with `shutdown_read` set, if it’s a #GSocket, for
     * example), all calls to this function will return %G_IO_ERROR_CLOSED.
     * 
     * On error -1 is returned and `error` is set accordingly. An error will only
     * be returned if zero messages could be received; otherwise the number of
     * messages successfully received before the error will be returned. If
     * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
     * other error.
     * @virtual 
     * @param messages an array of #GInputMessage structs
     * @param flags an int containing #GSocketMsgFlags flags for the overall operation
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a %GCancellable
     * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if @timeout is     zero or positive, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
     */
    vfunc_receive_messages(messages: InputMessage[], flags: number, timeout: number, cancellable: Cancellable | null): number
    /**
     * Send one or more data messages from `datagram_based` in one go.
     * 
     * `messages` must point to an array of #GOutputMessage structs and
     * `num_messages` must be the length of this array. Each #GOutputMessage
     * contains an address to send the data to, and a pointer to an array of
     * #GOutputVector structs to describe the buffers that the data to be sent
     * for each message will be gathered from.
     * 
     * `flags` modify how the message is sent. The commonly available arguments
     * for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too.
     * 
     * The other members of #GOutputMessage are treated as described in its
     * documentation.
     * 
     * If `timeout` is negative the call will block until `num_messages` have been
     * sent, `cancellable` is cancelled, or an error occurs.
     * 
     * If `timeout` is 0 the call will send up to `num_messages` without blocking,
     * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
     * 
     * If `timeout` is positive the call will block on the same conditions as if
     * `timeout` were negative. If the timeout is reached before any messages are
     * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
     * of messages sent before timing out.
     * 
     * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
     * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
     * g_datagram_based_send_messages() even if you were previously notified of a
     * %G_IO_OUT condition. (On Windows in particular, this is very common due to
     * the way the underlying APIs work.)
     * 
     * If the connection is shut down or closed (by calling g_socket_close() or
     * g_socket_shutdown() with `shutdown_write` set, if it’s a #GSocket, for
     * example), all calls to this function will return %G_IO_ERROR_CLOSED.
     * 
     * On error -1 is returned and `error` is set accordingly. An error will only
     * be returned if zero messages could be sent; otherwise the number of messages
     * successfully sent before the error will be returned. If `cancellable` is
     * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
     * @virtual 
     * @param messages an array of #GOutputMessage structs
     * @param flags an int containing #GSocketMsgFlags flags
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a %GCancellable
     * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if @timeout is zero     or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in     which case the caller may re-try to send the remaining messages.
     */
    vfunc_send_messages(messages: OutputMessage[], flags: number, timeout: number, cancellable: Cancellable | null): number

    // Class property signals of Gio-2.0.Gio.DatagramBased

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GDatagramBased is a networking interface for representing datagram-based
 * communications. It is a more or less direct mapping of the core parts of the
 * BSD socket API in a portable GObject interface. It is implemented by
 * #GSocket, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
 * 
 * #GDatagramBased is entirely platform independent, and is intended to be used
 * alongside higher-level networking APIs such as #GIOStream.
 * 
 * It uses vectored scatter/gather I/O by default, allowing for many messages
 * to be sent or received in a single call. Where possible, implementations of
 * the interface should take advantage of vectored I/O to minimise processing
 * or system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
 * possible. Callers should take advantage of scatter/gather I/O (the use of
 * multiple buffers per message) to avoid unnecessary copying of data to
 * assemble or disassemble a message.
 * 
 * Each #GDatagramBased operation has a timeout parameter which may be negative
 * for blocking behaviour, zero for non-blocking behaviour, or positive for
 * timeout behaviour. A blocking operation blocks until finished or there is an
 * error. A non-blocking operation will return immediately with a
 * %G_IO_ERROR_WOULD_BLOCK error if it cannot make progress. A timeout operation
 * will block until the operation is complete or the timeout expires; if the
 * timeout expires it will return what progress it made, or
 * %G_IO_ERROR_TIMED_OUT if no progress was made. To know when a call would
 * successfully run you can call g_datagram_based_condition_check() or
 * g_datagram_based_condition_wait(). You can also use
 * g_datagram_based_create_source() and attach it to a #GMainContext to get
 * callbacks when I/O is possible.
 * 
 * When running a non-blocking operation applications should always be able to
 * handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other function
 * said that I/O was possible. This can easily happen in case of a race
 * condition in the application, but it can also happen for other reasons. For
 * instance, on Windows a socket is always seen as writable until a write
 * returns %G_IO_ERROR_WOULD_BLOCK.
 * 
 * As with #GSocket, #GDatagramBaseds can be either connection oriented (for
 * example, SCTP) or connectionless (for example, UDP). #GDatagramBaseds must be
 * datagram-based, not stream-based. The interface does not cover connection
 * establishment — use methods on the underlying type to establish a connection
 * before sending and receiving data through the #GDatagramBased API. For
 * connectionless socket types the target/source address is specified or
 * received in each I/O operation.
 * 
 * Like most other APIs in GLib, #GDatagramBased is not inherently thread safe.
 * To use a #GDatagramBased concurrently from multiple threads, you must
 * implement your own locking.
 * @interface 
 */
class DatagramBased extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DatagramBased

    static name: string
    static $gtype: GObject.GType<DatagramBased>

    // Constructors of Gio-2.0.Gio.DatagramBased

    constructor(config?: DatagramBased.ConstructorProperties) 
    _init(config?: DatagramBased.ConstructorProperties): void
}

module DebugController {

    // Constructor properties interface

    interface ConstructorProperties extends Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DebugController

        /**
         * %TRUE if debug output should be exposed (for example by forwarding it to
         * the journal), %FALSE otherwise.
         */
        debug_enabled?: boolean | null
    }

}

interface DebugController extends Initable {

    // Own properties of Gio-2.0.Gio.DebugController

    /**
     * %TRUE if debug output should be exposed (for example by forwarding it to
     * the journal), %FALSE otherwise.
     */
    debug_enabled: boolean

    // Owm methods of Gio-2.0.Gio.DebugController

    /**
     * Get the value of #GDebugController:debug-enabled.
     * @returns %TRUE if debug output should be exposed, %FALSE otherwise
     */
    get_debug_enabled(): boolean
    /**
     * Set the value of #GDebugController:debug-enabled.
     * @param debug_enabled %TRUE if debug output should be exposed, %FALSE otherwise
     */
    set_debug_enabled(debug_enabled: boolean): void

    // Class property signals of Gio-2.0.Gio.DebugController

    connect(sigName: "notify::debug-enabled", callback: (($obj: DebugController, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::debug-enabled", callback: (($obj: DebugController, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::debug-enabled", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDebugController is an interface to expose control of debugging features and
 * debug output.
 * 
 * It is implemented on Linux using #GDebugControllerDBus, which exposes a D-Bus
 * interface to allow authenticated peers to control debug features in this
 * process.
 * 
 * Whether debug output is enabled is exposed as
 * #GDebugController:debug-enabled. This controls g_log_set_debug_enabled() by
 * default. Application code may connect to the #GObject::notify signal for it
 * to control other parts of its debug infrastructure as necessary.
 * 
 * If your application or service is using the default GLib log writer function,
 * creating one of the built-in implementations of #GDebugController should be
 * all that’s needed to dynamically enable or disable debug output.
 * @interface 
 */
class DebugController extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DebugController

    static name: string
    static $gtype: GObject.GType<DebugController>

    // Constructors of Gio-2.0.Gio.DebugController

    constructor(config?: DebugController.ConstructorProperties) 
    _init(config?: DebugController.ConstructorProperties): void
}

module DesktopAppInfoLookup {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface DesktopAppInfoLookup {

    // Owm methods of Gio-2.0.Gio.DesktopAppInfoLookup

    /**
     * Gets the default application for launching applications
     * using this URI scheme for a particular #GDesktopAppInfoLookup
     * implementation.
     * 
     * The #GDesktopAppInfoLookup interface and this function is used
     * to implement g_app_info_get_default_for_uri_scheme() backends
     * in a GIO module. There is no reason for applications to use it
     * directly. Applications should use g_app_info_get_default_for_uri_scheme().
     * @param uri_scheme a string containing a URI scheme.
     * @returns #GAppInfo for given @uri_scheme or    %NULL on error.
     */
    get_default_for_uri_scheme(uri_scheme: string | null): AppInfo | null

    // Own virtual methods of Gio-2.0.Gio.DesktopAppInfoLookup

    /**
     * Gets the default application for launching applications
     * using this URI scheme for a particular #GDesktopAppInfoLookup
     * implementation.
     * 
     * The #GDesktopAppInfoLookup interface and this function is used
     * to implement g_app_info_get_default_for_uri_scheme() backends
     * in a GIO module. There is no reason for applications to use it
     * directly. Applications should use g_app_info_get_default_for_uri_scheme().
     * @virtual 
     * @param uri_scheme a string containing a URI scheme.
     * @returns #GAppInfo for given @uri_scheme or    %NULL on error.
     */
    vfunc_get_default_for_uri_scheme(uri_scheme: string | null): AppInfo | null

    // Class property signals of Gio-2.0.Gio.DesktopAppInfoLookup

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDesktopAppInfoLookup is an opaque data structure and can only be accessed
 * using the following functions.
 * @interface 
 */
class DesktopAppInfoLookup extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DesktopAppInfoLookup

    static name: string
    static $gtype: GObject.GType<DesktopAppInfoLookup>

    // Constructors of Gio-2.0.Gio.DesktopAppInfoLookup

    constructor(config?: DesktopAppInfoLookup.ConstructorProperties) 
    _init(config?: DesktopAppInfoLookup.ConstructorProperties): void
}

module Drive {

    // Signal callback interfaces

    /**
     * Signal callback interface for `changed`
     */
    interface ChangedSignalCallback {
        ($obj: Drive): void
    }

    /**
     * Signal callback interface for `disconnected`
     */
    interface DisconnectedSignalCallback {
        ($obj: Drive): void
    }

    /**
     * Signal callback interface for `eject-button`
     */
    interface EjectButtonSignalCallback {
        ($obj: Drive): void
    }

    /**
     * Signal callback interface for `stop-button`
     */
    interface StopButtonSignalCallback {
        ($obj: Drive): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Drive {

    // Owm methods of Gio-2.0.Gio.Drive

    /**
     * Checks if a drive can be ejected.
     * @returns %TRUE if the @drive can be ejected, %FALSE otherwise.
     */
    can_eject(): boolean
    /**
     * Checks if a drive can be polled for media changes.
     * @returns %TRUE if the @drive can be polled for media changes,     %FALSE otherwise.
     */
    can_poll_for_media(): boolean
    /**
     * Checks if a drive can be started.
     * @returns %TRUE if the @drive can be started, %FALSE otherwise.
     */
    can_start(): boolean
    /**
     * Checks if a drive can be started degraded.
     * @returns %TRUE if the @drive can be started degraded, %FALSE otherwise.
     */
    can_start_degraded(): boolean
    /**
     * Checks if a drive can be stopped.
     * @returns %TRUE if the @drive can be stopped, %FALSE otherwise.
     */
    can_stop(): boolean
    /**
     * Asynchronously ejects a drive.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_drive_eject_finish() to obtain the
     * result of the operation.
     * @param flags flags affecting the unmount if required for eject
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    eject(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a drive.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive has been ejected successfully,     %FALSE otherwise.
     */
    eject_finish(result: AsyncResult): boolean
    /**
     * Ejects a drive. This is an asynchronous operation, and is
     * finished by calling g_drive_eject_with_operation_finish() with the `drive`
     * and #GAsyncResult data returned in the `callback`.
     * @param flags flags affecting the unmount if required for eject
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    eject_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a drive. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive was successfully ejected. %FALSE otherwise.
     */
    eject_with_operation_finish(result: AsyncResult): boolean
    /**
     * Gets the kinds of identifiers that `drive` has.
     * Use g_drive_get_identifier() to obtain the identifiers
     * themselves.
     * @returns a %NULL-terminated     array of strings containing kinds of identifiers. Use g_strfreev()     to free.
     */
    enumerate_identifiers(): string[]
    /**
     * Gets the icon for `drive`.
     * @returns #GIcon for the @drive.    Free the returned object with g_object_unref().
     */
    get_icon(): Icon
    /**
     * Gets the identifier of the given kind for `drive`. The only
     * identifier currently available is
     * %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
     * @param kind the kind of identifier to return
     * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GDrive     doesn't have this kind of identifier.
     */
    get_identifier(kind: string | null): string | null
    /**
     * Gets the name of `drive`.
     * @returns a string containing @drive's name. The returned     string should be freed when no longer needed.
     */
    get_name(): string | null
    /**
     * Gets the sort key for `drive,` if any.
     * @returns Sorting key for @drive or %NULL if no such key is available.
     */
    get_sort_key(): string | null
    /**
     * Gets a hint about how a drive can be started/stopped.
     * @returns A value from the #GDriveStartStopType enumeration.
     */
    get_start_stop_type(): DriveStartStopType
    /**
     * Gets the icon for `drive`.
     * @returns symbolic #GIcon for the @drive.    Free the returned object with g_object_unref().
     */
    get_symbolic_icon(): Icon
    /**
     * Get a list of mountable volumes for `drive`.
     * 
     * The returned list should be freed with g_list_free(), after
     * its elements have been unreffed with g_object_unref().
     * @returns #GList containing any #GVolume objects on the given @drive.
     */
    get_volumes(): Volume[]
    /**
     * Checks if the `drive` has media. Note that the OS may not be polling
     * the drive for media changes; see g_drive_is_media_check_automatic()
     * for more details.
     * @returns %TRUE if @drive has media, %FALSE otherwise.
     */
    has_media(): boolean
    /**
     * Check if `drive` has any mountable volumes.
     * @returns %TRUE if the @drive contains volumes, %FALSE otherwise.
     */
    has_volumes(): boolean
    /**
     * Checks if `drive` is capable of automatically detecting media changes.
     * @returns %TRUE if the @drive is capable of automatically detecting     media changes, %FALSE otherwise.
     */
    is_media_check_automatic(): boolean
    /**
     * Checks if the `drive` supports removable media.
     * @returns %TRUE if @drive supports removable media, %FALSE otherwise.
     */
    is_media_removable(): boolean
    /**
     * Checks if the #GDrive and/or its media is considered removable by the user.
     * See g_drive_is_media_removable().
     * @returns %TRUE if @drive and/or its media is considered removable, %FALSE otherwise.
     */
    is_removable(): boolean
    /**
     * Asynchronously polls `drive` to see if media has been inserted or removed.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_drive_poll_for_media_finish() to obtain the
     * result of the operation.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    poll_for_media(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an operation started with g_drive_poll_for_media() on a drive.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive has been poll_for_mediaed successfully,     %FALSE otherwise.
     */
    poll_for_media_finish(result: AsyncResult): boolean
    /**
     * Asynchronously starts a drive.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_drive_start_finish() to obtain the
     * result of the operation.
     * @param flags flags affecting the start operation.
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    start(flags: DriveStartFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes starting a drive.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive has been started successfully,     %FALSE otherwise.
     */
    start_finish(result: AsyncResult): boolean
    /**
     * Asynchronously stops a drive.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_drive_stop_finish() to obtain the
     * result of the operation.
     * @param flags flags affecting the unmount if required for stopping.
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    stop(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes stopping a drive.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive has been stopped successfully,     %FALSE otherwise.
     */
    stop_finish(result: AsyncResult): boolean

    // Own virtual methods of Gio-2.0.Gio.Drive

    /**
     * Checks if a drive can be ejected.
     * @virtual 
     * @returns %TRUE if the @drive can be ejected, %FALSE otherwise.
     */
    vfunc_can_eject(): boolean
    /**
     * Checks if a drive can be polled for media changes.
     * @virtual 
     * @returns %TRUE if the @drive can be polled for media changes,     %FALSE otherwise.
     */
    vfunc_can_poll_for_media(): boolean
    /**
     * Checks if a drive can be started.
     * @virtual 
     * @returns %TRUE if the @drive can be started, %FALSE otherwise.
     */
    vfunc_can_start(): boolean
    /**
     * Checks if a drive can be started degraded.
     * @virtual 
     * @returns %TRUE if the @drive can be started degraded, %FALSE otherwise.
     */
    vfunc_can_start_degraded(): boolean
    /**
     * Checks if a drive can be stopped.
     * @virtual 
     * @returns %TRUE if the @drive can be stopped, %FALSE otherwise.
     */
    vfunc_can_stop(): boolean
    vfunc_changed(): void
    vfunc_disconnected(): void
    /**
     * Asynchronously ejects a drive.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_drive_eject_finish() to obtain the
     * result of the operation.
     * @virtual 
     * @param flags flags affecting the unmount if required for eject
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_eject(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    vfunc_eject_button(): void
    /**
     * Finishes ejecting a drive.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive has been ejected successfully,     %FALSE otherwise.
     */
    vfunc_eject_finish(result: AsyncResult): boolean
    /**
     * Ejects a drive. This is an asynchronous operation, and is
     * finished by calling g_drive_eject_with_operation_finish() with the `drive`
     * and #GAsyncResult data returned in the `callback`.
     * @virtual 
     * @param flags flags affecting the unmount if required for eject
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_eject_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a drive. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive was successfully ejected. %FALSE otherwise.
     */
    vfunc_eject_with_operation_finish(result: AsyncResult): boolean
    /**
     * Gets the kinds of identifiers that `drive` has.
     * Use g_drive_get_identifier() to obtain the identifiers
     * themselves.
     * @virtual 
     * @returns a %NULL-terminated     array of strings containing kinds of identifiers. Use g_strfreev()     to free.
     */
    vfunc_enumerate_identifiers(): string[]
    /**
     * Gets the icon for `drive`.
     * @virtual 
     * @returns #GIcon for the @drive.    Free the returned object with g_object_unref().
     */
    vfunc_get_icon(): Icon
    /**
     * Gets the identifier of the given kind for `drive`. The only
     * identifier currently available is
     * %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
     * @virtual 
     * @param kind the kind of identifier to return
     * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GDrive     doesn't have this kind of identifier.
     */
    vfunc_get_identifier(kind: string | null): string | null
    /**
     * Gets the name of `drive`.
     * @virtual 
     * @returns a string containing @drive's name. The returned     string should be freed when no longer needed.
     */
    vfunc_get_name(): string | null
    /**
     * Gets the sort key for `drive,` if any.
     * @virtual 
     * @returns Sorting key for @drive or %NULL if no such key is available.
     */
    vfunc_get_sort_key(): string | null
    /**
     * Gets a hint about how a drive can be started/stopped.
     * @virtual 
     * @returns A value from the #GDriveStartStopType enumeration.
     */
    vfunc_get_start_stop_type(): DriveStartStopType
    /**
     * Gets the icon for `drive`.
     * @virtual 
     * @returns symbolic #GIcon for the @drive.    Free the returned object with g_object_unref().
     */
    vfunc_get_symbolic_icon(): Icon
    /**
     * Get a list of mountable volumes for `drive`.
     * 
     * The returned list should be freed with g_list_free(), after
     * its elements have been unreffed with g_object_unref().
     * @virtual 
     * @returns #GList containing any #GVolume objects on the given @drive.
     */
    vfunc_get_volumes(): Volume[]
    /**
     * Checks if the `drive` has media. Note that the OS may not be polling
     * the drive for media changes; see g_drive_is_media_check_automatic()
     * for more details.
     * @virtual 
     * @returns %TRUE if @drive has media, %FALSE otherwise.
     */
    vfunc_has_media(): boolean
    /**
     * Check if `drive` has any mountable volumes.
     * @virtual 
     * @returns %TRUE if the @drive contains volumes, %FALSE otherwise.
     */
    vfunc_has_volumes(): boolean
    /**
     * Checks if `drive` is capable of automatically detecting media changes.
     * @virtual 
     * @returns %TRUE if the @drive is capable of automatically detecting     media changes, %FALSE otherwise.
     */
    vfunc_is_media_check_automatic(): boolean
    /**
     * Checks if the `drive` supports removable media.
     * @virtual 
     * @returns %TRUE if @drive supports removable media, %FALSE otherwise.
     */
    vfunc_is_media_removable(): boolean
    /**
     * Checks if the #GDrive and/or its media is considered removable by the user.
     * See g_drive_is_media_removable().
     * @virtual 
     * @returns %TRUE if @drive and/or its media is considered removable, %FALSE otherwise.
     */
    vfunc_is_removable(): boolean
    /**
     * Asynchronously polls `drive` to see if media has been inserted or removed.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_drive_poll_for_media_finish() to obtain the
     * result of the operation.
     * @virtual 
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_poll_for_media(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an operation started with g_drive_poll_for_media() on a drive.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive has been poll_for_mediaed successfully,     %FALSE otherwise.
     */
    vfunc_poll_for_media_finish(result: AsyncResult): boolean
    /**
     * Asynchronously starts a drive.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_drive_start_finish() to obtain the
     * result of the operation.
     * @virtual 
     * @param flags flags affecting the start operation.
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_start(flags: DriveStartFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes starting a drive.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive has been started successfully,     %FALSE otherwise.
     */
    vfunc_start_finish(result: AsyncResult): boolean
    /**
     * Asynchronously stops a drive.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_drive_stop_finish() to obtain the
     * result of the operation.
     * @virtual 
     * @param flags flags affecting the unmount if required for stopping.
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_stop(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    vfunc_stop_button(): void
    /**
     * Finishes stopping a drive.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the drive has been stopped successfully,     %FALSE otherwise.
     */
    vfunc_stop_finish(result: AsyncResult): boolean

    // Own signals of Gio-2.0.Gio.Drive

    connect(sigName: "changed", callback: Drive.ChangedSignalCallback): number
    connect_after(sigName: "changed", callback: Drive.ChangedSignalCallback): number
    emit(sigName: "changed", ...args: any[]): void
    connect(sigName: "disconnected", callback: Drive.DisconnectedSignalCallback): number
    connect_after(sigName: "disconnected", callback: Drive.DisconnectedSignalCallback): number
    emit(sigName: "disconnected", ...args: any[]): void
    connect(sigName: "eject-button", callback: Drive.EjectButtonSignalCallback): number
    connect_after(sigName: "eject-button", callback: Drive.EjectButtonSignalCallback): number
    emit(sigName: "eject-button", ...args: any[]): void
    connect(sigName: "stop-button", callback: Drive.StopButtonSignalCallback): number
    connect_after(sigName: "stop-button", callback: Drive.StopButtonSignalCallback): number
    emit(sigName: "stop-button", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.Drive

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDrive - this represent a piece of hardware connected to the machine.
 * It's generally only created for removable hardware or hardware with
 * removable media.
 * 
 * #GDrive is a container class for #GVolume objects that stem from
 * the same piece of media. As such, #GDrive abstracts a drive with
 * (or without) removable media and provides operations for querying
 * whether media is available, determining whether media change is
 * automatically detected and ejecting the media.
 * 
 * If the #GDrive reports that media isn't automatically detected, one
 * can poll for media; typically one should not do this periodically
 * as a poll for media operation is potentially expensive and may
 * spin up the drive creating noise.
 * 
 * #GDrive supports starting and stopping drives with authentication
 * support for the former. This can be used to support a diverse set
 * of use cases including connecting/disconnecting iSCSI devices,
 * powering down external disk enclosures and starting/stopping
 * multi-disk devices such as RAID devices. Note that the actual
 * semantics and side-effects of starting/stopping a #GDrive may vary
 * according to implementation. To choose the correct verbs in e.g. a
 * file manager, use g_drive_get_start_stop_type().
 * 
 * For porting from GnomeVFS note that there is no equivalent of
 * #GDrive in that API.
 * @interface 
 */
class Drive extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Drive

    static name: string
    static $gtype: GObject.GType<Drive>

    // Constructors of Gio-2.0.Gio.Drive

    constructor(config?: Drive.ConstructorProperties) 
    _init(config?: Drive.ConstructorProperties): void
}

module DtlsClientConnection {

    // Constructor properties interface

    interface ConstructorProperties extends DatagramBased.ConstructorProperties, DtlsConnection.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DtlsClientConnection

        /**
         * A #GSocketConnectable describing the identity of the server that
         * is expected on the other end of the connection.
         * 
         * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
         * #GDtlsClientConnection:validation-flags, this object will be used
         * to determine the expected identify of the remote end of the
         * connection; if #GDtlsClientConnection:server-identity is not set,
         * or does not match the identity presented by the server, then the
         * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
         * 
         * In addition to its use in verifying the server certificate,
         * this is also used to give a hint to the server about what
         * certificate we expect, which is useful for servers that serve
         * virtual hosts.
         */
        server_identity?: SocketConnectable | null
        /**
         * What steps to perform when validating a certificate received from
         * a server. Server certificates that fail to validate in any of the
         * ways indicated here will be rejected unless the application
         * overrides the default via #GDtlsConnection::accept-certificate.
         * 
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to #GDtlsConnection::accept-certificate.
         */
        validation_flags?: TlsCertificateFlags | null
    }

}

interface DtlsClientConnection extends DatagramBased, DtlsConnection {

    // Own properties of Gio-2.0.Gio.DtlsClientConnection

    /**
     * A list of the distinguished names of the Certificate Authorities
     * that the server will accept client certificates signed by. If the
     * server requests a client certificate during the handshake, then
     * this property will be set after the handshake completes.
     * 
     * Each item in the list is a #GByteArray which contains the complete
     * subject DN of the certificate authority.
     */
    readonly accepted_cas: any[]
    /**
     * A #GSocketConnectable describing the identity of the server that
     * is expected on the other end of the connection.
     * 
     * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
     * #GDtlsClientConnection:validation-flags, this object will be used
     * to determine the expected identify of the remote end of the
     * connection; if #GDtlsClientConnection:server-identity is not set,
     * or does not match the identity presented by the server, then the
     * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
     * 
     * In addition to its use in verifying the server certificate,
     * this is also used to give a hint to the server about what
     * certificate we expect, which is useful for servers that serve
     * virtual hosts.
     */
    server_identity: SocketConnectable
    /**
     * What steps to perform when validating a certificate received from
     * a server. Server certificates that fail to validate in any of the
     * ways indicated here will be rejected unless the application
     * overrides the default via #GDtlsConnection::accept-certificate.
     * 
     * GLib guarantees that if certificate verification fails, at least one
     * flag will be set, but it does not guarantee that all possible flags
     * will be set. Accordingly, you may not safely decide to ignore any
     * particular type of error. For example, it would be incorrect to mask
     * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
     * because this could potentially be the only error flag set even if
     * other problems exist with the certificate. Therefore, there is no
     * safe way to use this property. This is not a horrible problem,
     * though, because you should not be attempting to ignore validation
     * errors anyway. If you really must ignore TLS certificate errors,
     * connect to #GDtlsConnection::accept-certificate.
     */
    validation_flags: TlsCertificateFlags

    // Owm methods of Gio-2.0.Gio.DtlsClientConnection

    /**
     * Gets the list of distinguished names of the Certificate Authorities
     * that the server will accept certificates from. This will be set
     * during the TLS handshake if the server requests a certificate.
     * Otherwise, it will be %NULL.
     * 
     * Each item in the list is a #GByteArray which contains the complete
     * subject DN of the certificate authority.
     * @returns the list of CA DNs. You should unref each element with g_byte_array_unref() and then the free the list with g_list_free().
     */
    get_accepted_cas(): GLib.List[]
    /**
     * Gets `conn'`s expected server identity
     * @returns a #GSocketConnectable describing the expected server identity, or %NULL if the expected identity is not known.
     */
    get_server_identity(): SocketConnectable
    /**
     * Gets `conn'`s validation flags
     * 
     * This function does not work as originally designed and is impossible
     * to use correctly. See #GDtlsClientConnection:validation-flags for more
     * information.
     * @returns the validation flags
     */
    get_validation_flags(): TlsCertificateFlags
    /**
     * Sets `conn'`s expected server identity, which is used both to tell
     * servers on virtual hosts which certificate to present, and also
     * to let `conn` know what name to look for in the certificate when
     * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
     * @param identity a #GSocketConnectable describing the expected server identity
     */
    set_server_identity(identity: SocketConnectable): void
    /**
     * Sets `conn'`s validation flags, to override the default set of
     * checks performed when validating a server certificate. By default,
     * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
     * 
     * This function does not work as originally designed and is impossible
     * to use correctly. See #GDtlsClientConnection:validation-flags for more
     * information.
     * @param flags the #GTlsCertificateFlags to use
     */
    set_validation_flags(flags: TlsCertificateFlags): void

    // Class property signals of Gio-2.0.Gio.DtlsClientConnection

    connect(sigName: "notify::accepted-cas", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::accepted-cas", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::accepted-cas", ...args: any[]): void
    connect(sigName: "notify::server-identity", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::server-identity", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::server-identity", ...args: any[]): void
    connect(sigName: "notify::validation-flags", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::validation-flags", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::validation-flags", ...args: any[]): void
    connect(sigName: "notify::advertised-protocols", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::advertised-protocols", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::advertised-protocols", ...args: any[]): void
    connect(sigName: "notify::base-socket", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::base-socket", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::base-socket", ...args: any[]): void
    connect(sigName: "notify::certificate", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::certificate", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::certificate", ...args: any[]): void
    connect(sigName: "notify::ciphersuite-name", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ciphersuite-name", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ciphersuite-name", ...args: any[]): void
    connect(sigName: "notify::database", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::database", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::database", ...args: any[]): void
    connect(sigName: "notify::interaction", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::negotiated-protocol", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::negotiated-protocol", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::negotiated-protocol", ...args: any[]): void
    connect(sigName: "notify::peer-certificate", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate", ...args: any[]): void
    connect(sigName: "notify::peer-certificate-errors", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate-errors", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate-errors", ...args: any[]): void
    connect(sigName: "notify::protocol-version", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-version", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol-version", ...args: any[]): void
    connect(sigName: "notify::rehandshake-mode", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rehandshake-mode", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::rehandshake-mode", ...args: any[]): void
    connect(sigName: "notify::require-close-notify", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::require-close-notify", callback: (($obj: DtlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::require-close-notify", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDtlsClientConnection is the client-side subclass of
 * #GDtlsConnection, representing a client-side DTLS connection.
 * @interface 
 */
class DtlsClientConnection extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DtlsClientConnection

    static name: string
    static $gtype: GObject.GType<DtlsClientConnection>

    // Constructors of Gio-2.0.Gio.DtlsClientConnection

    constructor(config?: DtlsClientConnection.ConstructorProperties) 
    _init(config?: DtlsClientConnection.ConstructorProperties): void
    /**
     * Creates a new #GDtlsClientConnection wrapping `base_socket` which is
     * assumed to communicate with the server identified by `server_identity`.
     * @param base_socket the #GDatagramBased to wrap
     * @param server_identity the expected identity of the server
     * @returns the new   #GDtlsClientConnection, or %NULL on error
     */
    static new(base_socket: DatagramBased, server_identity: SocketConnectable | null): DtlsClientConnection
}

module DtlsConnection {

    // Signal callback interfaces

    /**
     * Signal callback interface for `accept-certificate`
     */
    interface AcceptCertificateSignalCallback {
        ($obj: DtlsConnection, peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends DatagramBased.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DtlsConnection

        /**
         * The list of application-layer protocols that the connection
         * advertises that it is willing to speak. See
         * g_dtls_connection_set_advertised_protocols().
         */
        advertised_protocols?: string[] | null
        /**
         * The #GDatagramBased that the connection wraps. Note that this may be any
         * implementation of #GDatagramBased, not just a #GSocket.
         */
        base_socket?: DatagramBased | null
        /**
         * The connection's certificate; see
         * g_dtls_connection_set_certificate().
         */
        certificate?: TlsCertificate | null
        /**
         * The certificate database to use when verifying this TLS connection.
         * If no certificate database is set, then the default database will be
         * used. See g_tls_backend_get_default_database().
         * 
         * When using a non-default database, #GDtlsConnection must fall back to using
         * the #GTlsDatabase to perform certificate verification using
         * g_tls_database_verify_chain(), which means certificate verification will
         * not be able to make use of TLS session context. This may be less secure.
         * For example, if you create your own #GTlsDatabase that just wraps the
         * default #GTlsDatabase, you might expect that you have not changed anything,
         * but this is not true because you may have altered the behavior of
         * #GDtlsConnection by causing it to use g_tls_database_verify_chain(). See the
         * documentation of g_tls_database_verify_chain() for more details on specific
         * security checks that may not be performed. Accordingly, setting a
         * non-default database is discouraged except for specialty applications with
         * unusual security requirements.
         */
        database?: TlsDatabase | null
        /**
         * A #GTlsInteraction object to be used when the connection or certificate
         * database need to interact with the user. This will be used to prompt the
         * user for passwords where necessary.
         */
        interaction?: TlsInteraction | null
        /**
         * The rehandshaking mode. See
         * g_dtls_connection_set_rehandshake_mode().
         */
        rehandshake_mode?: TlsRehandshakeMode | null
        /**
         * Whether or not proper TLS close notification is required.
         * See g_dtls_connection_set_require_close_notify().
         */
        require_close_notify?: boolean | null
    }

}

interface DtlsConnection extends DatagramBased {

    // Own properties of Gio-2.0.Gio.DtlsConnection

    /**
     * The list of application-layer protocols that the connection
     * advertises that it is willing to speak. See
     * g_dtls_connection_set_advertised_protocols().
     */
    advertised_protocols: string[]
    /**
     * The #GDatagramBased that the connection wraps. Note that this may be any
     * implementation of #GDatagramBased, not just a #GSocket.
     */
    readonly base_socket: DatagramBased
    /**
     * The connection's certificate; see
     * g_dtls_connection_set_certificate().
     */
    certificate: TlsCertificate
    /**
     * The name of the DTLS ciphersuite in use. See g_dtls_connection_get_ciphersuite_name().
     */
    readonly ciphersuite_name: string | null
    /**
     * The certificate database to use when verifying this TLS connection.
     * If no certificate database is set, then the default database will be
     * used. See g_tls_backend_get_default_database().
     * 
     * When using a non-default database, #GDtlsConnection must fall back to using
     * the #GTlsDatabase to perform certificate verification using
     * g_tls_database_verify_chain(), which means certificate verification will
     * not be able to make use of TLS session context. This may be less secure.
     * For example, if you create your own #GTlsDatabase that just wraps the
     * default #GTlsDatabase, you might expect that you have not changed anything,
     * but this is not true because you may have altered the behavior of
     * #GDtlsConnection by causing it to use g_tls_database_verify_chain(). See the
     * documentation of g_tls_database_verify_chain() for more details on specific
     * security checks that may not be performed. Accordingly, setting a
     * non-default database is discouraged except for specialty applications with
     * unusual security requirements.
     */
    database: TlsDatabase
    /**
     * A #GTlsInteraction object to be used when the connection or certificate
     * database need to interact with the user. This will be used to prompt the
     * user for passwords where necessary.
     */
    interaction: TlsInteraction
    /**
     * The application-layer protocol negotiated during the TLS
     * handshake. See g_dtls_connection_get_negotiated_protocol().
     */
    readonly negotiated_protocol: string | null
    /**
     * The connection's peer's certificate, after the TLS handshake has
     * completed or failed. Note in particular that this is not yet set
     * during the emission of #GDtlsConnection::accept-certificate.
     * 
     * (You can watch for a #GObject::notify signal on this property to
     * detect when a handshake has occurred.)
     */
    readonly peer_certificate: TlsCertificate
    /**
     * The errors noticed while verifying
     * #GDtlsConnection:peer-certificate. Normally this should be 0, but
     * it may not be if #GDtlsClientConnection:validation-flags is not
     * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
     * #GDtlsConnection::accept-certificate overrode the default
     * behavior.
     * 
     * GLib guarantees that if certificate verification fails, at least
     * one error will be set, but it does not guarantee that all possible
     * errors will be set. Accordingly, you may not safely decide to
     * ignore any particular type of error. For example, it would be
     * incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
     * expired certificates, because this could potentially be the only
     * error flag set even if other problems exist with the certificate.
     */
    readonly peer_certificate_errors: TlsCertificateFlags
    /**
     * The DTLS protocol version in use. See g_dtls_connection_get_protocol_version().
     */
    readonly protocol_version: TlsProtocolVersion
    /**
     * The rehandshaking mode. See
     * g_dtls_connection_set_rehandshake_mode().
     */
    rehandshake_mode: TlsRehandshakeMode
    /**
     * Whether or not proper TLS close notification is required.
     * See g_dtls_connection_set_require_close_notify().
     */
    require_close_notify: boolean

    // Owm methods of Gio-2.0.Gio.DtlsConnection

    /**
     * Close the DTLS connection. This is equivalent to calling
     * g_dtls_connection_shutdown() to shut down both sides of the connection.
     * 
     * Closing a #GDtlsConnection waits for all buffered but untransmitted data to
     * be sent before it completes. It then sends a `close_notify` DTLS alert to the
     * peer and may wait for a `close_notify` to be received from the peer. It does
     * not close the underlying #GDtlsConnection:base-socket; that must be closed
     * separately.
     * 
     * Once `conn` is closed, all other operations will return %G_IO_ERROR_CLOSED.
     * Closing a #GDtlsConnection multiple times will not return an error.
     * 
     * #GDtlsConnections will be automatically closed when the last reference is
     * dropped, but you might want to call this function to make sure resources are
     * released as early as possible.
     * 
     * If `cancellable` is cancelled, the #GDtlsConnection may be left
     * partially-closed and any pending untransmitted data may be lost. Call
     * g_dtls_connection_close() again to complete closing the #GDtlsConnection.
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE on success, %FALSE otherwise
     */
    close(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously close the DTLS connection. See g_dtls_connection_close() for
     * more information.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the close operation is complete
     */
    close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of close_async

    /**
     * Promisified version of {@link close_async}
     * 
     * Asynchronously close the DTLS connection. See g_dtls_connection_close() for
     * more information.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE on success, %FALSE on failure, in which case @error will be set
     */
    close_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finish an asynchronous TLS close operation. See g_dtls_connection_close()
     * for more information.
     * @param result a #GAsyncResult
     * @returns %TRUE on success, %FALSE on failure, in which case @error will be set
     */
    close_finish(result: AsyncResult): boolean
    /**
     * Used by #GDtlsConnection implementations to emit the
     * #GDtlsConnection::accept-certificate signal.
     * @param peer_cert the peer's #GTlsCertificate
     * @param errors the problems with `peer_cert`
     * @returns %TRUE if one of the signal handlers has returned     %TRUE to accept @peer_cert
     */
    emit_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean
    /**
     * Gets `conn'`s certificate, as set by
     * g_dtls_connection_set_certificate().
     * @returns @conn's certificate, or %NULL
     */
    get_certificate(): TlsCertificate | null
    /**
     * Query the TLS backend for TLS channel binding data of `type` for `conn`.
     * 
     * This call retrieves TLS channel binding data as specified in RFC
     * [5056](https://tools.ietf.org/html/rfc5056), RFC
     * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
     * binding data is returned in `data`.  The `data` is resized by the callee
     * using #GByteArray buffer management and will be freed when the `data`
     * is destroyed by g_byte_array_unref(). If `data` is %NULL, it will only
     * check whether TLS backend is able to fetch the data (e.g. whether `type`
     * is supported by the TLS backend). It does not guarantee that the data
     * will be available though.  That could happen if TLS connection does not
     * support `type` or the binding data is not available yet due to additional
     * negotiation or input required.
     * @param type #GTlsChannelBindingType type of data to fetch
     * @returns %TRUE on success, %FALSE otherwise
     */
    get_channel_binding_data(type: TlsChannelBindingType): [ /* returnType */ boolean, /* data */ Uint8Array ]
    /**
     * Returns the name of the current DTLS ciphersuite, or %NULL if the
     * connection has not handshaked or has been closed. Beware that the TLS
     * backend may use any of multiple different naming conventions, because
     * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
     * are different from each other and different from the standard, IANA-
     * registered ciphersuite names. The ciphersuite name is intended to be
     * displayed to the user for informative purposes only, and parsing it
     * is not recommended.
     * @returns The name of the current DTLS ciphersuite, or %NULL
     */
    get_ciphersuite_name(): string | null
    /**
     * Gets the certificate database that `conn` uses to verify
     * peer certificates. See g_dtls_connection_set_database().
     * @returns the certificate database that @conn uses or %NULL
     */
    get_database(): TlsDatabase | null
    /**
     * Get the object that will be used to interact with the user. It will be used
     * for things like prompting the user for passwords. If %NULL is returned, then
     * no user interaction will occur for this connection.
     * @returns The interaction object.
     */
    get_interaction(): TlsInteraction | null
    /**
     * Gets the name of the application-layer protocol negotiated during
     * the handshake.
     * 
     * If the peer did not use the ALPN extension, or did not advertise a
     * protocol that matched one of `conn'`s protocols, or the TLS backend
     * does not support ALPN, then this will be %NULL. See
     * g_dtls_connection_set_advertised_protocols().
     * @returns the negotiated protocol, or %NULL
     */
    get_negotiated_protocol(): string | null
    /**
     * Gets `conn'`s peer's certificate after the handshake has completed
     * or failed. (It is not set during the emission of
     * #GDtlsConnection::accept-certificate.)
     * @returns @conn's peer's certificate, or %NULL
     */
    get_peer_certificate(): TlsCertificate | null
    /**
     * Gets the errors associated with validating `conn'`s peer's
     * certificate, after the handshake has completed or failed. (It is
     * not set during the emission of #GDtlsConnection::accept-certificate.)
     * @returns @conn's peer's certificate errors
     */
    get_peer_certificate_errors(): TlsCertificateFlags
    /**
     * Returns the current DTLS protocol version, which may be
     * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
     * has been closed, or if the TLS backend has implemented a protocol version
     * that is not a recognized #GTlsProtocolVersion.
     * @returns The current DTLS protocol version
     */
    get_protocol_version(): TlsProtocolVersion
    /**
     * Gets `conn` rehandshaking mode. See
     * g_dtls_connection_set_rehandshake_mode() for details.
     * @returns %G_TLS_REHANDSHAKE_SAFELY
     */
    get_rehandshake_mode(): TlsRehandshakeMode
    /**
     * Tests whether or not `conn` expects a proper TLS close notification
     * when the connection is closed. See
     * g_dtls_connection_set_require_close_notify() for details.
     * @returns %TRUE if @conn requires a proper TLS close notification.
     */
    get_require_close_notify(): boolean
    /**
     * Attempts a TLS handshake on `conn`.
     * 
     * On the client side, it is never necessary to call this method;
     * although the connection needs to perform a handshake after
     * connecting, #GDtlsConnection will handle this for you automatically
     * when you try to send or receive data on the connection. You can call
     * g_dtls_connection_handshake() manually if you want to know whether
     * the initial handshake succeeded or failed (as opposed to just
     * immediately trying to use `conn` to read or write, in which case,
     * if it fails, it may not be possible to tell if it failed before
     * or after completing the handshake), but beware that servers may reject
     * client authentication after the handshake has completed, so a
     * successful handshake does not indicate the connection will be usable.
     * 
     * Likewise, on the server side, although a handshake is necessary at
     * the beginning of the communication, you do not need to call this
     * function explicitly unless you want clearer error reporting.
     * 
     * Previously, calling g_dtls_connection_handshake() after the initial
     * handshake would trigger a rehandshake; however, this usage was
     * deprecated in GLib 2.60 because rehandshaking was removed from the
     * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
     * the initial handshake will no longer do anything.
     * 
     * #GDtlsConnection::accept_certificate may be emitted during the
     * handshake.
     * @param cancellable a #GCancellable, or %NULL
     * @returns success or failure
     */
    handshake(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously performs a TLS handshake on `conn`. See
     * g_dtls_connection_handshake() for more information.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the handshake is complete
     */
    handshake_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of handshake_async

    /**
     * Promisified version of {@link handshake_async}
     * 
     * Asynchronously performs a TLS handshake on `conn`. See
     * g_dtls_connection_handshake() for more information.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE on success, %FALSE on failure, in which case @error will be set.
     */
    handshake_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finish an asynchronous TLS handshake operation. See
     * g_dtls_connection_handshake() for more information.
     * @param result a #GAsyncResult.
     * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
     */
    handshake_finish(result: AsyncResult): boolean
    /**
     * Sets the list of application-layer protocols to advertise that the
     * caller is willing to speak on this connection. The
     * Application-Layer Protocol Negotiation (ALPN) extension will be
     * used to negotiate a compatible protocol with the peer; use
     * g_dtls_connection_get_negotiated_protocol() to find the negotiated
     * protocol after the handshake.  Specifying %NULL for the the value
     * of `protocols` will disable ALPN negotiation.
     * 
     * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
     * for a list of registered protocol IDs.
     * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
     */
    set_advertised_protocols(protocols: string[] | null): void
    /**
     * This sets the certificate that `conn` will present to its peer
     * during the TLS handshake. For a #GDtlsServerConnection, it is
     * mandatory to set this, and that will normally be done at construct
     * time.
     * 
     * For a #GDtlsClientConnection, this is optional. If a handshake fails
     * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
     * requires a certificate, and if you try connecting again, you should
     * call this method first. You can call
     * g_dtls_client_connection_get_accepted_cas() on the failed connection
     * to get a list of Certificate Authorities that the server will
     * accept certificates from.
     * 
     * (It is also possible that a server will allow the connection with
     * or without a certificate; in that case, if you don't provide a
     * certificate, you can tell that the server requested one by the fact
     * that g_dtls_client_connection_get_accepted_cas() will return
     * non-%NULL.)
     * @param certificate the certificate to use for `conn`
     */
    set_certificate(certificate: TlsCertificate): void
    /**
     * Sets the certificate database that is used to verify peer certificates.
     * This is set to the default database by default. See
     * g_tls_backend_get_default_database(). If set to %NULL, then
     * peer certificate validation will always set the
     * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
     * #GDtlsConnection::accept-certificate will always be emitted on
     * client-side connections, unless that bit is not set in
     * #GDtlsClientConnection:validation-flags).
     * 
     * There are nonintuitive security implications when using a non-default
     * database. See #GDtlsConnection:database for details.
     * @param database a #GTlsDatabase
     */
    set_database(database: TlsDatabase | null): void
    /**
     * Set the object that will be used to interact with the user. It will be used
     * for things like prompting the user for passwords.
     * 
     * The `interaction` argument will normally be a derived subclass of
     * #GTlsInteraction. %NULL can also be provided if no user interaction
     * should occur for this connection.
     * @param interaction an interaction object, or %NULL
     */
    set_interaction(interaction: TlsInteraction | null): void
    /**
     * Since GLib 2.64, changing the rehandshake mode is no longer supported
     * and will have no effect. With TLS 1.3, rehandshaking has been removed from
     * the TLS protocol, replaced by separate post-handshake authentication and
     * rekey operations.
     * @param mode the rehandshaking mode
     */
    set_rehandshake_mode(mode: TlsRehandshakeMode): void
    /**
     * Sets whether or not `conn` expects a proper TLS close notification
     * before the connection is closed. If this is %TRUE (the default),
     * then `conn` will expect to receive a TLS close notification from its
     * peer before the connection is closed, and will return a
     * %G_TLS_ERROR_EOF error if the connection is closed without proper
     * notification (since this may indicate a network error, or
     * man-in-the-middle attack).
     * 
     * In some protocols, the application will know whether or not the
     * connection was closed cleanly based on application-level data
     * (because the application-level data includes a length field, or is
     * somehow self-delimiting); in this case, the close notify is
     * redundant and may be omitted. You
     * can use g_dtls_connection_set_require_close_notify() to tell `conn`
     * to allow an "unannounced" connection close, in which case the close
     * will show up as a 0-length read, as in a non-TLS
     * #GDatagramBased, and it is up to the application to check that
     * the data has been fully received.
     * 
     * Note that this only affects the behavior when the peer closes the
     * connection; when the application calls g_dtls_connection_close_async() on
     * `conn` itself, this will send a close notification regardless of the
     * setting of this property. If you explicitly want to do an unclean
     * close, you can close `conn'`s #GDtlsConnection:base-socket rather
     * than closing `conn` itself.
     * @param require_close_notify whether or not to require close notification
     */
    set_require_close_notify(require_close_notify: boolean): void
    /**
     * Shut down part or all of a DTLS connection.
     * 
     * If `shutdown_read` is %TRUE then the receiving side of the connection is shut
     * down, and further reading is disallowed. Subsequent calls to
     * g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
     * 
     * If `shutdown_write` is %TRUE then the sending side of the connection is shut
     * down, and further writing is disallowed. Subsequent calls to
     * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
     * 
     * It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE — this
     * is equivalent to calling g_dtls_connection_close().
     * 
     * If `cancellable` is cancelled, the #GDtlsConnection may be left
     * partially-closed and any pending untransmitted data may be lost. Call
     * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
     * @param shutdown_read %TRUE to stop reception of incoming datagrams
     * @param shutdown_write %TRUE to stop sending outgoing datagrams
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE on success, %FALSE otherwise
     */
    shutdown(shutdown_read: boolean, shutdown_write: boolean, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously shut down part or all of the DTLS connection. See
     * g_dtls_connection_shutdown() for more information.
     * @param shutdown_read %TRUE to stop reception of incoming datagrams
     * @param shutdown_write %TRUE to stop sending outgoing datagrams
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the shutdown operation is complete
     */
    shutdown_async(shutdown_read: boolean, shutdown_write: boolean, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of shutdown_async

    /**
     * Promisified version of {@link shutdown_async}
     * 
     * Asynchronously shut down part or all of the DTLS connection. See
     * g_dtls_connection_shutdown() for more information.
     * @param shutdown_read %TRUE to stop reception of incoming datagrams
     * @param shutdown_write %TRUE to stop sending outgoing datagrams
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE on success, %FALSE on failure, in which case @error will be set
     */
    shutdown_async(shutdown_read: boolean, shutdown_write: boolean, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finish an asynchronous TLS shutdown operation. See
     * g_dtls_connection_shutdown() for more information.
     * @param result a #GAsyncResult
     * @returns %TRUE on success, %FALSE on failure, in which case @error will be set
     */
    shutdown_finish(result: AsyncResult): boolean

    // Own virtual methods of Gio-2.0.Gio.DtlsConnection

    vfunc_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean
    vfunc_get_binding_data(type: TlsChannelBindingType, data: Uint8Array): boolean
    /**
     * Gets the name of the application-layer protocol negotiated during
     * the handshake.
     * 
     * If the peer did not use the ALPN extension, or did not advertise a
     * protocol that matched one of `conn'`s protocols, or the TLS backend
     * does not support ALPN, then this will be %NULL. See
     * g_dtls_connection_set_advertised_protocols().
     * @virtual 
     * @returns the negotiated protocol, or %NULL
     */
    vfunc_get_negotiated_protocol(): string | null
    /**
     * Attempts a TLS handshake on `conn`.
     * 
     * On the client side, it is never necessary to call this method;
     * although the connection needs to perform a handshake after
     * connecting, #GDtlsConnection will handle this for you automatically
     * when you try to send or receive data on the connection. You can call
     * g_dtls_connection_handshake() manually if you want to know whether
     * the initial handshake succeeded or failed (as opposed to just
     * immediately trying to use `conn` to read or write, in which case,
     * if it fails, it may not be possible to tell if it failed before
     * or after completing the handshake), but beware that servers may reject
     * client authentication after the handshake has completed, so a
     * successful handshake does not indicate the connection will be usable.
     * 
     * Likewise, on the server side, although a handshake is necessary at
     * the beginning of the communication, you do not need to call this
     * function explicitly unless you want clearer error reporting.
     * 
     * Previously, calling g_dtls_connection_handshake() after the initial
     * handshake would trigger a rehandshake; however, this usage was
     * deprecated in GLib 2.60 because rehandshaking was removed from the
     * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
     * the initial handshake will no longer do anything.
     * 
     * #GDtlsConnection::accept_certificate may be emitted during the
     * handshake.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @returns success or failure
     */
    vfunc_handshake(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously performs a TLS handshake on `conn`. See
     * g_dtls_connection_handshake() for more information.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the handshake is complete
     */
    vfunc_handshake_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finish an asynchronous TLS handshake operation. See
     * g_dtls_connection_handshake() for more information.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
     */
    vfunc_handshake_finish(result: AsyncResult): boolean
    /**
     * Sets the list of application-layer protocols to advertise that the
     * caller is willing to speak on this connection. The
     * Application-Layer Protocol Negotiation (ALPN) extension will be
     * used to negotiate a compatible protocol with the peer; use
     * g_dtls_connection_get_negotiated_protocol() to find the negotiated
     * protocol after the handshake.  Specifying %NULL for the the value
     * of `protocols` will disable ALPN negotiation.
     * 
     * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
     * for a list of registered protocol IDs.
     * @virtual 
     * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
     */
    vfunc_set_advertised_protocols(protocols: string[] | null): void
    /**
     * Shut down part or all of a DTLS connection.
     * 
     * If `shutdown_read` is %TRUE then the receiving side of the connection is shut
     * down, and further reading is disallowed. Subsequent calls to
     * g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
     * 
     * If `shutdown_write` is %TRUE then the sending side of the connection is shut
     * down, and further writing is disallowed. Subsequent calls to
     * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
     * 
     * It is allowed for both `shutdown_read` and `shutdown_write` to be TRUE — this
     * is equivalent to calling g_dtls_connection_close().
     * 
     * If `cancellable` is cancelled, the #GDtlsConnection may be left
     * partially-closed and any pending untransmitted data may be lost. Call
     * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
     * @virtual 
     * @param shutdown_read %TRUE to stop reception of incoming datagrams
     * @param shutdown_write %TRUE to stop sending outgoing datagrams
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE on success, %FALSE otherwise
     */
    vfunc_shutdown(shutdown_read: boolean, shutdown_write: boolean, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously shut down part or all of the DTLS connection. See
     * g_dtls_connection_shutdown() for more information.
     * @virtual 
     * @param shutdown_read %TRUE to stop reception of incoming datagrams
     * @param shutdown_write %TRUE to stop sending outgoing datagrams
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the shutdown operation is complete
     */
    vfunc_shutdown_async(shutdown_read: boolean, shutdown_write: boolean, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finish an asynchronous TLS shutdown operation. See
     * g_dtls_connection_shutdown() for more information.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE on success, %FALSE on failure, in which case @error will be set
     */
    vfunc_shutdown_finish(result: AsyncResult): boolean

    // Own signals of Gio-2.0.Gio.DtlsConnection

    connect(sigName: "accept-certificate", callback: DtlsConnection.AcceptCertificateSignalCallback): number
    connect_after(sigName: "accept-certificate", callback: DtlsConnection.AcceptCertificateSignalCallback): number
    emit(sigName: "accept-certificate", peer_cert: TlsCertificate, errors: TlsCertificateFlags, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DtlsConnection

    connect(sigName: "notify::advertised-protocols", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::advertised-protocols", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::advertised-protocols", ...args: any[]): void
    connect(sigName: "notify::base-socket", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::base-socket", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::base-socket", ...args: any[]): void
    connect(sigName: "notify::certificate", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::certificate", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::certificate", ...args: any[]): void
    connect(sigName: "notify::ciphersuite-name", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ciphersuite-name", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ciphersuite-name", ...args: any[]): void
    connect(sigName: "notify::database", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::database", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::database", ...args: any[]): void
    connect(sigName: "notify::interaction", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::negotiated-protocol", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::negotiated-protocol", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::negotiated-protocol", ...args: any[]): void
    connect(sigName: "notify::peer-certificate", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate", ...args: any[]): void
    connect(sigName: "notify::peer-certificate-errors", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate-errors", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate-errors", ...args: any[]): void
    connect(sigName: "notify::protocol-version", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-version", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol-version", ...args: any[]): void
    connect(sigName: "notify::rehandshake-mode", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rehandshake-mode", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::rehandshake-mode", ...args: any[]): void
    connect(sigName: "notify::require-close-notify", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::require-close-notify", callback: (($obj: DtlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::require-close-notify", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDtlsConnection is the base DTLS connection class type, which wraps
 * a #GDatagramBased and provides DTLS encryption on top of it. Its
 * subclasses, #GDtlsClientConnection and #GDtlsServerConnection,
 * implement client-side and server-side DTLS, respectively.
 * 
 * For TLS support, see #GTlsConnection.
 * 
 * As DTLS is datagram based, #GDtlsConnection implements #GDatagramBased,
 * presenting a datagram-socket-like API for the encrypted connection. This
 * operates over a base datagram connection, which is also a #GDatagramBased
 * (#GDtlsConnection:base-socket).
 * 
 * To close a DTLS connection, use g_dtls_connection_close().
 * 
 * Neither #GDtlsServerConnection or #GDtlsClientConnection set the peer address
 * on their base #GDatagramBased if it is a #GSocket — it is up to the caller to
 * do that if they wish. If they do not, and g_socket_close() is called on the
 * base socket, the #GDtlsConnection will not raise a %G_IO_ERROR_NOT_CONNECTED
 * error on further I/O.
 * @interface 
 */
class DtlsConnection extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DtlsConnection

    static name: string
    static $gtype: GObject.GType<DtlsConnection>

    // Constructors of Gio-2.0.Gio.DtlsConnection

    constructor(config?: DtlsConnection.ConstructorProperties) 
    _init(config?: DtlsConnection.ConstructorProperties): void
}

module DtlsServerConnection {

    // Constructor properties interface

    interface ConstructorProperties extends DatagramBased.ConstructorProperties, DtlsConnection.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DtlsServerConnection

        /**
         * The #GTlsAuthenticationMode for the server. This can be changed
         * before calling g_dtls_connection_handshake() if you want to
         * rehandshake with a different mode from the initial handshake.
         */
        authentication_mode?: TlsAuthenticationMode | null
    }

}

interface DtlsServerConnection extends DatagramBased, DtlsConnection {

    // Own properties of Gio-2.0.Gio.DtlsServerConnection

    /**
     * The #GTlsAuthenticationMode for the server. This can be changed
     * before calling g_dtls_connection_handshake() if you want to
     * rehandshake with a different mode from the initial handshake.
     */
    authentication_mode: TlsAuthenticationMode

    // Class property signals of Gio-2.0.Gio.DtlsServerConnection

    connect(sigName: "notify::authentication-mode", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::authentication-mode", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::authentication-mode", ...args: any[]): void
    connect(sigName: "notify::advertised-protocols", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::advertised-protocols", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::advertised-protocols", ...args: any[]): void
    connect(sigName: "notify::base-socket", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::base-socket", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::base-socket", ...args: any[]): void
    connect(sigName: "notify::certificate", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::certificate", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::certificate", ...args: any[]): void
    connect(sigName: "notify::ciphersuite-name", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ciphersuite-name", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ciphersuite-name", ...args: any[]): void
    connect(sigName: "notify::database", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::database", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::database", ...args: any[]): void
    connect(sigName: "notify::interaction", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::negotiated-protocol", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::negotiated-protocol", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::negotiated-protocol", ...args: any[]): void
    connect(sigName: "notify::peer-certificate", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate", ...args: any[]): void
    connect(sigName: "notify::peer-certificate-errors", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate-errors", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate-errors", ...args: any[]): void
    connect(sigName: "notify::protocol-version", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-version", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol-version", ...args: any[]): void
    connect(sigName: "notify::rehandshake-mode", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rehandshake-mode", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::rehandshake-mode", ...args: any[]): void
    connect(sigName: "notify::require-close-notify", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::require-close-notify", callback: (($obj: DtlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::require-close-notify", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDtlsServerConnection is the server-side subclass of #GDtlsConnection,
 * representing a server-side DTLS connection.
 * @interface 
 */
class DtlsServerConnection extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DtlsServerConnection

    static name: string
    static $gtype: GObject.GType<DtlsServerConnection>

    // Constructors of Gio-2.0.Gio.DtlsServerConnection

    constructor(config?: DtlsServerConnection.ConstructorProperties) 
    _init(config?: DtlsServerConnection.ConstructorProperties): void
    /**
     * Creates a new #GDtlsServerConnection wrapping `base_socket`.
     * @param base_socket the #GDatagramBased to wrap
     * @param certificate the default server certificate, or %NULL
     * @returns the new   #GDtlsServerConnection, or %NULL on error
     */
    static new(base_socket: DatagramBased, certificate: TlsCertificate | null): DtlsServerConnection
}

module File {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface File {

    // Owm methods of Gio-2.0.Gio.File

    /**
     * Gets an output stream for appending data to the file.
     * If the file doesn't already exist it is created.
     * 
     * By default files created are generally readable by everyone,
     * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
     * will be made readable only to the current user, to the level that
     * is supported on the target filesystem.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * Some file systems don't allow all file names, and may return an
     * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
     * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
     * possible too, and depend on what kind of filesystem the file is on.
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
     */
    append_to(flags: FileCreateFlags, cancellable: Cancellable | null): FileOutputStream
    /**
     * Asynchronously opens `file` for appending.
     * 
     * For more details, see g_file_append_to() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_append_to_finish() to get the result
     * of the operation.
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    append_to_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of append_to_async

    /**
     * Promisified version of {@link append_to_async}
     * 
     * Asynchronously opens `file` for appending.
     * 
     * For more details, see g_file_append_to() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_append_to_finish() to get the result
     * of the operation.
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a valid #GFileOutputStream   or %NULL on error.   Free the returned object with g_object_unref().
     */
    append_to_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileOutputStream>
    /**
     * Finishes an asynchronous file append operation started with
     * g_file_append_to_async().
     * @param res #GAsyncResult
     * @returns a valid #GFileOutputStream   or %NULL on error.   Free the returned object with g_object_unref().
     */
    append_to_finish(res: AsyncResult): FileOutputStream
    /**
     * Prepares the file attribute query string for copying to `file`.
     * 
     * This function prepares an attribute query string to be
     * passed to g_file_query_info() to get a list of attributes
     * normally copied with the file (see g_file_copy_attributes()
     * for the detailed description). This function is used by the
     * implementation of g_file_copy_attributes() and is useful
     * when one needs to query and set the attributes in two
     * stages (e.g., for recursive move of a directory).
     * @param flags a set of #GFileCopyFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns an attribute query string for g_file_query_info(),   or %NULL if an error occurs.
     */
    build_attribute_list_for_copy(flags: FileCopyFlags, cancellable: Cancellable | null): string | null
    /**
     * Copies the file `source` to the location specified by `destination`.
     * Can not handle recursive copies of directories.
     * 
     * If the flag %G_FILE_COPY_OVERWRITE is specified an already
     * existing `destination` file is overwritten.
     * 
     * If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
     * will be copied as symlinks, otherwise the target of the
     * `source` symlink will be copied.
     * 
     * If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
     * that is possible to copy is copied, not just the default subset (which,
     * for instance, does not include the owner, see #GFileInfo).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If `progress_callback` is not %NULL, then the operation can be monitored
     * by setting this to a #GFileProgressCallback function.
     * `progress_callback_data` will be passed to this function. It is guaranteed
     * that this callback will be called after all data has been transferred with
     * the total number of bytes copied during the operation.
     * 
     * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND error
     * is returned, independent on the status of the `destination`.
     * 
     * If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
     * the error %G_IO_ERROR_EXISTS is returned.
     * 
     * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
     * error is returned. If trying to overwrite a directory with a directory the
     * %G_IO_ERROR_WOULD_MERGE error is returned.
     * 
     * If the source is a directory and the target does not exist, or
     * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
     * %G_IO_ERROR_WOULD_RECURSE error is returned.
     * 
     * If you are interested in copying the #GFile object itself (not the on-disk
     * file), see g_file_dup().
     * @param destination destination #GFile
     * @param flags set of #GFileCopyFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param progress_callback function to callback with   progress information, or %NULL if progress information is not needed
     * @returns %TRUE on success, %FALSE otherwise.
     */
    copy(destination: File, flags: FileCopyFlags, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null): boolean
    /**
     * Copies the file `source` to the location specified by `destination`
     * asynchronously. For details of the behaviour, see g_file_copy().
     * 
     * If `progress_callback` is not %NULL, then that function that will be called
     * just like in g_file_copy(). The callback will run in the default main context
     * of the thread calling g_file_copy_async() — the same context as `callback` is
     * run in.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_file_copy_finish() to get the result of the operation.
     * @param destination destination #GFile
     * @param flags set of #GFileCopyFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     */
    copy_async(destination: File, flags: FileCopyFlags, io_priority: number, cancellable: Cancellable | null): void
    /**
     * Copies the file attributes from `source` to `destination`.
     * 
     * Normally only a subset of the file attributes are copied,
     * those that are copies in a normal file copy operation
     * (which for instance does not include e.g. owner). However
     * if %G_FILE_COPY_ALL_METADATA is specified in `flags,` then
     * all the metadata that is possible to copy is copied. This
     * is useful when implementing move by copy + delete source.
     * @param destination a #GFile to copy attributes to
     * @param flags a set of #GFileCopyFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the attributes were copied successfully,   %FALSE otherwise.
     */
    copy_attributes(destination: File, flags: FileCopyFlags, cancellable: Cancellable | null): boolean
    /**
     * Finishes copying the file started with g_file_copy_async().
     * @param res a #GAsyncResult
     * @returns a %TRUE on success, %FALSE on error.
     */
    copy_finish(res: AsyncResult): boolean
    /**
     * Creates a new file and returns an output stream for writing to it.
     * The file must not already exist.
     * 
     * By default files created are generally readable by everyone,
     * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
     * will be made readable only to the current user, to the level
     * that is supported on the target filesystem.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If a file or directory with this name already exists the
     * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
     * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
     * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
     * be returned. Other errors are possible too, and depend on what kind
     * of filesystem the file is on.
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileOutputStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
     */
    create(flags: FileCreateFlags, cancellable: Cancellable | null): FileOutputStream
    /**
     * Asynchronously creates a new file and returns an output stream
     * for writing to it. The file must not already exist.
     * 
     * For more details, see g_file_create() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_create_finish() to get the result
     * of the operation.
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    create_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of create_async

    /**
     * Promisified version of {@link create_async}
     * 
     * Asynchronously creates a new file and returns an output stream
     * for writing to it. The file must not already exist.
     * 
     * For more details, see g_file_create() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_create_finish() to get the result
     * of the operation.
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    create_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileOutputStream>
    /**
     * Finishes an asynchronous file create operation started with
     * g_file_create_async().
     * @param res a #GAsyncResult
     * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    create_finish(res: AsyncResult): FileOutputStream
    /**
     * Creates a new file and returns a stream for reading and
     * writing to it. The file must not already exist.
     * 
     * By default files created are generally readable by everyone,
     * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
     * will be made readable only to the current user, to the level
     * that is supported on the target filesystem.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If a file or directory with this name already exists, the
     * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
     * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
     * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
     * will be returned. Other errors are possible too, and depend on what
     * kind of filesystem the file is on.
     * 
     * Note that in many non-local file cases read and write streams are
     * not supported, so make sure you really need to do read and write
     * streaming, rather than just opening for reading or writing.
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileIOStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
     */
    create_readwrite(flags: FileCreateFlags, cancellable: Cancellable | null): FileIOStream
    /**
     * Asynchronously creates a new file and returns a stream
     * for reading and writing to it. The file must not already exist.
     * 
     * For more details, see g_file_create_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_create_readwrite_finish() to get
     * the result of the operation.
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    create_readwrite_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of create_readwrite_async

    /**
     * Promisified version of {@link create_readwrite_async}
     * 
     * Asynchronously creates a new file and returns a stream
     * for reading and writing to it. The file must not already exist.
     * 
     * For more details, see g_file_create_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_create_readwrite_finish() to get
     * the result of the operation.
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    create_readwrite_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileIOStream>
    /**
     * Finishes an asynchronous file create operation started with
     * g_file_create_readwrite_async().
     * @param res a #GAsyncResult
     * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    create_readwrite_finish(res: AsyncResult): FileIOStream
    /**
     * Deletes a file. If the `file` is a directory, it will only be
     * deleted if it is empty. This has the same semantics as g_unlink().
     * 
     * If `file` doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
     * for deletion to be implemented avoiding
     * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
     * 
     * ```
     * g_autoptr(GError) local_error = NULL;
     * if (!g_file_delete (my_file, my_cancellable, &local_error) &&
     *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
     *   {
     *     // deletion failed for some reason other than the file not existing:
     *     // so report the error
     *     g_warning ("Failed to delete %s: %s",
     *                g_file_peek_path (my_file), local_error->message);
     *   }
     * ```
     * 
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the file was deleted. %FALSE otherwise.
     */
    delete(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously delete a file. If the `file` is a directory, it will
     * only be deleted if it is empty.  This has the same semantics as
     * g_unlink().
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    delete_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of delete_async

    /**
     * Promisified version of {@link delete_async}
     * 
     * Asynchronously delete a file. If the `file` is a directory, it will
     * only be deleted if it is empty.  This has the same semantics as
     * g_unlink().
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: %TRUE if the file was deleted. %FALSE otherwise.
     */
    delete_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes deleting a file started with g_file_delete_async().
     * @param result a #GAsyncResult
     * @returns %TRUE if the file was deleted. %FALSE otherwise.
     */
    delete_finish(result: AsyncResult): boolean
    /**
     * Duplicates a #GFile handle. This operation does not duplicate
     * the actual file or directory represented by the #GFile; see
     * g_file_copy() if attempting to copy a file.
     * 
     * g_file_dup() is useful when a second handle is needed to the same underlying
     * file, for use in a separate thread (#GFile is not thread-safe). For use
     * within the same thread, use g_object_ref() to increment the existing object’s
     * reference count.
     * 
     * This call does no blocking I/O.
     * @returns a new #GFile that is a duplicate   of the given #GFile.
     */
    dup(): File
    /**
     * Starts an asynchronous eject on a mountable.
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_eject_mountable_finish().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param flags flags affecting the operation
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    eject_mountable(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous eject operation started by
     * g_file_eject_mountable().
     * @param result a #GAsyncResult
     * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
     */
    eject_mountable_finish(result: AsyncResult): boolean
    /**
     * Starts an asynchronous eject on a mountable.
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_eject_mountable_with_operation_finish().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    eject_mountable_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous eject operation started by
     * g_file_eject_mountable_with_operation().
     * @param result a #GAsyncResult
     * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
     */
    eject_mountable_with_operation_finish(result: AsyncResult): boolean
    /**
     * Gets the requested information about the files in a directory.
     * The result is a #GFileEnumerator object that will give out
     * #GFileInfo objects for all the files in the directory.
     * 
     * The `attributes` value is a string that specifies the file
     * attributes that should be gathered. It is not an error if
     * it's not possible to read a particular requested attribute
     * from a file - it just won't be set. `attributes` should
     * be a comma-separated list of attributes or attribute wildcards.
     * The wildcard "*" means all attributes, and a wildcard like
     * "standard::*" means all attributes in the standard namespace.
     * An example attribute query be "standard::*,owner::user".
     * The standard attributes are available as defines, like
     * %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
     * always be specified if you plan to call g_file_enumerator_get_child() or
     * g_file_enumerator_iterate() on the returned enumerator.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
     * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
     * error will be returned. Other errors are possible too.
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A #GFileEnumerator if successful,   %NULL on error. Free the returned object with g_object_unref().
     */
    enumerate_children(attributes: string | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null): FileEnumerator
    /**
     * Asynchronously gets the requested information about the files
     * in a directory. The result is a #GFileEnumerator object that will
     * give out #GFileInfo objects for all the files in the directory.
     * 
     * For more details, see g_file_enumerate_children() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_enumerate_children_finish() to get the result of
     * the operation.
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the   request is satisfied
     */
    enumerate_children_async(attributes: string | null, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of enumerate_children_async

    /**
     * Promisified version of {@link enumerate_children_async}
     * 
     * Asynchronously gets the requested information about the files
     * in a directory. The result is a #GFileEnumerator object that will
     * give out #GFileInfo objects for all the files in the directory.
     * 
     * For more details, see g_file_enumerate_children() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_enumerate_children_finish() to get the result of
     * the operation.
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a #GFileEnumerator or %NULL   if an error occurred.   Free the returned object with g_object_unref().
     */
    enumerate_children_async(attributes: string | null, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileEnumerator>
    /**
     * Finishes an async enumerate children operation.
     * See g_file_enumerate_children_async().
     * @param res a #GAsyncResult
     * @returns a #GFileEnumerator or %NULL   if an error occurred.   Free the returned object with g_object_unref().
     */
    enumerate_children_finish(res: AsyncResult): FileEnumerator
    /**
     * Checks if the two given #GFiles refer to the same file.
     * 
     * Note that two #GFiles that differ can still refer to the same
     * file on the filesystem due to various forms of filename
     * aliasing.
     * 
     * This call does no blocking I/O.
     * @param file2 the second #GFile
     * @returns %TRUE if @file1 and @file2 are equal.
     */
    equal(file2: File): boolean
    /**
     * Gets a #GMount for the #GFile.
     * 
     * #GMount is returned only for user interesting locations, see
     * #GVolumeMonitor. If the #GFileIface for `file` does not have a #mount,
     * `error` will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GMount where the @file is located   or %NULL on error.   Free the returned object with g_object_unref().
     */
    find_enclosing_mount(cancellable: Cancellable | null): Mount
    /**
     * Asynchronously gets the mount for the file.
     * 
     * For more details, see g_file_find_enclosing_mount() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_find_enclosing_mount_finish() to
     * get the result of the operation.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    find_enclosing_mount_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of find_enclosing_mount_async

    /**
     * Promisified version of {@link find_enclosing_mount_async}
     * 
     * Asynchronously gets the mount for the file.
     * 
     * For more details, see g_file_find_enclosing_mount() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_find_enclosing_mount_finish() to
     * get the result of the operation.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: #GMount for given @file or %NULL on error.   Free the returned object with g_object_unref().
     */
    find_enclosing_mount_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<Mount>
    /**
     * Finishes an asynchronous find mount request.
     * See g_file_find_enclosing_mount_async().
     * @param res a #GAsyncResult
     * @returns #GMount for given @file or %NULL on error.   Free the returned object with g_object_unref().
     */
    find_enclosing_mount_finish(res: AsyncResult): Mount
    /**
     * Gets the base name (the last component of the path) for a given #GFile.
     * 
     * If called for the top level of a system (such as the filesystem root
     * or a uri like sftp://host/) it will return a single directory separator
     * (and on Windows, possibly a drive letter).
     * 
     * The base name is a byte string (not UTF-8). It has no defined encoding
     * or rules other than it may not contain zero bytes.  If you want to use
     * filenames in a user interface you should use the display name that you
     * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
     * attribute with g_file_query_info().
     * 
     * This call does no blocking I/O.
     * @returns string containing the #GFile's   base name, or %NULL if given #GFile is invalid. The returned string   should be freed with g_free() when no longer needed.
     */
    get_basename(): string | null
    /**
     * Gets a child of `file` with basename equal to `name`.
     * 
     * Note that the file with that specific name might not exist, but
     * you can still have a #GFile that points to it. You can use this
     * for instance to create that file.
     * 
     * This call does no blocking I/O.
     * @param name string containing the child's basename
     * @returns a #GFile to a child specified by @name.   Free the returned object with g_object_unref().
     */
    get_child(name: string): File
    /**
     * Gets the child of `file` for a given `display_name` (i.e. a UTF-8
     * version of the name). If this function fails, it returns %NULL
     * and `error` will be set. This is very useful when constructing a
     * #GFile for a new file and the user entered the filename in the
     * user interface, for instance when you select a directory and
     * type a filename in the file selector.
     * 
     * This call does no blocking I/O.
     * @param display_name string to a possible child
     * @returns a #GFile to the specified child, or   %NULL if the display name couldn't be converted.   Free the returned object with g_object_unref().
     */
    get_child_for_display_name(display_name: string | null): File
    /**
     * Gets the parent directory for the `file`.
     * If the `file` represents the root directory of the
     * file system, then %NULL will be returned.
     * 
     * This call does no blocking I/O.
     * @returns a #GFile structure to the   parent of the given #GFile or %NULL if there is no parent. Free   the returned object with g_object_unref().
     */
    get_parent(): File | null
    /**
     * Gets the parse name of the `file`.
     * A parse name is a UTF-8 string that describes the
     * file such that one can get the #GFile back using
     * g_file_parse_name().
     * 
     * This is generally used to show the #GFile as a nice
     * full-pathname kind of string in a user interface,
     * like in a location entry.
     * 
     * For local files with names that can safely be converted
     * to UTF-8 the pathname is used, otherwise the IRI is used
     * (a form of URI that allows UTF-8 characters unescaped).
     * 
     * This call does no blocking I/O.
     * @returns a string containing the #GFile's parse name.   The returned string should be freed with g_free()   when no longer needed.
     */
    get_parse_name(): string | null
    /**
     * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
     * guaranteed to be an absolute, canonical path. It might contain symlinks.
     * 
     * This call does no blocking I/O.
     * @returns string containing the #GFile's path,   or %NULL if no such path exists. The returned string should be freed   with g_free() when no longer needed.
     */
    get_path(): string | null
    /**
     * Gets the path for `descendant` relative to `parent`.
     * 
     * This call does no blocking I/O.
     * @param descendant input #GFile
     * @returns string with the relative path from   @descendant to @parent, or %NULL if @descendant doesn't have @parent as   prefix. The returned string should be freed with g_free() when   no longer needed.
     */
    get_relative_path(descendant: File): string | null
    /**
     * Gets the URI for the `file`.
     * 
     * This call does no blocking I/O.
     * @returns a string containing the #GFile's URI. If the #GFile was constructed   with an invalid URI, an invalid URI is returned.   The returned string should be freed with g_free()   when no longer needed.
     */
    get_uri(): string | null
    /**
     * Gets the URI scheme for a #GFile.
     * RFC 3986 decodes the scheme as:
     * 
     * ```
     * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
     * ```
     * 
     * Common schemes include "file", "http", "ftp", etc.
     * 
     * The scheme can be different from the one used to construct the #GFile,
     * in that it might be replaced with one that is logically equivalent to the #GFile.
     * 
     * This call does no blocking I/O.
     * @returns a string containing the URI scheme for the given   #GFile or %NULL if the #GFile was constructed with an invalid URI. The   returned string should be freed with g_free() when no longer needed.
     */
    get_uri_scheme(): string | null
    /**
     * Checks if `file` has a parent, and optionally, if it is `parent`.
     * 
     * If `parent` is %NULL then this function returns %TRUE if `file` has any
     * parent at all.  If `parent` is non-%NULL then %TRUE is only returned
     * if `file` is an immediate child of `parent`.
     * @param parent the parent to check for, or %NULL
     * @returns %TRUE if @file is an immediate child of @parent (or any parent in   the case that @parent is %NULL).
     */
    has_parent(parent: File | null): boolean
    /**
     * Checks whether `file` has the prefix specified by `prefix`.
     * 
     * In other words, if the names of initial elements of `file'`s
     * pathname match `prefix`. Only full pathname elements are matched,
     * so a path like /foo is not considered a prefix of /foobar, only
     * of /foo/bar.
     * 
     * A #GFile is not a prefix of itself. If you want to check for
     * equality, use g_file_equal().
     * 
     * This call does no I/O, as it works purely on names. As such it can
     * sometimes return %FALSE even if `file` is inside a `prefix` (from a
     * filesystem point of view), because the prefix of `file` is an alias
     * of `prefix`.
     * @param prefix input #GFile
     * @returns %TRUE if the @file's parent, grandparent, etc is @prefix,   %FALSE otherwise.
     */
    has_prefix(prefix: File): boolean
    /**
     * Checks to see if a #GFile has a given URI scheme.
     * 
     * This call does no blocking I/O.
     * @param uri_scheme a string containing a URI scheme
     * @returns %TRUE if #GFile's backend supports the   given URI scheme, %FALSE if URI scheme is %NULL,   not supported, or #GFile is invalid.
     */
    has_uri_scheme(uri_scheme: string | null): boolean
    /**
     * Creates a hash value for a #GFile.
     * 
     * This call does no blocking I/O.
     * @returns 0 if @file is not a valid #GFile, otherwise an   integer that can be used as hash value for the #GFile.   This function is intended for easily hashing a #GFile to   add to a #GHashTable or similar data structure.
     */
    hash(): number
    /**
     * Checks to see if a file is native to the platform.
     * 
     * A native file is one expressed in the platform-native filename format,
     * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
     * as it might be on a locally mounted remote filesystem.
     * 
     * On some systems non-native files may be available using the native
     * filesystem via a userspace filesystem (FUSE), in these cases this call
     * will return %FALSE, but g_file_get_path() will still return a native path.
     * 
     * This call does no blocking I/O.
     * @returns %TRUE if @file is native
     */
    is_native(): boolean
    /**
     * Loads the contents of `file` and returns it as #GBytes.
     * 
     * If `file` is a resource:// based URI, the resulting bytes will reference the
     * embedded resource instead of a copy. Otherwise, this is equivalent to calling
     * g_file_load_contents() and g_bytes_new_take().
     * 
     * For resources, `etag_out` will be set to %NULL.
     * 
     * The data contained in the resulting #GBytes is always zero-terminated, but
     * this is not included in the #GBytes length. The resulting #GBytes should be
     * freed with g_bytes_unref() when no longer in use.
     * @param cancellable a #GCancellable or %NULL
     * @returns a #GBytes or %NULL and @error is set
     */
    load_bytes(cancellable: Cancellable | null): [ /* returnType */ GLib.Bytes, /* etag_out */ string | null ]
    /**
     * Asynchronously loads the contents of `file` as #GBytes.
     * 
     * If `file` is a resource:// based URI, the resulting bytes will reference the
     * embedded resource instead of a copy. Otherwise, this is equivalent to calling
     * g_file_load_contents_async() and g_bytes_new_take().
     * 
     * `callback` should call g_file_load_bytes_finish() to get the result of this
     * asynchronous operation.
     * 
     * See g_file_load_bytes() for more information.
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the   request is satisfied
     */
    load_bytes_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of load_bytes_async

    /**
     * Promisified version of {@link load_bytes_async}
     * 
     * Asynchronously loads the contents of `file` as #GBytes.
     * 
     * If `file` is a resource:// based URI, the resulting bytes will reference the
     * embedded resource instead of a copy. Otherwise, this is equivalent to calling
     * g_file_load_contents_async() and g_bytes_new_take().
     * 
     * `callback` should call g_file_load_bytes_finish() to get the result of this
     * asynchronous operation.
     * 
     * See g_file_load_bytes() for more information.
     * @param cancellable a #GCancellable or %NULL
     * @returns A Promise of: a #GBytes or %NULL and @error is set
     */
    load_bytes_async(cancellable: Cancellable | null): globalThis.Promise</* etag_out */ string | null>
    /**
     * Completes an asynchronous request to g_file_load_bytes_async().
     * 
     * For resources, `etag_out` will be set to %NULL.
     * 
     * The data contained in the resulting #GBytes is always zero-terminated, but
     * this is not included in the #GBytes length. The resulting #GBytes should be
     * freed with g_bytes_unref() when no longer in use.
     * 
     * See g_file_load_bytes() for more information.
     * @param result a #GAsyncResult provided to the callback
     * @returns a #GBytes or %NULL and @error is set
     */
    load_bytes_finish(result: AsyncResult): [ /* returnType */ GLib.Bytes, /* etag_out */ string | null ]
    /**
     * Loads the content of the file into memory. The data is always
     * zero-terminated, but this is not included in the resultant `length`.
     * The returned `contents` should be freed with g_free() when no longer
     * needed.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns %TRUE if the @file's contents were successfully loaded.   %FALSE if there were errors.
     */
    load_contents(cancellable: Cancellable | null): [ /* returnType */ boolean, /* contents */ Uint8Array, /* etag_out */ string | null ]
    /**
     * Starts an asynchronous load of the `file'`s contents.
     * 
     * For more details, see g_file_load_contents() which is
     * the synchronous version of this call.
     * 
     * When the load operation has completed, `callback` will be called
     * with `user` data. To finish the operation, call
     * g_file_load_contents_finish() with the #GAsyncResult returned by
     * the `callback`.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    load_contents_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of load_contents_async

    /**
     * Promisified version of {@link load_contents_async}
     * 
     * Starts an asynchronous load of the `file'`s contents.
     * 
     * For more details, see g_file_load_contents() which is
     * the synchronous version of this call.
     * 
     * When the load operation has completed, `callback` will be called
     * with `user` data. To finish the operation, call
     * g_file_load_contents_finish() with the #GAsyncResult returned by
     * the `callback`.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: %TRUE if the load was successful. If %FALSE and @error is   present, it will be set appropriately.
     */
    load_contents_async(cancellable: Cancellable | null): globalThis.Promise<[ /* contents */ Uint8Array, /* etag_out */ string | null ]>
    /**
     * Finishes an asynchronous load of the `file'`s contents.
     * The contents are placed in `contents,` and `length` is set to the
     * size of the `contents` string. The `contents` should be freed with
     * g_free() when no longer needed. If `etag_out` is present, it will be
     * set to the new entity tag for the `file`.
     * @param res a #GAsyncResult
     * @returns %TRUE if the load was successful. If %FALSE and @error is   present, it will be set appropriately.
     */
    load_contents_finish(res: AsyncResult): [ /* returnType */ boolean, /* contents */ Uint8Array, /* etag_out */ string | null ]
    /**
     * Finishes an asynchronous partial load operation that was started
     * with g_file_load_partial_contents_async(). The data is always
     * zero-terminated, but this is not included in the resultant `length`.
     * The returned `contents` should be freed with g_free() when no longer
     * needed.
     * @param res a #GAsyncResult
     * @returns %TRUE if the load was successful. If %FALSE and @error is   present, it will be set appropriately.
     */
    load_partial_contents_finish(res: AsyncResult): [ /* returnType */ boolean, /* contents */ Uint8Array, /* etag_out */ string | null ]
    /**
     * Creates a directory. Note that this will only create a child directory
     * of the immediate parent directory of the path or URI given by the #GFile.
     * To recursively create directories, see g_file_make_directory_with_parents().
     * This function will fail if the parent directory does not exist, setting
     * `error` to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
     * creating directories, this function will fail, setting `error` to
     * %G_IO_ERROR_NOT_SUPPORTED.
     * 
     * For a local #GFile the newly created directory will have the default
     * (current) ownership and permissions of the current process.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE on successful creation, %FALSE otherwise.
     */
    make_directory(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously creates a directory.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    make_directory_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of make_directory_async

    /**
     * Promisified version of {@link make_directory_async}
     * 
     * Asynchronously creates a directory.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: %TRUE on successful directory creation, %FALSE otherwise.
     */
    make_directory_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes an asynchronous directory creation, started with
     * g_file_make_directory_async().
     * @param result a #GAsyncResult
     * @returns %TRUE on successful directory creation, %FALSE otherwise.
     */
    make_directory_finish(result: AsyncResult): boolean
    /**
     * Creates a directory and any parent directories that may not
     * exist similar to 'mkdir -p'. If the file system does not support
     * creating directories, this function will fail, setting `error` to
     * %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
     * this function will fail setting `error` to %G_IO_ERROR_EXISTS, unlike
     * the similar g_mkdir_with_parents().
     * 
     * For a local #GFile the newly created directories will have the default
     * (current) ownership and permissions of the current process.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if all directories have been successfully created, %FALSE otherwise.
     */
    make_directory_with_parents(cancellable: Cancellable | null): boolean
    /**
     * Creates a symbolic link named `file` which contains the string
     * `symlink_value`.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param symlink_value a string with the path for the target   of the new symlink
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE on the creation of a new symlink, %FALSE otherwise.
     */
    make_symbolic_link(symlink_value: string, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously creates a symbolic link named `file` which contains the
     * string `symlink_value`.
     * @param symlink_value a string with the path for the target   of the new symlink
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    make_symbolic_link_async(symlink_value: string, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of make_symbolic_link_async

    /**
     * Promisified version of {@link make_symbolic_link_async}
     * 
     * Asynchronously creates a symbolic link named `file` which contains the
     * string `symlink_value`.
     * @param symlink_value a string with the path for the target   of the new symlink
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: %TRUE on successful directory creation, %FALSE otherwise.
     */
    make_symbolic_link_async(symlink_value: string, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes an asynchronous symbolic link creation, started with
     * g_file_make_symbolic_link_async().
     * @param result a #GAsyncResult
     * @returns %TRUE on successful directory creation, %FALSE otherwise.
     */
    make_symbolic_link_finish(result: AsyncResult): boolean
    /**
     * Collects the results from an earlier call to
     * g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
     * more information.
     * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
     * @returns %TRUE if successful, with the out parameters set.   %FALSE otherwise, with @error set.
     */
    measure_disk_usage_finish(result: AsyncResult): [ /* returnType */ boolean, /* disk_usage */ number, /* num_dirs */ number, /* num_files */ number ]
    /**
     * Obtains a file or directory monitor for the given file,
     * depending on the type of the file.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param flags a set of #GFileMonitorFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
     */
    monitor(flags: FileMonitorFlags, cancellable: Cancellable | null): FileMonitor
    /**
     * Obtains a directory monitor for the given file.
     * This may fail if directory monitoring is not supported.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * It does not make sense for `flags` to contain
     * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
     * directories.  It is not possible to monitor all the files in a
     * directory for changes made via hard links; if you want to do this then
     * you must register individual watches with g_file_monitor().
     * @param flags a set of #GFileMonitorFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
     */
    monitor_directory(flags: FileMonitorFlags, cancellable: Cancellable | null): FileMonitor
    /**
     * Obtains a file monitor for the given file. If no file notification
     * mechanism exists, then regular polling of the file is used.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If `flags` contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
     * will also attempt to report changes made to the file via another
     * filename (ie, a hard link). Without this flag, you can only rely on
     * changes made through the filename contained in `file` to be
     * reported. Using this flag may result in an increase in resource
     * usage, and may not have any effect depending on the #GFileMonitor
     * backend and/or filesystem type.
     * @param flags a set of #GFileMonitorFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
     */
    monitor_file(flags: FileMonitorFlags, cancellable: Cancellable | null): FileMonitor
    /**
     * Starts a `mount_operation,` mounting the volume that contains
     * the file `location`.
     * 
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_mount_enclosing_volume_finish().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation   or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    mount_enclosing_volume(flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a mount operation started by g_file_mount_enclosing_volume().
     * @param result a #GAsyncResult
     * @returns %TRUE if successful. If an error has occurred,   this function will return %FALSE and set @error   appropriately if present.
     */
    mount_enclosing_volume_finish(result: AsyncResult): boolean
    /**
     * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
     * Using `mount_operation,` you can request callbacks when, for instance,
     * passwords are needed during authentication.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_mount_mountable_finish() to get
     * the result of the operation.
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    mount_mountable(flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a mount operation. See g_file_mount_mountable() for details.
     * 
     * Finish an asynchronous mount operation that was started
     * with g_file_mount_mountable().
     * @param result a #GAsyncResult
     * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
     */
    mount_mountable_finish(result: AsyncResult): File
    /**
     * Tries to move the file or directory `source` to the location specified
     * by `destination`. If native move operations are supported then this is
     * used, otherwise a copy + delete fallback is used. The native
     * implementation may support moving directories (for instance on moves
     * inside the same filesystem), but the fallback code does not.
     * 
     * If the flag %G_FILE_COPY_OVERWRITE is specified an already
     * existing `destination` file is overwritten.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If `progress_callback` is not %NULL, then the operation can be monitored
     * by setting this to a #GFileProgressCallback function.
     * `progress_callback_data` will be passed to this function. It is
     * guaranteed that this callback will be called after all data has been
     * transferred with the total number of bytes copied during the operation.
     * 
     * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND
     * error is returned, independent on the status of the `destination`.
     * 
     * If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
     * then the error %G_IO_ERROR_EXISTS is returned.
     * 
     * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
     * error is returned. If trying to overwrite a directory with a directory the
     * %G_IO_ERROR_WOULD_MERGE error is returned.
     * 
     * If the source is a directory and the target does not exist, or
     * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
     * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
     * move operation isn't available).
     * @param destination #GFile pointing to the destination location
     * @param flags set of #GFileCopyFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param progress_callback #GFileProgressCallback   function for updates
     * @returns %TRUE on successful move, %FALSE otherwise.
     */
    move(destination: File, flags: FileCopyFlags, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null): boolean
    /**
     * Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see g_file_move().
     * 
     * If `progress_callback` is not %NULL, then that function that will be called
     * just like in g_file_move(). The callback will run in the default main context
     * of the thread calling g_file_move_async() — the same context as `callback` is
     * run in.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_file_move_finish() to get the result of the operation.
     * @param destination #GFile pointing to the destination location
     * @param flags set of #GFileCopyFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param progress_callback #GFileProgressCallback   function for updates
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    move_async(destination: File, flags: FileCopyFlags, io_priority: number, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of move_async

    /**
     * Promisified version of {@link move_async}
     * 
     * Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see g_file_move().
     * 
     * If `progress_callback` is not %NULL, then that function that will be called
     * just like in g_file_move(). The callback will run in the default main context
     * of the thread calling g_file_move_async() — the same context as `callback` is
     * run in.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_file_move_finish() to get the result of the operation.
     * @param destination #GFile pointing to the destination location
     * @param flags set of #GFileCopyFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param progress_callback #GFileProgressCallback   function for updates
     * @returns A Promise of: %TRUE on successful file move, %FALSE otherwise.
     */
    move_async(destination: File, flags: FileCopyFlags, io_priority: number, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null): globalThis.Promise<boolean>
    /**
     * Finishes an asynchronous file movement, started with
     * g_file_move_async().
     * @param result a #GAsyncResult
     * @returns %TRUE on successful file move, %FALSE otherwise.
     */
    move_finish(result: AsyncResult): boolean
    /**
     * Opens an existing file for reading and writing. The result is
     * a #GFileIOStream that can be used to read and write the contents
     * of the file.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
     * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
     * error will be returned. Other errors are possible too, and depend on
     * what kind of filesystem the file is on. Note that in many non-local
     * file cases read and write streams are not supported, so make sure you
     * really need to do read and write streaming, rather than just opening
     * for reading or writing.
     * @param cancellable a #GCancellable
     * @returns #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    open_readwrite(cancellable: Cancellable | null): FileIOStream
    /**
     * Asynchronously opens `file` for reading and writing.
     * 
     * For more details, see g_file_open_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_open_readwrite_finish() to get
     * the result of the operation.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    open_readwrite_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of open_readwrite_async

    /**
     * Promisified version of {@link open_readwrite_async}
     * 
     * Asynchronously opens `file` for reading and writing.
     * 
     * For more details, see g_file_open_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_open_readwrite_finish() to get
     * the result of the operation.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    open_readwrite_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileIOStream>
    /**
     * Finishes an asynchronous file read operation started with
     * g_file_open_readwrite_async().
     * @param res a #GAsyncResult
     * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    open_readwrite_finish(res: AsyncResult): FileIOStream
    /**
     * Exactly like g_file_get_path(), but caches the result via
     * g_object_set_qdata_full().  This is useful for example in C
     * applications which mix `g_file_*` APIs with native ones.  It
     * also avoids an extra duplicated string when possible, so will be
     * generally more efficient.
     * 
     * This call does no blocking I/O.
     * @returns string containing the #GFile's path,   or %NULL if no such path exists. The returned string is owned by @file.
     */
    peek_path(): string | null
    /**
     * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_mount_mountable_finish() to get
     * the result of the operation.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    poll_mountable(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a poll operation. See g_file_poll_mountable() for details.
     * 
     * Finish an asynchronous poll operation that was polled
     * with g_file_poll_mountable().
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
     */
    poll_mountable_finish(result: AsyncResult): boolean
    /**
     * Returns the #GAppInfo that is registered as the default
     * application to handle the file specified by `file`.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns a #GAppInfo if the handle was found,   %NULL if there were errors.   When you are done with it, release it with g_object_unref()
     */
    query_default_handler(cancellable: Cancellable | null): AppInfo
    /**
     * Async version of g_file_query_default_handler().
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    query_default_handler_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of query_default_handler_async

    /**
     * Promisified version of {@link query_default_handler_async}
     * 
     * Async version of g_file_query_default_handler().
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: a #GAppInfo if the handle was found,   %NULL if there were errors.   When you are done with it, release it with g_object_unref()
     */
    query_default_handler_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<AppInfo>
    /**
     * Finishes a g_file_query_default_handler_async() operation.
     * @param result a #GAsyncResult
     * @returns a #GAppInfo if the handle was found,   %NULL if there were errors.   When you are done with it, release it with g_object_unref()
     */
    query_default_handler_finish(result: AsyncResult): AppInfo
    /**
     * Utility function to check if a particular file exists. This is
     * implemented using g_file_query_info() and as such does blocking I/O.
     * 
     * Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
     * and then execute something based on the outcome of that, because the
     * file might have been created or removed in between the operations. The
     * general approach to handling that is to not check, but just do the
     * operation and handle the errors as they come.
     * 
     * As an example of race-free checking, take the case of reading a file,
     * and if it doesn't exist, creating it. There are two racy versions: read
     * it, and on error create it; and: check if it exists, if not create it.
     * These can both result in two processes creating the file (with perhaps
     * a partially written file as the result). The correct approach is to
     * always try to create the file with g_file_create() which will either
     * atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
     * 
     * However, in many cases an existence check is useful in a user interface,
     * for instance to make a menu item sensitive/insensitive, so that you don't
     * have to fool users that something is possible and then just show an error
     * dialog. If you do this, you should make sure to also handle the errors
     * that can happen due to races when you execute the operation.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the file exists (and can be detected without error),   %FALSE otherwise (or if cancelled).
     */
    query_exists(cancellable: Cancellable | null): boolean
    /**
     * Utility function to inspect the #GFileType of a file. This is
     * implemented using g_file_query_info() and as such does blocking I/O.
     * 
     * The primary use case of this method is to check if a file is
     * a regular file, directory, or symlink.
     * @param flags a set of #GFileQueryInfoFlags passed to g_file_query_info()
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns The #GFileType of the file and %G_FILE_TYPE_UNKNOWN   if the file does not exist
     */
    query_file_type(flags: FileQueryInfoFlags, cancellable: Cancellable | null): FileType
    /**
     * Similar to g_file_query_info(), but obtains information
     * about the filesystem the `file` is on, rather than the file itself.
     * For instance the amount of space available and the type of
     * the filesystem.
     * 
     * The `attributes` value is a string that specifies the attributes
     * that should be gathered. It is not an error if it's not possible
     * to read a particular requested attribute from a file - it just
     * won't be set. `attributes` should be a comma-separated list of
     * attributes or attribute wildcards. The wildcard "*" means all
     * attributes, and a wildcard like "filesystem::*" means all attributes
     * in the filesystem namespace. The standard namespace for filesystem
     * attributes is "filesystem". Common attributes of interest are
     * %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
     * in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
     * and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
     * be returned. Other errors are possible too, and depend on what
     * kind of filesystem the file is on.
     * @param attributes an attribute query string
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileInfo or %NULL if there was an error.   Free the returned object with g_object_unref().
     */
    query_filesystem_info(attributes: string | null, cancellable: Cancellable | null): FileInfo
    /**
     * Asynchronously gets the requested information about the filesystem
     * that the specified `file` is on. The result is a #GFileInfo object
     * that contains key-value attributes (such as type or size for the
     * file).
     * 
     * For more details, see g_file_query_filesystem_info() which is the
     * synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_query_info_finish() to get the result of the
     * operation.
     * @param attributes an attribute query string
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    query_filesystem_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of query_filesystem_info_async

    /**
     * Promisified version of {@link query_filesystem_info_async}
     * 
     * Asynchronously gets the requested information about the filesystem
     * that the specified `file` is on. The result is a #GFileInfo object
     * that contains key-value attributes (such as type or size for the
     * file).
     * 
     * For more details, see g_file_query_filesystem_info() which is the
     * synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_query_info_finish() to get the result of the
     * operation.
     * @param attributes an attribute query string
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: #GFileInfo for given @file   or %NULL on error.   Free the returned object with g_object_unref().
     */
    query_filesystem_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileInfo>
    /**
     * Finishes an asynchronous filesystem info query.
     * See g_file_query_filesystem_info_async().
     * @param res a #GAsyncResult
     * @returns #GFileInfo for given @file   or %NULL on error.   Free the returned object with g_object_unref().
     */
    query_filesystem_info_finish(res: AsyncResult): FileInfo
    /**
     * Gets the requested information about specified `file`.
     * The result is a #GFileInfo object that contains key-value
     * attributes (such as the type or size of the file).
     * 
     * The `attributes` value is a string that specifies the file
     * attributes that should be gathered. It is not an error if
     * it's not possible to read a particular requested attribute
     * from a file - it just won't be set. `attributes` should be a
     * comma-separated list of attributes or attribute wildcards.
     * The wildcard "*" means all attributes, and a wildcard like
     * "standard::*" means all attributes in the standard namespace.
     * An example attribute query be "standard::*,owner::user".
     * The standard attributes are available as defines, like
     * %G_FILE_ATTRIBUTE_STANDARD_NAME.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * For symlinks, normally the information about the target of the
     * symlink is returned, rather than information about the symlink
     * itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
     * in `flags` the information about the symlink itself will be returned.
     * Also, for symlinks that point to non-existing files the information
     * about the symlink itself will be returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
     * returned. Other errors are possible too, and depend on what kind of
     * filesystem the file is on.
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileInfo for the given @file, or %NULL   on error. Free the returned object with g_object_unref().
     */
    query_info(attributes: string | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null): FileInfo
    /**
     * Asynchronously gets the requested information about specified `file`.
     * The result is a #GFileInfo object that contains key-value attributes
     * (such as type or size for the file).
     * 
     * For more details, see g_file_query_info() which is the synchronous
     * version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_query_info_finish() to get the result of the operation.
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the   request is satisfied
     */
    query_info_async(attributes: string | null, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of query_info_async

    /**
     * Promisified version of {@link query_info_async}
     * 
     * Asynchronously gets the requested information about specified `file`.
     * The result is a #GFileInfo object that contains key-value attributes
     * (such as type or size for the file).
     * 
     * For more details, see g_file_query_info() which is the synchronous
     * version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_query_info_finish() to get the result of the operation.
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: #GFileInfo for given @file   or %NULL on error. Free the returned object with   g_object_unref().
     */
    query_info_async(attributes: string | null, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileInfo>
    /**
     * Finishes an asynchronous file info query.
     * See g_file_query_info_async().
     * @param res a #GAsyncResult
     * @returns #GFileInfo for given @file   or %NULL on error. Free the returned object with   g_object_unref().
     */
    query_info_finish(res: AsyncResult): FileInfo
    /**
     * Obtain the list of settable attributes for the file.
     * 
     * Returns the type and full attribute name of all the attributes
     * that can be set on this file. This doesn't mean setting it will
     * always succeed though, you might get an access failure, or some
     * specific file may not support a specific attribute.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileAttributeInfoList describing the settable attributes.   When you are done with it, release it with   g_file_attribute_info_list_unref()
     */
    query_settable_attributes(cancellable: Cancellable | null): FileAttributeInfoList
    /**
     * Obtain the list of attribute namespaces where new attributes
     * can be created by a user. An example of this is extended
     * attributes (in the "xattr" namespace).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileAttributeInfoList describing the writable namespaces.   When you are done with it, release it with   g_file_attribute_info_list_unref()
     */
    query_writable_namespaces(cancellable: Cancellable | null): FileAttributeInfoList
    /**
     * Opens a file for reading. The result is a #GFileInputStream that
     * can be used to read the contents of the file.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
     * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
     * error will be returned. Other errors are possible too, and depend
     * on what kind of filesystem the file is on.
     * @param cancellable a #GCancellable
     * @returns #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    read(cancellable: Cancellable | null): FileInputStream
    /**
     * Asynchronously opens `file` for reading.
     * 
     * For more details, see g_file_read() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_read_finish() to get the result
     * of the operation.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    read_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of read_async

    /**
     * Promisified version of {@link read_async}
     * 
     * Asynchronously opens `file` for reading.
     * 
     * For more details, see g_file_read() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_read_finish() to get the result
     * of the operation.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    read_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileInputStream>
    /**
     * Finishes an asynchronous file read operation started with
     * g_file_read_async().
     * @param res a #GAsyncResult
     * @returns a #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    read_finish(res: AsyncResult): FileInputStream
    /**
     * Returns an output stream for overwriting the file, possibly
     * creating a backup copy of the file first. If the file doesn't exist,
     * it will be created.
     * 
     * This will try to replace the file in the safest way possible so
     * that any errors during the writing will not affect an already
     * existing copy of the file. For instance, for local files it
     * may write to a temporary file and then atomically rename over
     * the destination when the stream is closed.
     * 
     * By default files created are generally readable by everyone,
     * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
     * will be made readable only to the current user, to the level that
     * is supported on the target filesystem.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If you pass in a non-%NULL `etag` value and `file` already exists, then
     * this value is compared to the current entity tag of the file, and if
     * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
     * generally means that the file has been changed since you last read
     * it. You can get the new etag from g_file_output_stream_get_etag()
     * after you've finished writing and closed the #GFileOutputStream. When
     * you load a new file you can use g_file_input_stream_query_info() to
     * get the etag of the file.
     * 
     * If `make_backup` is %TRUE, this function will attempt to make a
     * backup of the current file before overwriting it. If this fails
     * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
     * want to replace anyway, try again with `make_backup` set to %FALSE.
     * 
     * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
     * be returned, and if the file is some other form of non-regular file
     * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
     * file systems don't allow all file names, and may return an
     * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
     * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
     * possible too, and depend on what kind of filesystem the file is on.
     * @param etag an optional [entity tag][gfile-etag]   for the current #GFile, or #NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    replace(etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null): FileOutputStream
    /**
     * Asynchronously overwrites the file, replacing the contents,
     * possibly creating a backup copy of the file first.
     * 
     * For more details, see g_file_replace() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_replace_finish() to get the result
     * of the operation.
     * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    replace_async(etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of replace_async

    /**
     * Promisified version of {@link replace_async}
     * 
     * Asynchronously overwrites the file, replacing the contents,
     * possibly creating a backup copy of the file first.
     * 
     * For more details, see g_file_replace() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_replace_finish() to get the result
     * of the operation.
     * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
     */
    replace_async(etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileOutputStream>
    /**
     * Replaces the contents of `file` with `contents` of `length` bytes.
     * 
     * If `etag` is specified (not %NULL), any existing file must have that etag,
     * or the error %G_IO_ERROR_WRONG_ETAG will be returned.
     * 
     * If `make_backup` is %TRUE, this function will attempt to make a backup
     * of `file`. Internally, it uses g_file_replace(), so will try to replace the
     * file contents in the safest way possible. For example, atomic renames are
     * used when replacing local files’ contents.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * The returned `new_etag` can be used to verify that the file hasn't
     * changed the next time it is saved over.
     * @param contents a string containing the new contents for `file`
     * @param etag the old [entity-tag][gfile-etag] for the document,   or %NULL
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns %TRUE if successful. If an error has occurred, this function   will return %FALSE and set @error appropriately if present.
     */
    replace_contents(contents: Uint8Array, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null): [ /* returnType */ boolean, /* new_etag */ string | null ]
    // Has conflict: replace_contents_async(contents: Uint8Array, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of replace_contents_async

    /**
     * Promisified version of {@link replace_contents_async}
     * 
     * Starts an asynchronous replacement of `file` with the given
     * `contents` of `length` bytes. `etag` will replace the document's
     * current entity tag.
     * 
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_replace_contents_finish().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If `make_backup` is %TRUE, this function will attempt to
     * make a backup of `file`.
     * 
     * Note that no copy of `contents` will be made, so it must stay valid
     * until `callback` is called. See g_file_replace_contents_bytes_async()
     * for a #GBytes version that will automatically hold a reference to the
     * contents (without copying) for the duration of the call.
     * @param contents string of contents to replace the file with
     * @param etag a new [entity tag][gfile-etag] for the `file,` or %NULL
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: %TRUE on success, %FALSE on failure.
     */
    replace_contents_async(contents: Uint8Array, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null): globalThis.Promise</* new_etag */ string | null>
    /**
     * Same as g_file_replace_contents_async() but takes a #GBytes input instead.
     * This function will keep a ref on `contents` until the operation is done.
     * Unlike g_file_replace_contents_async() this allows forgetting about the
     * content without waiting for the callback.
     * 
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_replace_contents_finish().
     * @param contents a #GBytes
     * @param etag a new [entity tag][gfile-etag] for the `file,` or %NULL
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    replace_contents_bytes_async(contents: GLib.Bytes, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous replace of the given `file`. See
     * g_file_replace_contents_async(). Sets `new_etag` to the new entity
     * tag for the document, if present.
     * @param res a #GAsyncResult
     * @returns %TRUE on success, %FALSE on failure.
     */
    replace_contents_finish(res: AsyncResult): [ /* returnType */ boolean, /* new_etag */ string | null ]
    /**
     * Finishes an asynchronous file replace operation started with
     * g_file_replace_async().
     * @param res a #GAsyncResult
     * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
     */
    replace_finish(res: AsyncResult): FileOutputStream
    /**
     * Returns an output stream for overwriting the file in readwrite mode,
     * possibly creating a backup copy of the file first. If the file doesn't
     * exist, it will be created.
     * 
     * For details about the behaviour, see g_file_replace() which does the
     * same thing but returns an output stream only.
     * 
     * Note that in many non-local file cases read and write streams are not
     * supported, so make sure you really need to do read and write streaming,
     * rather than just opening for reading or writing.
     * @param etag an optional [entity tag][gfile-etag]   for the current #GFile, or #NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    replace_readwrite(etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null): FileIOStream
    /**
     * Asynchronously overwrites the file in read-write mode,
     * replacing the contents, possibly creating a backup copy
     * of the file first.
     * 
     * For more details, see g_file_replace_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_replace_readwrite_finish() to get
     * the result of the operation.
     * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    replace_readwrite_async(etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of replace_readwrite_async

    /**
     * Promisified version of {@link replace_readwrite_async}
     * 
     * Asynchronously overwrites the file in read-write mode,
     * replacing the contents, possibly creating a backup copy
     * of the file first.
     * 
     * For more details, see g_file_replace_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_replace_readwrite_finish() to get
     * the result of the operation.
     * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a #GFileIOStream, or %NULL on error.   Free the returned object with g_object_unref().
     */
    replace_readwrite_async(etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileIOStream>
    /**
     * Finishes an asynchronous file replace operation started with
     * g_file_replace_readwrite_async().
     * @param res a #GAsyncResult
     * @returns a #GFileIOStream, or %NULL on error.   Free the returned object with g_object_unref().
     */
    replace_readwrite_finish(res: AsyncResult): FileIOStream
    /**
     * Resolves a relative path for `file` to an absolute path.
     * 
     * This call does no blocking I/O.
     * 
     * If the `relative_path` is an absolute path name, the resolution
     * is done absolutely (without taking `file` path as base).
     * @param relative_path a given relative path string
     * @returns a #GFile for the resolved path.
     */
    resolve_relative_path(relative_path: string): File
    /**
     * Sets an attribute in the file with attribute name `attribute` to `value_p`.
     * 
     * Some attributes can be unset by setting `type` to
     * %G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p` to %NULL.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param attribute a string containing the attribute's name
     * @param type The type of the attribute
     * @param value_p a pointer to the value (or the pointer   itself if the type is a pointer type)
     * @param flags a set of #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the attribute was set, %FALSE otherwise.
     */
    set_attribute(attribute: string | null, type: FileAttributeType, value_p: any | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to `value`.
     * If `attribute` is of a different type, this operation will fail,
     * returning %FALSE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param attribute a string containing the attribute's name
     * @param value a string containing the attribute's new value
     * @param flags a #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
     */
    set_attribute_byte_string(attribute: string | null, value: string | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_INT32 to `value`.
     * If `attribute` is of a different type, this operation will fail.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param attribute a string containing the attribute's name
     * @param value a #gint32 containing the attribute's new value
     * @param flags a #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
     */
    set_attribute_int32(attribute: string | null, value: number, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_INT64 to `value`.
     * If `attribute` is of a different type, this operation will fail.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param attribute a string containing the attribute's name
     * @param value a #guint64 containing the attribute's new value
     * @param flags a #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the @attribute was successfully set, %FALSE otherwise.
     */
    set_attribute_int64(attribute: string | null, value: number, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_STRING to `value`.
     * If `attribute` is of a different type, this operation will fail.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param attribute a string containing the attribute's name
     * @param value a string containing the attribute's value
     * @param flags #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the @attribute was successfully set, %FALSE otherwise.
     */
    set_attribute_string(attribute: string | null, value: string | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to `value`.
     * If `attribute` is of a different type, this operation will fail.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param attribute a string containing the attribute's name
     * @param value a #guint32 containing the attribute's new value
     * @param flags a #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
     */
    set_attribute_uint32(attribute: string | null, value: number, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Sets `attribute` of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to `value`.
     * If `attribute` is of a different type, this operation will fail.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param attribute a string containing the attribute's name
     * @param value a #guint64 containing the attribute's new value
     * @param flags a #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the @attribute was successfully set to @value   in the @file, %FALSE otherwise.
     */
    set_attribute_uint64(attribute: string | null, value: number, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously sets the attributes of `file` with `info`.
     * 
     * For more details, see g_file_set_attributes_from_info(),
     * which is the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_set_attributes_finish() to get
     * the result of the operation.
     * @param info a #GFileInfo
     * @param flags a #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback
     */
    set_attributes_async(info: FileInfo, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of set_attributes_async

    /**
     * Promisified version of {@link set_attributes_async}
     * 
     * Asynchronously sets the attributes of `file` with `info`.
     * 
     * For more details, see g_file_set_attributes_from_info(),
     * which is the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_set_attributes_finish() to get
     * the result of the operation.
     * @param info a #GFileInfo
     * @param flags a #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: %TRUE if the attributes were set correctly, %FALSE otherwise.
     */
    set_attributes_async(info: FileInfo, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* info */ FileInfo>
    /**
     * Finishes setting an attribute started in g_file_set_attributes_async().
     * @param result a #GAsyncResult
     * @returns %TRUE if the attributes were set correctly, %FALSE otherwise.
     */
    set_attributes_finish(result: AsyncResult): [ /* returnType */ boolean, /* info */ FileInfo ]
    /**
     * Tries to set all attributes in the #GFileInfo on the target
     * values, not stopping on the first error.
     * 
     * If there is any error during this operation then `error` will
     * be set to the first error. Error on particular fields are flagged
     * by setting the "status" field in the attribute value to
     * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
     * also detect further errors.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param info a #GFileInfo
     * @param flags #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %FALSE if there was any error, %TRUE otherwise.
     */
    set_attributes_from_info(info: FileInfo, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Renames `file` to the specified display name.
     * 
     * The display name is converted from UTF-8 to the correct encoding
     * for the target filesystem if possible and the `file` is renamed to this.
     * 
     * If you want to implement a rename operation in the user interface the
     * edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
     * initial value in the rename widget, and then the result after editing
     * should be passed to g_file_set_display_name().
     * 
     * On success the resulting converted filename is returned.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param display_name a string
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFile specifying what @file was renamed to,   or %NULL if there was an error.   Free the returned object with g_object_unref().
     */
    set_display_name(display_name: string | null, cancellable: Cancellable | null): File
    /**
     * Asynchronously sets the display name for a given #GFile.
     * 
     * For more details, see g_file_set_display_name() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_set_display_name_finish() to get
     * the result of the operation.
     * @param display_name a string
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    set_display_name_async(display_name: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of set_display_name_async

    /**
     * Promisified version of {@link set_display_name_async}
     * 
     * Asynchronously sets the display name for a given #GFile.
     * 
     * For more details, see g_file_set_display_name() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_set_display_name_finish() to get
     * the result of the operation.
     * @param display_name a string
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: a #GFile or %NULL on error.   Free the returned object with g_object_unref().
     */
    set_display_name_async(display_name: string | null, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<File>
    /**
     * Finishes setting a display name started with
     * g_file_set_display_name_async().
     * @param res a #GAsyncResult
     * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
     */
    set_display_name_finish(res: AsyncResult): File
    /**
     * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
     * Using `start_operation,` you can request callbacks when, for instance,
     * passwords are needed during authentication.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_mount_mountable_finish() to get
     * the result of the operation.
     * @param flags flags affecting the operation
     * @param start_operation a #GMountOperation, or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied, or %NULL
     */
    start_mountable(flags: DriveStartFlags, start_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a start operation. See g_file_start_mountable() for details.
     * 
     * Finish an asynchronous start operation that was started
     * with g_file_start_mountable().
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
     */
    start_mountable_finish(result: AsyncResult): boolean
    /**
     * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_stop_mountable_finish() to get
     * the result of the operation.
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    stop_mountable(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a stop operation, see g_file_stop_mountable() for details.
     * 
     * Finish an asynchronous stop operation that was started
     * with g_file_stop_mountable().
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
     */
    stop_mountable_finish(result: AsyncResult): boolean
    /**
     * Checks if `file` supports
     * [thread-default contexts][g-main-context-push-thread-default-context].
     * If this returns %FALSE, you cannot perform asynchronous operations on
     * `file` in a thread that has a thread-default context.
     * @returns Whether or not @file supports thread-default contexts.
     */
    supports_thread_contexts(): boolean
    /**
     * Sends `file` to the "Trashcan", if possible. This is similar to
     * deleting it, but the user can recover it before emptying the trashcan.
     * Not all file systems support trashing, so this call can return the
     * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
     * mount option can be used to disable g_file_trash() support for certain
     * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE on successful trash, %FALSE otherwise.
     */
    trash(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously sends `file` to the Trash location, if possible.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    trash_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of trash_async

    /**
     * Promisified version of {@link trash_async}
     * 
     * Asynchronously sends `file` to the Trash location, if possible.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A Promise of: %TRUE on successful trash, %FALSE otherwise.
     */
    trash_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes an asynchronous file trashing operation, started with
     * g_file_trash_async().
     * @param result a #GAsyncResult
     * @returns %TRUE on successful trash, %FALSE otherwise.
     */
    trash_finish(result: AsyncResult): boolean
    /**
     * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_unmount_mountable_finish() to get
     * the result of the operation.
     * @param flags flags affecting the operation
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    unmount_mountable(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an unmount operation, see g_file_unmount_mountable() for details.
     * 
     * Finish an asynchronous unmount operation that was started
     * with g_file_unmount_mountable().
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
     */
    unmount_mountable_finish(result: AsyncResult): boolean
    /**
     * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_unmount_mountable_finish() to get
     * the result of the operation.
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    unmount_mountable_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an unmount operation,
     * see g_file_unmount_mountable_with_operation() for details.
     * 
     * Finish an asynchronous unmount operation that was started
     * with g_file_unmount_mountable_with_operation().
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
     */
    unmount_mountable_with_operation_finish(result: AsyncResult): boolean
    /**
     * Starts an asynchronous replacement of `file` with the given
     * `contents` of `length` bytes. `etag` will replace the document's
     * current entity tag.
     * 
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_replace_contents_finish().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If `make_backup` is %TRUE, this function will attempt to
     * make a backup of `file`.
     * 
     * Note that no copy of `contents` will be made, so it must stay valid
     * until `callback` is called. See g_file_replace_contents_bytes_async()
     * for a #GBytes version that will automatically hold a reference to the
     * contents (without copying) for the duration of the call.
     * @param contents string of contents to replace the file with
     * @param etag a new [entity tag][gfile-etag] for the `file,` or %NULL
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    replace_contents_async(contents: Uint8Array, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null): void

    // Own virtual methods of Gio-2.0.Gio.File

    /**
     * Gets an output stream for appending data to the file.
     * If the file doesn't already exist it is created.
     * 
     * By default files created are generally readable by everyone,
     * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
     * will be made readable only to the current user, to the level that
     * is supported on the target filesystem.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * Some file systems don't allow all file names, and may return an
     * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
     * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
     * possible too, and depend on what kind of filesystem the file is on.
     * @virtual 
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_append_to(flags: FileCreateFlags, cancellable: Cancellable | null): FileOutputStream
    /**
     * Asynchronously opens `file` for appending.
     * 
     * For more details, see g_file_append_to() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_append_to_finish() to get the result
     * of the operation.
     * @virtual 
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_append_to_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file append operation started with
     * g_file_append_to_async().
     * @virtual 
     * @param res #GAsyncResult
     * @returns a valid #GFileOutputStream   or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_append_to_finish(res: AsyncResult): FileOutputStream
    /**
     * Copies the file `source` to the location specified by `destination`.
     * Can not handle recursive copies of directories.
     * 
     * If the flag %G_FILE_COPY_OVERWRITE is specified an already
     * existing `destination` file is overwritten.
     * 
     * If the flag %G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
     * will be copied as symlinks, otherwise the target of the
     * `source` symlink will be copied.
     * 
     * If the flag %G_FILE_COPY_ALL_METADATA is specified then all the metadata
     * that is possible to copy is copied, not just the default subset (which,
     * for instance, does not include the owner, see #GFileInfo).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If `progress_callback` is not %NULL, then the operation can be monitored
     * by setting this to a #GFileProgressCallback function.
     * `progress_callback_data` will be passed to this function. It is guaranteed
     * that this callback will be called after all data has been transferred with
     * the total number of bytes copied during the operation.
     * 
     * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND error
     * is returned, independent on the status of the `destination`.
     * 
     * If %G_FILE_COPY_OVERWRITE is not specified and the target exists, then
     * the error %G_IO_ERROR_EXISTS is returned.
     * 
     * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
     * error is returned. If trying to overwrite a directory with a directory the
     * %G_IO_ERROR_WOULD_MERGE error is returned.
     * 
     * If the source is a directory and the target does not exist, or
     * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
     * %G_IO_ERROR_WOULD_RECURSE error is returned.
     * 
     * If you are interested in copying the #GFile object itself (not the on-disk
     * file), see g_file_dup().
     * @virtual 
     * @param destination destination #GFile
     * @param flags set of #GFileCopyFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param progress_callback function to callback with   progress information, or %NULL if progress information is not needed
     * @returns %TRUE on success, %FALSE otherwise.
     */
    vfunc_copy(destination: File, flags: FileCopyFlags, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null): boolean
    /**
     * Copies the file `source` to the location specified by `destination`
     * asynchronously. For details of the behaviour, see g_file_copy().
     * 
     * If `progress_callback` is not %NULL, then that function that will be called
     * just like in g_file_copy(). The callback will run in the default main context
     * of the thread calling g_file_copy_async() — the same context as `callback` is
     * run in.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_file_copy_finish() to get the result of the operation.
     * @virtual 
     * @param destination destination #GFile
     * @param flags set of #GFileCopyFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     */
    vfunc_copy_async(destination: File, flags: FileCopyFlags, io_priority: number, cancellable: Cancellable | null): void
    /**
     * Finishes copying the file started with g_file_copy_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a %TRUE on success, %FALSE on error.
     */
    vfunc_copy_finish(res: AsyncResult): boolean
    /**
     * Creates a new file and returns an output stream for writing to it.
     * The file must not already exist.
     * 
     * By default files created are generally readable by everyone,
     * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
     * will be made readable only to the current user, to the level
     * that is supported on the target filesystem.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If a file or directory with this name already exists the
     * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
     * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
     * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
     * be returned. Other errors are possible too, and depend on what kind
     * of filesystem the file is on.
     * @virtual 
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileOutputStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_create(flags: FileCreateFlags, cancellable: Cancellable | null): FileOutputStream
    /**
     * Asynchronously creates a new file and returns an output stream
     * for writing to it. The file must not already exist.
     * 
     * For more details, see g_file_create() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_create_finish() to get the result
     * of the operation.
     * @virtual 
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_create_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file create operation started with
     * g_file_create_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_create_finish(res: AsyncResult): FileOutputStream
    /**
     * Creates a new file and returns a stream for reading and
     * writing to it. The file must not already exist.
     * 
     * By default files created are generally readable by everyone,
     * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
     * will be made readable only to the current user, to the level
     * that is supported on the target filesystem.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If a file or directory with this name already exists, the
     * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
     * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
     * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
     * will be returned. Other errors are possible too, and depend on what
     * kind of filesystem the file is on.
     * 
     * Note that in many non-local file cases read and write streams are
     * not supported, so make sure you really need to do read and write
     * streaming, rather than just opening for reading or writing.
     * @virtual 
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileIOStream for the newly created   file, or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_create_readwrite(flags: FileCreateFlags, cancellable: Cancellable | null): FileIOStream
    /**
     * Asynchronously creates a new file and returns a stream
     * for reading and writing to it. The file must not already exist.
     * 
     * For more details, see g_file_create_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_create_readwrite_finish() to get
     * the result of the operation.
     * @virtual 
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_create_readwrite_async(flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file create operation started with
     * g_file_create_readwrite_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_create_readwrite_finish(res: AsyncResult): FileIOStream
    /**
     * Deletes a file. If the `file` is a directory, it will only be
     * deleted if it is empty. This has the same semantics as g_unlink().
     * 
     * If `file` doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
     * for deletion to be implemented avoiding
     * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
     * 
     * ```
     * g_autoptr(GError) local_error = NULL;
     * if (!g_file_delete (my_file, my_cancellable, &local_error) &&
     *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
     *   {
     *     // deletion failed for some reason other than the file not existing:
     *     // so report the error
     *     g_warning ("Failed to delete %s: %s",
     *                g_file_peek_path (my_file), local_error->message);
     *   }
     * ```
     * 
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the file was deleted. %FALSE otherwise.
     */
    vfunc_delete_file(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously delete a file. If the `file` is a directory, it will
     * only be deleted if it is empty.  This has the same semantics as
     * g_unlink().
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_delete_file_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes deleting a file started with g_file_delete_async().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the file was deleted. %FALSE otherwise.
     */
    vfunc_delete_file_finish(result: AsyncResult): boolean
    /**
     * Duplicates a #GFile handle. This operation does not duplicate
     * the actual file or directory represented by the #GFile; see
     * g_file_copy() if attempting to copy a file.
     * 
     * g_file_dup() is useful when a second handle is needed to the same underlying
     * file, for use in a separate thread (#GFile is not thread-safe). For use
     * within the same thread, use g_object_ref() to increment the existing object’s
     * reference count.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns a new #GFile that is a duplicate   of the given #GFile.
     */
    vfunc_dup(): File
    /**
     * Starts an asynchronous eject on a mountable.
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_eject_mountable_finish().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param flags flags affecting the operation
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    vfunc_eject_mountable(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous eject operation started by
     * g_file_eject_mountable().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
     */
    vfunc_eject_mountable_finish(result: AsyncResult): boolean
    /**
     * Starts an asynchronous eject on a mountable.
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_eject_mountable_with_operation_finish().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    vfunc_eject_mountable_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous eject operation started by
     * g_file_eject_mountable_with_operation().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the @file was ejected successfully.   %FALSE otherwise.
     */
    vfunc_eject_mountable_with_operation_finish(result: AsyncResult): boolean
    /**
     * Gets the requested information about the files in a directory.
     * The result is a #GFileEnumerator object that will give out
     * #GFileInfo objects for all the files in the directory.
     * 
     * The `attributes` value is a string that specifies the file
     * attributes that should be gathered. It is not an error if
     * it's not possible to read a particular requested attribute
     * from a file - it just won't be set. `attributes` should
     * be a comma-separated list of attributes or attribute wildcards.
     * The wildcard "*" means all attributes, and a wildcard like
     * "standard::*" means all attributes in the standard namespace.
     * An example attribute query be "standard::*,owner::user".
     * The standard attributes are available as defines, like
     * %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
     * always be specified if you plan to call g_file_enumerator_get_child() or
     * g_file_enumerator_iterate() on the returned enumerator.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
     * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
     * error will be returned. Other errors are possible too.
     * @virtual 
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns A #GFileEnumerator if successful,   %NULL on error. Free the returned object with g_object_unref().
     */
    vfunc_enumerate_children(attributes: string | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null): FileEnumerator
    /**
     * Asynchronously gets the requested information about the files
     * in a directory. The result is a #GFileEnumerator object that will
     * give out #GFileInfo objects for all the files in the directory.
     * 
     * For more details, see g_file_enumerate_children() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_enumerate_children_finish() to get the result of
     * the operation.
     * @virtual 
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the   request is satisfied
     */
    vfunc_enumerate_children_async(attributes: string | null, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an async enumerate children operation.
     * See g_file_enumerate_children_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a #GFileEnumerator or %NULL   if an error occurred.   Free the returned object with g_object_unref().
     */
    vfunc_enumerate_children_finish(res: AsyncResult): FileEnumerator
    /**
     * Checks if the two given #GFiles refer to the same file.
     * 
     * Note that two #GFiles that differ can still refer to the same
     * file on the filesystem due to various forms of filename
     * aliasing.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @param file2 the second #GFile
     * @returns %TRUE if @file1 and @file2 are equal.
     */
    vfunc_equal(file2: File): boolean
    /**
     * Gets a #GMount for the #GFile.
     * 
     * #GMount is returned only for user interesting locations, see
     * #GVolumeMonitor. If the #GFileIface for `file` does not have a #mount,
     * `error` will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GMount where the @file is located   or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_find_enclosing_mount(cancellable: Cancellable | null): Mount
    /**
     * Asynchronously gets the mount for the file.
     * 
     * For more details, see g_file_find_enclosing_mount() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_find_enclosing_mount_finish() to
     * get the result of the operation.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_find_enclosing_mount_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous find mount request.
     * See g_file_find_enclosing_mount_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns #GMount for given @file or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_find_enclosing_mount_finish(res: AsyncResult): Mount
    /**
     * Gets the base name (the last component of the path) for a given #GFile.
     * 
     * If called for the top level of a system (such as the filesystem root
     * or a uri like sftp://host/) it will return a single directory separator
     * (and on Windows, possibly a drive letter).
     * 
     * The base name is a byte string (not UTF-8). It has no defined encoding
     * or rules other than it may not contain zero bytes.  If you want to use
     * filenames in a user interface you should use the display name that you
     * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
     * attribute with g_file_query_info().
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns string containing the #GFile's   base name, or %NULL if given #GFile is invalid. The returned string   should be freed with g_free() when no longer needed.
     */
    vfunc_get_basename(): string | null
    /**
     * Gets the child of `file` for a given `display_name` (i.e. a UTF-8
     * version of the name). If this function fails, it returns %NULL
     * and `error` will be set. This is very useful when constructing a
     * #GFile for a new file and the user entered the filename in the
     * user interface, for instance when you select a directory and
     * type a filename in the file selector.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @param display_name string to a possible child
     * @returns a #GFile to the specified child, or   %NULL if the display name couldn't be converted.   Free the returned object with g_object_unref().
     */
    vfunc_get_child_for_display_name(display_name: string | null): File
    /**
     * Gets the parent directory for the `file`.
     * If the `file` represents the root directory of the
     * file system, then %NULL will be returned.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns a #GFile structure to the   parent of the given #GFile or %NULL if there is no parent. Free   the returned object with g_object_unref().
     */
    vfunc_get_parent(): File | null
    /**
     * Gets the parse name of the `file`.
     * A parse name is a UTF-8 string that describes the
     * file such that one can get the #GFile back using
     * g_file_parse_name().
     * 
     * This is generally used to show the #GFile as a nice
     * full-pathname kind of string in a user interface,
     * like in a location entry.
     * 
     * For local files with names that can safely be converted
     * to UTF-8 the pathname is used, otherwise the IRI is used
     * (a form of URI that allows UTF-8 characters unescaped).
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns a string containing the #GFile's parse name.   The returned string should be freed with g_free()   when no longer needed.
     */
    vfunc_get_parse_name(): string | null
    /**
     * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
     * guaranteed to be an absolute, canonical path. It might contain symlinks.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns string containing the #GFile's path,   or %NULL if no such path exists. The returned string should be freed   with g_free() when no longer needed.
     */
    vfunc_get_path(): string | null
    /**
     * Gets the path for `descendant` relative to `parent`.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @param descendant input #GFile
     * @returns string with the relative path from   @descendant to @parent, or %NULL if @descendant doesn't have @parent as   prefix. The returned string should be freed with g_free() when   no longer needed.
     */
    vfunc_get_relative_path(descendant: File): string | null
    /**
     * Gets the URI for the `file`.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns a string containing the #GFile's URI. If the #GFile was constructed   with an invalid URI, an invalid URI is returned.   The returned string should be freed with g_free()   when no longer needed.
     */
    vfunc_get_uri(): string | null
    /**
     * Gets the URI scheme for a #GFile.
     * RFC 3986 decodes the scheme as:
     * 
     * ```
     * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
     * ```
     * 
     * Common schemes include "file", "http", "ftp", etc.
     * 
     * The scheme can be different from the one used to construct the #GFile,
     * in that it might be replaced with one that is logically equivalent to the #GFile.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns a string containing the URI scheme for the given   #GFile or %NULL if the #GFile was constructed with an invalid URI. The   returned string should be freed with g_free() when no longer needed.
     */
    vfunc_get_uri_scheme(): string | null
    /**
     * Checks to see if a #GFile has a given URI scheme.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @param uri_scheme a string containing a URI scheme
     * @returns %TRUE if #GFile's backend supports the   given URI scheme, %FALSE if URI scheme is %NULL,   not supported, or #GFile is invalid.
     */
    vfunc_has_uri_scheme(uri_scheme: string | null): boolean
    /**
     * Creates a hash value for a #GFile.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns 0 if @file is not a valid #GFile, otherwise an   integer that can be used as hash value for the #GFile.   This function is intended for easily hashing a #GFile to   add to a #GHashTable or similar data structure.
     */
    vfunc_hash(): number
    /**
     * Checks to see if a file is native to the platform.
     * 
     * A native file is one expressed in the platform-native filename format,
     * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
     * as it might be on a locally mounted remote filesystem.
     * 
     * On some systems non-native files may be available using the native
     * filesystem via a userspace filesystem (FUSE), in these cases this call
     * will return %FALSE, but g_file_get_path() will still return a native path.
     * 
     * This call does no blocking I/O.
     * @virtual 
     * @returns %TRUE if @file is native
     */
    vfunc_is_native(): boolean
    /**
     * Creates a directory. Note that this will only create a child directory
     * of the immediate parent directory of the path or URI given by the #GFile.
     * To recursively create directories, see g_file_make_directory_with_parents().
     * This function will fail if the parent directory does not exist, setting
     * `error` to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
     * creating directories, this function will fail, setting `error` to
     * %G_IO_ERROR_NOT_SUPPORTED.
     * 
     * For a local #GFile the newly created directory will have the default
     * (current) ownership and permissions of the current process.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE on successful creation, %FALSE otherwise.
     */
    vfunc_make_directory(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously creates a directory.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_make_directory_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous directory creation, started with
     * g_file_make_directory_async().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE on successful directory creation, %FALSE otherwise.
     */
    vfunc_make_directory_finish(result: AsyncResult): boolean
    /**
     * Creates a symbolic link named `file` which contains the string
     * `symlink_value`.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param symlink_value a string with the path for the target   of the new symlink
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE on the creation of a new symlink, %FALSE otherwise.
     */
    vfunc_make_symbolic_link(symlink_value: string, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously creates a symbolic link named `file` which contains the
     * string `symlink_value`.
     * @virtual 
     * @param symlink_value a string with the path for the target   of the new symlink
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_make_symbolic_link_async(symlink_value: string, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous symbolic link creation, started with
     * g_file_make_symbolic_link_async().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE on successful directory creation, %FALSE otherwise.
     */
    vfunc_make_symbolic_link_finish(result: AsyncResult): boolean
    /**
     * Collects the results from an earlier call to
     * g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
     * more information.
     * @virtual 
     * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
     * @returns %TRUE if successful, with the out parameters set.   %FALSE otherwise, with @error set.
     */
    vfunc_measure_disk_usage_finish(result: AsyncResult): [ /* returnType */ boolean, /* disk_usage */ number, /* num_dirs */ number, /* num_files */ number ]
    /**
     * Obtains a directory monitor for the given file.
     * This may fail if directory monitoring is not supported.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * It does not make sense for `flags` to contain
     * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
     * directories.  It is not possible to monitor all the files in a
     * directory for changes made via hard links; if you want to do this then
     * you must register individual watches with g_file_monitor().
     * @virtual 
     * @param flags a set of #GFileMonitorFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_monitor_dir(flags: FileMonitorFlags, cancellable: Cancellable | null): FileMonitor
    /**
     * Obtains a file monitor for the given file. If no file notification
     * mechanism exists, then regular polling of the file is used.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If `flags` contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
     * will also attempt to report changes made to the file via another
     * filename (ie, a hard link). Without this flag, you can only rely on
     * changes made through the filename contained in `file` to be
     * reported. Using this flag may result in an increase in resource
     * usage, and may not have any effect depending on the #GFileMonitor
     * backend and/or filesystem type.
     * @virtual 
     * @param flags a set of #GFileMonitorFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileMonitor for the given @file,   or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_monitor_file(flags: FileMonitorFlags, cancellable: Cancellable | null): FileMonitor
    /**
     * Starts a `mount_operation,` mounting the volume that contains
     * the file `location`.
     * 
     * When this operation has completed, `callback` will be called with
     * `user_user` data, and the operation can be finalized with
     * g_file_mount_enclosing_volume_finish().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation   or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    vfunc_mount_enclosing_volume(flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a mount operation started by g_file_mount_enclosing_volume().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if successful. If an error has occurred,   this function will return %FALSE and set @error   appropriately if present.
     */
    vfunc_mount_enclosing_volume_finish(result: AsyncResult): boolean
    /**
     * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
     * Using `mount_operation,` you can request callbacks when, for instance,
     * passwords are needed during authentication.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_mount_mountable_finish() to get
     * the result of the operation.
     * @virtual 
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    vfunc_mount_mountable(flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a mount operation. See g_file_mount_mountable() for details.
     * 
     * Finish an asynchronous mount operation that was started
     * with g_file_mount_mountable().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_mount_mountable_finish(result: AsyncResult): File
    /**
     * Tries to move the file or directory `source` to the location specified
     * by `destination`. If native move operations are supported then this is
     * used, otherwise a copy + delete fallback is used. The native
     * implementation may support moving directories (for instance on moves
     * inside the same filesystem), but the fallback code does not.
     * 
     * If the flag %G_FILE_COPY_OVERWRITE is specified an already
     * existing `destination` file is overwritten.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If `progress_callback` is not %NULL, then the operation can be monitored
     * by setting this to a #GFileProgressCallback function.
     * `progress_callback_data` will be passed to this function. It is
     * guaranteed that this callback will be called after all data has been
     * transferred with the total number of bytes copied during the operation.
     * 
     * If the `source` file does not exist, then the %G_IO_ERROR_NOT_FOUND
     * error is returned, independent on the status of the `destination`.
     * 
     * If %G_FILE_COPY_OVERWRITE is not specified and the target exists,
     * then the error %G_IO_ERROR_EXISTS is returned.
     * 
     * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
     * error is returned. If trying to overwrite a directory with a directory the
     * %G_IO_ERROR_WOULD_MERGE error is returned.
     * 
     * If the source is a directory and the target does not exist, or
     * %G_FILE_COPY_OVERWRITE is specified and the target is a file, then
     * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
     * move operation isn't available).
     * @virtual 
     * @param destination #GFile pointing to the destination location
     * @param flags set of #GFileCopyFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param progress_callback #GFileProgressCallback   function for updates
     * @returns %TRUE on successful move, %FALSE otherwise.
     */
    vfunc_move(destination: File, flags: FileCopyFlags, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null): boolean
    /**
     * Asynchronously moves a file `source` to the location of `destination`. For details of the behaviour, see g_file_move().
     * 
     * If `progress_callback` is not %NULL, then that function that will be called
     * just like in g_file_move(). The callback will run in the default main context
     * of the thread calling g_file_move_async() — the same context as `callback` is
     * run in.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_file_move_finish() to get the result of the operation.
     * @virtual 
     * @param destination #GFile pointing to the destination location
     * @param flags set of #GFileCopyFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param progress_callback #GFileProgressCallback   function for updates
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_move_async(destination: File, flags: FileCopyFlags, io_priority: number, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file movement, started with
     * g_file_move_async().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE on successful file move, %FALSE otherwise.
     */
    vfunc_move_finish(result: AsyncResult): boolean
    /**
     * Opens an existing file for reading and writing. The result is
     * a #GFileIOStream that can be used to read and write the contents
     * of the file.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
     * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
     * error will be returned. Other errors are possible too, and depend on
     * what kind of filesystem the file is on. Note that in many non-local
     * file cases read and write streams are not supported, so make sure you
     * really need to do read and write streaming, rather than just opening
     * for reading or writing.
     * @virtual 
     * @param cancellable a #GCancellable
     * @returns #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_open_readwrite(cancellable: Cancellable | null): FileIOStream
    /**
     * Asynchronously opens `file` for reading and writing.
     * 
     * For more details, see g_file_open_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_open_readwrite_finish() to get
     * the result of the operation.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_open_readwrite_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file read operation started with
     * g_file_open_readwrite_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_open_readwrite_finish(res: AsyncResult): FileIOStream
    /**
     * Polls a file of type %G_FILE_TYPE_MOUNTABLE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_mount_mountable_finish() to get
     * the result of the operation.
     * @virtual 
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    vfunc_poll_mountable(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a poll operation. See g_file_poll_mountable() for details.
     * 
     * Finish an asynchronous poll operation that was polled
     * with g_file_poll_mountable().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
     */
    vfunc_poll_mountable_finish(result: AsyncResult): boolean
    /**
     * Checks whether `file` has the prefix specified by `prefix`.
     * 
     * In other words, if the names of initial elements of `file'`s
     * pathname match `prefix`. Only full pathname elements are matched,
     * so a path like /foo is not considered a prefix of /foobar, only
     * of /foo/bar.
     * 
     * A #GFile is not a prefix of itself. If you want to check for
     * equality, use g_file_equal().
     * 
     * This call does no I/O, as it works purely on names. As such it can
     * sometimes return %FALSE even if `file` is inside a `prefix` (from a
     * filesystem point of view), because the prefix of `file` is an alias
     * of `prefix`.
     * @virtual 
     * @param file input #GFile
     * @returns %TRUE if the @file's parent, grandparent, etc is @prefix,   %FALSE otherwise.
     */
    vfunc_prefix_matches(file: File): boolean
    /**
     * Similar to g_file_query_info(), but obtains information
     * about the filesystem the `file` is on, rather than the file itself.
     * For instance the amount of space available and the type of
     * the filesystem.
     * 
     * The `attributes` value is a string that specifies the attributes
     * that should be gathered. It is not an error if it's not possible
     * to read a particular requested attribute from a file - it just
     * won't be set. `attributes` should be a comma-separated list of
     * attributes or attribute wildcards. The wildcard "*" means all
     * attributes, and a wildcard like "filesystem::*" means all attributes
     * in the filesystem namespace. The standard namespace for filesystem
     * attributes is "filesystem". Common attributes of interest are
     * %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
     * in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
     * and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
     * be returned. Other errors are possible too, and depend on what
     * kind of filesystem the file is on.
     * @virtual 
     * @param attributes an attribute query string
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileInfo or %NULL if there was an error.   Free the returned object with g_object_unref().
     */
    vfunc_query_filesystem_info(attributes: string | null, cancellable: Cancellable | null): FileInfo
    /**
     * Asynchronously gets the requested information about the filesystem
     * that the specified `file` is on. The result is a #GFileInfo object
     * that contains key-value attributes (such as type or size for the
     * file).
     * 
     * For more details, see g_file_query_filesystem_info() which is the
     * synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_query_info_finish() to get the result of the
     * operation.
     * @virtual 
     * @param attributes an attribute query string
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_query_filesystem_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous filesystem info query.
     * See g_file_query_filesystem_info_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns #GFileInfo for given @file   or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_query_filesystem_info_finish(res: AsyncResult): FileInfo
    /**
     * Gets the requested information about specified `file`.
     * The result is a #GFileInfo object that contains key-value
     * attributes (such as the type or size of the file).
     * 
     * The `attributes` value is a string that specifies the file
     * attributes that should be gathered. It is not an error if
     * it's not possible to read a particular requested attribute
     * from a file - it just won't be set. `attributes` should be a
     * comma-separated list of attributes or attribute wildcards.
     * The wildcard "*" means all attributes, and a wildcard like
     * "standard::*" means all attributes in the standard namespace.
     * An example attribute query be "standard::*,owner::user".
     * The standard attributes are available as defines, like
     * %G_FILE_ATTRIBUTE_STANDARD_NAME.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * For symlinks, normally the information about the target of the
     * symlink is returned, rather than information about the symlink
     * itself. However if you pass %G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
     * in `flags` the information about the symlink itself will be returned.
     * Also, for symlinks that point to non-existing files the information
     * about the symlink itself will be returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
     * returned. Other errors are possible too, and depend on what kind of
     * filesystem the file is on.
     * @virtual 
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileInfo for the given @file, or %NULL   on error. Free the returned object with g_object_unref().
     */
    vfunc_query_info(attributes: string | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null): FileInfo
    /**
     * Asynchronously gets the requested information about specified `file`.
     * The result is a #GFileInfo object that contains key-value attributes
     * (such as type or size for the file).
     * 
     * For more details, see g_file_query_info() which is the synchronous
     * version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can
     * then call g_file_query_info_finish() to get the result of the operation.
     * @virtual 
     * @param attributes an attribute query string
     * @param flags a set of #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the   request is satisfied
     */
    vfunc_query_info_async(attributes: string | null, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file info query.
     * See g_file_query_info_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns #GFileInfo for given @file   or %NULL on error. Free the returned object with   g_object_unref().
     */
    vfunc_query_info_finish(res: AsyncResult): FileInfo
    /**
     * Obtain the list of settable attributes for the file.
     * 
     * Returns the type and full attribute name of all the attributes
     * that can be set on this file. This doesn't mean setting it will
     * always succeed though, you might get an access failure, or some
     * specific file may not support a specific attribute.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileAttributeInfoList describing the settable attributes.   When you are done with it, release it with   g_file_attribute_info_list_unref()
     */
    vfunc_query_settable_attributes(cancellable: Cancellable | null): FileAttributeInfoList
    /**
     * Obtain the list of attribute namespaces where new attributes
     * can be created by a user. An example of this is extended
     * attributes (in the "xattr" namespace).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileAttributeInfoList describing the writable namespaces.   When you are done with it, release it with   g_file_attribute_info_list_unref()
     */
    vfunc_query_writable_namespaces(cancellable: Cancellable | null): FileAttributeInfoList
    /**
     * Asynchronously opens `file` for reading.
     * 
     * For more details, see g_file_read() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_read_finish() to get the result
     * of the operation.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_read_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file read operation started with
     * g_file_read_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_read_finish(res: AsyncResult): FileInputStream
    /**
     * Opens a file for reading. The result is a #GFileInputStream that
     * can be used to read the contents of the file.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
     * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
     * error will be returned. Other errors are possible too, and depend
     * on what kind of filesystem the file is on.
     * @virtual 
     * @param cancellable a #GCancellable
     * @returns #GFileInputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_read_fn(cancellable: Cancellable | null): FileInputStream
    /**
     * Returns an output stream for overwriting the file, possibly
     * creating a backup copy of the file first. If the file doesn't exist,
     * it will be created.
     * 
     * This will try to replace the file in the safest way possible so
     * that any errors during the writing will not affect an already
     * existing copy of the file. For instance, for local files it
     * may write to a temporary file and then atomically rename over
     * the destination when the stream is closed.
     * 
     * By default files created are generally readable by everyone,
     * but if you pass %G_FILE_CREATE_PRIVATE in `flags` the file
     * will be made readable only to the current user, to the level that
     * is supported on the target filesystem.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled
     * by triggering the cancellable object from another thread. If the
     * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
     * returned.
     * 
     * If you pass in a non-%NULL `etag` value and `file` already exists, then
     * this value is compared to the current entity tag of the file, and if
     * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
     * generally means that the file has been changed since you last read
     * it. You can get the new etag from g_file_output_stream_get_etag()
     * after you've finished writing and closed the #GFileOutputStream. When
     * you load a new file you can use g_file_input_stream_query_info() to
     * get the etag of the file.
     * 
     * If `make_backup` is %TRUE, this function will attempt to make a
     * backup of the current file before overwriting it. If this fails
     * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
     * want to replace anyway, try again with `make_backup` set to %FALSE.
     * 
     * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
     * be returned, and if the file is some other form of non-regular file
     * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
     * file systems don't allow all file names, and may return an
     * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
     * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
     * possible too, and depend on what kind of filesystem the file is on.
     * @virtual 
     * @param etag an optional [entity tag][gfile-etag]   for the current #GFile, or #NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileOutputStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_replace(etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null): FileOutputStream
    /**
     * Asynchronously overwrites the file, replacing the contents,
     * possibly creating a backup copy of the file first.
     * 
     * For more details, see g_file_replace() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_replace_finish() to get the result
     * of the operation.
     * @virtual 
     * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_replace_async(etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file replace operation started with
     * g_file_replace_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a #GFileOutputStream, or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_replace_finish(res: AsyncResult): FileOutputStream
    /**
     * Returns an output stream for overwriting the file in readwrite mode,
     * possibly creating a backup copy of the file first. If the file doesn't
     * exist, it will be created.
     * 
     * For details about the behaviour, see g_file_replace() which does the
     * same thing but returns an output stream only.
     * 
     * Note that in many non-local file cases read and write streams are not
     * supported, so make sure you really need to do read and write streaming,
     * rather than just opening for reading or writing.
     * @virtual 
     * @param etag an optional [entity tag][gfile-etag]   for the current #GFile, or #NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFileIOStream or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_replace_readwrite(etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null): FileIOStream
    /**
     * Asynchronously overwrites the file in read-write mode,
     * replacing the contents, possibly creating a backup copy
     * of the file first.
     * 
     * For more details, see g_file_replace_readwrite() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_replace_readwrite_finish() to get
     * the result of the operation.
     * @virtual 
     * @param etag an [entity tag][gfile-etag] for the current #GFile,   or %NULL to ignore
     * @param make_backup %TRUE if a backup should be created
     * @param flags a set of #GFileCreateFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_replace_readwrite_async(etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file replace operation started with
     * g_file_replace_readwrite_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a #GFileIOStream, or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_replace_readwrite_finish(res: AsyncResult): FileIOStream
    /**
     * Resolves a relative path for `file` to an absolute path.
     * 
     * This call does no blocking I/O.
     * 
     * If the `relative_path` is an absolute path name, the resolution
     * is done absolutely (without taking `file` path as base).
     * @virtual 
     * @param relative_path a given relative path string
     * @returns a #GFile for the resolved path.
     */
    vfunc_resolve_relative_path(relative_path: string): File
    /**
     * Sets an attribute in the file with attribute name `attribute` to `value_p`.
     * 
     * Some attributes can be unset by setting `type` to
     * %G_FILE_ATTRIBUTE_TYPE_INVALID and `value_p` to %NULL.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param attribute a string containing the attribute's name
     * @param type The type of the attribute
     * @param value_p a pointer to the value (or the pointer   itself if the type is a pointer type)
     * @param flags a set of #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE if the attribute was set, %FALSE otherwise.
     */
    vfunc_set_attribute(attribute: string | null, type: FileAttributeType, value_p: any | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously sets the attributes of `file` with `info`.
     * 
     * For more details, see g_file_set_attributes_from_info(),
     * which is the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_set_attributes_finish() to get
     * the result of the operation.
     * @virtual 
     * @param info a #GFileInfo
     * @param flags a #GFileQueryInfoFlags
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback
     */
    vfunc_set_attributes_async(info: FileInfo, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes setting an attribute started in g_file_set_attributes_async().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the attributes were set correctly, %FALSE otherwise.
     */
    vfunc_set_attributes_finish(result: AsyncResult): [ /* returnType */ boolean, /* info */ FileInfo ]
    /**
     * Tries to set all attributes in the #GFileInfo on the target
     * values, not stopping on the first error.
     * 
     * If there is any error during this operation then `error` will
     * be set to the first error. Error on particular fields are flagged
     * by setting the "status" field in the attribute value to
     * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
     * also detect further errors.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param info a #GFileInfo
     * @param flags #GFileQueryInfoFlags
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %FALSE if there was any error, %TRUE otherwise.
     */
    vfunc_set_attributes_from_info(info: FileInfo, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * Renames `file` to the specified display name.
     * 
     * The display name is converted from UTF-8 to the correct encoding
     * for the target filesystem if possible and the `file` is renamed to this.
     * 
     * If you want to implement a rename operation in the user interface the
     * edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
     * initial value in the rename widget, and then the result after editing
     * should be passed to g_file_set_display_name().
     * 
     * On success the resulting converted filename is returned.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param display_name a string
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns a #GFile specifying what @file was renamed to,   or %NULL if there was an error.   Free the returned object with g_object_unref().
     */
    vfunc_set_display_name(display_name: string | null, cancellable: Cancellable | null): File
    /**
     * Asynchronously sets the display name for a given #GFile.
     * 
     * For more details, see g_file_set_display_name() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_set_display_name_finish() to get
     * the result of the operation.
     * @virtual 
     * @param display_name a string
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_set_display_name_async(display_name: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes setting a display name started with
     * g_file_set_display_name_async().
     * @virtual 
     * @param res a #GAsyncResult
     * @returns a #GFile or %NULL on error.   Free the returned object with g_object_unref().
     */
    vfunc_set_display_name_finish(res: AsyncResult): File
    /**
     * Starts a file of type %G_FILE_TYPE_MOUNTABLE.
     * Using `start_operation,` you can request callbacks when, for instance,
     * passwords are needed during authentication.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_mount_mountable_finish() to get
     * the result of the operation.
     * @virtual 
     * @param flags flags affecting the operation
     * @param start_operation a #GMountOperation, or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied, or %NULL
     */
    vfunc_start_mountable(flags: DriveStartFlags, start_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a start operation. See g_file_start_mountable() for details.
     * 
     * Finish an asynchronous start operation that was started
     * with g_file_start_mountable().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully. %FALSE otherwise.
     */
    vfunc_start_mountable_finish(result: AsyncResult): boolean
    /**
     * Stops a file of type %G_FILE_TYPE_MOUNTABLE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_stop_mountable_finish() to get
     * the result of the operation.
     * @virtual 
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction.
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    vfunc_stop_mountable(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a stop operation, see g_file_stop_mountable() for details.
     * 
     * Finish an asynchronous stop operation that was started
     * with g_file_stop_mountable().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
     */
    vfunc_stop_mountable_finish(result: AsyncResult): boolean
    /**
     * Sends `file` to the "Trashcan", if possible. This is similar to
     * deleting it, but the user can recover it before emptying the trashcan.
     * Not all file systems support trashing, so this call can return the
     * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
     * mount option can be used to disable g_file_trash() support for certain
     * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @returns %TRUE on successful trash, %FALSE otherwise.
     */
    vfunc_trash(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously sends `file` to the Trash location, if possible.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied
     */
    vfunc_trash_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous file trashing operation, started with
     * g_file_trash_async().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE on successful trash, %FALSE otherwise.
     */
    vfunc_trash_finish(result: AsyncResult): boolean
    /**
     * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_unmount_mountable_finish() to get
     * the result of the operation.
     * @virtual 
     * @param flags flags affecting the operation
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    vfunc_unmount_mountable(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an unmount operation, see g_file_unmount_mountable() for details.
     * 
     * Finish an asynchronous unmount operation that was started
     * with g_file_unmount_mountable().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
     */
    vfunc_unmount_mountable_finish(result: AsyncResult): boolean
    /**
     * Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_file_unmount_mountable_finish() to get
     * the result of the operation.
     * @virtual 
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation,   or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object,   %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call   when the request is satisfied, or %NULL
     */
    vfunc_unmount_mountable_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an unmount operation,
     * see g_file_unmount_mountable_with_operation() for details.
     * 
     * Finish an asynchronous unmount operation that was started
     * with g_file_unmount_mountable_with_operation().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the operation finished successfully.   %FALSE otherwise.
     */
    vfunc_unmount_mountable_with_operation_finish(result: AsyncResult): boolean

    // Class property signals of Gio-2.0.Gio.File

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GFile is a high level abstraction for manipulating files on a
 * virtual file system. #GFiles are lightweight, immutable objects
 * that do no I/O upon creation. It is necessary to understand that
 * #GFile objects do not represent files, merely an identifier for a
 * file. All file content I/O is implemented as streaming operations
 * (see #GInputStream and #GOutputStream).
 * 
 * To construct a #GFile, you can use:
 * - g_file_new_for_path() if you have a path.
 * - g_file_new_for_uri() if you have a URI.
 * - g_file_new_for_commandline_arg() for a command line argument.
 * - g_file_new_tmp() to create a temporary file from a template.
 * - g_file_new_tmp_async() to asynchronously create a temporary file.
 * - g_file_new_tmp_dir_async() to asynchronously create a temporary directory.
 * - g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
 * - g_file_new_build_filename() to create a file from path elements.
 * 
 * One way to think of a #GFile is as an abstraction of a pathname. For
 * normal files the system pathname is what is stored internally, but as
 * #GFiles are extensible it could also be something else that corresponds
 * to a pathname in a userspace implementation of a filesystem.
 * 
 * #GFiles make up hierarchies of directories and files that correspond to
 * the files on a filesystem. You can move through the file system with
 * #GFile using g_file_get_parent() to get an identifier for the parent
 * directory, g_file_get_child() to get a child within a directory,
 * g_file_resolve_relative_path() to resolve a relative path between two
 * #GFiles. There can be multiple hierarchies, so you may not end up at
 * the same root if you repeatedly call g_file_get_parent() on two different
 * files.
 * 
 * All #GFiles have a basename (get with g_file_get_basename()). These names
 * are byte strings that are used to identify the file on the filesystem
 * (relative to its parent directory) and there is no guarantees that they
 * have any particular charset encoding or even make any sense at all. If
 * you want to use filenames in a user interface you should use the display
 * name that you can get by requesting the
 * %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().
 * This is guaranteed to be in UTF-8 and can be used in a user interface.
 * But always store the real basename or the #GFile to use to actually
 * access the file, because there is no way to go from a display name to
 * the actual name.
 * 
 * Using #GFile as an identifier has the same weaknesses as using a path
 * in that there may be multiple aliases for the same file. For instance,
 * hard or soft links may cause two different #GFiles to refer to the same
 * file. Other possible causes for aliases are: case insensitive filesystems,
 * short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
 * check if two #GFiles point to the same file you can query for the
 * %G_FILE_ATTRIBUTE_ID_FILE attribute. Note that #GFile does some trivial
 * canonicalization of pathnames passed in, so that trivial differences in
 * the path string used at creation (duplicated slashes, slash at end of
 * path, "." or ".." path segments, etc) does not create different #GFiles.
 * 
 * Many #GFile operations have both synchronous and asynchronous versions
 * to suit your application. Asynchronous versions of synchronous functions
 * simply have _async() appended to their function names. The asynchronous
 * I/O functions call a #GAsyncReadyCallback which is then used to finalize
 * the operation, producing a GAsyncResult which is then passed to the
 * function's matching _finish() operation.
 * 
 * It is highly recommended to use asynchronous calls when running within a
 * shared main loop, such as in the main thread of an application. This avoids
 * I/O operations blocking other sources on the main loop from being dispatched.
 * Synchronous I/O operations should be performed from worker threads. See the
 * [introduction to asynchronous programming section][async-programming] for
 * more.
 * 
 * Some #GFile operations almost always take a noticeable amount of time, and
 * so do not have synchronous analogs. Notable cases include:
 * - g_file_mount_mountable() to mount a mountable file.
 * - g_file_unmount_mountable_with_operation() to unmount a mountable file.
 * - g_file_eject_mountable_with_operation() to eject a mountable file.
 * 
 * ## Entity Tags # {#gfile-etag}
 * 
 * One notable feature of #GFiles are entity tags, or "etags" for
 * short. Entity tags are somewhat like a more abstract version of the
 * traditional mtime, and can be used to quickly determine if the file
 * has been modified from the version on the file system. See the
 * HTTP 1.1
 * [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
 * for HTTP Etag headers, which are a very similar concept.
 * @interface 
 */
class File extends GObject.Object {

    // Own properties of Gio-2.0.Gio.File

    static name: string
    static $gtype: GObject.GType<File>

    // Constructors of Gio-2.0.Gio.File

    constructor(config?: File.ConstructorProperties) 
    _init(config?: File.ConstructorProperties): void
    /**
     * Creates a #GFile with the given argument from the command line.
     * The value of `arg` can be either a URI, an absolute path or a
     * relative path resolved relative to the current working directory.
     * This operation never fails, but the returned object might not
     * support any I/O operation if `arg` points to a malformed path.
     * 
     * Note that on Windows, this function expects its argument to be in
     * UTF-8 -- not the system code page.  This means that you
     * should not use this function with string from argv as it is passed
     * to main().  g_win32_get_command_line() will return a UTF-8 version of
     * the commandline.  #GApplication also uses UTF-8 but
     * g_application_command_line_create_file_for_arg() may be more useful
     * for you there.  It is also always possible to use this function with
     * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
     * @param arg a command line string
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    static new_for_commandline_arg(arg: string): File
    /**
     * Creates a #GFile with the given argument from the command line.
     * 
     * This function is similar to g_file_new_for_commandline_arg() except
     * that it allows for passing the current working directory as an
     * argument instead of using the current working directory of the
     * process.
     * 
     * This is useful if the commandline argument was given in a context
     * other than the invocation of the current process.
     * 
     * See also g_application_command_line_create_file_for_arg().
     * @param arg a command line string
     * @param cwd the current working directory of the commandline
     * @returns a new #GFile
     */
    static new_for_commandline_arg_and_cwd(arg: string, cwd: string): File
    /**
     * Constructs a #GFile for a given path. This operation never
     * fails, but the returned object might not support any I/O
     * operation if `path` is malformed.
     * @param path a string containing a relative or absolute path.   The string must be encoded in the glib filename encoding.
     * @returns a new #GFile for the given @path.   Free the returned object with g_object_unref().
     */
    static new_for_path(path: string): File
    /**
     * Constructs a #GFile for a given URI. This operation never
     * fails, but the returned object might not support any I/O
     * operation if `uri` is malformed or if the uri type is
     * not supported.
     * @param uri a UTF-8 string containing a URI
     * @returns a new #GFile for the given @uri.   Free the returned object with g_object_unref().
     */
    static new_for_uri(uri: string | null): File
    /**
     * Opens a file in the preferred directory for temporary files (as
     * returned by g_get_tmp_dir()) and returns a #GFile and
     * #GFileIOStream pointing to it.
     * 
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * 
     * Unlike the other #GFile constructors, this will return %NULL if
     * a temporary file could not be created.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    static new_tmp(tmpl: string | null): [ /* returnType */ File, /* iostream */ FileIOStream ]
    /**
     * Asynchronously opens a file in the preferred directory for temporary files
     *  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
     * 
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_file_open_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    static new_tmp_async(tmpl: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<File> | null): void
    /**
     * Asynchronously creates a directory in the preferred directory for
     * temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
     * 
     * `tmpl` should be a string in the GLib file name encoding
     * containing a sequence of six 'X' characters, and containing no
     * directory components. If it is %NULL, a default template is used.
     * @param tmpl Template for the file   name, as in g_dir_make_tmp(), or %NULL for a default template
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback to call when the request is done
     */
    static new_tmp_dir_async(tmpl: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<File> | null): void
    /**
     * Finishes a temporary directory creation started by
     * g_file_new_tmp_dir_async().
     * @param result a #GAsyncResult
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    static new_tmp_dir_finish(result: AsyncResult): File
    /**
     * Finishes a temporary file creation started by g_file_new_tmp_async().
     * @param result a #GAsyncResult
     * @returns a new #GFile.   Free the returned object with g_object_unref().
     */
    static new_tmp_finish(result: AsyncResult): [ /* returnType */ File, /* iostream */ FileIOStream ]
    /**
     * Constructs a #GFile with the given `parse_name` (i.e. something
     * given by g_file_get_parse_name()). This operation never fails,
     * but the returned object might not support any I/O operation if
     * the `parse_name` cannot be parsed.
     * @param parse_name a file name or path to be parsed
     * @returns a new #GFile.
     */
    static parse_name(parse_name: string | null): File
}

module FileDescriptorBased {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface FileDescriptorBased {

    // Owm methods of Gio-2.0.Gio.FileDescriptorBased

    /**
     * Gets the underlying file descriptor.
     * @returns The file descriptor
     */
    get_fd(): number

    // Own virtual methods of Gio-2.0.Gio.FileDescriptorBased

    /**
     * Gets the underlying file descriptor.
     * @virtual 
     * @returns The file descriptor
     */
    vfunc_get_fd(): number

    // Class property signals of Gio-2.0.Gio.FileDescriptorBased

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GFileDescriptorBased is implemented by streams (implementations of
 * #GInputStream or #GOutputStream) that are based on file descriptors.
 * 
 * Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific
 * GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
 * file when using it.
 * @interface 
 */
class FileDescriptorBased extends GObject.Object {

    // Own properties of Gio-2.0.Gio.FileDescriptorBased

    static name: string
    static $gtype: GObject.GType<FileDescriptorBased>

    // Constructors of Gio-2.0.Gio.FileDescriptorBased

    constructor(config?: FileDescriptorBased.ConstructorProperties) 
    _init(config?: FileDescriptorBased.ConstructorProperties): void
}

module Icon {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Icon {

    // Owm methods of Gio-2.0.Gio.Icon

    /**
     * Checks if two icons are equal.
     * @param icon2 pointer to the second #GIcon.
     * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
     */
    equal(icon2: Icon | null): boolean
    /**
     * Gets a hash for an icon.
     * @returns a #guint containing a hash for the @icon, suitable for use in a #GHashTable or similar data structure.
     */
    hash(): number
    /**
     * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
     * back by calling g_icon_deserialize() on the returned value.
     * As serialization will avoid using raw icon data when possible, it only
     * makes sense to transfer the #GVariant between processes on the same machine,
     * (as opposed to over the network), and within the same file system namespace.
     * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
     */
    serialize(): GLib.Variant | null
    /**
     * Generates a textual representation of `icon` that can be used for
     * serialization such as when passing `icon` to a different process or
     * saving it to persistent storage. Use g_icon_new_for_string() to
     * get `icon` back from the returned string.
     * 
     * The encoding of the returned string is proprietary to #GIcon except
     * in the following two cases
     * 
     * - If `icon` is a #GFileIcon, the returned string is a native path
     *   (such as `/path/to/my icon.png`) without escaping
     *   if the #GFile for `icon` is a native file.  If the file is not
     *   native, the returned string is the result of g_file_get_uri()
     *   (such as `sftp://path/to/my%20icon.png`).
     * 
     * - If `icon` is a #GThemedIcon with exactly one name and no fallbacks,
     *   the encoding is simply the name (such as `network-server`).
     * @returns An allocated NUL-terminated UTF8 string or %NULL if @icon can't be serialized. Use g_free() to free.
     */
    to_string(): string | null

    // Own virtual methods of Gio-2.0.Gio.Icon

    /**
     * Checks if two icons are equal.
     * @virtual 
     * @param icon2 pointer to the second #GIcon.
     * @returns %TRUE if @icon1 is equal to @icon2. %FALSE otherwise.
     */
    vfunc_equal(icon2: Icon | null): boolean
    /**
     * Gets a hash for an icon.
     * @virtual 
     * @returns a #guint containing a hash for the @icon, suitable for use in a #GHashTable or similar data structure.
     */
    vfunc_hash(): number
    /**
     * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
     * back by calling g_icon_deserialize() on the returned value.
     * As serialization will avoid using raw icon data when possible, it only
     * makes sense to transfer the #GVariant between processes on the same machine,
     * (as opposed to over the network), and within the same file system namespace.
     * @virtual 
     * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
     */
    vfunc_serialize(): GLib.Variant | null
    /**
     * Serializes the `icon` into string tokens.
     * This is can be invoked when g_icon_new_for_string() is called.
     * @virtual 
     * @returns %TRUE if serialization took place, %FALSE otherwise
     */
    vfunc_to_tokens(): [ /* returnType */ boolean, /* tokens */ string[], /* out_version */ number ]

    // Class property signals of Gio-2.0.Gio.Icon

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GIcon is a very minimal interface for icons. It provides functions
 * for checking the equality of two icons, hashing of icons and
 * serializing an icon to and from strings.
 * 
 * #GIcon does not provide the actual pixmap for the icon as this is out
 * of GIO's scope, however implementations of #GIcon may contain the name
 * of an icon (see #GThemedIcon), or the path to an icon (see #GLoadableIcon).
 * 
 * To obtain a hash of a #GIcon, see g_icon_hash().
 * 
 * To check if two #GIcons are equal, see g_icon_equal().
 * 
 * For serializing a #GIcon, use g_icon_serialize() and
 * g_icon_deserialize().
 * 
 * If you want to consume #GIcon (for example, in a toolkit) you must
 * be prepared to handle at least the three following cases:
 * #GLoadableIcon, #GThemedIcon and #GEmblemedIcon.  It may also make
 * sense to have fast-paths for other cases (like handling #GdkPixbuf
 * directly, for example) but all compliant #GIcon implementations
 * outside of GIO must implement #GLoadableIcon.
 * 
 * If your application or library provides one or more #GIcon
 * implementations you need to ensure that your new implementation also
 * implements #GLoadableIcon.  Additionally, you must provide an
 * implementation of g_icon_serialize() that gives a result that is
 * understood by g_icon_deserialize(), yielding one of the built-in icon
 * types.
 * @interface 
 */
class Icon extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Icon

    static name: string
    static $gtype: GObject.GType<Icon>

    // Constructors of Gio-2.0.Gio.Icon

    constructor(config?: Icon.ConstructorProperties) 
    _init(config?: Icon.ConstructorProperties): void
    /**
     * Generate a #GIcon instance from `str`. This function can fail if
     * `str` is not valid - see g_icon_to_string() for discussion.
     * 
     * If your application or library provides one or more #GIcon
     * implementations you need to ensure that each #GType is registered
     * with the type system prior to calling g_icon_new_for_string().
     * @param str A string obtained via g_icon_to_string().
     * @returns An object implementing the #GIcon          interface or %NULL if @error is set.
     */
    static new_for_string(str: string | null): Icon
    /**
     * Deserializes a #GIcon previously serialized using g_icon_serialize().
     * @param value a #GVariant created with g_icon_serialize()
     * @returns a #GIcon, or %NULL when deserialization fails.
     */
    static deserialize(value: GLib.Variant): Icon | null
}

module Initable {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Initable {

    // Owm methods of Gio-2.0.Gio.Initable

    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
     */
    init(cancellable: Cancellable | null): boolean

    // Own virtual methods of Gio-2.0.Gio.Initable

    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     * @virtual 
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if successful. If an error has occurred, this function will     return %FALSE and set @error appropriately if present.
     */
    vfunc_init(cancellable: Cancellable | null): boolean

    // Class property signals of Gio-2.0.Gio.Initable

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GInitable is implemented by objects that can fail during
 * initialization. If an object implements this interface then
 * it must be initialized as the first thing after construction,
 * either via g_initable_init() or g_async_initable_init_async()
 * (the latter is only available if it also implements #GAsyncInitable).
 * 
 * If the object is not initialized, or initialization returns with an
 * error, then all operations on the object except g_object_ref() and
 * g_object_unref() are considered to be invalid, and have undefined
 * behaviour. They will often fail with g_critical() or g_warning(), but
 * this must not be relied on.
 * 
 * Users of objects implementing this are not intended to use
 * the interface method directly, instead it will be used automatically
 * in various ways. For C applications you generally just call
 * g_initable_new() directly, or indirectly via a foo_thing_new() wrapper.
 * This will call g_initable_init() under the cover, returning %NULL and
 * setting a #GError on failure (at which point the instance is
 * unreferenced).
 * 
 * For bindings in languages where the native constructor supports
 * exceptions the binding could check for objects implementing %GInitable
 * during normal construction and automatically initialize them, throwing
 * an exception on failure.
 * @interface 
 */
class Initable extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Initable

    static name: string
    static $gtype: GObject.GType<Initable>

    // Constructors of Gio-2.0.Gio.Initable

    constructor(config?: Initable.ConstructorProperties) 
    _init(config?: Initable.ConstructorProperties): void
    // Has conflict: static newv(object_type: GObject.GType, parameters: GObject.Parameter[], cancellable: Cancellable | null): GObject.Object

    // Overloads of newv

    /**
     * Creates a new instance of a #GObject subtype and sets its properties.
     * 
     * Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
     * which are not explicitly specified are set to their default values.
     * @constructor 
     * @param object_type the type id of the #GObject subtype to instantiate
     * @param parameters an array of #GParameter
     * @returns a new instance of @object_type
     */
    static newv(object_type: GObject.GType, parameters: GObject.Parameter[]): GObject.Object
}

module ListModel {

    // Signal callback interfaces

    /**
     * Signal callback interface for `items-changed`
     */
    interface ItemsChangedSignalCallback {
        ($obj: ListModel, position: number, removed: number, added: number): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface ListModel {

    // Owm methods of Gio-2.0.Gio.ListModel

    /**
     * Gets the type of the items in `list`.
     * 
     * All items returned from g_list_model_get_item() are of the type
     * returned by this function, or a subtype, or if the type is an
     * interface, they are an implementation of that interface.
     * 
     * The item type of a #GListModel can not change during the life of the
     * model.
     * @returns the #GType of the items contained in @list.
     */
    get_item_type(): GObject.GType
    /**
     * Gets the number of items in `list`.
     * 
     * Depending on the model implementation, calling this function may be
     * less efficient than iterating the list with increasing values for
     * `position` until g_list_model_get_item() returns %NULL.
     * @returns the number of items in @list.
     */
    get_n_items(): number
    /**
     * Get the item at `position`.
     * 
     * If `position` is greater than the number of items in `list,` %NULL is
     * returned.
     * 
     * %NULL is never returned for an index that is smaller than the length
     * of the list.
     * 
     * This function is meant to be used by language bindings in place
     * of g_list_model_get_item().
     * 
     * See also: g_list_model_get_n_items()
     * @param position the position of the item to fetch
     * @returns the object at @position.
     */
    get_item(position: number): GObject.Object | null
    /**
     * Emits the #GListModel::items-changed signal on `list`.
     * 
     * This function should only be called by classes implementing
     * #GListModel. It has to be called after the internal representation
     * of `list` has been updated, because handlers connected to this signal
     * might query the new state of the list.
     * 
     * Implementations must only make changes to the model (as visible to
     * its consumer) in places that will not cause problems for that
     * consumer.  For models that are driven directly by a write API (such
     * as #GListStore), changes can be reported in response to uses of that
     * API.  For models that represent remote data, changes should only be
     * made from a fresh mainloop dispatch.  It is particularly not
     * permitted to make changes in response to a call to the #GListModel
     * consumer API.
     * 
     * Stated another way: in general, it is assumed that code making a
     * series of accesses to the model via the API, without returning to the
     * mainloop, and without calling other code, will continue to view the
     * same contents of the model.
     * @param position the position at which `list` changed
     * @param removed the number of items removed
     * @param added the number of items added
     */
    items_changed(position: number, removed: number, added: number): void

    // Own virtual methods of Gio-2.0.Gio.ListModel

    /**
     * Get the item at `position`. If `position` is greater than the number of
     * items in `list,` %NULL is returned.
     * 
     * %NULL is never returned for an index that is smaller than the length
     * of the list.  See g_list_model_get_n_items().
     * @virtual 
     * @param position the position of the item to fetch
     * @returns the object at @position.
     */
    vfunc_get_item(position: number): GObject.Object | null
    /**
     * Gets the type of the items in `list`.
     * 
     * All items returned from g_list_model_get_item() are of the type
     * returned by this function, or a subtype, or if the type is an
     * interface, they are an implementation of that interface.
     * 
     * The item type of a #GListModel can not change during the life of the
     * model.
     * @virtual 
     * @returns the #GType of the items contained in @list.
     */
    vfunc_get_item_type(): GObject.GType
    /**
     * Gets the number of items in `list`.
     * 
     * Depending on the model implementation, calling this function may be
     * less efficient than iterating the list with increasing values for
     * `position` until g_list_model_get_item() returns %NULL.
     * @virtual 
     * @returns the number of items in @list.
     */
    vfunc_get_n_items(): number

    // Own signals of Gio-2.0.Gio.ListModel

    connect(sigName: "items-changed", callback: ListModel.ItemsChangedSignalCallback): number
    connect_after(sigName: "items-changed", callback: ListModel.ItemsChangedSignalCallback): number
    emit(sigName: "items-changed", position: number, removed: number, added: number, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.ListModel

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GListModel is an interface that represents a mutable list of
 * #GObjects. Its main intention is as a model for various widgets in
 * user interfaces, such as list views, but it can also be used as a
 * convenient method of returning lists of data, with support for
 * updates.
 * 
 * Each object in the list may also report changes in itself via some
 * mechanism (normally the #GObject::notify signal).  Taken together
 * with the #GListModel::items-changed signal, this provides for a list
 * that can change its membership, and in which the members can change
 * their individual properties.
 * 
 * A good example would be the list of visible wireless network access
 * points, where each access point can report dynamic properties such as
 * signal strength.
 * 
 * It is important to note that the #GListModel itself does not report
 * changes to the individual items.  It only reports changes to the list
 * membership.  If you want to observe changes to the objects themselves
 * then you need to connect signals to the objects that you are
 * interested in.
 * 
 * All items in a #GListModel are of (or derived from) the same type.
 * g_list_model_get_item_type() returns that type.  The type may be an
 * interface, in which case all objects in the list must implement it.
 * 
 * The semantics are close to that of an array:
 * g_list_model_get_n_items() returns the number of items in the list and
 * g_list_model_get_item() returns an item at a (0-based) position. In
 * order to allow implementations to calculate the list length lazily,
 * you can also iterate over items: starting from 0, repeatedly call
 * g_list_model_get_item() until it returns %NULL.
 * 
 * An implementation may create objects lazily, but must take care to
 * return the same object for a given position until all references to
 * it are gone.
 * 
 * On the other side, a consumer is expected only to hold references on
 * objects that are currently "user visible", in order to facilitate the
 * maximum level of laziness in the implementation of the list and to
 * reduce the required number of signal connections at a given time.
 * 
 * This interface is intended only to be used from a single thread.  The
 * thread in which it is appropriate to use it depends on the particular
 * implementation, but typically it will be from the thread that owns
 * the [thread-default main context][g-main-context-push-thread-default]
 * in effect at the time that the model was created.
 * 
 * Over time, it has established itself as good practice for listmodel
 * implementations to provide properties `item-type` and `n-items` to
 * ease working with them. While it is not required, it is recommended
 * that implementations provide these two properties. They should return
 * the values of g_list_model_get_item_type() and g_list_model_get_n_items()
 * respectively and be defined as such:
 * 
 * ```c
 * properties[PROP_ITEM_TYPE] =
 *   g_param_spec_gtype ("item-type", "", "", G_TYPE_OBJECT,
 *                       G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 * properties[PROP_N_ITEMS] =
 *   g_param_spec_uint ("n-items", "", "", 0, G_MAXUINT, 0,
 *                      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 * ```
 * 
 * @interface 
 */
class ListModel extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ListModel

    static name: string
    static $gtype: GObject.GType<ListModel>

    // Constructors of Gio-2.0.Gio.ListModel

    constructor(config?: ListModel.ConstructorProperties) 
    _init(config?: ListModel.ConstructorProperties): void
}

module LoadableIcon {

    // Constructor properties interface

    interface ConstructorProperties extends Icon.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface LoadableIcon extends Icon {

    // Owm methods of Gio-2.0.Gio.LoadableIcon

    /**
     * Loads a loadable icon. For the asynchronous version of this function,
     * see g_loadable_icon_load_async().
     * @param size an integer.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GInputStream to read the icon from.
     */
    load(size: number, cancellable: Cancellable | null): [ /* returnType */ InputStream, /* type */ string | null ]
    /**
     * Loads an icon asynchronously. To finish this function, see
     * g_loadable_icon_load_finish(). For the synchronous, blocking
     * version of this function, see g_loadable_icon_load().
     * @param size an integer.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the            request is satisfied
     */
    load_async(size: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of load_async

    /**
     * Promisified version of {@link load_async}
     * 
     * Loads an icon asynchronously. To finish this function, see
     * g_loadable_icon_load_finish(). For the synchronous, blocking
     * version of this function, see g_loadable_icon_load().
     * @param size an integer.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: a #GInputStream to read the icon from.
     */
    load_async(size: number, cancellable: Cancellable | null): globalThis.Promise</* type */ string | null>
    /**
     * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
     * @param res a #GAsyncResult.
     * @returns a #GInputStream to read the icon from.
     */
    load_finish(res: AsyncResult): [ /* returnType */ InputStream, /* type */ string | null ]

    // Own virtual methods of Gio-2.0.Gio.LoadableIcon

    /**
     * Loads a loadable icon. For the asynchronous version of this function,
     * see g_loadable_icon_load_async().
     * @virtual 
     * @param size an integer.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GInputStream to read the icon from.
     */
    vfunc_load(size: number, cancellable: Cancellable | null): [ /* returnType */ InputStream, /* type */ string | null ]
    /**
     * Loads an icon asynchronously. To finish this function, see
     * g_loadable_icon_load_finish(). For the synchronous, blocking
     * version of this function, see g_loadable_icon_load().
     * @virtual 
     * @param size an integer.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the            request is satisfied
     */
    vfunc_load_async(size: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous icon load started in g_loadable_icon_load_async().
     * @virtual 
     * @param res a #GAsyncResult.
     * @returns a #GInputStream to read the icon from.
     */
    vfunc_load_finish(res: AsyncResult): [ /* returnType */ InputStream, /* type */ string | null ]

    // Class property signals of Gio-2.0.Gio.LoadableIcon

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Extends the #GIcon interface and adds the ability to
 * load icons from streams.
 * @interface 
 */
class LoadableIcon extends GObject.Object {

    // Own properties of Gio-2.0.Gio.LoadableIcon

    static name: string
    static $gtype: GObject.GType<LoadableIcon>

    // Constructors of Gio-2.0.Gio.LoadableIcon

    constructor(config?: LoadableIcon.ConstructorProperties) 
    _init(config?: LoadableIcon.ConstructorProperties): void
}

module MemoryMonitor {

    // Signal callback interfaces

    /**
     * Signal callback interface for `low-memory-warning`
     */
    interface LowMemoryWarningSignalCallback {
        ($obj: MemoryMonitor, level: MemoryMonitorWarningLevel): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends Initable.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface MemoryMonitor extends Initable {

    // Own virtual methods of Gio-2.0.Gio.MemoryMonitor

    vfunc_low_memory_warning(level: MemoryMonitorWarningLevel): void

    // Own signals of Gio-2.0.Gio.MemoryMonitor

    connect(sigName: "low-memory-warning", callback: MemoryMonitor.LowMemoryWarningSignalCallback): number
    connect_after(sigName: "low-memory-warning", callback: MemoryMonitor.LowMemoryWarningSignalCallback): number
    emit(sigName: "low-memory-warning", level: MemoryMonitorWarningLevel, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.MemoryMonitor

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMemoryMonitor will monitor system memory and suggest to the application
 * when to free memory so as to leave more room for other applications.
 * It is implemented on Linux using the [Low Memory Monitor](https://gitlab.freedesktop.org/hadess/low-memory-monitor/)
 * ([API documentation](https://hadess.pages.freedesktop.org/low-memory-monitor/)).
 * 
 * There is also an implementation for use inside Flatpak sandboxes.
 * 
 * Possible actions to take when the signal is received are:
 * 
 *  - Free caches
 *  - Save files that haven't been looked at in a while to disk, ready to be reopened when needed
 *  - Run a garbage collection cycle
 *  - Try and compress fragmented allocations
 *  - Exit on idle if the process has no reason to stay around
 *  - Call [`malloc_trim(3)`](man:malloc_trim) to return cached heap pages to
 *    the kernel (if supported by your libc)
 * 
 * Note that some actions may not always improve system performance, and so
 * should be profiled for your application. `malloc_trim()`, for example, may
 * make future heap allocations slower (due to releasing cached heap pages back
 * to the kernel).
 * 
 * See #GMemoryMonitorWarningLevel for details on the various warning levels.
 * 
 * 
 * ```c
 * static void
 * warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
 * {
 *   g_debug ("Warning level: %d", level);
 *   if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
 *     drop_caches ();
 * }
 * 
 * static GMemoryMonitor *
 * monitor_low_memory (void)
 * {
 *   GMemoryMonitor *m;
 *   m = g_memory_monitor_dup_default ();
 *   g_signal_connect (G_OBJECT (m), "low-memory-warning",
 *                     G_CALLBACK (warning_cb), NULL);
 *   return m;
 * }
 * ```
 * 
 * 
 * Don't forget to disconnect the #GMemoryMonitor::low-memory-warning
 * signal, and unref the #GMemoryMonitor itself when exiting.
 * @interface 
 */
class MemoryMonitor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.MemoryMonitor

    static name: string
    static $gtype: GObject.GType<MemoryMonitor>

    // Constructors of Gio-2.0.Gio.MemoryMonitor

    constructor(config?: MemoryMonitor.ConstructorProperties) 
    _init(config?: MemoryMonitor.ConstructorProperties): void
    /**
     * Gets a reference to the default #GMemoryMonitor for the system.
     * @returns a new reference to the default #GMemoryMonitor
     */
    static dup_default(): MemoryMonitor
}

module Mount {

    // Signal callback interfaces

    /**
     * Signal callback interface for `changed`
     */
    interface ChangedSignalCallback {
        ($obj: Mount): void
    }

    /**
     * Signal callback interface for `pre-unmount`
     */
    interface PreUnmountSignalCallback {
        ($obj: Mount): void
    }

    /**
     * Signal callback interface for `unmounted`
     */
    interface UnmountedSignalCallback {
        ($obj: Mount): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Mount {

    // Owm methods of Gio-2.0.Gio.Mount

    /**
     * Checks if `mount` can be ejected.
     * @returns %TRUE if the @mount can be ejected.
     */
    can_eject(): boolean
    /**
     * Checks if `mount` can be unmounted.
     * @returns %TRUE if the @mount can be unmounted.
     */
    can_unmount(): boolean
    /**
     * Ejects a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_eject_finish() with the `mount`
     * and #GAsyncResult data returned in the `callback`.
     * @param flags flags affecting the unmount if required for eject
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    eject(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
     */
    eject_finish(result: AsyncResult): boolean
    /**
     * Ejects a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_eject_with_operation_finish() with the `mount`
     * and #GAsyncResult data returned in the `callback`.
     * @param flags flags affecting the unmount if required for eject
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    eject_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
     */
    eject_with_operation_finish(result: AsyncResult): boolean
    /**
     * Gets the default location of `mount`. The default location of the given
     * `mount` is a path that reflects the main entry point for the user (e.g.
     * the home directory, or the root of the volume).
     * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    get_default_location(): File
    /**
     * Gets the drive for the `mount`.
     * 
     * This is a convenience method for getting the #GVolume and then
     * using that object to get the #GDrive.
     * @returns a #GDrive or %NULL if @mount is not      associated with a volume or a drive.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    get_drive(): Drive | null
    /**
     * Gets the icon for `mount`.
     * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    get_icon(): Icon
    /**
     * Gets the name of `mount`.
     * @returns the name for the given @mount.     The returned string should be freed with g_free()     when no longer needed.
     */
    get_name(): string | null
    /**
     * Gets the root directory on `mount`.
     * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    get_root(): File
    /**
     * Gets the sort key for `mount,` if any.
     * @returns Sorting key for @mount or %NULL if no such key is available.
     */
    get_sort_key(): string | null
    /**
     * Gets the symbolic icon for `mount`.
     * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    get_symbolic_icon(): Icon
    /**
     * Gets the UUID for the `mount`. The reference is typically based on
     * the file system UUID for the mount in question and should be
     * considered an opaque string. Returns %NULL if there is no UUID
     * available.
     * @returns the UUID for @mount or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
     */
    get_uuid(): string | null
    /**
     * Gets the volume for the `mount`.
     * @returns a #GVolume or %NULL if @mount is not      associated with a volume.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    get_volume(): Volume | null
    /**
     * Tries to guess the type of content stored on `mount`. Returns one or
     * more textual identifiers of well-known content types (typically
     * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
     * memory cards. See the
     * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
     * specification for more on x-content types.
     * 
     * This is an asynchronous operation (see
     * g_mount_guess_content_type_sync() for the synchronous version), and
     * is finished by calling g_mount_guess_content_type_finish() with the
     * `mount` and #GAsyncResult data returned in the `callback`.
     * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback
     */
    guess_content_type(force_rescan: boolean, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes guessing content types of `mount`. If any errors occurred
     * during the operation, `error` will be set to contain the errors and
     * %FALSE will be returned. In particular, you may get an
     * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
     * guessing.
     * @param result a #GAsyncResult
     * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
     */
    guess_content_type_finish(result: AsyncResult): string[]
    /**
     * Tries to guess the type of content stored on `mount`. Returns one or
     * more textual identifiers of well-known content types (typically
     * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
     * memory cards. See the
     * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
     * specification for more on x-content types.
     * 
     * This is a synchronous operation and as such may block doing IO;
     * see g_mount_guess_content_type() for the asynchronous version.
     * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
     */
    guess_content_type_sync(force_rescan: boolean, cancellable: Cancellable | null): string[]
    /**
     * Determines if `mount` is shadowed. Applications or libraries should
     * avoid displaying `mount` in the user interface if it is shadowed.
     * 
     * A mount is said to be shadowed if there exists one or more user
     * visible objects (currently #GMount objects) with a root that is
     * inside the root of `mount`.
     * 
     * One application of shadow mounts is when exposing a single file
     * system that is used to address several logical volumes. In this
     * situation, a #GVolumeMonitor implementation would create two
     * #GVolume objects (for example, one for the camera functionality of
     * the device and one for a SD card reader on the device) with
     * activation URIs `gphoto2://[usb:001,002]/store1/`
     * and `gphoto2://[usb:001,002]/store2/`. When the
     * underlying mount (with root
     * `gphoto2://[usb:001,002]/`) is mounted, said
     * #GVolumeMonitor implementation would create two #GMount objects
     * (each with their root matching the corresponding volume activation
     * root) that would shadow the original mount.
     * 
     * The proxy monitor in GVfs 2.26 and later, automatically creates and
     * manage shadow mounts (and shadows the underlying mount) if the
     * activation root on a #GVolume is set.
     * @returns %TRUE if @mount is shadowed.
     */
    is_shadowed(): boolean
    /**
     * Remounts a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_remount_finish() with the `mount`
     * and #GAsyncResults data returned in the `callback`.
     * 
     * Remounting is useful when some setting affecting the operation
     * of the volume has been changed, as these may need a remount to
     * take affect. While this is semantically equivalent with unmounting
     * and then remounting not all backends might need to actually be
     * unmounted.
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    remount(flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes remounting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully remounted. %FALSE otherwise.
     */
    remount_finish(result: AsyncResult): boolean
    /**
     * Increments the shadow count on `mount`. Usually used by
     * #GVolumeMonitor implementations when creating a shadow mount for
     * `mount,` see g_mount_is_shadowed() for more information. The caller
     * will need to emit the #GMount::changed signal on `mount` manually.
     */
    shadow(): void
    /**
     * Unmounts a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_unmount_finish() with the `mount`
     * and #GAsyncResult data returned in the `callback`.
     * @param flags flags affecting the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    unmount(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes unmounting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
     */
    unmount_finish(result: AsyncResult): boolean
    /**
     * Unmounts a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_unmount_with_operation_finish() with the `mount`
     * and #GAsyncResult data returned in the `callback`.
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    unmount_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes unmounting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
     */
    unmount_with_operation_finish(result: AsyncResult): boolean
    /**
     * Decrements the shadow count on `mount`. Usually used by
     * #GVolumeMonitor implementations when destroying a shadow mount for
     * `mount,` see g_mount_is_shadowed() for more information. The caller
     * will need to emit the #GMount::changed signal on `mount` manually.
     */
    unshadow(): void

    // Own virtual methods of Gio-2.0.Gio.Mount

    /**
     * Checks if `mount` can be ejected.
     * @virtual 
     * @returns %TRUE if the @mount can be ejected.
     */
    vfunc_can_eject(): boolean
    /**
     * Checks if `mount` can be unmounted.
     * @virtual 
     * @returns %TRUE if the @mount can be unmounted.
     */
    vfunc_can_unmount(): boolean
    vfunc_changed(): void
    /**
     * Ejects a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_eject_finish() with the `mount`
     * and #GAsyncResult data returned in the `callback`.
     * @virtual 
     * @param flags flags affecting the unmount if required for eject
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_eject(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
     */
    vfunc_eject_finish(result: AsyncResult): boolean
    /**
     * Ejects a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_eject_with_operation_finish() with the `mount`
     * and #GAsyncResult data returned in the `callback`.
     * @virtual 
     * @param flags flags affecting the unmount if required for eject
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_eject_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
     */
    vfunc_eject_with_operation_finish(result: AsyncResult): boolean
    /**
     * Gets the default location of `mount`. The default location of the given
     * `mount` is a path that reflects the main entry point for the user (e.g.
     * the home directory, or the root of the volume).
     * @virtual 
     * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    vfunc_get_default_location(): File
    /**
     * Gets the drive for the `mount`.
     * 
     * This is a convenience method for getting the #GVolume and then
     * using that object to get the #GDrive.
     * @virtual 
     * @returns a #GDrive or %NULL if @mount is not      associated with a volume or a drive.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    vfunc_get_drive(): Drive | null
    /**
     * Gets the icon for `mount`.
     * @virtual 
     * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    vfunc_get_icon(): Icon
    /**
     * Gets the name of `mount`.
     * @virtual 
     * @returns the name for the given @mount.     The returned string should be freed with g_free()     when no longer needed.
     */
    vfunc_get_name(): string | null
    /**
     * Gets the root directory on `mount`.
     * @virtual 
     * @returns a #GFile.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    vfunc_get_root(): File
    /**
     * Gets the sort key for `mount,` if any.
     * @virtual 
     * @returns Sorting key for @mount or %NULL if no such key is available.
     */
    vfunc_get_sort_key(): string | null
    /**
     * Gets the symbolic icon for `mount`.
     * @virtual 
     * @returns a #GIcon.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    vfunc_get_symbolic_icon(): Icon
    /**
     * Gets the UUID for the `mount`. The reference is typically based on
     * the file system UUID for the mount in question and should be
     * considered an opaque string. Returns %NULL if there is no UUID
     * available.
     * @virtual 
     * @returns the UUID for @mount or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
     */
    vfunc_get_uuid(): string | null
    /**
     * Gets the volume for the `mount`.
     * @virtual 
     * @returns a #GVolume or %NULL if @mount is not      associated with a volume.      The returned object should be unreffed with      g_object_unref() when no longer needed.
     */
    vfunc_get_volume(): Volume | null
    /**
     * Tries to guess the type of content stored on `mount`. Returns one or
     * more textual identifiers of well-known content types (typically
     * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
     * memory cards. See the
     * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
     * specification for more on x-content types.
     * 
     * This is an asynchronous operation (see
     * g_mount_guess_content_type_sync() for the synchronous version), and
     * is finished by calling g_mount_guess_content_type_finish() with the
     * `mount` and #GAsyncResult data returned in the `callback`.
     * @virtual 
     * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback
     */
    vfunc_guess_content_type(force_rescan: boolean, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes guessing content types of `mount`. If any errors occurred
     * during the operation, `error` will be set to contain the errors and
     * %FALSE will be returned. In particular, you may get an
     * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
     * guessing.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
     */
    vfunc_guess_content_type_finish(result: AsyncResult): string[]
    /**
     * Tries to guess the type of content stored on `mount`. Returns one or
     * more textual identifiers of well-known content types (typically
     * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
     * memory cards. See the
     * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
     * specification for more on x-content types.
     * 
     * This is a synchronous operation and as such may block doing IO;
     * see g_mount_guess_content_type() for the asynchronous version.
     * @virtual 
     * @param force_rescan Whether to force a rescan of the content.     Otherwise a cached result will be used if available
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns a %NULL-terminated array of content types or %NULL on error.     Caller should free this array with g_strfreev() when done with it.
     */
    vfunc_guess_content_type_sync(force_rescan: boolean, cancellable: Cancellable | null): string[]
    vfunc_pre_unmount(): void
    /**
     * Remounts a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_remount_finish() with the `mount`
     * and #GAsyncResults data returned in the `callback`.
     * 
     * Remounting is useful when some setting affecting the operation
     * of the volume has been changed, as these may need a remount to
     * take affect. While this is semantically equivalent with unmounting
     * and then remounting not all backends might need to actually be
     * unmounted.
     * @virtual 
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_remount(flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes remounting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully remounted. %FALSE otherwise.
     */
    vfunc_remount_finish(result: AsyncResult): boolean
    /**
     * Unmounts a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_unmount_finish() with the `mount`
     * and #GAsyncResult data returned in the `callback`.
     * @virtual 
     * @param flags flags affecting the operation
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_unmount(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes unmounting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
     */
    vfunc_unmount_finish(result: AsyncResult): boolean
    /**
     * Unmounts a mount. This is an asynchronous operation, and is
     * finished by calling g_mount_unmount_with_operation_finish() with the `mount`
     * and #GAsyncResult data returned in the `callback`.
     * @virtual 
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation or %NULL to avoid     user interaction.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback, or %NULL.
     */
    vfunc_unmount_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes unmounting a mount. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
     */
    vfunc_unmount_with_operation_finish(result: AsyncResult): boolean
    vfunc_unmounted(): void

    // Own signals of Gio-2.0.Gio.Mount

    connect(sigName: "changed", callback: Mount.ChangedSignalCallback): number
    connect_after(sigName: "changed", callback: Mount.ChangedSignalCallback): number
    emit(sigName: "changed", ...args: any[]): void
    connect(sigName: "pre-unmount", callback: Mount.PreUnmountSignalCallback): number
    connect_after(sigName: "pre-unmount", callback: Mount.PreUnmountSignalCallback): number
    emit(sigName: "pre-unmount", ...args: any[]): void
    connect(sigName: "unmounted", callback: Mount.UnmountedSignalCallback): number
    connect_after(sigName: "unmounted", callback: Mount.UnmountedSignalCallback): number
    emit(sigName: "unmounted", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.Mount

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GMount interface represents user-visible mounts. Note, when
 * porting from GnomeVFS, #GMount is the moral equivalent of #GnomeVFSVolume.
 * 
 * #GMount is a "mounted" filesystem that you can access. Mounted is in
 * quotes because it's not the same as a unix mount, it might be a gvfs
 * mount, but you can still access the files on it if you use GIO. Might or
 * might not be related to a volume object.
 * 
 * Unmounting a #GMount instance is an asynchronous operation. For
 * more information about asynchronous operations, see #GAsyncResult
 * and #GTask. To unmount a #GMount instance, first call
 * g_mount_unmount_with_operation() with (at least) the #GMount instance and a
 * #GAsyncReadyCallback.  The callback will be fired when the
 * operation has resolved (either with success or failure), and a
 * #GAsyncResult structure will be passed to the callback.  That
 * callback should then call g_mount_unmount_with_operation_finish() with the #GMount
 * and the #GAsyncResult data to see if the operation was completed
 * successfully.  If an `error` is present when g_mount_unmount_with_operation_finish()
 * is called, then it will be filled with any error information.
 * @interface 
 */
class Mount extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Mount

    static name: string
    static $gtype: GObject.GType<Mount>

    // Constructors of Gio-2.0.Gio.Mount

    constructor(config?: Mount.ConstructorProperties) 
    _init(config?: Mount.ConstructorProperties): void
}

module NetworkMonitor {

    // Signal callback interfaces

    /**
     * Signal callback interface for `network-changed`
     */
    interface NetworkChangedSignalCallback {
        ($obj: NetworkMonitor, network_available: boolean): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends Initable.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface NetworkMonitor extends Initable {

    // Own properties of Gio-2.0.Gio.NetworkMonitor

    /**
     * More detailed information about the host's network connectivity.
     * See g_network_monitor_get_connectivity() and
     * #GNetworkConnectivity for more details.
     */
    readonly connectivity: NetworkConnectivity
    /**
     * Whether the network is considered available. That is, whether the
     * system has a default route for at least one of IPv4 or IPv6.
     * 
     * Real-world networks are of course much more complicated than
     * this; the machine may be connected to a wifi hotspot that
     * requires payment before allowing traffic through, or may be
     * connected to a functioning router that has lost its own upstream
     * connectivity. Some hosts might only be accessible when a VPN is
     * active. Other hosts might only be accessible when the VPN is
     * not active. Thus, it is best to use g_network_monitor_can_reach()
     * or g_network_monitor_can_reach_async() to test for reachability
     * on a host-by-host basis. (On the other hand, when the property is
     * %FALSE, the application can reasonably expect that no remote
     * hosts at all are reachable, and should indicate this to the user
     * in its UI.)
     * 
     * See also #GNetworkMonitor::network-changed.
     */
    readonly network_available: boolean
    /**
     * Whether the network is considered metered. That is, whether the
     * system has traffic flowing through the default connection that is
     * subject to limitations set by service providers. For example, traffic
     * might be billed by the amount of data transmitted, or there might be a
     * quota on the amount of traffic per month. This is typical with tethered
     * connections (3G and 4G) and in such situations, bandwidth intensive
     * applications may wish to avoid network activity where possible if it will
     * cost the user money or use up their limited quota.
     * 
     * If more information is required about specific devices then the
     * system network management API should be used instead (for example,
     * NetworkManager or ConnMan).
     * 
     * If this information is not available then no networks will be
     * marked as metered.
     * 
     * See also #GNetworkMonitor:network-available.
     */
    readonly network_metered: boolean

    // Owm methods of Gio-2.0.Gio.NetworkMonitor

    /**
     * Attempts to determine whether or not the host pointed to by
     * `connectable` can be reached, without actually trying to connect to
     * it.
     * 
     * This may return %TRUE even when #GNetworkMonitor:network-available
     * is %FALSE, if, for example, `monitor` can determine that
     * `connectable` refers to a host on a local network.
     * 
     * If `monitor` believes that an attempt to connect to `connectable`
     * will succeed, it will return %TRUE. Otherwise, it will return
     * %FALSE and set `error` to an appropriate error (such as
     * %G_IO_ERROR_HOST_UNREACHABLE).
     * 
     * Note that although this does not attempt to connect to
     * `connectable,` it may still block for a brief period of time (eg,
     * trying to do multicast DNS on the local network), so if you do not
     * want to block, you should use g_network_monitor_can_reach_async().
     * @param connectable a #GSocketConnectable
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if @connectable is reachable, %FALSE if not.
     */
    can_reach(connectable: SocketConnectable, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously attempts to determine whether or not the host
     * pointed to by `connectable` can be reached, without actually
     * trying to connect to it.
     * 
     * For more details, see g_network_monitor_can_reach().
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_network_monitor_can_reach_finish()
     * to get the result of the operation.
     * @param connectable a #GSocketConnectable
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback to call when the     request is satisfied
     */
    can_reach_async(connectable: SocketConnectable, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of can_reach_async

    /**
     * Promisified version of {@link can_reach_async}
     * 
     * Asynchronously attempts to determine whether or not the host
     * pointed to by `connectable` can be reached, without actually
     * trying to connect to it.
     * 
     * For more details, see g_network_monitor_can_reach().
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_network_monitor_can_reach_finish()
     * to get the result of the operation.
     * @param connectable a #GSocketConnectable
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE if network is reachable, %FALSE if not.
     */
    can_reach_async(connectable: SocketConnectable, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes an async network connectivity test.
     * See g_network_monitor_can_reach_async().
     * @param result a #GAsyncResult
     * @returns %TRUE if network is reachable, %FALSE if not.
     */
    can_reach_finish(result: AsyncResult): boolean
    /**
     * Gets a more detailed networking state than
     * g_network_monitor_get_network_available().
     * 
     * If #GNetworkMonitor:network-available is %FALSE, then the
     * connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.
     * 
     * If #GNetworkMonitor:network-available is %TRUE, then the
     * connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
     * is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
     * the host has a default route, but appears to be unable to actually
     * reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
     * host is trapped behind a "captive portal" that requires some sort
     * of login or acknowledgement before allowing full Internet access).
     * 
     * Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
     * %G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
     * reachable but others are not. In this case, applications can
     * attempt to connect to remote servers, but should gracefully fall
     * back to their "offline" behavior if the connection attempt fails.
     * @returns the network connectivity state
     */
    get_connectivity(): NetworkConnectivity
    /**
     * Checks if the network is available. "Available" here means that the
     * system has a default route available for at least one of IPv4 or
     * IPv6. It does not necessarily imply that the public Internet is
     * reachable. See #GNetworkMonitor:network-available for more details.
     * @returns whether the network is available
     */
    get_network_available(): boolean
    /**
     * Checks if the network is metered.
     * See #GNetworkMonitor:network-metered for more details.
     * @returns whether the connection is metered
     */
    get_network_metered(): boolean

    // Own virtual methods of Gio-2.0.Gio.NetworkMonitor

    /**
     * Attempts to determine whether or not the host pointed to by
     * `connectable` can be reached, without actually trying to connect to
     * it.
     * 
     * This may return %TRUE even when #GNetworkMonitor:network-available
     * is %FALSE, if, for example, `monitor` can determine that
     * `connectable` refers to a host on a local network.
     * 
     * If `monitor` believes that an attempt to connect to `connectable`
     * will succeed, it will return %TRUE. Otherwise, it will return
     * %FALSE and set `error` to an appropriate error (such as
     * %G_IO_ERROR_HOST_UNREACHABLE).
     * 
     * Note that although this does not attempt to connect to
     * `connectable,` it may still block for a brief period of time (eg,
     * trying to do multicast DNS on the local network), so if you do not
     * want to block, you should use g_network_monitor_can_reach_async().
     * @virtual 
     * @param connectable a #GSocketConnectable
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if @connectable is reachable, %FALSE if not.
     */
    vfunc_can_reach(connectable: SocketConnectable, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously attempts to determine whether or not the host
     * pointed to by `connectable` can be reached, without actually
     * trying to connect to it.
     * 
     * For more details, see g_network_monitor_can_reach().
     * 
     * When the operation is finished, `callback` will be called.
     * You can then call g_network_monitor_can_reach_finish()
     * to get the result of the operation.
     * @virtual 
     * @param connectable a #GSocketConnectable
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback to call when the     request is satisfied
     */
    vfunc_can_reach_async(connectable: SocketConnectable, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an async network connectivity test.
     * See g_network_monitor_can_reach_async().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if network is reachable, %FALSE if not.
     */
    vfunc_can_reach_finish(result: AsyncResult): boolean
    vfunc_network_changed(network_available: boolean): void

    // Own signals of Gio-2.0.Gio.NetworkMonitor

    connect(sigName: "network-changed", callback: NetworkMonitor.NetworkChangedSignalCallback): number
    connect_after(sigName: "network-changed", callback: NetworkMonitor.NetworkChangedSignalCallback): number
    emit(sigName: "network-changed", network_available: boolean, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.NetworkMonitor

    connect(sigName: "notify::connectivity", callback: (($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connectivity", callback: (($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::connectivity", ...args: any[]): void
    connect(sigName: "notify::network-available", callback: (($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::network-available", callback: (($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::network-available", ...args: any[]): void
    connect(sigName: "notify::network-metered", callback: (($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::network-metered", callback: (($obj: NetworkMonitor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::network-metered", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GNetworkMonitor provides an easy-to-use cross-platform API
 * for monitoring network connectivity. On Linux, the available
 * implementations are based on the kernel's netlink interface and
 * on NetworkManager.
 * 
 * There is also an implementation for use inside Flatpak sandboxes.
 * @interface 
 */
class NetworkMonitor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.NetworkMonitor

    static name: string
    static $gtype: GObject.GType<NetworkMonitor>

    // Constructors of Gio-2.0.Gio.NetworkMonitor

    constructor(config?: NetworkMonitor.ConstructorProperties) 
    _init(config?: NetworkMonitor.ConstructorProperties): void
    /**
     * Gets the default #GNetworkMonitor for the system.
     * @returns a #GNetworkMonitor, which will be     a dummy object if no network monitor is available
     */
    static get_default(): NetworkMonitor
}

module PollableInputStream {

    // Constructor properties interface

    interface ConstructorProperties extends InputStream.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface PollableInputStream extends InputStream {

    // Owm methods of Gio-2.0.Gio.PollableInputStream

    /**
     * Checks if `stream` is actually pollable. Some classes may implement
     * #GPollableInputStream but have only certain instances of that class
     * be pollable. If this method returns %FALSE, then the behavior of
     * other #GPollableInputStream methods is undefined.
     * 
     * For any given stream, the value returned by this method is constant;
     * a stream cannot switch from pollable to non-pollable or vice versa.
     * @returns %TRUE if @stream is pollable, %FALSE if not.
     */
    can_poll(): boolean
    /**
     * Creates a #GSource that triggers when `stream` can be read, or
     * `cancellable` is triggered or an error occurs. The callback on the
     * source is of the #GPollableSourceFunc type.
     * 
     * As with g_pollable_input_stream_is_readable(), it is possible that
     * the stream may not actually be readable even after the source
     * triggers, so you should use g_pollable_input_stream_read_nonblocking()
     * rather than g_input_stream_read() from the callback.
     * @param cancellable a #GCancellable, or %NULL
     * @returns a new #GSource
     */
    create_source(cancellable: Cancellable | null): GLib.Source
    /**
     * Checks if `stream` can be read.
     * 
     * Note that some stream types may not be able to implement this 100%
     * reliably, and it is possible that a call to g_input_stream_read()
     * after this returns %TRUE would still block. To guarantee
     * non-blocking behavior, you should always use
     * g_pollable_input_stream_read_nonblocking(), which will return a
     * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
     * @returns %TRUE if @stream is readable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_input_stream_is_readable() returning %TRUE, and the   next attempt to read will return the error.
     */
    is_readable(): boolean
    /**
     * Attempts to read up to `count` bytes from `stream` into `buffer,` as
     * with g_input_stream_read(). If `stream` is not currently readable,
     * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
     * use g_pollable_input_stream_create_source() to create a #GSource
     * that will be triggered when `stream` is readable.
     * 
     * Note that since this method never blocks, you cannot actually
     * use `cancellable` to cancel it. However, it will return an error
     * if `cancellable` has already been cancelled when you call, which
     * may happen if you call this method after a source triggers due
     * to having been cancelled.
     * @param cancellable a #GCancellable, or %NULL
     * @returns the number of bytes read, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
     */
    read_nonblocking(cancellable: Cancellable | null): [ /* returnType */ number, /* buffer */ Uint8Array ]

    // Own virtual methods of Gio-2.0.Gio.PollableInputStream

    /**
     * Checks if `stream` is actually pollable. Some classes may implement
     * #GPollableInputStream but have only certain instances of that class
     * be pollable. If this method returns %FALSE, then the behavior of
     * other #GPollableInputStream methods is undefined.
     * 
     * For any given stream, the value returned by this method is constant;
     * a stream cannot switch from pollable to non-pollable or vice versa.
     * @virtual 
     * @returns %TRUE if @stream is pollable, %FALSE if not.
     */
    vfunc_can_poll(): boolean
    /**
     * Creates a #GSource that triggers when `stream` can be read, or
     * `cancellable` is triggered or an error occurs. The callback on the
     * source is of the #GPollableSourceFunc type.
     * 
     * As with g_pollable_input_stream_is_readable(), it is possible that
     * the stream may not actually be readable even after the source
     * triggers, so you should use g_pollable_input_stream_read_nonblocking()
     * rather than g_input_stream_read() from the callback.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @returns a new #GSource
     */
    vfunc_create_source(cancellable: Cancellable | null): GLib.Source
    /**
     * Checks if `stream` can be read.
     * 
     * Note that some stream types may not be able to implement this 100%
     * reliably, and it is possible that a call to g_input_stream_read()
     * after this returns %TRUE would still block. To guarantee
     * non-blocking behavior, you should always use
     * g_pollable_input_stream_read_nonblocking(), which will return a
     * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
     * @virtual 
     * @returns %TRUE if @stream is readable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_input_stream_is_readable() returning %TRUE, and the   next attempt to read will return the error.
     */
    vfunc_is_readable(): boolean
    /**
     * Attempts to read up to `count` bytes from `stream` into `buffer,` as
     * with g_input_stream_read(). If `stream` is not currently readable,
     * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
     * use g_pollable_input_stream_create_source() to create a #GSource
     * that will be triggered when `stream` is readable.
     * 
     * Note that since this method never blocks, you cannot actually
     * use `cancellable` to cancel it. However, it will return an error
     * if `cancellable` has already been cancelled when you call, which
     * may happen if you call this method after a source triggers due
     * to having been cancelled.
     * @virtual 
     * @returns the number of bytes read, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
     */
    vfunc_read_nonblocking(): [ /* returnType */ number, /* buffer */ Uint8Array | null ]

    // Class property signals of Gio-2.0.Gio.PollableInputStream

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GPollableInputStream is implemented by #GInputStreams that
 * can be polled for readiness to read. This can be used when
 * interfacing with a non-GIO API that expects
 * UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
 * @interface 
 */
class PollableInputStream extends GObject.Object {

    // Own properties of Gio-2.0.Gio.PollableInputStream

    static name: string
    static $gtype: GObject.GType<PollableInputStream>

    // Constructors of Gio-2.0.Gio.PollableInputStream

    constructor(config?: PollableInputStream.ConstructorProperties) 
    _init(config?: PollableInputStream.ConstructorProperties): void
}

module PollableOutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends OutputStream.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface PollableOutputStream extends OutputStream {

    // Owm methods of Gio-2.0.Gio.PollableOutputStream

    /**
     * Checks if `stream` is actually pollable. Some classes may implement
     * #GPollableOutputStream but have only certain instances of that
     * class be pollable. If this method returns %FALSE, then the behavior
     * of other #GPollableOutputStream methods is undefined.
     * 
     * For any given stream, the value returned by this method is constant;
     * a stream cannot switch from pollable to non-pollable or vice versa.
     * @returns %TRUE if @stream is pollable, %FALSE if not.
     */
    can_poll(): boolean
    /**
     * Creates a #GSource that triggers when `stream` can be written, or
     * `cancellable` is triggered or an error occurs. The callback on the
     * source is of the #GPollableSourceFunc type.
     * 
     * As with g_pollable_output_stream_is_writable(), it is possible that
     * the stream may not actually be writable even after the source
     * triggers, so you should use g_pollable_output_stream_write_nonblocking()
     * rather than g_output_stream_write() from the callback.
     * @param cancellable a #GCancellable, or %NULL
     * @returns a new #GSource
     */
    create_source(cancellable: Cancellable | null): GLib.Source
    /**
     * Checks if `stream` can be written.
     * 
     * Note that some stream types may not be able to implement this 100%
     * reliably, and it is possible that a call to g_output_stream_write()
     * after this returns %TRUE would still block. To guarantee
     * non-blocking behavior, you should always use
     * g_pollable_output_stream_write_nonblocking(), which will return a
     * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
     * @returns %TRUE if @stream is writable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_output_stream_is_writable() returning %TRUE, and the   next attempt to write will return the error.
     */
    is_writable(): boolean
    /**
     * Attempts to write up to `count` bytes from `buffer` to `stream,` as
     * with g_output_stream_write(). If `stream` is not currently writable,
     * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
     * use g_pollable_output_stream_create_source() to create a #GSource
     * that will be triggered when `stream` is writable.
     * 
     * Note that since this method never blocks, you cannot actually
     * use `cancellable` to cancel it. However, it will return an error
     * if `cancellable` has already been cancelled when you call, which
     * may happen if you call this method after a source triggers due
     * to having been cancelled.
     * 
     * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
     * transports like D/TLS require that you re-send the same `buffer` and
     * `count` in the next write call.
     * @param buffer a buffer to write     data from
     * @param cancellable a #GCancellable, or %NULL
     * @returns the number of bytes written, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
     */
    write_nonblocking(buffer: Uint8Array, cancellable: Cancellable | null): number
    /**
     * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
     * as with g_output_stream_writev(). If `stream` is not currently writable,
     * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
     * use g_pollable_output_stream_create_source() to create a #GSource
     * that will be triggered when `stream` is writable. `error` will *not* be
     * set in that case.
     * 
     * Note that since this method never blocks, you cannot actually
     * use `cancellable` to cancel it. However, it will return an error
     * if `cancellable` has already been cancelled when you call, which
     * may happen if you call this method after a source triggers due
     * to having been cancelled.
     * 
     * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
     * transports like D/TLS require that you re-send the same `vectors` and
     * `n_vectors` in the next write call.
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param cancellable a #GCancellable, or %NULL
     * @returns %@G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable (and @error is *not* set), or %G_POLLABLE_RETURN_FAILED if there was an error in which case @error will be set.
     */
    writev_nonblocking(vectors: OutputVector[], cancellable: Cancellable | null): [ /* returnType */ PollableReturn, /* bytes_written */ number ]

    // Own virtual methods of Gio-2.0.Gio.PollableOutputStream

    /**
     * Checks if `stream` is actually pollable. Some classes may implement
     * #GPollableOutputStream but have only certain instances of that
     * class be pollable. If this method returns %FALSE, then the behavior
     * of other #GPollableOutputStream methods is undefined.
     * 
     * For any given stream, the value returned by this method is constant;
     * a stream cannot switch from pollable to non-pollable or vice versa.
     * @virtual 
     * @returns %TRUE if @stream is pollable, %FALSE if not.
     */
    vfunc_can_poll(): boolean
    /**
     * Creates a #GSource that triggers when `stream` can be written, or
     * `cancellable` is triggered or an error occurs. The callback on the
     * source is of the #GPollableSourceFunc type.
     * 
     * As with g_pollable_output_stream_is_writable(), it is possible that
     * the stream may not actually be writable even after the source
     * triggers, so you should use g_pollable_output_stream_write_nonblocking()
     * rather than g_output_stream_write() from the callback.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @returns a new #GSource
     */
    vfunc_create_source(cancellable: Cancellable | null): GLib.Source
    /**
     * Checks if `stream` can be written.
     * 
     * Note that some stream types may not be able to implement this 100%
     * reliably, and it is possible that a call to g_output_stream_write()
     * after this returns %TRUE would still block. To guarantee
     * non-blocking behavior, you should always use
     * g_pollable_output_stream_write_nonblocking(), which will return a
     * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
     * @virtual 
     * @returns %TRUE if @stream is writable, %FALSE if not. If an error   has occurred on @stream, this will result in   g_pollable_output_stream_is_writable() returning %TRUE, and the   next attempt to write will return the error.
     */
    vfunc_is_writable(): boolean
    /**
     * Attempts to write up to `count` bytes from `buffer` to `stream,` as
     * with g_output_stream_write(). If `stream` is not currently writable,
     * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
     * use g_pollable_output_stream_create_source() to create a #GSource
     * that will be triggered when `stream` is writable.
     * 
     * Note that since this method never blocks, you cannot actually
     * use `cancellable` to cancel it. However, it will return an error
     * if `cancellable` has already been cancelled when you call, which
     * may happen if you call this method after a source triggers due
     * to having been cancelled.
     * 
     * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
     * transports like D/TLS require that you re-send the same `buffer` and
     * `count` in the next write call.
     * @virtual 
     * @param buffer a buffer to write     data from
     * @returns the number of bytes written, or -1 on error (including   %G_IO_ERROR_WOULD_BLOCK).
     */
    vfunc_write_nonblocking(buffer: Uint8Array | null): number
    /**
     * Attempts to write the bytes contained in the `n_vectors` `vectors` to `stream,`
     * as with g_output_stream_writev(). If `stream` is not currently writable,
     * this will immediately return %`G_POLLABLE_RETURN_WOULD_BLOCK,` and you can
     * use g_pollable_output_stream_create_source() to create a #GSource
     * that will be triggered when `stream` is writable. `error` will *not* be
     * set in that case.
     * 
     * Note that since this method never blocks, you cannot actually
     * use `cancellable` to cancel it. However, it will return an error
     * if `cancellable` has already been cancelled when you call, which
     * may happen if you call this method after a source triggers due
     * to having been cancelled.
     * 
     * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
     * transports like D/TLS require that you re-send the same `vectors` and
     * `n_vectors` in the next write call.
     * @virtual 
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @returns %@G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK if the stream is not currently writable (and @error is *not* set), or %G_POLLABLE_RETURN_FAILED if there was an error in which case @error will be set.
     */
    vfunc_writev_nonblocking(vectors: OutputVector[]): [ /* returnType */ PollableReturn, /* bytes_written */ number ]

    // Class property signals of Gio-2.0.Gio.PollableOutputStream

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GPollableOutputStream is implemented by #GOutputStreams that
 * can be polled for readiness to write. This can be used when
 * interfacing with a non-GIO API that expects
 * UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
 * @interface 
 */
class PollableOutputStream extends GObject.Object {

    // Own properties of Gio-2.0.Gio.PollableOutputStream

    static name: string
    static $gtype: GObject.GType<PollableOutputStream>

    // Constructors of Gio-2.0.Gio.PollableOutputStream

    constructor(config?: PollableOutputStream.ConstructorProperties) 
    _init(config?: PollableOutputStream.ConstructorProperties): void
}

module PowerProfileMonitor {

    // Constructor properties interface

    interface ConstructorProperties extends Initable.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface PowerProfileMonitor extends Initable {

    // Own properties of Gio-2.0.Gio.PowerProfileMonitor

    /**
     * Whether “Power Saver” mode is enabled on the system.
     */
    readonly power_saver_enabled: boolean

    // Owm methods of Gio-2.0.Gio.PowerProfileMonitor

    /**
     * Gets whether the system is in “Power Saver” mode.
     * 
     * You are expected to listen to the
     * #GPowerProfileMonitor::notify::power-saver-enabled signal to know when the profile has
     * changed.
     * @returns Whether the system is in “Power Saver” mode.
     */
    get_power_saver_enabled(): boolean

    // Class property signals of Gio-2.0.Gio.PowerProfileMonitor

    connect(sigName: "notify::power-saver-enabled", callback: (($obj: PowerProfileMonitor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::power-saver-enabled", callback: (($obj: PowerProfileMonitor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::power-saver-enabled", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GPowerProfileMonitor makes it possible for applications as well as OS components
 * to monitor system power profiles and act upon them. It currently only exports
 * whether the system is in “Power Saver” mode (known as “Low Power” mode on
 * some systems).
 * 
 * When in “Low Power” mode, it is recommended that applications:
 * - disable automatic downloads;
 * - reduce the rate of refresh from online sources such as calendar or
 *   email synchronisation;
 * - reduce the use of expensive visual effects.
 * 
 * It is also likely that OS components providing services to applications will
 * lower their own background activity, for the sake of the system.
 * 
 * There are a variety of tools that exist for power consumption analysis, but those
 * usually depend on the OS and hardware used. On Linux, one could use `upower` to
 * monitor the battery discharge rate, `powertop` to check on the background activity
 * or activity at all), `sysprof` to inspect CPU usage, and `intel_gpu_time` to
 * profile GPU usage.
 * 
 * Don't forget to disconnect the #GPowerProfileMonitor::notify::power-saver-enabled
 * signal, and unref the #GPowerProfileMonitor itself when exiting.
 * @interface 
 */
class PowerProfileMonitor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.PowerProfileMonitor

    static name: string
    static $gtype: GObject.GType<PowerProfileMonitor>

    // Constructors of Gio-2.0.Gio.PowerProfileMonitor

    constructor(config?: PowerProfileMonitor.ConstructorProperties) 
    _init(config?: PowerProfileMonitor.ConstructorProperties): void
    /**
     * Gets a reference to the default #GPowerProfileMonitor for the system.
     * @returns a new reference to the default #GPowerProfileMonitor
     */
    static dup_default(): PowerProfileMonitor
}

module Proxy {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Proxy {

    // Owm methods of Gio-2.0.Gio.Proxy

    /**
     * Given `connection` to communicate with a proxy (eg, a
     * #GSocketConnection that is connected to the proxy server), this
     * does the necessary handshake to connect to `proxy_address,` and if
     * required, wraps the #GIOStream to handle proxy payload.
     * @param connection a #GIOStream
     * @param proxy_address a #GProxyAddress
     * @param cancellable a #GCancellable
     * @returns a #GIOStream that will replace @connection. This might               be the same as @connection, in which case a reference               will be added.
     */
    connect(connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | null): IOStream
    /**
     * Asynchronous version of g_proxy_connect().
     * @param connection a #GIOStream
     * @param proxy_address a #GProxyAddress
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback
     */
    connect_async(connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of connect_async

    /**
     * Promisified version of {@link connect_async}
     * 
     * Asynchronous version of g_proxy_connect().
     * @param connection a #GIOStream
     * @param proxy_address a #GProxyAddress
     * @param cancellable a #GCancellable
     * @returns A Promise of: a #GIOStream.
     */
    connect_async(connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | null): globalThis.Promise<IOStream>
    /**
     * See g_proxy_connect().
     * @param result a #GAsyncResult
     * @returns a #GIOStream.
     */
    connect_finish(result: AsyncResult): IOStream
    /**
     * Some proxy protocols expect to be passed a hostname, which they
     * will resolve to an IP address themselves. Others, like SOCKS4, do
     * not allow this. This function will return %FALSE if `proxy` is
     * implementing such a protocol. When %FALSE is returned, the caller
     * should resolve the destination hostname first, and then pass a
     * #GProxyAddress containing the stringified IP address to
     * g_proxy_connect() or g_proxy_connect_async().
     * @returns %TRUE if hostname resolution is supported.
     */
    supports_hostname(): boolean

    // Own virtual methods of Gio-2.0.Gio.Proxy

    /**
     * Given `connection` to communicate with a proxy (eg, a
     * #GSocketConnection that is connected to the proxy server), this
     * does the necessary handshake to connect to `proxy_address,` and if
     * required, wraps the #GIOStream to handle proxy payload.
     * @virtual 
     * @param connection a #GIOStream
     * @param proxy_address a #GProxyAddress
     * @param cancellable a #GCancellable
     * @returns a #GIOStream that will replace @connection. This might               be the same as @connection, in which case a reference               will be added.
     */
    vfunc_connect(connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | null): IOStream
    /**
     * Asynchronous version of g_proxy_connect().
     * @virtual 
     * @param connection a #GIOStream
     * @param proxy_address a #GProxyAddress
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback
     */
    vfunc_connect_async(connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * See g_proxy_connect().
     * @virtual 
     * @param result a #GAsyncResult
     * @returns a #GIOStream.
     */
    vfunc_connect_finish(result: AsyncResult): IOStream
    /**
     * Some proxy protocols expect to be passed a hostname, which they
     * will resolve to an IP address themselves. Others, like SOCKS4, do
     * not allow this. This function will return %FALSE if `proxy` is
     * implementing such a protocol. When %FALSE is returned, the caller
     * should resolve the destination hostname first, and then pass a
     * #GProxyAddress containing the stringified IP address to
     * g_proxy_connect() or g_proxy_connect_async().
     * @virtual 
     * @returns %TRUE if hostname resolution is supported.
     */
    vfunc_supports_hostname(): boolean

    // Class property signals of Gio-2.0.Gio.Proxy

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GProxy handles connecting to a remote host via a given type of
 * proxy server. It is implemented by the 'gio-proxy' extension point.
 * The extensions are named after their proxy protocol name. As an
 * example, a SOCKS5 proxy implementation can be retrieved with the
 * name 'socks5' using the function
 * g_io_extension_point_get_extension_by_name().
 * @interface 
 */
class Proxy extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Proxy

    static name: string
    static $gtype: GObject.GType<Proxy>

    // Constructors of Gio-2.0.Gio.Proxy

    constructor(config?: Proxy.ConstructorProperties) 
    _init(config?: Proxy.ConstructorProperties): void
    /**
     * Find the `gio-proxy` extension point for a proxy implementation that supports
     * the specified protocol.
     * @param protocol the proxy protocol name (e.g. http, socks, etc)
     * @returns return a #GProxy or NULL if protocol               is not supported.
     */
    static get_default_for_protocol(protocol: string | null): Proxy | null
}

module ProxyResolver {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface ProxyResolver {

    // Owm methods of Gio-2.0.Gio.ProxyResolver

    /**
     * Checks if `resolver` can be used on this system. (This is used
     * internally; g_proxy_resolver_get_default() will only return a proxy
     * resolver that returns %TRUE for this method.)
     * @returns %TRUE if @resolver is supported.
     */
    is_supported(): boolean
    /**
     * Looks into the system proxy configuration to determine what proxy,
     * if any, to use to connect to `uri`. The returned proxy URIs are of
     * the form `<protocol>://[user[:password]`]`host[:port]` or
     * `direct://`, where <protocol> could be http, rtsp, socks
     * or other proxying protocol.
     * 
     * If you don't know what network protocol is being used on the
     * socket, you should use `none` as the URI protocol.
     * In this case, the resolver might still return a generic proxy type
     * (such as SOCKS), but would not return protocol-specific proxy types
     * (such as http).
     * 
     * `direct://` is used when no proxy is needed.
     * Direct connection should not be attempted unless it is part of the
     * returned array of proxies.
     * @param uri a URI representing the destination to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
     */
    lookup(uri: string | null, cancellable: Cancellable | null): string[]
    /**
     * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
     * details.
     * @param uri a URI representing the destination to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    lookup_async(uri: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_async

    /**
     * Promisified version of {@link lookup_async}
     * 
     * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
     * details.
     * @param uri a URI representing the destination to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
     */
    lookup_async(uri: string | null, cancellable: Cancellable | null): globalThis.Promise<string[]>
    /**
     * Call this function to obtain the array of proxy URIs when
     * g_proxy_resolver_lookup_async() is complete. See
     * g_proxy_resolver_lookup() for more details.
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
     */
    lookup_finish(result: AsyncResult): string[]

    // Own virtual methods of Gio-2.0.Gio.ProxyResolver

    /**
     * Checks if `resolver` can be used on this system. (This is used
     * internally; g_proxy_resolver_get_default() will only return a proxy
     * resolver that returns %TRUE for this method.)
     * @virtual 
     * @returns %TRUE if @resolver is supported.
     */
    vfunc_is_supported(): boolean
    /**
     * Looks into the system proxy configuration to determine what proxy,
     * if any, to use to connect to `uri`. The returned proxy URIs are of
     * the form `<protocol>://[user[:password]`]`host[:port]` or
     * `direct://`, where <protocol> could be http, rtsp, socks
     * or other proxying protocol.
     * 
     * If you don't know what network protocol is being used on the
     * socket, you should use `none` as the URI protocol.
     * In this case, the resolver might still return a generic proxy type
     * (such as SOCKS), but would not return protocol-specific proxy types
     * (such as http).
     * 
     * `direct://` is used when no proxy is needed.
     * Direct connection should not be attempted unless it is part of the
     * returned array of proxies.
     * @virtual 
     * @param uri a URI representing the destination to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
     */
    vfunc_lookup(uri: string | null, cancellable: Cancellable | null): string[]
    /**
     * Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
     * details.
     * @virtual 
     * @param uri a URI representing the destination to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    vfunc_lookup_async(uri: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Call this function to obtain the array of proxy URIs when
     * g_proxy_resolver_lookup_async() is complete. See
     * g_proxy_resolver_lookup() for more details.
     * @virtual 
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns A               NULL-terminated array of proxy URIs. Must be freed               with g_strfreev().
     */
    vfunc_lookup_finish(result: AsyncResult): string[]

    // Class property signals of Gio-2.0.Gio.ProxyResolver

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GProxyResolver provides synchronous and asynchronous network proxy
 * resolution. #GProxyResolver is used within #GSocketClient through
 * the method g_socket_connectable_proxy_enumerate().
 * 
 * Implementations of #GProxyResolver based on libproxy and GNOME settings can
 * be found in glib-networking. GIO comes with an implementation for use inside
 * Flatpak portals.
 * @interface 
 */
class ProxyResolver extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ProxyResolver

    static name: string
    static $gtype: GObject.GType<ProxyResolver>

    // Constructors of Gio-2.0.Gio.ProxyResolver

    constructor(config?: ProxyResolver.ConstructorProperties) 
    _init(config?: ProxyResolver.ConstructorProperties): void
    /**
     * Gets the default #GProxyResolver for the system.
     * @returns the default #GProxyResolver, which     will be a dummy object if no proxy resolver is available
     */
    static get_default(): ProxyResolver
}

module RemoteActionGroup {

    // Constructor properties interface

    interface ConstructorProperties extends ActionGroup.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface RemoteActionGroup extends ActionGroup {

    // Owm methods of Gio-2.0.Gio.RemoteActionGroup

    /**
     * Activates the remote action.
     * 
     * This is the same as g_action_group_activate_action() except that it
     * allows for provision of "platform data" to be sent along with the
     * activation request.  This typically contains details such as the user
     * interaction timestamp or startup notification information.
     * 
     * `platform_data` must be non-%NULL and must have the type
     * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
     * @param action_name the name of the action to activate
     * @param parameter the optional parameter to the activation
     * @param platform_data the platform data to send
     */
    activate_action_full(action_name: string | null, parameter: GLib.Variant | null, platform_data: GLib.Variant): void
    /**
     * Changes the state of a remote action.
     * 
     * This is the same as g_action_group_change_action_state() except that
     * it allows for provision of "platform data" to be sent along with the
     * state change request.  This typically contains details such as the
     * user interaction timestamp or startup notification information.
     * 
     * `platform_data` must be non-%NULL and must have the type
     * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
     * @param action_name the name of the action to change the state of
     * @param value the new requested value for the state
     * @param platform_data the platform data to send
     */
    change_action_state_full(action_name: string | null, value: GLib.Variant, platform_data: GLib.Variant): void

    // Own virtual methods of Gio-2.0.Gio.RemoteActionGroup

    /**
     * Activates the remote action.
     * 
     * This is the same as g_action_group_activate_action() except that it
     * allows for provision of "platform data" to be sent along with the
     * activation request.  This typically contains details such as the user
     * interaction timestamp or startup notification information.
     * 
     * `platform_data` must be non-%NULL and must have the type
     * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
     * @virtual 
     * @param action_name the name of the action to activate
     * @param parameter the optional parameter to the activation
     * @param platform_data the platform data to send
     */
    vfunc_activate_action_full(action_name: string | null, parameter: GLib.Variant | null, platform_data: GLib.Variant): void
    /**
     * Changes the state of a remote action.
     * 
     * This is the same as g_action_group_change_action_state() except that
     * it allows for provision of "platform data" to be sent along with the
     * state change request.  This typically contains details such as the
     * user interaction timestamp or startup notification information.
     * 
     * `platform_data` must be non-%NULL and must have the type
     * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
     * @virtual 
     * @param action_name the name of the action to change the state of
     * @param value the new requested value for the state
     * @param platform_data the platform data to send
     */
    vfunc_change_action_state_full(action_name: string | null, value: GLib.Variant, platform_data: GLib.Variant): void

    // Class property signals of Gio-2.0.Gio.RemoteActionGroup

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The GRemoteActionGroup interface is implemented by #GActionGroup
 * instances that either transmit action invocations to other processes
 * or receive action invocations in the local process from other
 * processes.
 * 
 * The interface has `_full` variants of the two
 * methods on #GActionGroup used to activate actions:
 * g_action_group_activate_action() and
 * g_action_group_change_action_state(). These variants allow a
 * "platform data" #GVariant to be specified: a dictionary providing
 * context for the action invocation (for example: timestamps, startup
 * notification IDs, etc).
 * 
 * #GDBusActionGroup implements #GRemoteActionGroup.  This provides a
 * mechanism to send platform data for action invocations over D-Bus.
 * 
 * Additionally, g_dbus_connection_export_action_group() will check if
 * the exported #GActionGroup implements #GRemoteActionGroup and use the
 * `_full` variants of the calls if available.  This
 * provides a mechanism by which to receive platform data for action
 * invocations that arrive by way of D-Bus.
 * @interface 
 */
class RemoteActionGroup extends GObject.Object {

    // Own properties of Gio-2.0.Gio.RemoteActionGroup

    static name: string
    static $gtype: GObject.GType<RemoteActionGroup>

    // Constructors of Gio-2.0.Gio.RemoteActionGroup

    constructor(config?: RemoteActionGroup.ConstructorProperties) 
    _init(config?: RemoteActionGroup.ConstructorProperties): void
}

module Seekable {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Seekable {

    // Owm methods of Gio-2.0.Gio.Seekable

    /**
     * Tests if the stream supports the #GSeekableIface.
     * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
     */
    can_seek(): boolean
    /**
     * Tests if the length of the stream can be adjusted with
     * g_seekable_truncate().
     * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
     */
    can_truncate(): boolean
    /**
     * Seeks in the stream by the given `offset,` modified by `type`.
     * 
     * Attempting to seek past the end of the stream will have different
     * results depending on if the stream is fixed-sized or resizable.  If
     * the stream is resizable then seeking past the end and then writing
     * will result in zeros filling the empty space.  Seeking past the end
     * of a resizable stream and reading will result in EOF.  Seeking past
     * the end of a fixed-sized stream will fail.
     * 
     * Any operation that would result in a negative offset will fail.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param offset a #goffset.
     * @param type a #GSeekType.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
     */
    seek(offset: number, type: GLib.SeekType, cancellable: Cancellable | null): boolean
    /**
     * Tells the current position within the stream.
     * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
     */
    tell(): number
    /**
     * Sets the length of the stream to `offset`. If the stream was previously
     * larger than `offset,` the extra data is discarded. If the stream was
     * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * @param offset new length for `seekable,` in bytes.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
     */
    truncate(offset: number, cancellable: Cancellable | null): boolean

    // Own virtual methods of Gio-2.0.Gio.Seekable

    /**
     * Tests if the stream supports the #GSeekableIface.
     * @virtual 
     * @returns %TRUE if @seekable can be seeked. %FALSE otherwise.
     */
    vfunc_can_seek(): boolean
    /**
     * Tests if the length of the stream can be adjusted with
     * g_seekable_truncate().
     * @virtual 
     * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
     */
    vfunc_can_truncate(): boolean
    /**
     * Seeks in the stream by the given `offset,` modified by `type`.
     * 
     * Attempting to seek past the end of the stream will have different
     * results depending on if the stream is fixed-sized or resizable.  If
     * the stream is resizable then seeking past the end and then writing
     * will result in zeros filling the empty space.  Seeking past the end
     * of a resizable stream and reading will result in EOF.  Seeking past
     * the end of a fixed-sized stream will fail.
     * 
     * Any operation that would result in a negative offset will fail.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param offset a #goffset.
     * @param type a #GSeekType.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
     */
    vfunc_seek(offset: number, type: GLib.SeekType, cancellable: Cancellable | null): boolean
    /**
     * Tells the current position within the stream.
     * @virtual 
     * @returns the (positive or zero) offset from the beginning of the buffer, zero if the target is not seekable.
     */
    vfunc_tell(): number
    /**
     * Sets the length of the stream to `offset`. If the stream was previously
     * larger than `offset,` the extra data is discarded. If the stream was
     * previously shorter than `offset,` it is extended with NUL ('\0') bytes.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * @virtual 
     * @param offset new length for `seekable,` in bytes.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if successful. If an error     has occurred, this function will return %FALSE and set @error     appropriately if present.
     */
    vfunc_truncate_fn(offset: number, cancellable: Cancellable | null): boolean

    // Class property signals of Gio-2.0.Gio.Seekable

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSeekable is implemented by streams (implementations of
 * #GInputStream or #GOutputStream) that support seeking.
 * 
 * Seekable streams largely fall into two categories: resizable and
 * fixed-size.
 * 
 * #GSeekable on fixed-sized streams is approximately the same as POSIX
 * lseek() on a block device (for example: attempting to seek past the
 * end of the device is an error).  Fixed streams typically cannot be
 * truncated.
 * 
 * #GSeekable on resizable streams is approximately the same as POSIX
 * lseek() on a normal file.  Seeking past the end and writing data will
 * usually cause the stream to resize by introducing zero bytes.
 * @interface 
 */
class Seekable extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Seekable

    static name: string
    static $gtype: GObject.GType<Seekable>

    // Constructors of Gio-2.0.Gio.Seekable

    constructor(config?: Seekable.ConstructorProperties) 
    _init(config?: Seekable.ConstructorProperties): void
}

module SocketConnectable {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface SocketConnectable {

    // Owm methods of Gio-2.0.Gio.SocketConnectable

    /**
     * Creates a #GSocketAddressEnumerator for `connectable`.
     * @returns a new #GSocketAddressEnumerator.
     */
    enumerate(): SocketAddressEnumerator
    /**
     * Creates a #GSocketAddressEnumerator for `connectable` that will
     * return a #GProxyAddress for each of its addresses that you must connect
     * to via a proxy.
     * 
     * If `connectable` does not implement
     * g_socket_connectable_proxy_enumerate(), this will fall back to
     * calling g_socket_connectable_enumerate().
     * @returns a new #GSocketAddressEnumerator.
     */
    proxy_enumerate(): SocketAddressEnumerator
    /**
     * Format a #GSocketConnectable as a string. This is a human-readable format for
     * use in debugging output, and is not a stable serialization format. It is not
     * suitable for use in user interfaces as it exposes too much information for a
     * user.
     * 
     * If the #GSocketConnectable implementation does not support string formatting,
     * the implementation’s type name will be returned as a fallback.
     * @returns the formatted string
     */
    to_string(): string | null

    // Own virtual methods of Gio-2.0.Gio.SocketConnectable

    /**
     * Creates a #GSocketAddressEnumerator for `connectable`.
     * @virtual 
     * @returns a new #GSocketAddressEnumerator.
     */
    vfunc_enumerate(): SocketAddressEnumerator
    /**
     * Creates a #GSocketAddressEnumerator for `connectable` that will
     * return a #GProxyAddress for each of its addresses that you must connect
     * to via a proxy.
     * 
     * If `connectable` does not implement
     * g_socket_connectable_proxy_enumerate(), this will fall back to
     * calling g_socket_connectable_enumerate().
     * @virtual 
     * @returns a new #GSocketAddressEnumerator.
     */
    vfunc_proxy_enumerate(): SocketAddressEnumerator
    /**
     * Format a #GSocketConnectable as a string. This is a human-readable format for
     * use in debugging output, and is not a stable serialization format. It is not
     * suitable for use in user interfaces as it exposes too much information for a
     * user.
     * 
     * If the #GSocketConnectable implementation does not support string formatting,
     * the implementation’s type name will be returned as a fallback.
     * @virtual 
     * @returns the formatted string
     */
    vfunc_to_string(): string | null

    // Class property signals of Gio-2.0.Gio.SocketConnectable

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Objects that describe one or more potential socket endpoints
 * implement #GSocketConnectable. Callers can then use
 * g_socket_connectable_enumerate() to get a #GSocketAddressEnumerator
 * to try out each socket address in turn until one succeeds, as shown
 * in the sample code below.
 * 
 * 
 * ```c
 * MyConnectionType *
 * connect_to_host (const char    *hostname,
 *                  guint16        port,
 *                  GCancellable  *cancellable,
 *                  GError       **error)
 * {
 *   MyConnection *conn = NULL;
 *   GSocketConnectable *addr;
 *   GSocketAddressEnumerator *enumerator;
 *   GSocketAddress *sockaddr;
 *   GError *conn_error = NULL;
 * 
 *   addr = g_network_address_new (hostname, port);
 *   enumerator = g_socket_connectable_enumerate (addr);
 *   g_object_unref (addr);
 * 
 *   // Try each sockaddr until we succeed. Record the first connection error,
 *   // but not any further ones (since they'll probably be basically the same
 *   // as the first).
 *   while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
 *     {
 *       conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
 *       g_object_unref (sockaddr);
 *     }
 *   g_object_unref (enumerator);
 * 
 *   if (conn)
 *     {
 *       if (conn_error)
 *         {
 *           // We couldn't connect to the first address, but we succeeded
 *           // in connecting to a later address.
 *           g_error_free (conn_error);
 *         }
 *       return conn;
 *     }
 *   else if (error)
 *     {
 *       /// Either initial lookup failed, or else the caller cancelled us.
 *       if (conn_error)
 *         g_error_free (conn_error);
 *       return NULL;
 *     }
 *   else
 *     {
 *       g_error_propagate (error, conn_error);
 *       return NULL;
 *     }
 * }
 * ```
 * 
 * @interface 
 */
class SocketConnectable extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SocketConnectable

    static name: string
    static $gtype: GObject.GType<SocketConnectable>

    // Constructors of Gio-2.0.Gio.SocketConnectable

    constructor(config?: SocketConnectable.ConstructorProperties) 
    _init(config?: SocketConnectable.ConstructorProperties): void
}

module TlsBackend {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface TlsBackend {

    // Owm methods of Gio-2.0.Gio.TlsBackend

    /**
     * Gets the #GType of `backend'`s #GTlsCertificate implementation.
     * @returns the #GType of @backend's #GTlsCertificate   implementation.
     */
    get_certificate_type(): GObject.GType
    /**
     * Gets the #GType of `backend'`s #GTlsClientConnection implementation.
     * @returns the #GType of @backend's #GTlsClientConnection   implementation.
     */
    get_client_connection_type(): GObject.GType
    /**
     * Gets the default #GTlsDatabase used to verify TLS connections.
     * @returns the default database, which should be               unreffed when done.
     */
    get_default_database(): TlsDatabase
    /**
     * Gets the #GType of `backend’`s #GDtlsClientConnection implementation.
     * @returns the #GType of @backend’s #GDtlsClientConnection   implementation, or %G_TYPE_INVALID if this backend doesn’t support DTLS.
     */
    get_dtls_client_connection_type(): GObject.GType
    /**
     * Gets the #GType of `backend’`s #GDtlsServerConnection implementation.
     * @returns the #GType of @backend’s #GDtlsServerConnection   implementation, or %G_TYPE_INVALID if this backend doesn’t support DTLS.
     */
    get_dtls_server_connection_type(): GObject.GType
    /**
     * Gets the #GType of `backend'`s #GTlsFileDatabase implementation.
     * @returns the #GType of backend's #GTlsFileDatabase implementation.
     */
    get_file_database_type(): GObject.GType
    /**
     * Gets the #GType of `backend'`s #GTlsServerConnection implementation.
     * @returns the #GType of @backend's #GTlsServerConnection   implementation.
     */
    get_server_connection_type(): GObject.GType
    /**
     * Set the default #GTlsDatabase used to verify TLS connections
     * 
     * Any subsequent call to g_tls_backend_get_default_database() will return
     * the database set in this call.  Existing databases and connections are not
     * modified.
     * 
     * Setting a %NULL default database will reset to using the system default
     * database as if g_tls_backend_set_default_database() had never been called.
     * @param database the #GTlsDatabase
     */
    set_default_database(database: TlsDatabase | null): void
    /**
     * Checks if DTLS is supported. DTLS support may not be available even if TLS
     * support is available, and vice-versa.
     * @returns whether DTLS is supported
     */
    supports_dtls(): boolean
    /**
     * Checks if TLS is supported; if this returns %FALSE for the default
     * #GTlsBackend, it means no "real" TLS backend is available.
     * @returns whether or not TLS is supported
     */
    supports_tls(): boolean

    // Own virtual methods of Gio-2.0.Gio.TlsBackend

    /**
     * Gets the default #GTlsDatabase used to verify TLS connections.
     * @virtual 
     * @returns the default database, which should be               unreffed when done.
     */
    vfunc_get_default_database(): TlsDatabase
    /**
     * Checks if DTLS is supported. DTLS support may not be available even if TLS
     * support is available, and vice-versa.
     * @virtual 
     * @returns whether DTLS is supported
     */
    vfunc_supports_dtls(): boolean
    /**
     * Checks if TLS is supported; if this returns %FALSE for the default
     * #GTlsBackend, it means no "real" TLS backend is available.
     * @virtual 
     * @returns whether or not TLS is supported
     */
    vfunc_supports_tls(): boolean

    // Class property signals of Gio-2.0.Gio.TlsBackend

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * TLS (Transport Layer Security, aka SSL) and DTLS backend.
 * @interface 
 */
class TlsBackend extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TlsBackend

    static name: string
    static $gtype: GObject.GType<TlsBackend>

    // Constructors of Gio-2.0.Gio.TlsBackend

    constructor(config?: TlsBackend.ConstructorProperties) 
    _init(config?: TlsBackend.ConstructorProperties): void
    /**
     * Gets the default #GTlsBackend for the system.
     * @returns a #GTlsBackend, which will be a     dummy object if no TLS backend is available
     */
    static get_default(): TlsBackend
}

module TlsClientConnection {

    // Constructor properties interface

    interface ConstructorProperties extends TlsConnection.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TlsClientConnection

        /**
         * A #GSocketConnectable describing the identity of the server that
         * is expected on the other end of the connection.
         * 
         * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
         * #GTlsClientConnection:validation-flags, this object will be used
         * to determine the expected identify of the remote end of the
         * connection; if #GTlsClientConnection:server-identity is not set,
         * or does not match the identity presented by the server, then the
         * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
         * 
         * In addition to its use in verifying the server certificate,
         * this is also used to give a hint to the server about what
         * certificate we expect, which is useful for servers that serve
         * virtual hosts.
         */
        server_identity?: SocketConnectable | null
        /**
         * SSL 3.0 is no longer supported. See
         * g_tls_client_connection_set_use_ssl3() for details.
         */
        use_ssl3?: boolean | null
        /**
         * What steps to perform when validating a certificate received from
         * a server. Server certificates that fail to validate in any of the
         * ways indicated here will be rejected unless the application
         * overrides the default via #GTlsConnection::accept-certificate.
         * 
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to #GTlsConnection::accept-certificate.
         */
        validation_flags?: TlsCertificateFlags | null
    }

}

interface TlsClientConnection extends TlsConnection {

    // Own properties of Gio-2.0.Gio.TlsClientConnection

    /**
     * A list of the distinguished names of the Certificate Authorities
     * that the server will accept client certificates signed by. If the
     * server requests a client certificate during the handshake, then
     * this property will be set after the handshake completes.
     * 
     * Each item in the list is a #GByteArray which contains the complete
     * subject DN of the certificate authority.
     */
    readonly accepted_cas: any[]
    /**
     * A #GSocketConnectable describing the identity of the server that
     * is expected on the other end of the connection.
     * 
     * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
     * #GTlsClientConnection:validation-flags, this object will be used
     * to determine the expected identify of the remote end of the
     * connection; if #GTlsClientConnection:server-identity is not set,
     * or does not match the identity presented by the server, then the
     * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
     * 
     * In addition to its use in verifying the server certificate,
     * this is also used to give a hint to the server about what
     * certificate we expect, which is useful for servers that serve
     * virtual hosts.
     */
    server_identity: SocketConnectable
    /**
     * SSL 3.0 is no longer supported. See
     * g_tls_client_connection_set_use_ssl3() for details.
     */
    use_ssl3: boolean
    /**
     * What steps to perform when validating a certificate received from
     * a server. Server certificates that fail to validate in any of the
     * ways indicated here will be rejected unless the application
     * overrides the default via #GTlsConnection::accept-certificate.
     * 
     * GLib guarantees that if certificate verification fails, at least one
     * flag will be set, but it does not guarantee that all possible flags
     * will be set. Accordingly, you may not safely decide to ignore any
     * particular type of error. For example, it would be incorrect to mask
     * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
     * because this could potentially be the only error flag set even if
     * other problems exist with the certificate. Therefore, there is no
     * safe way to use this property. This is not a horrible problem,
     * though, because you should not be attempting to ignore validation
     * errors anyway. If you really must ignore TLS certificate errors,
     * connect to #GTlsConnection::accept-certificate.
     */
    validation_flags: TlsCertificateFlags

    // Conflicting properties

    parent_instance: IOStream & GObject.Object & GObject.Object

    // Owm methods of Gio-2.0.Gio.TlsClientConnection

    /**
     * Possibly copies session state from one connection to another, for use
     * in TLS session resumption. This is not normally needed, but may be
     * used when the same session needs to be used between different
     * endpoints, as is required by some protocols, such as FTP over TLS.
     * `source` should have already completed a handshake and, since TLS 1.3,
     * it should have been used to read data at least once. `conn` should not
     * have completed a handshake.
     * 
     * It is not possible to know whether a call to this function will
     * actually do anything. Because session resumption is normally used
     * only for performance benefit, the TLS backend might not implement
     * this function. Even if implemented, it may not actually succeed in
     * allowing `conn` to resume `source'`s TLS session, because the server
     * may not have sent a session resumption token to `source,` or it may
     * refuse to accept the token from `conn`. There is no way to know
     * whether a call to this function is actually successful.
     * 
     * Using this function is not required to benefit from session
     * resumption. If the TLS backend supports session resumption, the
     * session will be resumed automatically if it is possible to do so
     * without weakening the privacy guarantees normally provided by TLS,
     * without need to call this function. For example, with TLS 1.3,
     * a session ticket will be automatically copied from any
     * #GTlsClientConnection that has previously received session tickets
     * from the server, provided a ticket is available that has not
     * previously been used for session resumption, since session ticket
     * reuse would be a privacy weakness. Using this function causes the
     * ticket to be copied without regard for privacy considerations.
     * @param source a #GTlsClientConnection
     */
    copy_session_state(source: TlsClientConnection): void
    /**
     * Gets the list of distinguished names of the Certificate Authorities
     * that the server will accept certificates from. This will be set
     * during the TLS handshake if the server requests a certificate.
     * Otherwise, it will be %NULL.
     * 
     * Each item in the list is a #GByteArray which contains the complete
     * subject DN of the certificate authority.
     * @returns the list of CA DNs. You should unref each element with g_byte_array_unref() and then the free the list with g_list_free().
     */
    get_accepted_cas(): GLib.List[]
    /**
     * Gets `conn'`s expected server identity
     * @returns a #GSocketConnectable describing the expected server identity, or %NULL if the expected identity is not known.
     */
    get_server_identity(): SocketConnectable | null
    /**
     * SSL 3.0 is no longer supported. See
     * g_tls_client_connection_set_use_ssl3() for details.
     * @returns %FALSE
     */
    get_use_ssl3(): boolean
    /**
     * Gets `conn'`s validation flags
     * 
     * This function does not work as originally designed and is impossible
     * to use correctly. See #GTlsClientConnection:validation-flags for more
     * information.
     * @returns the validation flags
     */
    get_validation_flags(): TlsCertificateFlags
    /**
     * Sets `conn'`s expected server identity, which is used both to tell
     * servers on virtual hosts which certificate to present, and also
     * to let `conn` know what name to look for in the certificate when
     * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
     * @param identity a #GSocketConnectable describing the expected server identity
     */
    set_server_identity(identity: SocketConnectable): void
    /**
     * Since GLib 2.42.1, SSL 3.0 is no longer supported.
     * 
     * From GLib 2.42.1 through GLib 2.62, this function could be used to
     * force use of TLS 1.0, the lowest-supported TLS protocol version at
     * the time. In the past, this was needed to connect to broken TLS
     * servers that exhibited protocol version intolerance. Such servers
     * are no longer common, and using TLS 1.0 is no longer considered
     * acceptable.
     * 
     * Since GLib 2.64, this function does nothing.
     * @param use_ssl3 a #gboolean, ignored
     */
    set_use_ssl3(use_ssl3: boolean): void
    /**
     * Sets `conn'`s validation flags, to override the default set of
     * checks performed when validating a server certificate. By default,
     * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
     * 
     * This function does not work as originally designed and is impossible
     * to use correctly. See #GTlsClientConnection:validation-flags for more
     * information.
     * @param flags the #GTlsCertificateFlags to use
     */
    set_validation_flags(flags: TlsCertificateFlags): void

    // Own virtual methods of Gio-2.0.Gio.TlsClientConnection

    /**
     * Possibly copies session state from one connection to another, for use
     * in TLS session resumption. This is not normally needed, but may be
     * used when the same session needs to be used between different
     * endpoints, as is required by some protocols, such as FTP over TLS.
     * `source` should have already completed a handshake and, since TLS 1.3,
     * it should have been used to read data at least once. `conn` should not
     * have completed a handshake.
     * 
     * It is not possible to know whether a call to this function will
     * actually do anything. Because session resumption is normally used
     * only for performance benefit, the TLS backend might not implement
     * this function. Even if implemented, it may not actually succeed in
     * allowing `conn` to resume `source'`s TLS session, because the server
     * may not have sent a session resumption token to `source,` or it may
     * refuse to accept the token from `conn`. There is no way to know
     * whether a call to this function is actually successful.
     * 
     * Using this function is not required to benefit from session
     * resumption. If the TLS backend supports session resumption, the
     * session will be resumed automatically if it is possible to do so
     * without weakening the privacy guarantees normally provided by TLS,
     * without need to call this function. For example, with TLS 1.3,
     * a session ticket will be automatically copied from any
     * #GTlsClientConnection that has previously received session tickets
     * from the server, provided a ticket is available that has not
     * previously been used for session resumption, since session ticket
     * reuse would be a privacy weakness. Using this function causes the
     * ticket to be copied without regard for privacy considerations.
     * @virtual 
     * @param source a #GTlsClientConnection
     */
    vfunc_copy_session_state(source: TlsClientConnection): void

    // Class property signals of Gio-2.0.Gio.TlsClientConnection

    connect(sigName: "notify::accepted-cas", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::accepted-cas", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::accepted-cas", ...args: any[]): void
    connect(sigName: "notify::server-identity", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::server-identity", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::server-identity", ...args: any[]): void
    connect(sigName: "notify::use-ssl3", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-ssl3", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::use-ssl3", ...args: any[]): void
    connect(sigName: "notify::validation-flags", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::validation-flags", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::validation-flags", ...args: any[]): void
    connect(sigName: "notify::advertised-protocols", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::advertised-protocols", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::advertised-protocols", ...args: any[]): void
    connect(sigName: "notify::base-io-stream", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::base-io-stream", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::base-io-stream", ...args: any[]): void
    connect(sigName: "notify::certificate", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::certificate", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::certificate", ...args: any[]): void
    connect(sigName: "notify::ciphersuite-name", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ciphersuite-name", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ciphersuite-name", ...args: any[]): void
    connect(sigName: "notify::database", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::database", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::database", ...args: any[]): void
    connect(sigName: "notify::interaction", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::negotiated-protocol", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::negotiated-protocol", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::negotiated-protocol", ...args: any[]): void
    connect(sigName: "notify::peer-certificate", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate", ...args: any[]): void
    connect(sigName: "notify::peer-certificate-errors", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate-errors", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate-errors", ...args: any[]): void
    connect(sigName: "notify::protocol-version", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-version", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol-version", ...args: any[]): void
    connect(sigName: "notify::rehandshake-mode", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rehandshake-mode", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::rehandshake-mode", ...args: any[]): void
    connect(sigName: "notify::require-close-notify", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::require-close-notify", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::require-close-notify", ...args: any[]): void
    connect(sigName: "notify::use-system-certdb", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-system-certdb", callback: (($obj: TlsClientConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::use-system-certdb", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GTlsClientConnection is the client-side subclass of
 * #GTlsConnection, representing a client-side TLS connection.
 * @interface 
 */
class TlsClientConnection extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TlsClientConnection

    static name: string
    static $gtype: GObject.GType<TlsClientConnection>

    // Constructors of Gio-2.0.Gio.TlsClientConnection

    constructor(config?: TlsClientConnection.ConstructorProperties) 
    _init(config?: TlsClientConnection.ConstructorProperties): void
    /**
     * Creates a new #GTlsClientConnection wrapping `base_io_stream` (which
     * must have pollable input and output streams) which is assumed to
     * communicate with the server identified by `server_identity`.
     * 
     * See the documentation for #GTlsConnection:base-io-stream for restrictions
     * on when application code can run operations on the `base_io_stream` after
     * this function has returned.
     * @param base_io_stream the #GIOStream to wrap
     * @param server_identity the expected identity of the server
     * @returns the new #GTlsClientConnection, or %NULL on error
     */
    static new(base_io_stream: IOStream, server_identity: SocketConnectable | null): TlsClientConnection
}

module TlsFileDatabase {

    // Constructor properties interface

    interface ConstructorProperties extends TlsDatabase.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TlsFileDatabase

        /**
         * The path to a file containing PEM encoded certificate authority
         * root anchors. The certificates in this file will be treated as
         * root authorities for the purpose of verifying other certificates
         * via the g_tls_database_verify_chain() operation.
         */
        anchors?: string | null
    }

}

interface TlsFileDatabase extends TlsDatabase {

    // Own properties of Gio-2.0.Gio.TlsFileDatabase

    /**
     * The path to a file containing PEM encoded certificate authority
     * root anchors. The certificates in this file will be treated as
     * root authorities for the purpose of verifying other certificates
     * via the g_tls_database_verify_chain() operation.
     */
    anchors: string | null

    // Class property signals of Gio-2.0.Gio.TlsFileDatabase

    connect(sigName: "notify::anchors", callback: (($obj: TlsFileDatabase, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anchors", callback: (($obj: TlsFileDatabase, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::anchors", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GTlsFileDatabase is implemented by #GTlsDatabase objects which load
 * their certificate information from a file. It is an interface which
 * TLS library specific subtypes implement.
 * @interface 
 */
class TlsFileDatabase extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TlsFileDatabase

    static name: string
    static $gtype: GObject.GType<TlsFileDatabase>

    // Constructors of Gio-2.0.Gio.TlsFileDatabase

    constructor(config?: TlsFileDatabase.ConstructorProperties) 
    _init(config?: TlsFileDatabase.ConstructorProperties): void
    /**
     * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
     * in `anchors` to verify certificate chains.
     * 
     * The certificates in `anchors` must be PEM encoded.
     * @param anchors filename of anchor certificate authorities.
     * @returns the new #GTlsFileDatabase, or %NULL on error
     */
    static new(anchors: string): TlsFileDatabase
}

module TlsServerConnection {

    // Constructor properties interface

    interface ConstructorProperties extends TlsConnection.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TlsServerConnection

        /**
         * The #GTlsAuthenticationMode for the server. This can be changed
         * before calling g_tls_connection_handshake() if you want to
         * rehandshake with a different mode from the initial handshake.
         */
        authentication_mode?: TlsAuthenticationMode | null
    }

}

interface TlsServerConnection extends TlsConnection {

    // Own properties of Gio-2.0.Gio.TlsServerConnection

    /**
     * The #GTlsAuthenticationMode for the server. This can be changed
     * before calling g_tls_connection_handshake() if you want to
     * rehandshake with a different mode from the initial handshake.
     */
    authentication_mode: TlsAuthenticationMode

    // Conflicting properties

    parent_instance: IOStream & GObject.Object & GObject.Object

    // Class property signals of Gio-2.0.Gio.TlsServerConnection

    connect(sigName: "notify::authentication-mode", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::authentication-mode", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::authentication-mode", ...args: any[]): void
    connect(sigName: "notify::advertised-protocols", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::advertised-protocols", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::advertised-protocols", ...args: any[]): void
    connect(sigName: "notify::base-io-stream", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::base-io-stream", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::base-io-stream", ...args: any[]): void
    connect(sigName: "notify::certificate", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::certificate", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::certificate", ...args: any[]): void
    connect(sigName: "notify::ciphersuite-name", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ciphersuite-name", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ciphersuite-name", ...args: any[]): void
    connect(sigName: "notify::database", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::database", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::database", ...args: any[]): void
    connect(sigName: "notify::interaction", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::negotiated-protocol", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::negotiated-protocol", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::negotiated-protocol", ...args: any[]): void
    connect(sigName: "notify::peer-certificate", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate", ...args: any[]): void
    connect(sigName: "notify::peer-certificate-errors", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate-errors", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate-errors", ...args: any[]): void
    connect(sigName: "notify::protocol-version", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-version", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol-version", ...args: any[]): void
    connect(sigName: "notify::rehandshake-mode", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rehandshake-mode", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::rehandshake-mode", ...args: any[]): void
    connect(sigName: "notify::require-close-notify", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::require-close-notify", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::require-close-notify", ...args: any[]): void
    connect(sigName: "notify::use-system-certdb", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-system-certdb", callback: (($obj: TlsServerConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::use-system-certdb", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GTlsServerConnection is the server-side subclass of #GTlsConnection,
 * representing a server-side TLS connection.
 * @interface 
 */
class TlsServerConnection extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TlsServerConnection

    static name: string
    static $gtype: GObject.GType<TlsServerConnection>

    // Constructors of Gio-2.0.Gio.TlsServerConnection

    constructor(config?: TlsServerConnection.ConstructorProperties) 
    _init(config?: TlsServerConnection.ConstructorProperties): void
    /**
     * Creates a new #GTlsServerConnection wrapping `base_io_stream` (which
     * must have pollable input and output streams).
     * 
     * See the documentation for #GTlsConnection:base-io-stream for restrictions
     * on when application code can run operations on the `base_io_stream` after
     * this function has returned.
     * @param base_io_stream the #GIOStream to wrap
     * @param certificate the default server certificate, or %NULL
     * @returns the new #GTlsServerConnection, or %NULL on error
     */
    static new(base_io_stream: IOStream, certificate: TlsCertificate | null): TlsServerConnection
}

module Volume {

    // Signal callback interfaces

    /**
     * Signal callback interface for `changed`
     */
    interface ChangedSignalCallback {
        ($obj: Volume): void
    }

    /**
     * Signal callback interface for `removed`
     */
    interface RemovedSignalCallback {
        ($obj: Volume): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Volume {

    // Owm methods of Gio-2.0.Gio.Volume

    /**
     * Checks if a volume can be ejected.
     * @returns %TRUE if the @volume can be ejected. %FALSE otherwise
     */
    can_eject(): boolean
    /**
     * Checks if a volume can be mounted.
     * @returns %TRUE if the @volume can be mounted. %FALSE otherwise
     */
    can_mount(): boolean
    /**
     * Ejects a volume. This is an asynchronous operation, and is
     * finished by calling g_volume_eject_finish() with the `volume`
     * and #GAsyncResult returned in the `callback`.
     * @param flags flags affecting the unmount if required for eject
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback, or %NULL
     */
    eject(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a volume. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @param result a #GAsyncResult
     * @returns %TRUE, %FALSE if operation failed
     */
    eject_finish(result: AsyncResult): boolean
    /**
     * Ejects a volume. This is an asynchronous operation, and is
     * finished by calling g_volume_eject_with_operation_finish() with the `volume`
     * and #GAsyncResult data returned in the `callback`.
     * @param flags flags affecting the unmount if required for eject
     * @param mount_operation a #GMountOperation or %NULL to     avoid user interaction
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback, or %NULL
     */
    eject_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a volume. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @param result a #GAsyncResult
     * @returns %TRUE if the volume was successfully ejected. %FALSE otherwise
     */
    eject_with_operation_finish(result: AsyncResult): boolean
    /**
     * Gets the kinds of [identifiers][volume-identifier] that `volume` has.
     * Use g_volume_get_identifier() to obtain the identifiers themselves.
     * @returns a %NULL-terminated array   of strings containing kinds of identifiers. Use g_strfreev() to free.
     */
    enumerate_identifiers(): string[]
    /**
     * Gets the activation root for a #GVolume if it is known ahead of
     * mount time. Returns %NULL otherwise. If not %NULL and if `volume`
     * is mounted, then the result of g_mount_get_root() on the
     * #GMount object obtained from g_volume_get_mount() will always
     * either be equal or a prefix of what this function returns. In
     * other words, in code
     * 
     * 
     * ```c
     *   GMount *mount;
     *   GFile *mount_root
     *   GFile *volume_activation_root;
     * 
     *   mount = g_volume_get_mount (volume); // mounted, so never NULL
     *   mount_root = g_mount_get_root (mount);
     *   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
     * ```
     * 
     * then the expression
     * 
     * ```c
     *   (g_file_has_prefix (volume_activation_root, mount_root) ||
     *    g_file_equal (volume_activation_root, mount_root))
     * ```
     * 
     * will always be %TRUE.
     * 
     * Activation roots are typically used in #GVolumeMonitor
     * implementations to find the underlying mount to shadow, see
     * g_mount_is_shadowed() for more details.
     * @returns the activation root of @volume     or %NULL. Use g_object_unref() to free.
     */
    get_activation_root(): File | null
    /**
     * Gets the drive for the `volume`.
     * @returns a #GDrive or %NULL if @volume is not     associated with a drive. The returned object should be unreffed     with g_object_unref() when no longer needed.
     */
    get_drive(): Drive | null
    /**
     * Gets the icon for `volume`.
     * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
     */
    get_icon(): Icon
    /**
     * Gets the identifier of the given kind for `volume`.
     * See the [introduction][volume-identifier] for more
     * information about volume identifiers.
     * @param kind the kind of identifier to return
     * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GVolume     doesn't have this kind of identifier
     */
    get_identifier(kind: string | null): string | null
    /**
     * Gets the mount for the `volume`.
     * @returns a #GMount or %NULL if @volume isn't mounted.     The returned object should be unreffed with g_object_unref()     when no longer needed.
     */
    get_mount(): Mount | null
    /**
     * Gets the name of `volume`.
     * @returns the name for the given @volume. The returned string should     be freed with g_free() when no longer needed.
     */
    get_name(): string | null
    /**
     * Gets the sort key for `volume,` if any.
     * @returns Sorting key for @volume or %NULL if no such key is available
     */
    get_sort_key(): string | null
    /**
     * Gets the symbolic icon for `volume`.
     * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
     */
    get_symbolic_icon(): Icon
    /**
     * Gets the UUID for the `volume`. The reference is typically based on
     * the file system UUID for the volume in question and should be
     * considered an opaque string. Returns %NULL if there is no UUID
     * available.
     * @returns the UUID for @volume or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
     */
    get_uuid(): string | null
    /**
     * Mounts a volume. This is an asynchronous operation, and is
     * finished by calling g_volume_mount_finish() with the `volume`
     * and #GAsyncResult returned in the `callback`.
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback, or %NULL
     */
    mount(flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes mounting a volume. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * 
     * If the mount operation succeeded, g_volume_get_mount() on `volume`
     * is guaranteed to return the mount right after calling this
     * function; there's no need to listen for the 'mount-added' signal on
     * #GVolumeMonitor.
     * @param result a #GAsyncResult
     * @returns %TRUE, %FALSE if operation failed
     */
    mount_finish(result: AsyncResult): boolean
    /**
     * Returns whether the volume should be automatically mounted.
     * @returns %TRUE if the volume should be automatically mounted
     */
    should_automount(): boolean

    // Own virtual methods of Gio-2.0.Gio.Volume

    /**
     * Checks if a volume can be ejected.
     * @virtual 
     * @returns %TRUE if the @volume can be ejected. %FALSE otherwise
     */
    vfunc_can_eject(): boolean
    /**
     * Checks if a volume can be mounted.
     * @virtual 
     * @returns %TRUE if the @volume can be mounted. %FALSE otherwise
     */
    vfunc_can_mount(): boolean
    vfunc_changed(): void
    /**
     * Ejects a volume. This is an asynchronous operation, and is
     * finished by calling g_volume_eject_finish() with the `volume`
     * and #GAsyncResult returned in the `callback`.
     * @virtual 
     * @param flags flags affecting the unmount if required for eject
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback, or %NULL
     */
    vfunc_eject(flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a volume. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE, %FALSE if operation failed
     */
    vfunc_eject_finish(result: AsyncResult): boolean
    /**
     * Ejects a volume. This is an asynchronous operation, and is
     * finished by calling g_volume_eject_with_operation_finish() with the `volume`
     * and #GAsyncResult data returned in the `callback`.
     * @virtual 
     * @param flags flags affecting the unmount if required for eject
     * @param mount_operation a #GMountOperation or %NULL to     avoid user interaction
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback, or %NULL
     */
    vfunc_eject_with_operation(flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes ejecting a volume. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if the volume was successfully ejected. %FALSE otherwise
     */
    vfunc_eject_with_operation_finish(result: AsyncResult): boolean
    /**
     * Gets the kinds of [identifiers][volume-identifier] that `volume` has.
     * Use g_volume_get_identifier() to obtain the identifiers themselves.
     * @virtual 
     * @returns a %NULL-terminated array   of strings containing kinds of identifiers. Use g_strfreev() to free.
     */
    vfunc_enumerate_identifiers(): string[]
    /**
     * Gets the activation root for a #GVolume if it is known ahead of
     * mount time. Returns %NULL otherwise. If not %NULL and if `volume`
     * is mounted, then the result of g_mount_get_root() on the
     * #GMount object obtained from g_volume_get_mount() will always
     * either be equal or a prefix of what this function returns. In
     * other words, in code
     * 
     * 
     * ```c
     *   GMount *mount;
     *   GFile *mount_root
     *   GFile *volume_activation_root;
     * 
     *   mount = g_volume_get_mount (volume); // mounted, so never NULL
     *   mount_root = g_mount_get_root (mount);
     *   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
     * ```
     * 
     * then the expression
     * 
     * ```c
     *   (g_file_has_prefix (volume_activation_root, mount_root) ||
     *    g_file_equal (volume_activation_root, mount_root))
     * ```
     * 
     * will always be %TRUE.
     * 
     * Activation roots are typically used in #GVolumeMonitor
     * implementations to find the underlying mount to shadow, see
     * g_mount_is_shadowed() for more details.
     * @virtual 
     * @returns the activation root of @volume     or %NULL. Use g_object_unref() to free.
     */
    vfunc_get_activation_root(): File | null
    /**
     * Gets the drive for the `volume`.
     * @virtual 
     * @returns a #GDrive or %NULL if @volume is not     associated with a drive. The returned object should be unreffed     with g_object_unref() when no longer needed.
     */
    vfunc_get_drive(): Drive | null
    /**
     * Gets the icon for `volume`.
     * @virtual 
     * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
     */
    vfunc_get_icon(): Icon
    /**
     * Gets the identifier of the given kind for `volume`.
     * See the [introduction][volume-identifier] for more
     * information about volume identifiers.
     * @virtual 
     * @param kind the kind of identifier to return
     * @returns a newly allocated string containing the     requested identifier, or %NULL if the #GVolume     doesn't have this kind of identifier
     */
    vfunc_get_identifier(kind: string | null): string | null
    /**
     * Gets the mount for the `volume`.
     * @virtual 
     * @returns a #GMount or %NULL if @volume isn't mounted.     The returned object should be unreffed with g_object_unref()     when no longer needed.
     */
    vfunc_get_mount(): Mount | null
    /**
     * Gets the name of `volume`.
     * @virtual 
     * @returns the name for the given @volume. The returned string should     be freed with g_free() when no longer needed.
     */
    vfunc_get_name(): string | null
    /**
     * Gets the sort key for `volume,` if any.
     * @virtual 
     * @returns Sorting key for @volume or %NULL if no such key is available
     */
    vfunc_get_sort_key(): string | null
    /**
     * Gets the symbolic icon for `volume`.
     * @virtual 
     * @returns a #GIcon.     The returned object should be unreffed with g_object_unref()     when no longer needed.
     */
    vfunc_get_symbolic_icon(): Icon
    /**
     * Gets the UUID for the `volume`. The reference is typically based on
     * the file system UUID for the volume in question and should be
     * considered an opaque string. Returns %NULL if there is no UUID
     * available.
     * @virtual 
     * @returns the UUID for @volume or %NULL if no UUID     can be computed.     The returned string should be freed with g_free()     when no longer needed.
     */
    vfunc_get_uuid(): string | null
    /**
     * Finishes mounting a volume. If any errors occurred during the operation,
     * `error` will be set to contain the errors and %FALSE will be returned.
     * 
     * If the mount operation succeeded, g_volume_get_mount() on `volume`
     * is guaranteed to return the mount right after calling this
     * function; there's no need to listen for the 'mount-added' signal on
     * #GVolumeMonitor.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE, %FALSE if operation failed
     */
    vfunc_mount_finish(result: AsyncResult): boolean
    /**
     * Mounts a volume. This is an asynchronous operation, and is
     * finished by calling g_volume_mount_finish() with the `volume`
     * and #GAsyncResult returned in the `callback`.
     * @virtual 
     * @param flags flags affecting the operation
     * @param mount_operation a #GMountOperation or %NULL to avoid user interaction
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback a #GAsyncReadyCallback, or %NULL
     */
    vfunc_mount_fn(flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    vfunc_removed(): void
    /**
     * Returns whether the volume should be automatically mounted.
     * @virtual 
     * @returns %TRUE if the volume should be automatically mounted
     */
    vfunc_should_automount(): boolean

    // Own signals of Gio-2.0.Gio.Volume

    connect(sigName: "changed", callback: Volume.ChangedSignalCallback): number
    connect_after(sigName: "changed", callback: Volume.ChangedSignalCallback): number
    emit(sigName: "changed", ...args: any[]): void
    connect(sigName: "removed", callback: Volume.RemovedSignalCallback): number
    connect_after(sigName: "removed", callback: Volume.RemovedSignalCallback): number
    emit(sigName: "removed", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.Volume

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GVolume interface represents user-visible objects that can be
 * mounted. Note, when porting from GnomeVFS, #GVolume is the moral
 * equivalent of #GnomeVFSDrive.
 * 
 * Mounting a #GVolume instance is an asynchronous operation. For more
 * information about asynchronous operations, see #GAsyncResult and
 * #GTask. To mount a #GVolume, first call g_volume_mount() with (at
 * least) the #GVolume instance, optionally a #GMountOperation object
 * and a #GAsyncReadyCallback.
 * 
 * Typically, one will only want to pass %NULL for the
 * #GMountOperation if automounting all volumes when a desktop session
 * starts since it's not desirable to put up a lot of dialogs asking
 * for credentials.
 * 
 * The callback will be fired when the operation has resolved (either
 * with success or failure), and a #GAsyncResult instance will be
 * passed to the callback.  That callback should then call
 * g_volume_mount_finish() with the #GVolume instance and the
 * #GAsyncResult data to see if the operation was completed
 * successfully.  If an `error` is present when g_volume_mount_finish()
 * is called, then it will be filled with any error information.
 * 
 * ## Volume Identifiers # {#volume-identifier}
 * 
 * It is sometimes necessary to directly access the underlying
 * operating system object behind a volume (e.g. for passing a volume
 * to an application via the commandline). For this purpose, GIO
 * allows to obtain an 'identifier' for the volume. There can be
 * different kinds of identifiers, such as Hal UDIs, filesystem labels,
 * traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
 * strings as names for the different kinds of identifiers:
 * %G_VOLUME_IDENTIFIER_KIND_UUID, %G_VOLUME_IDENTIFIER_KIND_LABEL, etc.
 * Use g_volume_get_identifier() to obtain an identifier for a volume.
 * 
 * 
 * Note that %G_VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available
 * when the gvfs hal volume monitor is in use. Other volume monitors
 * will generally be able to provide the %G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE
 * identifier, which can be used to obtain a hal device by means of
 * libhal_manager_find_device_string_match().
 * @interface 
 */
class Volume extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Volume

    static name: string
    static $gtype: GObject.GType<Volume>

    // Constructors of Gio-2.0.Gio.Volume

    constructor(config?: Volume.ConstructorProperties) 
    _init(config?: Volume.ConstructorProperties): void
}

// See https://gitlab.gnome.org/GNOME/gjs/-/blob/master/modules/core/overrides/Gio.js
export const DBus: {
    readonly session: DBusConnection;
    readonly system: DBusConnection;
    get(bus_type: BusType, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
    get_finish(res: AsyncResult): DBusConnection;
    get_sync(bus_type: BusType, cancellable?: Cancellable | null): DBusConnection;
    own_name(
        bus_type: BusType,
        name: string,
        flags: BusNameOwnerFlags,
        bus_acquired_closure?: GObject.Closure | null,
        name_acquired_closure?: GObject.Closure | null,
        name_lost_closure?: GObject.Closure | null
    ): number;
    own_name_on_connection(
        connection: DBusConnection,
        name: string,
        flags: BusNameOwnerFlags,
        name_acquired_closure?: GObject.Closure | null,
        name_lost_closure?: GObject.Closure | null
    ): number;
    unown_name(owner_id: number): void;
    watch_name(
        bus_type: BusType,
        name: string,
        flags: BusNameWatcherFlags,
        name_appeared_closure?: GObject.Closure | null,
        name_vanished_closure?: GObject.Closure | null
    ): number;
    unwatch_name(watcher_id: number): void;
    watch_name_on_connection(
        connection: DBusConnection,
        name: string,
        flags: BusNameWatcherFlags,
        name_appeared_closure?: GObject.Closure | null,
        name_vanished_closure?: GObject.Closure | null
    ): number;
}

export module DBusExportedObject {
    export interface ConstructorProperties {
        [key: string]: any;
    }
}

// See https://gitlab.gnome.org/GNOME/gjs/-/blob/master/modules/core/overrides/Gio.js
export class DBusExportedObject {
    static $gtype: GObject.GType<DBusExportedObject>;

    constructor(properties?: Partial<DBusExportedObject.ConstructorProperties>, ...args: any[]);
    _init(properties?: Partial<DBusExportedObject.ConstructorProperties>, ...args: any[]): void;

    static wrapJSObject(info: string, obj: any): DBusExportedObject;
    get_info(): DBusInterfaceInfo;
    get_connection(): DBusConnection;
    get_object_path(): string;
    unexport_from_connection(connection: DBusConnection): void;
    ["export"](busConnection: DBusConnection, objectPath: string): void;
    unexport(): void;
    flush(): void;
    emit_signal(name: string, variant: GLib.Variant): void;
    emit_property_changed(name: string, variant: GLib.Variant): void;
}

/**
 * A convenient helper to create Promise wrappers for asynchronous functions in GJS.
 * 
 * This utility replaces the original function on the class prototype with a Promise-based version,
 * allowing the function to be called on any instance of the class, including subclasses.
 * Simply pass the class prototype, the "async" function name, and the "finish" function name as arguments.
 * 
 * The function can be used like any other Promise, without the need for a custom wrapper, by leaving out the callback argument.
 * The original function will still be available, and can be used by passing the callback.
 * 
 * @param proto - The class prototype that contains the asynchronous function.
 * @param asyncFunc - The name of the asynchronous function.
 * @param finishFunc - The name of the "finish" function that is used to retrieve the result of the asynchronous function.
 * 
 * @version Gjs 1.54
 * @see https://gjs.guide/guides/gjs/asynchronous-programming.html#promisify-helper
 * 
 * @example
 * ```js
 * import Gio from "gi://Gio?version=2.0";
 * 
 * Gio._promisify(Gio.InputStream.prototype, 'read_bytes_async', 'read_bytes_finish');
 * 
 * try {
 *    const inputStream = new Gio.UnixInputStream({fd: 0});
 *    const bytes = await inputStream.read_bytes_async(4096, GLib.PRIORITY_DEFAULT, null);
 * } catch (e) {
 *    logError(e, 'Failed to read bytes');
 * }
 * ```
 * 
 */
export function _promisify(proto: any, asyncFunc: string, finishFunc?: string): void;

/** Temporary Gio.File.prototype fix */
export const _LocalFilePrototype: typeof File.prototype;

module AppInfoMonitor {

    // Signal callback interfaces

    /**
     * Signal callback interface for `changed`
     */
    interface ChangedSignalCallback {
        ($obj: AppInfoMonitor): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface AppInfoMonitor {

    // Own signals of Gio-2.0.Gio.AppInfoMonitor

    connect(sigName: "changed", callback: AppInfoMonitor.ChangedSignalCallback): number
    connect_after(sigName: "changed", callback: AppInfoMonitor.ChangedSignalCallback): number
    emit(sigName: "changed", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.AppInfoMonitor

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GAppInfoMonitor is a very simple object used for monitoring the app
 * info database for changes (ie: newly installed or removed
 * applications).
 * 
 * Call g_app_info_monitor_get() to get a #GAppInfoMonitor and connect
 * to the "changed" signal.
 * 
 * In the usual case, applications should try to make note of the change
 * (doing things like invalidating caches) but not act on it.  In
 * particular, applications should avoid making calls to #GAppInfo APIs
 * in response to the change signal, deferring these until the time that
 * the data is actually required.  The exception to this case is when
 * application information is actually being displayed on the screen
 * (eg: during a search or when the list of all applications is shown).
 * The reason for this is that changes to the list of installed
 * applications often come in groups (like during system updates) and
 * rescanning the list on every change is pointless and expensive.
 * @class 
 */
class AppInfoMonitor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.AppInfoMonitor

    static name: string
    static $gtype: GObject.GType<AppInfoMonitor>

    // Constructors of Gio-2.0.Gio.AppInfoMonitor

    constructor(config?: AppInfoMonitor.ConstructorProperties) 
    _init(config?: AppInfoMonitor.ConstructorProperties): void
    /**
     * Gets the #GAppInfoMonitor for the current thread-default main
     * context.
     * 
     * The #GAppInfoMonitor will emit a "changed" signal in the
     * thread-default main context whenever the list of installed
     * applications (as reported by g_app_info_get_all()) may have changed.
     * 
     * You must only call g_object_unref() on the return value from under
     * the same main context as you created it.
     * @returns a reference to a #GAppInfoMonitor
     */
    static get(): AppInfoMonitor
}

module AppLaunchContext {

    // Signal callback interfaces

    /**
     * Signal callback interface for `launch-failed`
     */
    interface LaunchFailedSignalCallback {
        ($obj: AppLaunchContext, startup_notify_id: string | null): void
    }

    /**
     * Signal callback interface for `launch-started`
     */
    interface LaunchStartedSignalCallback {
        ($obj: AppLaunchContext, info: AppInfo, platform_data: GLib.Variant | null): void
    }

    /**
     * Signal callback interface for `launched`
     */
    interface LaunchedSignalCallback {
        ($obj: AppLaunchContext, info: AppInfo, platform_data: GLib.Variant): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface AppLaunchContext {

    // Own fields of Gio-2.0.Gio.AppLaunchContext

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.AppLaunchContext

    /**
     * Gets the display string for the `context`. This is used to ensure new
     * applications are started on the same display as the launching
     * application, by setting the `DISPLAY` environment variable.
     * @param info a #GAppInfo
     * @param files a #GList of #GFile objects
     * @returns a display string for the display.
     */
    get_display(info: AppInfo, files: File[]): string | null
    /**
     * Gets the complete environment variable list to be passed to
     * the child process when `context` is used to launch an application.
     * This is a %NULL-terminated array of strings, where each string has
     * the form `KEY=VALUE`.
     * @returns      the child's environment
     */
    get_environment(): string[]
    /**
     * Initiates startup notification for the application and returns the
     * `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
     * if supported.
     * 
     * The returned token may be referred to equivalently as an ‘activation token’
     * (using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
     * The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
     * 
     * Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
     * and startup notification IDs are defined in the
     * [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
     * 
     * Support for the XDG Activation Protocol was added in GLib 2.76.
     * @param info a #GAppInfo
     * @param files a #GList of of #GFile objects
     * @returns a startup notification ID for the application, or %NULL if     not supported.
     */
    get_startup_notify_id(info: AppInfo, files: File[]): string | null
    /**
     * Called when an application has failed to launch, so that it can cancel
     * the application startup notification started in g_app_launch_context_get_startup_notify_id().
     * @param startup_notify_id the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().
     */
    launch_failed(startup_notify_id: string | null): void
    /**
     * Arranges for `variable` to be set to `value` in the child's
     * environment when `context` is used to launch an application.
     * @param variable the environment variable to set
     * @param value the value for to set the variable to.
     */
    setenv(variable: string, value: string): void
    /**
     * Arranges for `variable` to be unset in the child's environment
     * when `context` is used to launch an application.
     * @param variable the environment variable to remove
     */
    unsetenv(variable: string): void

    // Own virtual methods of Gio-2.0.Gio.AppLaunchContext

    /**
     * Gets the display string for the `context`. This is used to ensure new
     * applications are started on the same display as the launching
     * application, by setting the `DISPLAY` environment variable.
     * @virtual 
     * @param info a #GAppInfo
     * @param files a #GList of #GFile objects
     * @returns a display string for the display.
     */
    vfunc_get_display(info: AppInfo, files: File[]): string | null
    /**
     * Initiates startup notification for the application and returns the
     * `XDG_ACTIVATION_TOKEN` or `DESKTOP_STARTUP_ID` for the launched operation,
     * if supported.
     * 
     * The returned token may be referred to equivalently as an ‘activation token’
     * (using Wayland terminology) or a ‘startup sequence ID’ (using X11 terminology).
     * The two [are interoperable](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/xdg-activation/x11-interoperation.rst).
     * 
     * Activation tokens are defined in the [XDG Activation Protocol](https://wayland.app/protocols/xdg-activation-v1),
     * and startup notification IDs are defined in the
     * [freedesktop.org Startup Notification Protocol](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
     * 
     * Support for the XDG Activation Protocol was added in GLib 2.76.
     * @virtual 
     * @param info a #GAppInfo
     * @param files a #GList of of #GFile objects
     * @returns a startup notification ID for the application, or %NULL if     not supported.
     */
    vfunc_get_startup_notify_id(info: AppInfo, files: File[]): string | null
    /**
     * Called when an application has failed to launch, so that it can cancel
     * the application startup notification started in g_app_launch_context_get_startup_notify_id().
     * @virtual 
     * @param startup_notify_id the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().
     */
    vfunc_launch_failed(startup_notify_id: string | null): void
    vfunc_launch_started(info: AppInfo, platform_data: GLib.Variant): void
    vfunc_launched(info: AppInfo, platform_data: GLib.Variant): void

    // Own signals of Gio-2.0.Gio.AppLaunchContext

    connect(sigName: "launch-failed", callback: AppLaunchContext.LaunchFailedSignalCallback): number
    connect_after(sigName: "launch-failed", callback: AppLaunchContext.LaunchFailedSignalCallback): number
    emit(sigName: "launch-failed", startup_notify_id: string | null, ...args: any[]): void
    connect(sigName: "launch-started", callback: AppLaunchContext.LaunchStartedSignalCallback): number
    connect_after(sigName: "launch-started", callback: AppLaunchContext.LaunchStartedSignalCallback): number
    emit(sigName: "launch-started", info: AppInfo, platform_data: GLib.Variant | null, ...args: any[]): void
    connect(sigName: "launched", callback: AppLaunchContext.LaunchedSignalCallback): number
    connect_after(sigName: "launched", callback: AppLaunchContext.LaunchedSignalCallback): number
    emit(sigName: "launched", info: AppInfo, platform_data: GLib.Variant, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.AppLaunchContext

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Integrating the launch with the launching application. This is used to
 * handle for instance startup notification and launching the new application
 * on the same screen as the launching window.
 * @class 
 */
class AppLaunchContext extends GObject.Object {

    // Own properties of Gio-2.0.Gio.AppLaunchContext

    static name: string
    static $gtype: GObject.GType<AppLaunchContext>

    // Constructors of Gio-2.0.Gio.AppLaunchContext

    constructor(config?: AppLaunchContext.ConstructorProperties) 
    /**
     * Creates a new application launch context. This is not normally used,
     * instead you instantiate a subclass of this, such as #GdkAppLaunchContext.
     * @constructor 
     * @returns a #GAppLaunchContext.
     */
    constructor() 
    /**
     * Creates a new application launch context. This is not normally used,
     * instead you instantiate a subclass of this, such as #GdkAppLaunchContext.
     * @constructor 
     * @returns a #GAppLaunchContext.
     */
    static new(): AppLaunchContext
    _init(config?: AppLaunchContext.ConstructorProperties): void
}

module Application {

    // Signal callback interfaces

    /**
     * Signal callback interface for `activate`
     */
    interface ActivateSignalCallback {
        ($obj: Application): void
    }

    /**
     * Signal callback interface for `command-line`
     */
    interface CommandLineSignalCallback {
        ($obj: Application, command_line: ApplicationCommandLine): number
    }

    /**
     * Signal callback interface for `handle-local-options`
     */
    interface HandleLocalOptionsSignalCallback {
        ($obj: Application, options: GLib.VariantDict): number
    }

    /**
     * Signal callback interface for `name-lost`
     */
    interface NameLostSignalCallback {
        ($obj: Application): boolean
    }

    /**
     * Signal callback interface for `open`
     */
    interface OpenSignalCallback {
        ($obj: Application, files: File[], hint: string | null): void
    }

    /**
     * Signal callback interface for `shutdown`
     */
    interface ShutdownSignalCallback {
        ($obj: Application): void
    }

    /**
     * Signal callback interface for `startup`
     */
    interface StartupSignalCallback {
        ($obj: Application): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends ActionGroup.ConstructorProperties, ActionMap.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.Application

        action_group?: ActionGroup | null
        application_id?: string | null
        flags?: ApplicationFlags | null
        inactivity_timeout?: number | null
        resource_base_path?: string | null
    }

}

interface Application extends ActionGroup, ActionMap {

    // Own properties of Gio-2.0.Gio.Application

    action_group: ActionGroup
    application_id: string | null
    flags: ApplicationFlags
    inactivity_timeout: number
    /**
     * Whether the application is currently marked as busy through
     * g_application_mark_busy() or g_application_bind_busy_property().
     */
    readonly is_busy: boolean
    readonly is_registered: boolean
    readonly is_remote: boolean
    resource_base_path: string | null

    // Owm methods of Gio-2.0.Gio.Application

    /**
     * Activates the application.
     * 
     * In essence, this results in the #GApplication::activate signal being
     * emitted in the primary instance.
     * 
     * The application must be registered before calling this function.
     */
    activate(): void
    /**
     * Add an option to be handled by `application`.
     * 
     * Calling this function is the equivalent of calling
     * g_application_add_main_option_entries() with a single #GOptionEntry
     * that has its arg_data member set to %NULL.
     * 
     * The parsed arguments will be packed into a #GVariantDict which
     * is passed to #GApplication::handle-local-options. If
     * %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
     * be sent to the primary instance. See
     * g_application_add_main_option_entries() for more details.
     * 
     * See #GOptionEntry for more documentation of the arguments.
     * @param long_name the long name of an option used to specify it in a commandline
     * @param short_name the short name of an option
     * @param flags flags from #GOptionFlags
     * @param arg the type of the option, as a #GOptionArg
     * @param description the description for the option in `--help` output
     * @param arg_description the placeholder to use for the extra argument    parsed by the option in `--help` output
     */
    add_main_option(long_name: string | null, short_name: number, flags: GLib.OptionFlags, arg: GLib.OptionArg, description: string | null, arg_description: string | null): void
    /**
     * Adds main option entries to be handled by `application`.
     * 
     * This function is comparable to g_option_context_add_main_entries().
     * 
     * After the commandline arguments are parsed, the
     * #GApplication::handle-local-options signal will be emitted.  At this
     * point, the application can inspect the values pointed to by `arg_data`
     * in the given #GOptionEntrys.
     * 
     * Unlike #GOptionContext, #GApplication supports giving a %NULL
     * `arg_data` for a non-callback #GOptionEntry.  This results in the
     * argument in question being packed into a #GVariantDict which is also
     * passed to #GApplication::handle-local-options, where it can be
     * inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
     * set, then the resulting dictionary is sent to the primary instance,
     * where g_application_command_line_get_options_dict() will return it.
     * As it has been passed outside the process at this point, the types of all
     * values in the options dict must be checked before being used.
     * This "packing" is done according to the type of the argument --
     * booleans for normal flags, strings for strings, bytestrings for
     * filenames, etc.  The packing only occurs if the flag is given (ie: we
     * do not pack a "false" #GVariant in the case that a flag is missing).
     * 
     * In general, it is recommended that all commandline arguments are
     * parsed locally.  The options dictionary should then be used to
     * transmit the result of the parsing to the primary instance, where
     * g_variant_dict_lookup() can be used.  For local options, it is
     * possible to either use `arg_data` in the usual way, or to consult (and
     * potentially remove) the option from the options dictionary.
     * 
     * This function is new in GLib 2.40.  Before then, the only real choice
     * was to send all of the commandline arguments (options and all) to the
     * primary instance for handling.  #GApplication ignored them completely
     * on the local side.  Calling this function "opts in" to the new
     * behaviour, and in particular, means that unrecognised options will be
     * treated as errors.  Unrecognised options have never been ignored when
     * %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
     * 
     * If #GApplication::handle-local-options needs to see the list of
     * filenames, then the use of %G_OPTION_REMAINING is recommended.  If
     * `arg_data` is %NULL then %G_OPTION_REMAINING can be used as a key into
     * the options dictionary.  If you do use %G_OPTION_REMAINING then you
     * need to handle these arguments for yourself because once they are
     * consumed, they will no longer be visible to the default handling
     * (which treats them as filenames to be opened).
     * 
     * It is important to use the proper GVariant format when retrieving
     * the options with g_variant_dict_lookup():
     * - for %G_OPTION_ARG_NONE, use `b`
     * - for %G_OPTION_ARG_STRING, use `&s`
     * - for %G_OPTION_ARG_INT, use `i`
     * - for %G_OPTION_ARG_INT64, use `x`
     * - for %G_OPTION_ARG_DOUBLE, use `d`
     * - for %G_OPTION_ARG_FILENAME, use `^&ay`
     * - for %G_OPTION_ARG_STRING_ARRAY, use `^a&s`
     * - for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&ay`
     * @param entries a           %NULL-terminated list of #GOptionEntrys
     */
    add_main_option_entries(entries: GLib.OptionEntry[]): void
    /**
     * Adds a #GOptionGroup to the commandline handling of `application`.
     * 
     * This function is comparable to g_option_context_add_group().
     * 
     * Unlike g_application_add_main_option_entries(), this function does
     * not deal with %NULL `arg_data` and never transmits options to the
     * primary instance.
     * 
     * The reason for that is because, by the time the options arrive at the
     * primary instance, it is typically too late to do anything with them.
     * Taking the GTK option group as an example: GTK will already have been
     * initialised by the time the #GApplication::command-line handler runs.
     * In the case that this is not the first-running instance of the
     * application, the existing instance may already have been running for
     * a very long time.
     * 
     * This means that the options from #GOptionGroup are only really usable
     * in the case that the instance of the application being run is the
     * first instance.  Passing options like `--display=` or `--gdk-debug=`
     * on future runs will have no effect on the existing primary instance.
     * 
     * Calling this function will cause the options in the supplied option
     * group to be parsed, but it does not cause you to be "opted in" to the
     * new functionality whereby unrecognised options are rejected even if
     * %G_APPLICATION_HANDLES_COMMAND_LINE was given.
     * @param group a #GOptionGroup
     */
    add_option_group(group: GLib.OptionGroup): void
    /**
     * Marks `application` as busy (see g_application_mark_busy()) while
     * `property` on `object` is %TRUE.
     * 
     * The binding holds a reference to `application` while it is active, but
     * not to `object`. Instead, the binding is destroyed when `object` is
     * finalized.
     * @param object a #GObject
     * @param property the name of a boolean property of `object`
     */
    bind_busy_property(object: GObject.Object, property: string | null): void
    /**
     * Gets the unique identifier for `application`.
     * @returns the identifier for @application, owned by @application
     */
    get_application_id(): string | null
    /**
     * Gets the #GDBusConnection being used by the application, or %NULL.
     * 
     * If #GApplication is using its D-Bus backend then this function will
     * return the #GDBusConnection being used for uniqueness and
     * communication with the desktop environment and other instances of the
     * application.
     * 
     * If #GApplication is not using D-Bus then this function will return
     * %NULL.  This includes the situation where the D-Bus backend would
     * normally be in use but we were unable to connect to the bus.
     * 
     * This function must not be called before the application has been
     * registered.  See g_application_get_is_registered().
     * @returns a #GDBusConnection, or %NULL
     */
    get_dbus_connection(): DBusConnection | null
    /**
     * Gets the D-Bus object path being used by the application, or %NULL.
     * 
     * If #GApplication is using its D-Bus backend then this function will
     * return the D-Bus object path that #GApplication is using.  If the
     * application is the primary instance then there is an object published
     * at this path.  If the application is not the primary instance then
     * the result of this function is undefined.
     * 
     * If #GApplication is not using D-Bus then this function will return
     * %NULL.  This includes the situation where the D-Bus backend would
     * normally be in use but we were unable to connect to the bus.
     * 
     * This function must not be called before the application has been
     * registered.  See g_application_get_is_registered().
     * @returns the object path, or %NULL
     */
    get_dbus_object_path(): string | null
    /**
     * Gets the flags for `application`.
     * 
     * See #GApplicationFlags.
     * @returns the flags for @application
     */
    get_flags(): ApplicationFlags
    /**
     * Gets the current inactivity timeout for the application.
     * 
     * This is the amount of time (in milliseconds) after the last call to
     * g_application_release() before the application stops running.
     * @returns the timeout, in milliseconds
     */
    get_inactivity_timeout(): number
    /**
     * Gets the application's current busy state, as set through
     * g_application_mark_busy() or g_application_bind_busy_property().
     * @returns %TRUE if @application is currently marked as busy
     */
    get_is_busy(): boolean
    /**
     * Checks if `application` is registered.
     * 
     * An application is registered if g_application_register() has been
     * successfully called.
     * @returns %TRUE if @application is registered
     */
    get_is_registered(): boolean
    /**
     * Checks if `application` is remote.
     * 
     * If `application` is remote then it means that another instance of
     * application already exists (the 'primary' instance).  Calls to
     * perform actions on `application` will result in the actions being
     * performed by the primary instance.
     * 
     * The value of this property cannot be accessed before
     * g_application_register() has been called.  See
     * g_application_get_is_registered().
     * @returns %TRUE if @application is remote
     */
    get_is_remote(): boolean
    /**
     * Gets the resource base path of `application`.
     * 
     * See g_application_set_resource_base_path() for more information.
     * @returns the base resource path, if one is set
     */
    get_resource_base_path(): string | null
    /**
     * Increases the use count of `application`.
     * 
     * Use this function to indicate that the application has a reason to
     * continue to run.  For example, g_application_hold() is called by GTK+
     * when a toplevel window is on the screen.
     * 
     * To cancel the hold, call g_application_release().
     */
    hold(): void
    /**
     * Increases the busy count of `application`.
     * 
     * Use this function to indicate that the application is busy, for instance
     * while a long running operation is pending.
     * 
     * The busy state will be exposed to other processes, so a session shell will
     * use that information to indicate the state to the user (e.g. with a
     * spinner).
     * 
     * To cancel the busy indication, use g_application_unmark_busy().
     * 
     * The application must be registered before calling this function.
     */
    mark_busy(): void
    /**
     * Opens the given files.
     * 
     * In essence, this results in the #GApplication::open signal being emitted
     * in the primary instance.
     * 
     * `n_files` must be greater than zero.
     * 
     * `hint` is simply passed through to the ::open signal.  It is
     * intended to be used by applications that have multiple modes for
     * opening files (eg: "view" vs "edit", etc).  Unless you have a need
     * for this functionality, you should use "".
     * 
     * The application must be registered before calling this function
     * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
     * @param files an array of #GFiles to open
     * @param hint a hint (or ""), but never %NULL
     */
    open(files: File[], hint: string | null): void
    /**
     * Immediately quits the application.
     * 
     * Upon return to the mainloop, g_application_run() will return,
     * calling only the 'shutdown' function before doing so.
     * 
     * The hold count is ignored.
     * Take care if your code has called g_application_hold() on the application and
     * is therefore still expecting it to exist.
     * (Note that you may have called g_application_hold() indirectly, for example
     * through gtk_application_add_window().)
     * 
     * The result of calling g_application_run() again after it returns is
     * unspecified.
     */
    quit(): void
    /**
     * Attempts registration of the application.
     * 
     * This is the point at which the application discovers if it is the
     * primary instance or merely acting as a remote for an already-existing
     * primary instance.  This is implemented by attempting to acquire the
     * application identifier as a unique bus name on the session bus using
     * GDBus.
     * 
     * If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
     * given, then this process will always become the primary instance.
     * 
     * Due to the internal architecture of GDBus, method calls can be
     * dispatched at any time (even if a main loop is not running).  For
     * this reason, you must ensure that any object paths that you wish to
     * register are registered before calling this function.
     * 
     * If the application has already been registered then %TRUE is
     * returned with no work performed.
     * 
     * The #GApplication::startup signal is emitted if registration succeeds
     * and `application` is the primary instance (including the non-unique
     * case).
     * 
     * In the event of an error (such as `cancellable` being cancelled, or a
     * failure to connect to the session bus), %FALSE is returned and `error`
     * is set appropriately.
     * 
     * Note: the return value of this function is not an indicator that this
     * instance is or is not the primary instance of the application.  See
     * g_application_get_is_remote() for that.
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if registration succeeded
     */
    register(cancellable: Cancellable | null): boolean
    /**
     * Decrease the use count of `application`.
     * 
     * When the use count reaches zero, the application will stop running.
     * 
     * Never call this function except to cancel the effect of a previous
     * call to g_application_hold().
     */
    release(): void
    /**
     * Runs the application.
     * 
     * This function is intended to be run from main() and its return value
     * is intended to be returned by main(). Although you are expected to pass
     * the `argc,` `argv` parameters from main() to this function, it is possible
     * to pass %NULL if `argv` is not available or commandline handling is not
     * required.  Note that on Windows, `argc` and `argv` are ignored, and
     * g_win32_get_command_line() is called internally (for proper support
     * of Unicode commandline arguments).
     * 
     * #GApplication will attempt to parse the commandline arguments.  You
     * can add commandline flags to the list of recognised options by way of
     * g_application_add_main_option_entries().  After this, the
     * #GApplication::handle-local-options signal is emitted, from which the
     * application can inspect the values of its #GOptionEntrys.
     * 
     * #GApplication::handle-local-options is a good place to handle options
     * such as `--version`, where an immediate reply from the local process is
     * desired (instead of communicating with an already-running instance).
     * A #GApplication::handle-local-options handler can stop further processing
     * by returning a non-negative value, which then becomes the exit status of
     * the process.
     * 
     * What happens next depends on the flags: if
     * %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
     * commandline arguments are sent to the primary instance, where a
     * #GApplication::command-line signal is emitted.  Otherwise, the
     * remaining commandline arguments are assumed to be a list of files.
     * If there are no files listed, the application is activated via the
     * #GApplication::activate signal.  If there are one or more files, and
     * %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
     * via the #GApplication::open signal.
     * 
     * If you are interested in doing more complicated local handling of the
     * commandline then you should implement your own #GApplication subclass
     * and override local_command_line(). In this case, you most likely want
     * to return %TRUE from your local_command_line() implementation to
     * suppress the default handling. See
     * [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
     * for an example.
     * 
     * If, after the above is done, the use count of the application is zero
     * then the exit status is returned immediately.  If the use count is
     * non-zero then the default main context is iterated until the use count
     * falls to zero, at which point 0 is returned.
     * 
     * If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
     * run for as much as 10 seconds with a use count of zero while waiting
     * for the message that caused the activation to arrive.  After that,
     * if the use count falls to zero the application will exit immediately,
     * except in the case that g_application_set_inactivity_timeout() is in
     * use.
     * 
     * This function sets the prgname (g_set_prgname()), if not already set,
     * to the basename of argv[0].
     * 
     * Much like g_main_loop_run(), this function will acquire the main context
     * for the duration that the application is running.
     * 
     * Since 2.40, applications that are not explicitly flagged as services
     * or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
     * %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
     * default handler for local_command_line) if "--gapplication-service"
     * was given in the command line.  If this flag is present then normal
     * commandline processing is interrupted and the
     * %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
     * solution whereby running an application directly from the commandline
     * will invoke it in the normal way (which can be useful for debugging)
     * while still allowing applications to be D-Bus activated in service
     * mode.  The D-Bus service file should invoke the executable with
     * "--gapplication-service" as the sole commandline argument.  This
     * approach is suitable for use by most graphical applications but
     * should not be used from applications like editors that need precise
     * control over when processes invoked via the commandline will exit and
     * what their exit status will be.
     * @param argv      the argv from main(), or %NULL
     * @returns the exit status
     */
    run(argv: string[] | null): number
    /**
     * Sends a notification on behalf of `application` to the desktop shell.
     * There is no guarantee that the notification is displayed immediately,
     * or even at all.
     * 
     * Notifications may persist after the application exits. It will be
     * D-Bus-activated when the notification or one of its actions is
     * activated.
     * 
     * Modifying `notification` after this call has no effect. However, the
     * object can be reused for a later call to this function.
     * 
     * `id` may be any string that uniquely identifies the event for the
     * application. It does not need to be in any special format. For
     * example, "new-message" might be appropriate for a notification about
     * new messages.
     * 
     * If a previous notification was sent with the same `id,` it will be
     * replaced with `notification` and shown again as if it was a new
     * notification. This works even for notifications sent from a previous
     * execution of the application, as long as `id` is the same string.
     * 
     * `id` may be %NULL, but it is impossible to replace or withdraw
     * notifications without an id.
     * 
     * If `notification` is no longer relevant, it can be withdrawn with
     * g_application_withdraw_notification().
     * @param id id of the notification, or %NULL
     * @param notification the #GNotification to send
     */
    send_notification(id: string | null, notification: Notification): void
    /**
     * This used to be how actions were associated with a #GApplication.
     * Now there is #GActionMap for that.
     * @param action_group a #GActionGroup, or %NULL
     */
    set_action_group(action_group: ActionGroup | null): void
    /**
     * Sets the unique identifier for `application`.
     * 
     * The application id can only be modified if `application` has not yet
     * been registered.
     * 
     * If non-%NULL, the application id must be valid.  See
     * g_application_id_is_valid().
     * @param application_id the identifier for `application`
     */
    set_application_id(application_id: string | null): void
    /**
     * Sets or unsets the default application for the process, as returned
     * by g_application_get_default().
     * 
     * This function does not take its own reference on `application`.  If
     * `application` is destroyed then the default application will revert
     * back to %NULL.
     */
    set_default(): void
    /**
     * Sets the flags for `application`.
     * 
     * The flags can only be modified if `application` has not yet been
     * registered.
     * 
     * See #GApplicationFlags.
     * @param flags the flags for `application`
     */
    set_flags(flags: ApplicationFlags): void
    /**
     * Sets the current inactivity timeout for the application.
     * 
     * This is the amount of time (in milliseconds) after the last call to
     * g_application_release() before the application stops running.
     * 
     * This call has no side effects of its own.  The value set here is only
     * used for next time g_application_release() drops the use count to
     * zero.  Any timeouts currently in progress are not impacted.
     * @param inactivity_timeout the timeout, in milliseconds
     */
    set_inactivity_timeout(inactivity_timeout: number): void
    /**
     * Adds a description to the `application` option context.
     * 
     * See g_option_context_set_description() for more information.
     * @param description a string to be shown in `--help` output  after the list of options, or %NULL
     */
    set_option_context_description(description: string | null): void
    /**
     * Sets the parameter string to be used by the commandline handling of `application`.
     * 
     * This function registers the argument to be passed to g_option_context_new()
     * when the internal #GOptionContext of `application` is created.
     * 
     * See g_option_context_new() for more information about `parameter_string`.
     * @param parameter_string a string which is displayed   in the first line of `--help` output, after the usage summary `programname [OPTION...]`.
     */
    set_option_context_parameter_string(parameter_string: string | null): void
    /**
     * Adds a summary to the `application` option context.
     * 
     * See g_option_context_set_summary() for more information.
     * @param summary a string to be shown in `--help` output  before the list of options, or %NULL
     */
    set_option_context_summary(summary: string | null): void
    /**
     * Sets (or unsets) the base resource path of `application`.
     * 
     * The path is used to automatically load various [application
     * resources][gresource] such as menu layouts and action descriptions.
     * The various types of resources will be found at fixed names relative
     * to the given base path.
     * 
     * By default, the resource base path is determined from the application
     * ID by prefixing '/' and replacing each '.' with '/'.  This is done at
     * the time that the #GApplication object is constructed.  Changes to
     * the application ID after that point will not have an impact on the
     * resource base path.
     * 
     * As an example, if the application has an ID of "org.example.app" then
     * the default resource base path will be "/org/example/app".  If this
     * is a #GtkApplication (and you have not manually changed the path)
     * then Gtk will then search for the menus of the application at
     * "/org/example/app/gtk/menus.ui".
     * 
     * See #GResource for more information about adding resources to your
     * application.
     * 
     * You can disable automatic resource loading functionality by setting
     * the path to %NULL.
     * 
     * Changing the resource base path once the application is running is
     * not recommended.  The point at which the resource path is consulted
     * for forming paths for various purposes is unspecified.  When writing
     * a sub-class of #GApplication you should either set the
     * #GApplication:resource-base-path property at construction time, or call
     * this function during the instance initialization. Alternatively, you
     * can call this function in the #GApplicationClass.startup virtual function,
     * before chaining up to the parent implementation.
     * @param resource_path the resource path to use
     */
    set_resource_base_path(resource_path: string | null): void
    /**
     * Destroys a binding between `property` and the busy state of
     * `application` that was previously created with
     * g_application_bind_busy_property().
     * @param object a #GObject
     * @param property the name of a boolean property of `object`
     */
    unbind_busy_property(object: GObject.Object, property: string | null): void
    /**
     * Decreases the busy count of `application`.
     * 
     * When the busy count reaches zero, the new state will be propagated
     * to other processes.
     * 
     * This function must only be called to cancel the effect of a previous
     * call to g_application_mark_busy().
     */
    unmark_busy(): void
    /**
     * Withdraws a notification that was sent with
     * g_application_send_notification().
     * 
     * This call does nothing if a notification with `id` doesn't exist or
     * the notification was never sent.
     * 
     * This function works even for notifications sent in previous
     * executions of this application, as long `id` is the same as it was for
     * the sent notification.
     * 
     * Note that notifications are dismissed when the user clicks on one
     * of the buttons in a notification or triggers its default action, so
     * there is no need to explicitly withdraw the notification in that case.
     * @param id id of a previously sent notification
     */
    withdraw_notification(id: string | null): void

    // Own virtual methods of Gio-2.0.Gio.Application

    /**
     * Activates the application.
     * 
     * In essence, this results in the #GApplication::activate signal being
     * emitted in the primary instance.
     * 
     * The application must be registered before calling this function.
     * @virtual 
     */
    vfunc_activate(): void
    vfunc_add_platform_data(builder: GLib.VariantBuilder): void
    vfunc_after_emit(platform_data: GLib.Variant): void
    vfunc_before_emit(platform_data: GLib.Variant): void
    vfunc_command_line(command_line: ApplicationCommandLine): number
    vfunc_dbus_register(connection: DBusConnection, object_path: string | null): boolean
    vfunc_dbus_unregister(connection: DBusConnection, object_path: string | null): void
    vfunc_handle_local_options(options: GLib.VariantDict): number
    /**
     * This virtual function is always invoked in the local instance. It
     * gets passed a pointer to a %NULL-terminated copy of `argv` and is
     * expected to remove arguments that it handled (shifting up remaining
     * arguments).
     * 
     * The last argument to local_command_line() is a pointer to the `status`
     * variable which can used to set the exit status that is returned from
     * g_application_run().
     * 
     * See g_application_run() for more details on #GApplication startup.
     * @virtual 
     * @param arguments_ array of command line arguments
     * @returns %TRUE if the commandline has been completely handled
     */
    vfunc_local_command_line(arguments_: string[]): [ /* returnType */ boolean, /* arguments_ */ string[], /* exit_status */ number ]
    vfunc_name_lost(): boolean
    /**
     * Opens the given files.
     * 
     * In essence, this results in the #GApplication::open signal being emitted
     * in the primary instance.
     * 
     * `n_files` must be greater than zero.
     * 
     * `hint` is simply passed through to the ::open signal.  It is
     * intended to be used by applications that have multiple modes for
     * opening files (eg: "view" vs "edit", etc).  Unless you have a need
     * for this functionality, you should use "".
     * 
     * The application must be registered before calling this function
     * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
     * @virtual 
     * @param files an array of #GFiles to open
     * @param hint a hint (or ""), but never %NULL
     */
    vfunc_open(files: File[], hint: string | null): void
    vfunc_quit_mainloop(): void
    vfunc_run_mainloop(): void
    vfunc_shutdown(): void
    vfunc_startup(): void

    // Own signals of Gio-2.0.Gio.Application

    connect(sigName: "activate", callback: Application.ActivateSignalCallback): number
    connect_after(sigName: "activate", callback: Application.ActivateSignalCallback): number
    emit(sigName: "activate", ...args: any[]): void
    connect(sigName: "command-line", callback: Application.CommandLineSignalCallback): number
    connect_after(sigName: "command-line", callback: Application.CommandLineSignalCallback): number
    emit(sigName: "command-line", command_line: ApplicationCommandLine, ...args: any[]): void
    connect(sigName: "handle-local-options", callback: Application.HandleLocalOptionsSignalCallback): number
    connect_after(sigName: "handle-local-options", callback: Application.HandleLocalOptionsSignalCallback): number
    emit(sigName: "handle-local-options", options: GLib.VariantDict, ...args: any[]): void
    connect(sigName: "name-lost", callback: Application.NameLostSignalCallback): number
    connect_after(sigName: "name-lost", callback: Application.NameLostSignalCallback): number
    emit(sigName: "name-lost", ...args: any[]): void
    connect(sigName: "open", callback: Application.OpenSignalCallback): number
    connect_after(sigName: "open", callback: Application.OpenSignalCallback): number
    emit(sigName: "open", files: File[], hint: string | null, ...args: any[]): void
    connect(sigName: "shutdown", callback: Application.ShutdownSignalCallback): number
    connect_after(sigName: "shutdown", callback: Application.ShutdownSignalCallback): number
    emit(sigName: "shutdown", ...args: any[]): void
    connect(sigName: "startup", callback: Application.StartupSignalCallback): number
    connect_after(sigName: "startup", callback: Application.StartupSignalCallback): number
    emit(sigName: "startup", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.Application

    connect(sigName: "notify::action-group", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::action-group", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::action-group", ...args: any[]): void
    connect(sigName: "notify::application-id", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::application-id", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::application-id", ...args: any[]): void
    connect(sigName: "notify::flags", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: "notify::inactivity-timeout", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::inactivity-timeout", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::inactivity-timeout", ...args: any[]): void
    connect(sigName: "notify::is-busy", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-busy", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-busy", ...args: any[]): void
    connect(sigName: "notify::is-registered", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-registered", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-registered", ...args: any[]): void
    connect(sigName: "notify::is-remote", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-remote", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-remote", ...args: any[]): void
    connect(sigName: "notify::resource-base-path", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::resource-base-path", callback: (($obj: Application, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::resource-base-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GApplication is the foundation of an application.  It wraps some
 * low-level platform-specific services and is intended to act as the
 * foundation for higher-level application classes such as
 * #GtkApplication or #MxApplication.  In general, you should not use
 * this class outside of a higher level framework.
 * 
 * GApplication provides convenient life cycle management by maintaining
 * a "use count" for the primary application instance. The use count can
 * be changed using g_application_hold() and g_application_release(). If
 * it drops to zero, the application exits. Higher-level classes such as
 * #GtkApplication employ the use count to ensure that the application
 * stays alive as long as it has any opened windows.
 * 
 * Another feature that GApplication (optionally) provides is process
 * uniqueness. Applications can make use of this functionality by
 * providing a unique application ID. If given, only one application
 * with this ID can be running at a time per session. The session
 * concept is platform-dependent, but corresponds roughly to a graphical
 * desktop login. When your application is launched again, its
 * arguments are passed through platform communication to the already
 * running program. The already running instance of the program is
 * called the "primary instance"; for non-unique applications this is
 * always the current instance. On Linux, the D-Bus session bus
 * is used for communication.
 * 
 * The use of #GApplication differs from some other commonly-used
 * uniqueness libraries (such as libunique) in important ways. The
 * application is not expected to manually register itself and check
 * if it is the primary instance. Instead, the main() function of a
 * #GApplication should do very little more than instantiating the
 * application instance, possibly connecting signal handlers, then
 * calling g_application_run(). All checks for uniqueness are done
 * internally. If the application is the primary instance then the
 * startup signal is emitted and the mainloop runs. If the application
 * is not the primary instance then a signal is sent to the primary
 * instance and g_application_run() promptly returns. See the code
 * examples below.
 * 
 * If used, the expected form of an application identifier is the same as
 * that of of a
 * [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
 * Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
 * `org._7_zip.Archiver`.
 * For details on valid application identifiers, see g_application_id_is_valid().
 * 
 * On Linux, the application identifier is claimed as a well-known bus name
 * on the user's session bus.  This means that the uniqueness of your
 * application is scoped to the current session.  It also means that your
 * application may provide additional services (through registration of other
 * object paths) at that bus name.  The registration of these object paths
 * should be done with the shared GDBus session bus.  Note that due to the
 * internal architecture of GDBus, method calls can be dispatched at any time
 * (even if a main loop is not running).  For this reason, you must ensure that
 * any object paths that you wish to register are registered before #GApplication
 * attempts to acquire the bus name of your application (which happens in
 * g_application_register()).  Unfortunately, this means that you cannot use
 * g_application_get_is_remote() to decide if you want to register object paths.
 * 
 * GApplication also implements the #GActionGroup and #GActionMap
 * interfaces and lets you easily export actions by adding them with
 * g_action_map_add_action(). When invoking an action by calling
 * g_action_group_activate_action() on the application, it is always
 * invoked in the primary instance. The actions are also exported on
 * the session bus, and GIO provides the #GDBusActionGroup wrapper to
 * conveniently access them remotely. GIO provides a #GDBusMenuModel wrapper
 * for remote access to exported #GMenuModels.
 * 
 * There is a number of different entry points into a GApplication:
 * 
 * - via 'Activate' (i.e. just starting the application)
 * 
 * - via 'Open' (i.e. opening some files)
 * 
 * - by handling a command-line
 * 
 * - via activating an action
 * 
 * The #GApplication::startup signal lets you handle the application
 * initialization for all of these in a single place.
 * 
 * Regardless of which of these entry points is used to start the
 * application, GApplication passes some ‘platform data’ from the
 * launching instance to the primary instance, in the form of a
 * #GVariant dictionary mapping strings to variants. To use platform
 * data, override the `before_emit` or `after_emit` virtual functions
 * in your #GApplication subclass. When dealing with
 * #GApplicationCommandLine objects, the platform data is
 * directly available via g_application_command_line_get_cwd(),
 * g_application_command_line_get_environ() and
 * g_application_command_line_get_platform_data().
 * 
 * As the name indicates, the platform data may vary depending on the
 * operating system, but it always includes the current directory (key
 * "cwd"), and optionally the environment (ie the set of environment
 * variables and their values) of the calling process (key "environ").
 * The environment is only added to the platform data if the
 * %G_APPLICATION_SEND_ENVIRONMENT flag is set. #GApplication subclasses
 * can add their own platform data by overriding the `add_platform_data`
 * virtual function. For instance, #GtkApplication adds startup notification
 * data in this way.
 * 
 * To parse commandline arguments you may handle the
 * #GApplication::command-line signal or override the local_command_line()
 * vfunc, to parse them in either the primary instance or the local instance,
 * respectively.
 * 
 * For an example of opening files with a GApplication, see
 * [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).
 * 
 * For an example of using actions with GApplication, see
 * [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).
 * 
 * For an example of using extra D-Bus hooks with GApplication, see
 * [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
 * @class 
 */
class Application extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Application

    static name: string
    static $gtype: GObject.GType<Application>

    // Constructors of Gio-2.0.Gio.Application

    constructor(config?: Application.ConstructorProperties) 
    /**
     * Creates a new #GApplication instance.
     * 
     * If non-%NULL, the application id must be valid.  See
     * g_application_id_is_valid().
     * 
     * If no application ID is given then some features of #GApplication
     * (most notably application uniqueness) will be disabled.
     * @constructor 
     * @param application_id the application id
     * @param flags the application flags
     * @returns a new #GApplication instance
     */
    constructor(application_id: string | null, flags: ApplicationFlags) 
    /**
     * Creates a new #GApplication instance.
     * 
     * If non-%NULL, the application id must be valid.  See
     * g_application_id_is_valid().
     * 
     * If no application ID is given then some features of #GApplication
     * (most notably application uniqueness) will be disabled.
     * @constructor 
     * @param application_id the application id
     * @param flags the application flags
     * @returns a new #GApplication instance
     */
    static new(application_id: string | null, flags: ApplicationFlags): Application
    _init(config?: Application.ConstructorProperties): void
    /**
     * Returns the default #GApplication instance for this process.
     * 
     * Normally there is only one #GApplication per process and it becomes
     * the default when it is created.  You can exercise more control over
     * this by using g_application_set_default().
     * 
     * If there is no default application then %NULL is returned.
     * @returns the default application for this process, or %NULL
     */
    static get_default(): Application | null
    /**
     * Checks if `application_id` is a valid application identifier.
     * 
     * A valid ID is required for calls to g_application_new() and
     * g_application_set_application_id().
     * 
     * Application identifiers follow the same format as
     * [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
     * For convenience, the restrictions on application identifiers are
     * reproduced here:
     * 
     * - Application identifiers are composed of 1 or more elements separated by a
     *   period (`.`) character. All elements must contain at least one character.
     * 
     * - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
     *   with `-` discouraged in new application identifiers. Each element must not
     *   begin with a digit.
     * 
     * - Application identifiers must contain at least one `.` (period) character
     *   (and thus at least two elements).
     * 
     * - Application identifiers must not begin with a `.` (period) character.
     * 
     * - Application identifiers must not exceed 255 characters.
     * 
     * Note that the hyphen (`-`) character is allowed in application identifiers,
     * but is problematic or not allowed in various specifications and APIs that
     * refer to D-Bus, such as
     * [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
     * the
     * [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
     * and the convention that an application's "main" interface and object path
     * resemble its application identifier and bus name. To avoid situations that
     * require special-case handling, it is recommended that new application
     * identifiers consistently replace hyphens with underscores.
     * 
     * Like D-Bus interface names, application identifiers should start with the
     * reversed DNS domain name of the author of the interface (in lower-case), and
     * it is conventional for the rest of the application identifier to consist of
     * words run together, with initial capital letters.
     * 
     * As with D-Bus interface names, if the author's DNS domain name contains
     * hyphen/minus characters they should be replaced by underscores, and if it
     * contains leading digits they should be escaped by prepending an underscore.
     * For example, if the owner of 7-zip.org used an application identifier for an
     * archiving application, it might be named `org._7_zip.Archiver`.
     * @param application_id a potential application identifier
     * @returns %TRUE if @application_id is valid
     */
    static id_is_valid(application_id: string | null): boolean
}

module ApplicationCommandLine {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ApplicationCommandLine

        "arguments"?: GLib.Variant | null
        options?: GLib.Variant | null
        platform_data?: GLib.Variant | null
    }

}

interface ApplicationCommandLine {

    // Own properties of Gio-2.0.Gio.ApplicationCommandLine

    readonly "arguments": GLib.Variant
    readonly is_remote: boolean
    readonly options: GLib.Variant
    readonly platform_data: GLib.Variant

    // Owm methods of Gio-2.0.Gio.ApplicationCommandLine

    /**
     * Creates a #GFile corresponding to a filename that was given as part
     * of the invocation of `cmdline`.
     * 
     * This differs from g_file_new_for_commandline_arg() in that it
     * resolves relative pathnames using the current working directory of
     * the invoking process rather than the local process.
     * @param arg an argument from `cmdline`
     * @returns a new #GFile
     */
    create_file_for_arg(arg: string): File
    /**
     * Gets the list of arguments that was passed on the command line.
     * 
     * The strings in the array may contain non-UTF-8 data on UNIX (such as
     * filenames or arguments given in the system locale) but are always in
     * UTF-8 on Windows.
     * 
     * If you wish to use the return value with #GOptionContext, you must
     * use g_option_context_parse_strv().
     * 
     * The return value is %NULL-terminated and should be freed using
     * g_strfreev().
     * @returns       the string array containing the arguments (the argv)
     */
    get_arguments(): string[]
    /**
     * Gets the working directory of the command line invocation.
     * The string may contain non-utf8 data.
     * 
     * It is possible that the remote application did not send a working
     * directory, so this may be %NULL.
     * 
     * The return value should not be modified or freed and is valid for as
     * long as `cmdline` exists.
     * @returns the current directory, or %NULL
     */
    get_cwd(): string | null
    /**
     * Gets the contents of the 'environ' variable of the command line
     * invocation, as would be returned by g_get_environ(), ie as a
     * %NULL-terminated list of strings in the form 'NAME=VALUE'.
     * The strings may contain non-utf8 data.
     * 
     * The remote application usually does not send an environment.  Use
     * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
     * set it is possible that the environment is still not available (due
     * to invocation messages from other applications).
     * 
     * The return value should not be modified or freed and is valid for as
     * long as `cmdline` exists.
     * 
     * See g_application_command_line_getenv() if you are only interested
     * in the value of a single environment variable.
     * @returns      the environment strings, or %NULL if they were not sent
     */
    get_environ(): string[]
    /**
     * Gets the exit status of `cmdline`.  See
     * g_application_command_line_set_exit_status() for more information.
     * @returns the exit status
     */
    get_exit_status(): number
    /**
     * Determines if `cmdline` represents a remote invocation.
     * @returns %TRUE if the invocation was remote
     */
    get_is_remote(): boolean
    /**
     * Gets the options that were passed to g_application_command_line().
     * 
     * If you did not override local_command_line() then these are the same
     * options that were parsed according to the #GOptionEntrys added to the
     * application with g_application_add_main_option_entries() and possibly
     * modified from your GApplication::handle-local-options handler.
     * 
     * If no options were sent then an empty dictionary is returned so that
     * you don't need to check for %NULL.
     * 
     * The data has been passed via an untrusted external process, so the types of
     * all values must be checked before being used.
     * @returns a #GVariantDict with the options
     */
    get_options_dict(): GLib.VariantDict
    /**
     * Gets the platform data associated with the invocation of `cmdline`.
     * 
     * This is a #GVariant dictionary containing information about the
     * context in which the invocation occurred.  It typically contains
     * information like the current working directory and the startup
     * notification ID.
     * 
     * It comes from an untrusted external process and hence the types of all
     * values must be validated before being used.
     * 
     * For local invocation, it will be %NULL.
     * @returns the platform data, or %NULL
     */
    get_platform_data(): GLib.Variant | null
    /**
     * Gets the stdin of the invoking process.
     * 
     * The #GInputStream can be used to read data passed to the standard
     * input of the invoking process.
     * This doesn't work on all platforms.  Presently, it is only available
     * on UNIX when using a D-Bus daemon capable of passing file descriptors.
     * If stdin is not available then %NULL will be returned.  In the
     * future, support may be expanded to other platforms.
     * 
     * You must only call this function once per commandline invocation.
     * @returns a #GInputStream for stdin
     */
    get_stdin(): InputStream | null
    /**
     * Gets the value of a particular environment variable of the command
     * line invocation, as would be returned by g_getenv().  The strings may
     * contain non-utf8 data.
     * 
     * The remote application usually does not send an environment.  Use
     * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
     * set it is possible that the environment is still not available (due
     * to invocation messages from other applications).
     * 
     * The return value should not be modified or freed and is valid for as
     * long as `cmdline` exists.
     * @param name the environment variable to get
     * @returns the value of the variable, or %NULL if unset or unsent
     */
    getenv(name: string): string | null
    /**
     * Sets the exit status that will be used when the invoking process
     * exits.
     * 
     * The return value of the #GApplication::command-line signal is
     * passed to this function when the handler returns.  This is the usual
     * way of setting the exit status.
     * 
     * In the event that you want the remote invocation to continue running
     * and want to decide on the exit status in the future, you can use this
     * call.  For the case of a remote invocation, the remote process will
     * typically exit when the last reference is dropped on `cmdline`.  The
     * exit status of the remote process will be equal to the last value
     * that was set with this function.
     * 
     * In the case that the commandline invocation is local, the situation
     * is slightly more complicated.  If the commandline invocation results
     * in the mainloop running (ie: because the use-count of the application
     * increased to a non-zero value) then the application is considered to
     * have been 'successful' in a certain sense, and the exit status is
     * always zero.  If the application use count is zero, though, the exit
     * status of the local #GApplicationCommandLine is used.
     * @param exit_status the exit status
     */
    set_exit_status(exit_status: number): void

    // Own virtual methods of Gio-2.0.Gio.ApplicationCommandLine

    /**
     * Gets the stdin of the invoking process.
     * 
     * The #GInputStream can be used to read data passed to the standard
     * input of the invoking process.
     * This doesn't work on all platforms.  Presently, it is only available
     * on UNIX when using a D-Bus daemon capable of passing file descriptors.
     * If stdin is not available then %NULL will be returned.  In the
     * future, support may be expanded to other platforms.
     * 
     * You must only call this function once per commandline invocation.
     * @virtual 
     * @returns a #GInputStream for stdin
     */
    vfunc_get_stdin(): InputStream | null
    vfunc_print_literal(message: string | null): void
    vfunc_printerr_literal(message: string | null): void

    // Class property signals of Gio-2.0.Gio.ApplicationCommandLine

    connect(sigName: "notify::arguments", callback: (($obj: ApplicationCommandLine, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::arguments", callback: (($obj: ApplicationCommandLine, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::arguments", ...args: any[]): void
    connect(sigName: "notify::is-remote", callback: (($obj: ApplicationCommandLine, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-remote", callback: (($obj: ApplicationCommandLine, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-remote", ...args: any[]): void
    connect(sigName: "notify::options", callback: (($obj: ApplicationCommandLine, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::options", callback: (($obj: ApplicationCommandLine, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::options", ...args: any[]): void
    connect(sigName: "notify::platform-data", callback: (($obj: ApplicationCommandLine, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::platform-data", callback: (($obj: ApplicationCommandLine, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::platform-data", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GApplicationCommandLine represents a command-line invocation of
 * an application.  It is created by #GApplication and emitted
 * in the #GApplication::command-line signal and virtual function.
 * 
 * The class contains the list of arguments that the program was invoked
 * with.  It is also possible to query if the commandline invocation was
 * local (ie: the current process is running in direct response to the
 * invocation) or remote (ie: some other process forwarded the
 * commandline to this process).
 * 
 * The GApplicationCommandLine object can provide the `argc` and `argv`
 * parameters for use with the #GOptionContext command-line parsing API,
 * with the g_application_command_line_get_arguments() function. See
 * [gapplication-example-cmdline3.c][gapplication-example-cmdline3]
 * for an example.
 * 
 * The exit status of the originally-invoked process may be set and
 * messages can be printed to stdout or stderr of that process.  The
 * lifecycle of the originally-invoked process is tied to the lifecycle
 * of this object (ie: the process exits when the last reference is
 * dropped).
 * 
 * The main use for #GApplicationCommandLine (and the
 * #GApplication::command-line signal) is 'Emacs server' like use cases:
 * You can set the `EDITOR` environment variable to have e.g. git use
 * your favourite editor to edit commit messages, and if you already
 * have an instance of the editor running, the editing will happen
 * in the running instance, instead of opening a new one. An important
 * aspect of this use case is that the process that gets started by git
 * does not return until the editing is done.
 * 
 * Normally, the commandline is completely handled in the
 * #GApplication::command-line handler. The launching instance exits
 * once the signal handler in the primary instance has returned, and
 * the return value of the signal handler becomes the exit status
 * of the launching instance.
 * 
 * ```c
 * static int
 * command_line (GApplication            *application,
 *               GApplicationCommandLine *cmdline)
 * {
 *   gchar **argv;
 *   gint argc;
 *   gint i;
 * 
 *   argv = g_application_command_line_get_arguments (cmdline, &argc);
 * 
 *   g_application_command_line_print (cmdline,
 *                                     "This text is written back\n"
 *                                     "to stdout of the caller\n");
 * 
 *   for (i = 0; i < argc; i++)
 *     g_print ("argument %d: %s\n", i, argv[i]);
 * 
 *   g_strfreev (argv);
 * 
 *   return 0;
 * }
 * ```
 * 
 * The complete example can be found here:
 * [gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)
 * 
 * In more complicated cases, the handling of the commandline can be
 * split between the launcher and the primary instance.
 * 
 * ```c
 * static gboolean
 *  test_local_cmdline (GApplication   *application,
 *                      gchar        ***arguments,
 *                      gint           *exit_status)
 * {
 *   gint i, j;
 *   gchar **argv;
 * 
 *   argv = *arguments;
 * 
 *   if (argv[0] == NULL)
 *     {
 *       *exit_status = 0;
 *       return FALSE;
 *     }
 * 
 *   i = 1;
 *   while (argv[i])
 *     {
 *       if (g_str_has_prefix (argv[i], "--local-"))
 *         {
 *           g_print ("handling argument %s locally\n", argv[i]);
 *           g_free (argv[i]);
 *           for (j = i; argv[j]; j++)
 *             argv[j] = argv[j + 1];
 *         }
 *       else
 *         {
 *           g_print ("not handling argument %s locally\n", argv[i]);
 *           i++;
 *         }
 *     }
 * 
 *   *exit_status = 0;
 * 
 *   return FALSE;
 * }
 * 
 * static void
 * test_application_class_init (TestApplicationClass *class)
 * {
 *   G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;
 * 
 *   ...
 * }
 * ```
 * 
 * In this example of split commandline handling, options that start
 * with `--local-` are handled locally, all other options are passed
 * to the #GApplication::command-line handler which runs in the primary
 * instance.
 * 
 * The complete example can be found here:
 * [gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)
 * 
 * If handling the commandline requires a lot of work, it may
 * be better to defer it.
 * 
 * ```c
 * static gboolean
 * my_cmdline_handler (gpointer data)
 * {
 *   GApplicationCommandLine *cmdline = data;
 * 
 *   // do the heavy lifting in an idle
 * 
 *   g_application_command_line_set_exit_status (cmdline, 0);
 *   g_object_unref (cmdline); // this releases the application
 * 
 *   return G_SOURCE_REMOVE;
 * }
 * 
 * static int
 * command_line (GApplication            *application,
 *               GApplicationCommandLine *cmdline)
 * {
 *   // keep the application running until we are done with this commandline
 *   g_application_hold (application);
 * 
 *   g_object_set_data_full (G_OBJECT (cmdline),
 *                           "application", application,
 *                           (GDestroyNotify)g_application_release);
 * 
 *   g_object_ref (cmdline);
 *   g_idle_add (my_cmdline_handler, cmdline);
 * 
 *   return 0;
 * }
 * ```
 * 
 * In this example the commandline is not completely handled before
 * the #GApplication::command-line handler returns. Instead, we keep
 * a reference to the #GApplicationCommandLine object and handle it
 * later (in this example, in an idle). Note that it is necessary to
 * hold the application until you are done with the commandline.
 * 
 * The complete example can be found here:
 * [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
 * @class 
 */
class ApplicationCommandLine extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ApplicationCommandLine

    static name: string
    static $gtype: GObject.GType<ApplicationCommandLine>

    // Constructors of Gio-2.0.Gio.ApplicationCommandLine

    constructor(config?: ApplicationCommandLine.ConstructorProperties) 
    _init(config?: ApplicationCommandLine.ConstructorProperties): void
}

module BufferedInputStream {

    // Constructor properties interface

    interface ConstructorProperties extends Seekable.ConstructorProperties, FilterInputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.BufferedInputStream

        buffer_size?: number | null
    }

}

interface BufferedInputStream extends Seekable {

    // Own properties of Gio-2.0.Gio.BufferedInputStream

    buffer_size: number

    // Own fields of Gio-2.0.Gio.BufferedInputStream

    parent_instance: FilterInputStream & InputStream & GObject.Object & GObject.Object

    // Owm methods of Gio-2.0.Gio.BufferedInputStream

    /**
     * Tries to read `count` bytes from the stream into the buffer.
     * Will block during this read.
     * 
     * If `count` is zero, returns zero and does nothing. A value of `count`
     * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes read into the buffer is returned.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file. Zero is returned on end of file
     * (or if `count` is zero),  but never otherwise.
     * 
     * If `count` is -1 then the attempted read size is equal to the number of
     * bytes that are required to fill the buffer.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * 
     * For the asynchronous, non-blocking, version of this function, see
     * g_buffered_input_stream_fill_async().
     * @param count the number of bytes that will be read from the stream
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns the number of bytes read into @stream's buffer, up to @count,     or -1 on error.
     */
    fill(count: number, cancellable: Cancellable | null): number
    /**
     * Reads data into `stream'`s buffer asynchronously, up to `count` size.
     * `io_priority` can be used to prioritize reads. For the synchronous
     * version of this function, see g_buffered_input_stream_fill().
     * 
     * If `count` is -1 then the attempted read size is equal to the number
     * of bytes that are required to fill the buffer.
     * @param count the number of bytes that will be read from the stream
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object
     * @param callback a #GAsyncReadyCallback
     */
    fill_async(count: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of fill_async

    /**
     * Promisified version of {@link fill_async}
     * 
     * Reads data into `stream'`s buffer asynchronously, up to `count` size.
     * `io_priority` can be used to prioritize reads. For the synchronous
     * version of this function, see g_buffered_input_stream_fill().
     * 
     * If `count` is -1 then the attempted read size is equal to the number
     * of bytes that are required to fill the buffer.
     * @param count the number of bytes that will be read from the stream
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object
     * @returns A Promise of: a #gssize of the read stream, or `-1` on an error.
     */
    fill_async(count: number, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<number>
    /**
     * Finishes an asynchronous read.
     * @param result a #GAsyncResult
     * @returns a #gssize of the read stream, or `-1` on an error.
     */
    fill_finish(result: AsyncResult): number
    /**
     * Gets the size of the available data within the stream.
     * @returns size of the available stream.
     */
    get_available(): number
    /**
     * Gets the size of the input buffer.
     * @returns the current buffer size.
     */
    get_buffer_size(): number
    /**
     * Peeks in the buffer, copying data of size `count` into `buffer,`
     * offset `offset` bytes.
     * @param buffer a pointer to   an allocated chunk of memory
     * @param offset a #gsize
     * @returns a #gsize of the number of bytes peeked, or -1 on error.
     */
    peek(buffer: Uint8Array, offset: number): number
    /**
     * Returns the buffer with the currently available bytes. The returned
     * buffer must not be modified and will become invalid when reading from
     * the stream or filling the buffer.
     * @returns           read-only buffer
     */
    peek_buffer(): Uint8Array
    /**
     * Tries to read a single byte from the stream or the buffer. Will block
     * during this read.
     * 
     * On success, the byte read from the stream is returned. On end of stream
     * -1 is returned but it's not an exceptional error and `error` is not set.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns the byte read from the @stream, or -1 on end of stream or error.
     */
    read_byte(cancellable: Cancellable | null): number
    /**
     * Sets the size of the internal buffer of `stream` to `size,` or to the
     * size of the contents of the buffer. The buffer can never be resized
     * smaller than its current contents.
     * @param size a #gsize
     */
    set_buffer_size(size: number): void

    // Own virtual methods of Gio-2.0.Gio.BufferedInputStream

    /**
     * Tries to read `count` bytes from the stream into the buffer.
     * Will block during this read.
     * 
     * If `count` is zero, returns zero and does nothing. A value of `count`
     * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes read into the buffer is returned.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file. Zero is returned on end of file
     * (or if `count` is zero),  but never otherwise.
     * 
     * If `count` is -1 then the attempted read size is equal to the number of
     * bytes that are required to fill the buffer.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * 
     * For the asynchronous, non-blocking, version of this function, see
     * g_buffered_input_stream_fill_async().
     * @virtual 
     * @param count the number of bytes that will be read from the stream
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns the number of bytes read into @stream's buffer, up to @count,     or -1 on error.
     */
    vfunc_fill(count: number, cancellable: Cancellable | null): number
    /**
     * Reads data into `stream'`s buffer asynchronously, up to `count` size.
     * `io_priority` can be used to prioritize reads. For the synchronous
     * version of this function, see g_buffered_input_stream_fill().
     * 
     * If `count` is -1 then the attempted read size is equal to the number
     * of bytes that are required to fill the buffer.
     * @virtual 
     * @param count the number of bytes that will be read from the stream
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object
     * @param callback a #GAsyncReadyCallback
     */
    vfunc_fill_async(count: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous read.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns a #gssize of the read stream, or `-1` on an error.
     */
    vfunc_fill_finish(result: AsyncResult): number

    // Class property signals of Gio-2.0.Gio.BufferedInputStream

    connect(sigName: "notify::buffer-size", callback: (($obj: BufferedInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::buffer-size", callback: (($obj: BufferedInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::buffer-size", ...args: any[]): void
    connect(sigName: "notify::close-base-stream", callback: (($obj: BufferedInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-base-stream", callback: (($obj: BufferedInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-base-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Buffered input stream implements #GFilterInputStream and provides
 * for buffered reads.
 * 
 * By default, #GBufferedInputStream's buffer size is set at 4 kilobytes.
 * 
 * To create a buffered input stream, use g_buffered_input_stream_new(),
 * or g_buffered_input_stream_new_sized() to specify the buffer's size at
 * construction.
 * 
 * To get the size of a buffer within a buffered input stream, use
 * g_buffered_input_stream_get_buffer_size(). To change the size of a
 * buffered input stream's buffer, use
 * g_buffered_input_stream_set_buffer_size(). Note that the buffer's size
 * cannot be reduced below the size of the data within the buffer.
 * @class 
 */
class BufferedInputStream extends FilterInputStream {

    // Own properties of Gio-2.0.Gio.BufferedInputStream

    static name: string
    static $gtype: GObject.GType<BufferedInputStream>

    // Constructors of Gio-2.0.Gio.BufferedInputStream

    constructor(config?: BufferedInputStream.ConstructorProperties) 
    /**
     * Creates a new #GInputStream from the given `base_stream,` with
     * a buffer set to the default size (4 kilobytes).
     * @constructor 
     * @param base_stream a #GInputStream
     * @returns a #GInputStream for the given @base_stream.
     */
    constructor(base_stream: InputStream) 
    /**
     * Creates a new #GInputStream from the given `base_stream,` with
     * a buffer set to the default size (4 kilobytes).
     * @constructor 
     * @param base_stream a #GInputStream
     * @returns a #GInputStream for the given @base_stream.
     */
    static new(base_stream: InputStream): BufferedInputStream
    /**
     * Creates a new #GBufferedInputStream from the given `base_stream,`
     * with a buffer set to `size`.
     * @constructor 
     * @param base_stream a #GInputStream
     * @param size a #gsize
     * @returns a #GInputStream.
     */
    static new_sized(base_stream: InputStream, size: number): BufferedInputStream
    _init(config?: BufferedInputStream.ConstructorProperties): void
}

module BufferedOutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends Seekable.ConstructorProperties, FilterOutputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.BufferedOutputStream

        auto_grow?: boolean | null
        buffer_size?: number | null
    }

}

interface BufferedOutputStream extends Seekable {

    // Own properties of Gio-2.0.Gio.BufferedOutputStream

    auto_grow: boolean
    buffer_size: number

    // Own fields of Gio-2.0.Gio.BufferedOutputStream

    parent_instance: FilterOutputStream & OutputStream & GObject.Object & GObject.Object
    priv: BufferedOutputStreamPrivate

    // Owm methods of Gio-2.0.Gio.BufferedOutputStream

    /**
     * Checks if the buffer automatically grows as data is added.
     * @returns %TRUE if the @stream's buffer automatically grows, %FALSE otherwise.
     */
    get_auto_grow(): boolean
    /**
     * Gets the size of the buffer in the `stream`.
     * @returns the current size of the buffer.
     */
    get_buffer_size(): number
    /**
     * Sets whether or not the `stream'`s buffer should automatically grow.
     * If `auto_grow` is true, then each write will just make the buffer
     * larger, and you must manually flush the buffer to actually write out
     * the data to the underlying stream.
     * @param auto_grow a #gboolean.
     */
    set_auto_grow(auto_grow: boolean): void
    /**
     * Sets the size of the internal buffer to `size`.
     * @param size a #gsize.
     */
    set_buffer_size(size: number): void

    // Class property signals of Gio-2.0.Gio.BufferedOutputStream

    connect(sigName: "notify::auto-grow", callback: (($obj: BufferedOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-grow", callback: (($obj: BufferedOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::auto-grow", ...args: any[]): void
    connect(sigName: "notify::buffer-size", callback: (($obj: BufferedOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::buffer-size", callback: (($obj: BufferedOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::buffer-size", ...args: any[]): void
    connect(sigName: "notify::close-base-stream", callback: (($obj: BufferedOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-base-stream", callback: (($obj: BufferedOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-base-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Buffered output stream implements #GFilterOutputStream and provides
 * for buffered writes.
 * 
 * By default, #GBufferedOutputStream's buffer size is set at 4 kilobytes.
 * 
 * To create a buffered output stream, use g_buffered_output_stream_new(),
 * or g_buffered_output_stream_new_sized() to specify the buffer's size
 * at construction.
 * 
 * To get the size of a buffer within a buffered input stream, use
 * g_buffered_output_stream_get_buffer_size(). To change the size of a
 * buffered output stream's buffer, use
 * g_buffered_output_stream_set_buffer_size(). Note that the buffer's
 * size cannot be reduced below the size of the data within the buffer.
 * @class 
 */
class BufferedOutputStream extends FilterOutputStream {

    // Own properties of Gio-2.0.Gio.BufferedOutputStream

    static name: string
    static $gtype: GObject.GType<BufferedOutputStream>

    // Constructors of Gio-2.0.Gio.BufferedOutputStream

    constructor(config?: BufferedOutputStream.ConstructorProperties) 
    /**
     * Creates a new buffered output stream for a base stream.
     * @constructor 
     * @param base_stream a #GOutputStream.
     * @returns a #GOutputStream for the given @base_stream.
     */
    constructor(base_stream: OutputStream) 
    /**
     * Creates a new buffered output stream for a base stream.
     * @constructor 
     * @param base_stream a #GOutputStream.
     * @returns a #GOutputStream for the given @base_stream.
     */
    static new(base_stream: OutputStream): BufferedOutputStream
    /**
     * Creates a new buffered output stream with a given buffer size.
     * @constructor 
     * @param base_stream a #GOutputStream.
     * @param size a #gsize.
     * @returns a #GOutputStream with an internal buffer set to @size.
     */
    static new_sized(base_stream: OutputStream, size: number): BufferedOutputStream
    _init(config?: BufferedOutputStream.ConstructorProperties): void
}

module BytesIcon {

    // Constructor properties interface

    interface ConstructorProperties extends Icon.ConstructorProperties, LoadableIcon.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.BytesIcon

        /**
         * The bytes containing the icon.
         */
        bytes?: GLib.Bytes | null
    }

}

interface BytesIcon extends Icon, LoadableIcon {

    // Own properties of Gio-2.0.Gio.BytesIcon

    /**
     * The bytes containing the icon.
     */
    readonly bytes: GLib.Bytes

    // Owm methods of Gio-2.0.Gio.BytesIcon

    /**
     * Gets the #GBytes associated with the given `icon`.
     * @returns a #GBytes.
     */
    get_bytes(): GLib.Bytes

    // Class property signals of Gio-2.0.Gio.BytesIcon

    connect(sigName: "notify::bytes", callback: (($obj: BytesIcon, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bytes", callback: (($obj: BytesIcon, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::bytes", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GBytesIcon specifies an image held in memory in a common format (usually
 * png) to be used as icon.
 * @class 
 */
class BytesIcon extends GObject.Object {

    // Own properties of Gio-2.0.Gio.BytesIcon

    static name: string
    static $gtype: GObject.GType<BytesIcon>

    // Constructors of Gio-2.0.Gio.BytesIcon

    constructor(config?: BytesIcon.ConstructorProperties) 
    /**
     * Creates a new icon for a bytes.
     * 
     * This cannot fail, but loading and interpreting the bytes may fail later on
     * (for example, if g_loadable_icon_load() is called) if the image is invalid.
     * @constructor 
     * @param bytes a #GBytes.
     * @returns a #GIcon for the given   @bytes.
     */
    constructor(bytes: GLib.Bytes) 
    /**
     * Creates a new icon for a bytes.
     * 
     * This cannot fail, but loading and interpreting the bytes may fail later on
     * (for example, if g_loadable_icon_load() is called) if the image is invalid.
     * @constructor 
     * @param bytes a #GBytes.
     * @returns a #GIcon for the given   @bytes.
     */
    static new(bytes: GLib.Bytes): BytesIcon
    _init(config?: BytesIcon.ConstructorProperties): void
}

module Cancellable {

    // Signal callback interfaces

    /**
     * Signal callback interface for `cancelled`
     */
    interface CancelledSignalCallback {
        ($obj: Cancellable): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Cancellable {

    // Own fields of Gio-2.0.Gio.Cancellable

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.Cancellable

    /**
     * Will set `cancellable` to cancelled, and will emit the
     * #GCancellable::cancelled signal. (However, see the warning about
     * race conditions in the documentation for that signal if you are
     * planning to connect to it.)
     * 
     * This function is thread-safe. In other words, you can safely call
     * it from a thread other than the one running the operation that was
     * passed the `cancellable`.
     * 
     * If `cancellable` is %NULL, this function returns immediately for convenience.
     * 
     * The convention within GIO is that cancelling an asynchronous
     * operation causes it to complete asynchronously. That is, if you
     * cancel the operation from the same thread in which it is running,
     * then the operation's #GAsyncReadyCallback will not be invoked until
     * the application returns to the main loop.
     */
    cancel(): void
    /**
     * Convenience function to connect to the #GCancellable::cancelled
     * signal. Also handles the race condition that may happen
     * if the cancellable is cancelled right before connecting.
     * 
     * `callback` is called at most once, either directly at the
     * time of the connect if `cancellable` is already cancelled,
     * or when `cancellable` is cancelled in some thread.
     * 
     * `data_destroy_func` will be called when the handler is
     * disconnected, or immediately if the cancellable is already
     * cancelled.
     * 
     * See #GCancellable::cancelled for details on how to use this.
     * 
     * Since GLib 2.40, the lock protecting `cancellable` is not held when
     * `callback` is invoked.  This lifts a restriction in place for
     * earlier GLib versions which now makes it easier to write cleanup
     * code that unconditionally invokes e.g. g_cancellable_cancel().
     * @param callback The #GCallback to connect.
     * @returns The id of the signal handler or 0 if @cancellable has already          been cancelled.
     */
    connect(callback: GObject.Callback): number
    /**
     * Disconnects a handler from a cancellable instance similar to
     * g_signal_handler_disconnect().  Additionally, in the event that a
     * signal handler is currently running, this call will block until the
     * handler has finished.  Calling this function from a
     * #GCancellable::cancelled signal handler will therefore result in a
     * deadlock.
     * 
     * This avoids a race condition where a thread cancels at the
     * same time as the cancellable operation is finished and the
     * signal handler is removed. See #GCancellable::cancelled for
     * details on how to use this.
     * 
     * If `cancellable` is %NULL or `handler_id` is `0` this function does
     * nothing.
     * @param handler_id Handler id of the handler to be disconnected, or `0`.
     */
    disconnect(handler_id: number): void
    /**
     * Gets the file descriptor for a cancellable job. This can be used to
     * implement cancellable operations on Unix systems. The returned fd will
     * turn readable when `cancellable` is cancelled.
     * 
     * You are not supposed to read from the fd yourself, just check for
     * readable status. Reading to unset the readable status is done
     * with g_cancellable_reset().
     * 
     * After a successful return from this function, you should use
     * g_cancellable_release_fd() to free up resources allocated for
     * the returned file descriptor.
     * 
     * See also g_cancellable_make_pollfd().
     * @returns A valid file descriptor. `-1` if the file descriptor is not supported, or on errors.
     */
    get_fd(): number
    /**
     * Checks if a cancellable job has been cancelled.
     * @returns %TRUE if @cancellable is cancelled, FALSE if called with %NULL or if item is not cancelled.
     */
    is_cancelled(): boolean
    /**
     * Creates a #GPollFD corresponding to `cancellable;` this can be passed
     * to g_poll() and used to poll for cancellation. This is useful both
     * for unix systems without a native poll and for portability to
     * windows.
     * 
     * When this function returns %TRUE, you should use
     * g_cancellable_release_fd() to free up resources allocated for the
     * `pollfd`. After a %FALSE return, do not call g_cancellable_release_fd().
     * 
     * If this function returns %FALSE, either no `cancellable` was given or
     * resource limits prevent this function from allocating the necessary
     * structures for polling. (On Linux, you will likely have reached
     * the maximum number of file descriptors.) The suggested way to handle
     * these cases is to ignore the `cancellable`.
     * 
     * You are not supposed to read from the fd yourself, just check for
     * readable status. Reading to unset the readable status is done
     * with g_cancellable_reset().
     * @param pollfd a pointer to a #GPollFD
     * @returns %TRUE if @pollfd was successfully initialized, %FALSE on          failure to prepare the cancellable.
     */
    make_pollfd(pollfd: GLib.PollFD): boolean
    /**
     * Pops `cancellable` off the cancellable stack (verifying that `cancellable`
     * is on the top of the stack).
     */
    pop_current(): void
    /**
     * Pushes `cancellable` onto the cancellable stack. The current
     * cancellable can then be received using g_cancellable_get_current().
     * 
     * This is useful when implementing cancellable operations in
     * code that does not allow you to pass down the cancellable object.
     * 
     * This is typically called automatically by e.g. #GFile operations,
     * so you rarely have to call this yourself.
     */
    push_current(): void
    /**
     * Releases a resources previously allocated by g_cancellable_get_fd()
     * or g_cancellable_make_pollfd().
     * 
     * For compatibility reasons with older releases, calling this function
     * is not strictly required, the resources will be automatically freed
     * when the `cancellable` is finalized. However, the `cancellable` will
     * block scarce file descriptors until it is finalized if this function
     * is not called. This can cause the application to run out of file
     * descriptors when many #GCancellables are used at the same time.
     */
    release_fd(): void
    /**
     * Resets `cancellable` to its uncancelled state.
     * 
     * If cancellable is currently in use by any cancellable operation
     * then the behavior of this function is undefined.
     * 
     * Note that it is generally not a good idea to reuse an existing
     * cancellable for more operations after it has been cancelled once,
     * as this function might tempt you to do. The recommended practice
     * is to drop the reference to a cancellable after cancelling it,
     * and let it die with the outstanding async operations. You should
     * create a fresh cancellable for further async operations.
     */
    reset(): void
    /**
     * If the `cancellable` is cancelled, sets the error to notify
     * that the operation was cancelled.
     * @returns %TRUE if @cancellable was cancelled, %FALSE if it was not
     */
    set_error_if_cancelled(): boolean
    /**
     * Creates a source that triggers if `cancellable` is cancelled and
     * calls its callback of type #GCancellableSourceFunc. This is
     * primarily useful for attaching to another (non-cancellable) source
     * with g_source_add_child_source() to add cancellability to it.
     * 
     * For convenience, you can call this with a %NULL #GCancellable,
     * in which case the source will never trigger.
     * 
     * The new #GSource will hold a reference to the #GCancellable.
     * @returns the new #GSource.
     */
    source_new(): GLib.Source

    // Own virtual methods of Gio-2.0.Gio.Cancellable

    vfunc_cancelled(): void

    // Own signals of Gio-2.0.Gio.Cancellable

    connect(sigName: "cancelled", callback: Cancellable.CancelledSignalCallback): number
    connect_after(sigName: "cancelled", callback: Cancellable.CancelledSignalCallback): number
    emit(sigName: "cancelled", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.Cancellable

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * GCancellable is a thread-safe operation cancellation stack used
 * throughout GIO to allow for cancellation of synchronous and
 * asynchronous operations.
 * @class 
 */
class Cancellable extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Cancellable

    static name: string
    static $gtype: GObject.GType<Cancellable>

    // Constructors of Gio-2.0.Gio.Cancellable

    constructor(config?: Cancellable.ConstructorProperties) 
    /**
     * Creates a new #GCancellable object.
     * 
     * Applications that want to start one or more operations
     * that should be cancellable should create a #GCancellable
     * and pass it to the operations.
     * 
     * One #GCancellable can be used in multiple consecutive
     * operations or in multiple concurrent operations.
     * @constructor 
     * @returns a #GCancellable.
     */
    constructor() 
    /**
     * Creates a new #GCancellable object.
     * 
     * Applications that want to start one or more operations
     * that should be cancellable should create a #GCancellable
     * and pass it to the operations.
     * 
     * One #GCancellable can be used in multiple consecutive
     * operations or in multiple concurrent operations.
     * @constructor 
     * @returns a #GCancellable.
     */
    static new(): Cancellable
    _init(config?: Cancellable.ConstructorProperties): void
    /**
     * Gets the top cancellable from the stack.
     * @returns a #GCancellable from the top of the stack, or %NULL if the stack is empty.
     */
    static get_current(): Cancellable | null
}

module CharsetConverter {

    // Constructor properties interface

    interface ConstructorProperties extends Converter.ConstructorProperties, Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.CharsetConverter

        from_charset?: string | null
        to_charset?: string | null
        use_fallback?: boolean | null
    }

}

interface CharsetConverter extends Converter, Initable {

    // Own properties of Gio-2.0.Gio.CharsetConverter

    readonly from_charset: string | null
    readonly to_charset: string | null
    use_fallback: boolean

    // Owm methods of Gio-2.0.Gio.CharsetConverter

    /**
     * Gets the number of fallbacks that `converter` has applied so far.
     * @returns the number of fallbacks that @converter has applied
     */
    get_num_fallbacks(): number
    /**
     * Gets the #GCharsetConverter:use-fallback property.
     * @returns %TRUE if fallbacks are used by @converter
     */
    get_use_fallback(): boolean
    /**
     * Sets the #GCharsetConverter:use-fallback property.
     * @param use_fallback %TRUE to use fallbacks
     */
    set_use_fallback(use_fallback: boolean): void

    // Class property signals of Gio-2.0.Gio.CharsetConverter

    connect(sigName: "notify::from-charset", callback: (($obj: CharsetConverter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::from-charset", callback: (($obj: CharsetConverter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::from-charset", ...args: any[]): void
    connect(sigName: "notify::to-charset", callback: (($obj: CharsetConverter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::to-charset", callback: (($obj: CharsetConverter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::to-charset", ...args: any[]): void
    connect(sigName: "notify::use-fallback", callback: (($obj: CharsetConverter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-fallback", callback: (($obj: CharsetConverter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::use-fallback", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GCharsetConverter is an implementation of #GConverter based on
 * GIConv.
 * @class 
 */
class CharsetConverter extends GObject.Object {

    // Own properties of Gio-2.0.Gio.CharsetConverter

    static name: string
    static $gtype: GObject.GType<CharsetConverter>

    // Constructors of Gio-2.0.Gio.CharsetConverter

    constructor(config?: CharsetConverter.ConstructorProperties) 
    /**
     * Creates a new #GCharsetConverter.
     * @constructor 
     * @param to_charset destination charset
     * @param from_charset source charset
     * @returns a new #GCharsetConverter or %NULL on error.
     */
    constructor(to_charset: string | null, from_charset: string | null) 
    /**
     * Creates a new #GCharsetConverter.
     * @constructor 
     * @param to_charset destination charset
     * @param from_charset source charset
     * @returns a new #GCharsetConverter or %NULL on error.
     */
    static new(to_charset: string | null, from_charset: string | null): CharsetConverter
    _init(config?: CharsetConverter.ConstructorProperties): void
}

module ConverterInputStream {

    // Constructor properties interface

    interface ConstructorProperties extends PollableInputStream.ConstructorProperties, FilterInputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ConverterInputStream

        converter?: Converter | null
    }

}

interface ConverterInputStream extends PollableInputStream {

    // Own properties of Gio-2.0.Gio.ConverterInputStream

    readonly converter: Converter

    // Own fields of Gio-2.0.Gio.ConverterInputStream

    parent_instance: FilterInputStream & InputStream & GObject.Object & GObject.Object

    // Owm methods of Gio-2.0.Gio.ConverterInputStream

    /**
     * Gets the #GConverter that is used by `converter_stream`.
     * @returns the converter of the converter input stream
     */
    get_converter(): Converter

    // Class property signals of Gio-2.0.Gio.ConverterInputStream

    connect(sigName: "notify::converter", callback: (($obj: ConverterInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::converter", callback: (($obj: ConverterInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::converter", ...args: any[]): void
    connect(sigName: "notify::close-base-stream", callback: (($obj: ConverterInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-base-stream", callback: (($obj: ConverterInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-base-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Converter input stream implements #GInputStream and allows
 * conversion of data of various types during reading.
 * 
 * As of GLib 2.34, #GConverterInputStream implements
 * #GPollableInputStream.
 * @class 
 */
class ConverterInputStream extends FilterInputStream {

    // Own properties of Gio-2.0.Gio.ConverterInputStream

    static name: string
    static $gtype: GObject.GType<ConverterInputStream>

    // Constructors of Gio-2.0.Gio.ConverterInputStream

    constructor(config?: ConverterInputStream.ConstructorProperties) 
    /**
     * Creates a new converter input stream for the `base_stream`.
     * @constructor 
     * @param base_stream a #GInputStream
     * @param converter a #GConverter
     * @returns a new #GInputStream.
     */
    constructor(base_stream: InputStream, converter: Converter) 
    /**
     * Creates a new converter input stream for the `base_stream`.
     * @constructor 
     * @param base_stream a #GInputStream
     * @param converter a #GConverter
     * @returns a new #GInputStream.
     */
    static new(base_stream: InputStream, converter: Converter): ConverterInputStream
    _init(config?: ConverterInputStream.ConstructorProperties): void
}

module ConverterOutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends PollableOutputStream.ConstructorProperties, FilterOutputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ConverterOutputStream

        converter?: Converter | null
    }

}

interface ConverterOutputStream extends PollableOutputStream {

    // Own properties of Gio-2.0.Gio.ConverterOutputStream

    readonly converter: Converter

    // Own fields of Gio-2.0.Gio.ConverterOutputStream

    parent_instance: FilterOutputStream & OutputStream & GObject.Object & GObject.Object

    // Owm methods of Gio-2.0.Gio.ConverterOutputStream

    /**
     * Gets the #GConverter that is used by `converter_stream`.
     * @returns the converter of the converter output stream
     */
    get_converter(): Converter

    // Class property signals of Gio-2.0.Gio.ConverterOutputStream

    connect(sigName: "notify::converter", callback: (($obj: ConverterOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::converter", callback: (($obj: ConverterOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::converter", ...args: any[]): void
    connect(sigName: "notify::close-base-stream", callback: (($obj: ConverterOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-base-stream", callback: (($obj: ConverterOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-base-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Converter output stream implements #GOutputStream and allows
 * conversion of data of various types during reading.
 * 
 * As of GLib 2.34, #GConverterOutputStream implements
 * #GPollableOutputStream.
 * @class 
 */
class ConverterOutputStream extends FilterOutputStream {

    // Own properties of Gio-2.0.Gio.ConverterOutputStream

    static name: string
    static $gtype: GObject.GType<ConverterOutputStream>

    // Constructors of Gio-2.0.Gio.ConverterOutputStream

    constructor(config?: ConverterOutputStream.ConstructorProperties) 
    /**
     * Creates a new converter output stream for the `base_stream`.
     * @constructor 
     * @param base_stream a #GOutputStream
     * @param converter a #GConverter
     * @returns a new #GOutputStream.
     */
    constructor(base_stream: OutputStream, converter: Converter) 
    /**
     * Creates a new converter output stream for the `base_stream`.
     * @constructor 
     * @param base_stream a #GOutputStream
     * @param converter a #GConverter
     * @returns a new #GOutputStream.
     */
    static new(base_stream: OutputStream, converter: Converter): ConverterOutputStream
    _init(config?: ConverterOutputStream.ConstructorProperties): void
}

module Credentials {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Credentials {

    // Owm methods of Gio-2.0.Gio.Credentials

    /**
     * Tries to get the UNIX process identifier from `credentials`. This
     * method is only available on UNIX platforms.
     * 
     * This operation can fail if #GCredentials is not supported on the
     * OS or if the native credentials type does not contain information
     * about the UNIX process ID.
     * @returns The UNIX process ID, or `-1` if @error is set.
     */
    get_unix_pid(): number
    /**
     * Tries to get the UNIX user identifier from `credentials`. This
     * method is only available on UNIX platforms.
     * 
     * This operation can fail if #GCredentials is not supported on the
     * OS or if the native credentials type does not contain information
     * about the UNIX user.
     * @returns The UNIX user identifier or `-1` if @error is set.
     */
    get_unix_user(): number
    /**
     * Checks if `credentials` and `other_credentials` is the same user.
     * 
     * This operation can fail if #GCredentials is not supported on the
     * the OS.
     * @param other_credentials A #GCredentials.
     * @returns %TRUE if @credentials and @other_credentials has the same user, %FALSE otherwise or if @error is set.
     */
    is_same_user(other_credentials: Credentials): boolean
    /**
     * Copies the native credentials of type `native_type` from `native`
     * into `credentials`.
     * 
     * It is a programming error (which will cause a warning to be
     * logged) to use this method if there is no #GCredentials support for
     * the OS or if `native_type` isn't supported by the OS.
     * @param native_type The type of native credentials to set.
     * @param native A pointer to native credentials.
     */
    set_native(native_type: CredentialsType, native: any): void
    /**
     * Tries to set the UNIX user identifier on `credentials`. This method
     * is only available on UNIX platforms.
     * 
     * This operation can fail if #GCredentials is not supported on the
     * OS or if the native credentials type does not contain information
     * about the UNIX user. It can also fail if the OS does not allow the
     * use of "spoofed" credentials.
     * @param uid The UNIX user identifier to set.
     * @returns %TRUE if @uid was set, %FALSE if error is set.
     */
    set_unix_user(uid: number): boolean
    /**
     * Creates a human-readable textual representation of `credentials`
     * that can be used in logging and debug messages. The format of the
     * returned string may change in future GLib release.
     * @returns A string that should be freed with g_free().
     */
    to_string(): string | null

    // Class property signals of Gio-2.0.Gio.Credentials

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GCredentials type is a reference-counted wrapper for native
 * credentials. This information is typically used for identifying,
 * authenticating and authorizing other processes.
 * 
 * Some operating systems supports looking up the credentials of the
 * remote peer of a communication endpoint - see e.g.
 * g_socket_get_credentials().
 * 
 * Some operating systems supports securely sending and receiving
 * credentials over a Unix Domain Socket, see
 * #GUnixCredentialsMessage, g_unix_connection_send_credentials() and
 * g_unix_connection_receive_credentials() for details.
 * 
 * On Linux, the native credential type is a `struct ucred` - see the
 * unix(7) man page for details. This corresponds to
 * %G_CREDENTIALS_TYPE_LINUX_UCRED.
 * 
 * On Apple operating systems (including iOS, tvOS, and macOS),
 * the native credential type is a `struct xucred`.
 * This corresponds to %G_CREDENTIALS_TYPE_APPLE_XUCRED.
 * 
 * On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native
 * credential type is a `struct cmsgcred`. This corresponds
 * to %G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
 * 
 * On NetBSD, the native credential type is a `struct unpcbid`.
 * This corresponds to %G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
 * 
 * On OpenBSD, the native credential type is a `struct sockpeercred`.
 * This corresponds to %G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
 * 
 * On Solaris (including OpenSolaris and its derivatives), the native
 * credential type is a `ucred_t`. This corresponds to
 * %G_CREDENTIALS_TYPE_SOLARIS_UCRED.
 * 
 * Since GLib 2.72, on Windows, the native credentials may contain the PID of a
 * process. This corresponds to %G_CREDENTIALS_TYPE_WIN32_PID.
 * @class 
 */
class Credentials extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Credentials

    static name: string
    static $gtype: GObject.GType<Credentials>

    // Constructors of Gio-2.0.Gio.Credentials

    constructor(config?: Credentials.ConstructorProperties) 
    /**
     * Creates a new #GCredentials object with credentials matching the
     * the current process.
     * @constructor 
     * @returns A #GCredentials. Free with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new #GCredentials object with credentials matching the
     * the current process.
     * @constructor 
     * @returns A #GCredentials. Free with g_object_unref().
     */
    static new(): Credentials
    _init(config?: Credentials.ConstructorProperties): void
}

module DBusActionGroup {

    // Constructor properties interface

    interface ConstructorProperties extends ActionGroup.ConstructorProperties, RemoteActionGroup.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface DBusActionGroup extends ActionGroup, RemoteActionGroup {

    // Class property signals of Gio-2.0.Gio.DBusActionGroup

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDBusActionGroup is an implementation of the #GActionGroup
 * interface that can be used as a proxy for an action group
 * that is exported over D-Bus with g_dbus_connection_export_action_group().
 * @class 
 */
class DBusActionGroup extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusActionGroup

    static name: string
    static $gtype: GObject.GType<DBusActionGroup>

    // Constructors of Gio-2.0.Gio.DBusActionGroup

    constructor(config?: DBusActionGroup.ConstructorProperties) 
    _init(config?: DBusActionGroup.ConstructorProperties): void
    /**
     * Obtains a #GDBusActionGroup for the action group which is exported at
     * the given `bus_name` and `object_path`.
     * 
     * The thread default main context is taken at the time of this call.
     * All signals on the menu model (and any linked models) are reported
     * with respect to this context.  All calls on the returned menu model
     * (and linked models) must also originate from this same context, with
     * the thread default main context unchanged.
     * 
     * This call is non-blocking.  The returned action group may or may not
     * already be filled in.  The correct thing to do is connect the signals
     * for the action group to monitor for changes and then to call
     * g_action_group_list_actions() to get the initial list.
     * @param connection A #GDBusConnection
     * @param bus_name the bus name which exports the action     group or %NULL if `connection` is not a message bus connection
     * @param object_path the object path at which the action group is exported
     * @returns a #GDBusActionGroup
     */
    static get(connection: DBusConnection, bus_name: string | null, object_path: string | null): DBusActionGroup
}

module DBusAuthObserver {

    // Signal callback interfaces

    /**
     * Signal callback interface for `allow-mechanism`
     */
    interface AllowMechanismSignalCallback {
        ($obj: DBusAuthObserver, mechanism: string | null): boolean
    }

    /**
     * Signal callback interface for `authorize-authenticated-peer`
     */
    interface AuthorizeAuthenticatedPeerSignalCallback {
        ($obj: DBusAuthObserver, stream: IOStream, credentials: Credentials | null): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface DBusAuthObserver {

    // Owm methods of Gio-2.0.Gio.DBusAuthObserver

    /**
     * Emits the #GDBusAuthObserver::allow-mechanism signal on `observer`.
     * @param mechanism The name of the mechanism, e.g. `DBUS_COOKIE_SHA1`.
     * @returns %TRUE if @mechanism can be used to authenticate the other peer, %FALSE if not.
     */
    allow_mechanism(mechanism: string | null): boolean
    /**
     * Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on `observer`.
     * @param stream A #GIOStream for the #GDBusConnection.
     * @param credentials Credentials received from the peer or %NULL.
     * @returns %TRUE if the peer is authorized, %FALSE if not.
     */
    authorize_authenticated_peer(stream: IOStream, credentials: Credentials | null): boolean

    // Own signals of Gio-2.0.Gio.DBusAuthObserver

    connect(sigName: "allow-mechanism", callback: DBusAuthObserver.AllowMechanismSignalCallback): number
    connect_after(sigName: "allow-mechanism", callback: DBusAuthObserver.AllowMechanismSignalCallback): number
    emit(sigName: "allow-mechanism", mechanism: string | null, ...args: any[]): void
    connect(sigName: "authorize-authenticated-peer", callback: DBusAuthObserver.AuthorizeAuthenticatedPeerSignalCallback): number
    connect_after(sigName: "authorize-authenticated-peer", callback: DBusAuthObserver.AuthorizeAuthenticatedPeerSignalCallback): number
    emit(sigName: "authorize-authenticated-peer", stream: IOStream, credentials: Credentials | null, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusAuthObserver

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GDBusAuthObserver type provides a mechanism for participating
 * in how a #GDBusServer (or a #GDBusConnection) authenticates remote
 * peers. Simply instantiate a #GDBusAuthObserver and connect to the
 * signals you are interested in. Note that new signals may be added
 * in the future
 * 
 * ## Controlling Authentication Mechanisms
 * 
 * By default, a #GDBusServer or server-side #GDBusConnection will allow
 * any authentication mechanism to be used. If you only
 * want to allow D-Bus connections with the `EXTERNAL` mechanism,
 * which makes use of credentials passing and is the recommended
 * mechanism for modern Unix platforms such as Linux and the BSD family,
 * you would use a signal handler like this:
 * 
 * 
 * ```c
 * static gboolean
 * on_allow_mechanism (GDBusAuthObserver *observer,
 *                     const gchar       *mechanism,
 *                     gpointer           user_data)
 * {
 *   if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
 *     {
 *       return TRUE;
 *     }
 * 
 *   return FALSE;
 * }
 * ```
 * 
 * 
 * ## Controlling Authorization # {#auth-observer}
 * 
 * By default, a #GDBusServer or server-side #GDBusConnection will accept
 * connections from any successfully authenticated user (but not from
 * anonymous connections using the `ANONYMOUS` mechanism). If you only
 * want to allow D-Bus connections from processes owned by the same uid
 * as the server, since GLib 2.68, you should use the
 * %G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag. It’s equivalent
 * to the following signal handler:
 * 
 * 
 * ```c
 * static gboolean
 * on_authorize_authenticated_peer (GDBusAuthObserver *observer,
 *                                  GIOStream         *stream,
 *                                  GCredentials      *credentials,
 *                                  gpointer           user_data)
 * {
 *   gboolean authorized;
 * 
 *   authorized = FALSE;
 *   if (credentials != NULL)
 *     {
 *       GCredentials *own_credentials;
 *       own_credentials = g_credentials_new ();
 *       if (g_credentials_is_same_user (credentials, own_credentials, NULL))
 *         authorized = TRUE;
 *       g_object_unref (own_credentials);
 *     }
 * 
 *   return authorized;
 * }
 * ```
 * 
 * @class 
 */
class DBusAuthObserver extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusAuthObserver

    static name: string
    static $gtype: GObject.GType<DBusAuthObserver>

    // Constructors of Gio-2.0.Gio.DBusAuthObserver

    constructor(config?: DBusAuthObserver.ConstructorProperties) 
    /**
     * Creates a new #GDBusAuthObserver object.
     * @constructor 
     * @returns A #GDBusAuthObserver. Free with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new #GDBusAuthObserver object.
     * @constructor 
     * @returns A #GDBusAuthObserver. Free with g_object_unref().
     */
    static new(): DBusAuthObserver
    _init(config?: DBusAuthObserver.ConstructorProperties): void
}

module DBusConnection {

    // Signal callback interfaces

    /**
     * Signal callback interface for `closed`
     */
    interface ClosedSignalCallback {
        ($obj: DBusConnection, remote_peer_vanished: boolean, error: GLib.Error | null): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends AsyncInitable.ConstructorProperties, Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DBusConnection

        /**
         * A D-Bus address specifying potential endpoints that can be used
         * when establishing the connection.
         */
        address?: string | null
        /**
         * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
         */
        authentication_observer?: DBusAuthObserver | null
        /**
         * A boolean specifying whether the process will be terminated (by
         * calling `raise(SIGTERM)`) if the connection is closed by the
         * remote peer.
         * 
         * Note that #GDBusConnection objects returned by g_bus_get_finish()
         * and g_bus_get_sync() will (usually) have this property set to %TRUE.
         */
        exit_on_close?: boolean | null
        /**
         * Flags from the #GDBusConnectionFlags enumeration.
         */
        flags?: DBusConnectionFlags | null
        /**
         * The GUID of the peer performing the role of server when
         * authenticating.
         * 
         * If you are constructing a #GDBusConnection and pass
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
         * #GDBusConnection:flags property then you **must** also set this
         * property to a valid guid.
         * 
         * If you are constructing a #GDBusConnection and pass
         * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
         * #GDBusConnection:flags property you will be able to read the GUID
         * of the other peer here after the connection has been successfully
         * initialized.
         * 
         * Note that the
         * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
         * uses the term ‘UUID’ to refer to this, whereas GLib consistently uses the
         * term ‘GUID’ for historical reasons.
         * 
         * Despite its name, the format of #GDBusConnection:guid does not follow
         * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
         * GUID format.
         */
        guid?: string | null
        /**
         * The underlying #GIOStream used for I/O.
         * 
         * If this is passed on construction and is a #GSocketConnection,
         * then the corresponding #GSocket will be put into non-blocking mode.
         * 
         * While the #GDBusConnection is active, it will interact with this
         * stream from a worker thread, so it is not safe to interact with
         * the stream directly.
         */
        stream?: IOStream | null
    }

}

interface DBusConnection extends AsyncInitable, Initable {

    // Own properties of Gio-2.0.Gio.DBusConnection

    /**
     * A D-Bus address specifying potential endpoints that can be used
     * when establishing the connection.
     */
    readonly address: string | null
    /**
     * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
     */
    readonly authentication_observer: DBusAuthObserver
    /**
     * Flags from the #GDBusCapabilityFlags enumeration
     * representing connection features negotiated with the other peer.
     */
    readonly capabilities: DBusCapabilityFlags
    /**
     * A boolean specifying whether the connection has been closed.
     */
    readonly closed: boolean
    /**
     * A boolean specifying whether the process will be terminated (by
     * calling `raise(SIGTERM)`) if the connection is closed by the
     * remote peer.
     * 
     * Note that #GDBusConnection objects returned by g_bus_get_finish()
     * and g_bus_get_sync() will (usually) have this property set to %TRUE.
     */
    exit_on_close: boolean
    /**
     * Flags from the #GDBusConnectionFlags enumeration.
     */
    readonly flags: DBusConnectionFlags
    /**
     * The GUID of the peer performing the role of server when
     * authenticating.
     * 
     * If you are constructing a #GDBusConnection and pass
     * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
     * #GDBusConnection:flags property then you **must** also set this
     * property to a valid guid.
     * 
     * If you are constructing a #GDBusConnection and pass
     * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
     * #GDBusConnection:flags property you will be able to read the GUID
     * of the other peer here after the connection has been successfully
     * initialized.
     * 
     * Note that the
     * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
     * uses the term ‘UUID’ to refer to this, whereas GLib consistently uses the
     * term ‘GUID’ for historical reasons.
     * 
     * Despite its name, the format of #GDBusConnection:guid does not follow
     * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
     * GUID format.
     */
    readonly guid: string | null
    /**
     * The underlying #GIOStream used for I/O.
     * 
     * If this is passed on construction and is a #GSocketConnection,
     * then the corresponding #GSocket will be put into non-blocking mode.
     * 
     * While the #GDBusConnection is active, it will interact with this
     * stream from a worker thread, so it is not safe to interact with
     * the stream directly.
     */
    readonly stream: IOStream
    /**
     * The unique name as assigned by the message bus or %NULL if the
     * connection is not open or not a message bus connection.
     */
    readonly unique_name: string | null

    // Owm methods of Gio-2.0.Gio.DBusConnection

    /**
     * Adds a message filter. Filters are handlers that are run on all
     * incoming and outgoing messages, prior to standard dispatch. Filters
     * are run in the order that they were added.  The same handler can be
     * added as a filter more than once, in which case it will be run more
     * than once.  Filters added during a filter callback won't be run on
     * the message being processed. Filter functions are allowed to modify
     * and even drop messages.
     * 
     * Note that filters are run in a dedicated message handling thread so
     * they can't block and, generally, can't do anything but signal a
     * worker thread. Also note that filters are rarely needed - use API
     * such as g_dbus_connection_send_message_with_reply(),
     * g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
     * 
     * If a filter consumes an incoming message the message is not
     * dispatched anywhere else - not even the standard dispatch machinery
     * (that API such as g_dbus_connection_signal_subscribe() and
     * g_dbus_connection_send_message_with_reply() relies on) will see the
     * message. Similarly, if a filter consumes an outgoing message, the
     * message will not be sent to the other peer.
     * 
     * If `user_data_free_func` is non-%NULL, it will be called (in the
     * thread-default main context of the thread you are calling this
     * method from) at some point after `user_data` is no longer
     * needed. (It is not guaranteed to be called synchronously when the
     * filter is removed, and may be called after `connection` has been
     * destroyed.)
     * @param filter_function a filter function
     * @returns a filter identifier that can be used with     g_dbus_connection_remove_filter()
     */
    add_filter(filter_function: DBusMessageFilterFunction): number
    /**
     * Asynchronously invokes the `method_name` method on the
     * `interface_name` D-Bus interface on the remote object at
     * `object_path` owned by `bus_name`.
     * 
     * If `connection` is closed then the operation will fail with
     * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
     * fail with %G_IO_ERROR_CANCELLED. If `parameters` contains a value
     * not compatible with the D-Bus protocol, the operation fails with
     * %G_IO_ERROR_INVALID_ARGUMENT.
     * 
     * If `reply_type` is non-%NULL then the reply will be checked for having this type and an
     * error will be raised if it does not match.  Said another way, if you give a `reply_type`
     * then any non-%NULL return value will be of this type. Unless it’s
     * %G_VARIANT_TYPE_UNIT, the `reply_type` will be a tuple containing one or more
     * values.
     * 
     * If the `parameters` #GVariant is floating, it is consumed. This allows
     * convenient 'inline' use of g_variant_new(), e.g.:
     * 
     * ```c
     *  g_dbus_connection_call (connection,
     *                          "org.freedesktop.StringThings",
     *                          "/org/freedesktop/StringThings",
     *                          "org.freedesktop.StringThings",
     *                          "TwoStrings",
     *                          g_variant_new ("(ss)",
     *                                         "Thing One",
     *                                         "Thing Two"),
     *                          NULL,
     *                          G_DBUS_CALL_FLAGS_NONE,
     *                          -1,
     *                          NULL,
     *                          (GAsyncReadyCallback) two_strings_done,
     *                          NULL);
     * ```
     * 
     * 
     * This is an asynchronous method. When the operation is finished,
     * `callback` will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can then call
     * g_dbus_connection_call_finish() to get the result of the operation.
     * See g_dbus_connection_call_sync() for the synchronous version of this
     * function.
     * 
     * If `callback` is %NULL then the D-Bus method call message will be sent with
     * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
     * @param bus_name a unique or well-known bus name or %NULL if     `connection` is not a message bus connection
     * @param object_path path of remote object
     * @param interface_name D-Bus interface to invoke method on
     * @param method_name the name of the method to invoke
     * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
     * @param reply_type the expected type of the reply (which will be a     tuple), or %NULL
     * @param flags flags from the #GDBusCallFlags enumeration
     * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request     is satisfied or %NULL if you don't care about the result of the     method invocation
     */
    call(bus_name: string | null, object_path: string | null, interface_name: string | null, method_name: string | null, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, flags: DBusCallFlags, timeout_msec: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an operation started with g_dbus_connection_call().
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_call()
     * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
     */
    call_finish(res: AsyncResult): GLib.Variant
    /**
     * Synchronously invokes the `method_name` method on the
     * `interface_name` D-Bus interface on the remote object at
     * `object_path` owned by `bus_name`.
     * 
     * If `connection` is closed then the operation will fail with
     * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the
     * operation will fail with %G_IO_ERROR_CANCELLED. If `parameters`
     * contains a value not compatible with the D-Bus protocol, the operation
     * fails with %G_IO_ERROR_INVALID_ARGUMENT.
     * 
     * If `reply_type` is non-%NULL then the reply will be checked for having
     * this type and an error will be raised if it does not match.  Said
     * another way, if you give a `reply_type` then any non-%NULL return
     * value will be of this type.
     * 
     * If the `parameters` #GVariant is floating, it is consumed.
     * This allows convenient 'inline' use of g_variant_new(), e.g.:
     * 
     * ```c
     *  g_dbus_connection_call_sync (connection,
     *                               "org.freedesktop.StringThings",
     *                               "/org/freedesktop/StringThings",
     *                               "org.freedesktop.StringThings",
     *                               "TwoStrings",
     *                               g_variant_new ("(ss)",
     *                                              "Thing One",
     *                                              "Thing Two"),
     *                               NULL,
     *                               G_DBUS_CALL_FLAGS_NONE,
     *                               -1,
     *                               NULL,
     *                               &error);
     * ```
     * 
     * 
     * The calling thread is blocked until a reply is received. See
     * g_dbus_connection_call() for the asynchronous version of
     * this method.
     * @param bus_name a unique or well-known bus name or %NULL if     `connection` is not a message bus connection
     * @param object_path path of remote object
     * @param interface_name D-Bus interface to invoke method on
     * @param method_name the name of the method to invoke
     * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
     * @param reply_type the expected type of the reply, or %NULL
     * @param flags flags from the #GDBusCallFlags enumeration
     * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
     * @param cancellable a #GCancellable or %NULL
     * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
     */
    call_sync(bus_name: string | null, object_path: string | null, interface_name: string | null, method_name: string | null, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, flags: DBusCallFlags, timeout_msec: number, cancellable: Cancellable | null): GLib.Variant
    /**
     * Like g_dbus_connection_call() but also takes a #GUnixFDList object.
     * 
     * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
     * values in the body of the message. For example, if a message contains
     * two file descriptors, `fd_list` would have length 2, and
     * `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
     * somewhere in the body of the message (not necessarily in that order!)
     * to represent the file descriptors at indexes 0 and 1 respectively.
     * 
     * When designing D-Bus APIs that are intended to be interoperable,
     * please note that non-GDBus implementations of D-Bus can usually only
     * access file descriptors if they are referenced in this way by a
     * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
     * 
     * This method is only available on UNIX.
     * @param bus_name a unique or well-known bus name or %NULL if     `connection` is not a message bus connection
     * @param object_path path of remote object
     * @param interface_name D-Bus interface to invoke method on
     * @param method_name the name of the method to invoke
     * @param parameters a #GVariant tuple with parameters for the method     or %NULL if not passing parameters
     * @param reply_type the expected type of the reply, or %NULL
     * @param flags flags from the #GDBusCallFlags enumeration
     * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
     * @param fd_list a #GUnixFDList or %NULL
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request is     satisfied or %NULL if you don't * care about the result of the     method invocation
     */
    call_with_unix_fd_list(bus_name: string | null, object_path: string | null, interface_name: string | null, method_name: string | null, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, flags: DBusCallFlags, timeout_msec: number, fd_list: UnixFDList | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an operation started with g_dbus_connection_call_with_unix_fd_list().
     * 
     * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
     * values in the body of the message. For example,
     * if g_variant_get_handle() returns 5, that is intended to be a reference
     * to the file descriptor that can be accessed by
     * `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
     * 
     * When designing D-Bus APIs that are intended to be interoperable,
     * please note that non-GDBus implementations of D-Bus can usually only
     * access file descriptors if they are referenced in this way by a
     * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to     g_dbus_connection_call_with_unix_fd_list()
     * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
     */
    call_with_unix_fd_list_finish(res: AsyncResult): [ /* returnType */ GLib.Variant, /* out_fd_list */ UnixFDList ]
    /**
     * Like g_dbus_connection_call_sync() but also takes and returns #GUnixFDList objects.
     * See g_dbus_connection_call_with_unix_fd_list() and
     * g_dbus_connection_call_with_unix_fd_list_finish() for more details.
     * 
     * This method is only available on UNIX.
     * @param bus_name a unique or well-known bus name or %NULL     if `connection` is not a message bus connection
     * @param object_path path of remote object
     * @param interface_name D-Bus interface to invoke method on
     * @param method_name the name of the method to invoke
     * @param parameters a #GVariant tuple with parameters for     the method or %NULL if not passing parameters
     * @param reply_type the expected type of the reply, or %NULL
     * @param flags flags from the #GDBusCallFlags enumeration
     * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
     * @param fd_list a #GUnixFDList or %NULL
     * @param cancellable a #GCancellable or %NULL
     * @returns %NULL if @error is set. Otherwise a non-floating     #GVariant tuple with return values. Free with g_variant_unref().
     */
    call_with_unix_fd_list_sync(bus_name: string | null, object_path: string | null, interface_name: string | null, method_name: string | null, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, flags: DBusCallFlags, timeout_msec: number, fd_list: UnixFDList | null, cancellable: Cancellable | null): [ /* returnType */ GLib.Variant, /* out_fd_list */ UnixFDList ]
    /**
     * Closes `connection`. Note that this never causes the process to
     * exit (this might only happen if the other end of a shared message
     * bus connection disconnects, see #GDBusConnection:exit-on-close).
     * 
     * Once the connection is closed, operations such as sending a message
     * will return with the error %G_IO_ERROR_CLOSED. Closing a connection
     * will not automatically flush the connection so queued messages may
     * be lost. Use g_dbus_connection_flush() if you need such guarantees.
     * 
     * If `connection` is already closed, this method fails with
     * %G_IO_ERROR_CLOSED.
     * 
     * When `connection` has been closed, the #GDBusConnection::closed
     * signal is emitted in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread that `connection` was constructed in.
     * 
     * This is an asynchronous method. When the operation is finished,
     * `callback` will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_connection_close_finish() to get the result of the
     * operation. See g_dbus_connection_close_sync() for the synchronous
     * version.
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request is     satisfied or %NULL if you don't care about the result
     */
    close(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an operation started with g_dbus_connection_close().
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_dbus_connection_close()
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set
     */
    close_finish(res: AsyncResult): boolean
    /**
     * Synchronously closes `connection`. The calling thread is blocked
     * until this is done. See g_dbus_connection_close() for the
     * asynchronous version of this method and more details about what it
     * does.
     * @param cancellable a #GCancellable or %NULL
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set
     */
    close_sync(cancellable: Cancellable | null): boolean
    /**
     * Emits a signal.
     * 
     * If the parameters GVariant is floating, it is consumed.
     * 
     * This can only fail if `parameters` is not compatible with the D-Bus protocol
     * (%G_IO_ERROR_INVALID_ARGUMENT), or if `connection` has been closed
     * (%G_IO_ERROR_CLOSED).
     * @param destination_bus_name the unique bus name for the destination     for the signal or %NULL to emit to all listeners
     * @param object_path path of remote object
     * @param interface_name D-Bus interface to emit a signal on
     * @param signal_name the name of the signal to emit
     * @param parameters a #GVariant tuple with parameters for the signal              or %NULL if not passing parameters
     * @returns %TRUE unless @error is set
     */
    emit_signal(destination_bus_name: string | null, object_path: string | null, interface_name: string | null, signal_name: string | null, parameters: GLib.Variant | null): boolean
    /**
     * Exports `action_group` on `connection` at `object_path`.
     * 
     * The implemented D-Bus API should be considered private.  It is
     * subject to change in the future.
     * 
     * A given object path can only have one action group exported on it.
     * If this constraint is violated, the export will fail and 0 will be
     * returned (with `error` set accordingly).
     * 
     * You can unexport the action group using
     * g_dbus_connection_unexport_action_group() with the return value of
     * this function.
     * 
     * The thread default main context is taken at the time of this call.
     * All incoming action activations and state change requests are
     * reported from this context.  Any changes on the action group that
     * cause it to emit signals must also come from this same context.
     * Since incoming action activations and state change requests are
     * rather likely to cause changes on the action group, this effectively
     * limits a given action group to being exported from only one main
     * context.
     * @param object_path a D-Bus object path
     * @param action_group a #GActionGroup
     * @returns the ID of the export (never zero), or 0 in case of failure
     */
    export_action_group(object_path: string | null, action_group: ActionGroup): number
    /**
     * Exports `menu` on `connection` at `object_path`.
     * 
     * The implemented D-Bus API should be considered private.
     * It is subject to change in the future.
     * 
     * An object path can only have one menu model exported on it. If this
     * constraint is violated, the export will fail and 0 will be
     * returned (with `error` set accordingly).
     * 
     * Exporting menus with sections containing more than
     * %G_MENU_EXPORTER_MAX_SECTION_SIZE items is not supported and results in
     * undefined behavior.
     * 
     * You can unexport the menu model using
     * g_dbus_connection_unexport_menu_model() with the return value of
     * this function.
     * @param object_path a D-Bus object path
     * @param menu a #GMenuModel
     * @returns the ID of the export (never zero), or 0 in case of failure
     */
    export_menu_model(object_path: string | null, menu: MenuModel): number
    /**
     * Asynchronously flushes `connection,` that is, writes all queued
     * outgoing message to the transport and then flushes the transport
     * (using g_output_stream_flush_async()). This is useful in programs
     * that wants to emit a D-Bus signal and then exit immediately. Without
     * flushing the connection, there is no guaranteed that the message has
     * been sent to the networking buffers in the OS kernel.
     * 
     * This is an asynchronous method. When the operation is finished,
     * `callback` will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_connection_flush_finish() to get the result of the
     * operation. See g_dbus_connection_flush_sync() for the synchronous
     * version.
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the     request is satisfied or %NULL if you don't care about the result
     */
    flush(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an operation started with g_dbus_connection_flush().
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_dbus_connection_flush()
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set
     */
    flush_finish(res: AsyncResult): boolean
    /**
     * Synchronously flushes `connection`. The calling thread is blocked
     * until this is done. See g_dbus_connection_flush() for the
     * asynchronous version of this method and more details about what it
     * does.
     * @param cancellable a #GCancellable or %NULL
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set
     */
    flush_sync(cancellable: Cancellable | null): boolean
    /**
     * Gets the capabilities negotiated with the remote peer
     * @returns zero or more flags from the #GDBusCapabilityFlags enumeration
     */
    get_capabilities(): DBusCapabilityFlags
    /**
     * Gets whether the process is terminated when `connection` is
     * closed by the remote peer. See
     * #GDBusConnection:exit-on-close for more details.
     * @returns whether the process is terminated when @connection is     closed by the remote peer
     */
    get_exit_on_close(): boolean
    /**
     * Gets the flags used to construct this connection
     * @returns zero or more flags from the #GDBusConnectionFlags enumeration
     */
    get_flags(): DBusConnectionFlags
    /**
     * The GUID of the peer performing the role of server when
     * authenticating. See #GDBusConnection:guid for more details.
     * @returns The GUID. Do not free this string, it is owned by     @connection.
     */
    get_guid(): string | null
    /**
     * Retrieves the last serial number assigned to a #GDBusMessage on
     * the current thread. This includes messages sent via both low-level
     * API such as g_dbus_connection_send_message() as well as
     * high-level API such as g_dbus_connection_emit_signal(),
     * g_dbus_connection_call() or g_dbus_proxy_call().
     * @returns the last used serial or zero when no message has been sent     within the current thread
     */
    get_last_serial(): number
    /**
     * Gets the credentials of the authenticated peer. This will always
     * return %NULL unless `connection` acted as a server
     * (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
     * when set up and the client passed credentials as part of the
     * authentication process.
     * 
     * In a message bus setup, the message bus is always the server and
     * each application is a client. So this method will always return
     * %NULL for message bus clients.
     * @returns a #GCredentials or %NULL if not     available. Do not free this object, it is owned by @connection.
     */
    get_peer_credentials(): Credentials | null
    /**
     * Gets the underlying stream used for IO.
     * 
     * While the #GDBusConnection is active, it will interact with this
     * stream from a worker thread, so it is not safe to interact with
     * the stream directly.
     * @returns the stream used for IO
     */
    get_stream(): IOStream
    /**
     * Gets the unique name of `connection` as assigned by the message
     * bus. This can also be used to figure out if `connection` is a
     * message bus connection.
     * @returns the unique name or %NULL if @connection is not a message     bus connection. Do not free this string, it is owned by     @connection.
     */
    get_unique_name(): string | null
    /**
     * Gets whether `connection` is closed.
     * @returns %TRUE if the connection is closed, %FALSE otherwise
     */
    is_closed(): boolean
    /**
     * Version of g_dbus_connection_register_object() using closures instead of a
     * #GDBusInterfaceVTable for easier binding in other languages.
     * @param object_path The object path to register at.
     * @param interface_info Introspection data for the interface.
     * @param method_call_closure #GClosure for handling incoming method calls.
     * @param get_property_closure #GClosure for getting a property.
     * @param set_property_closure #GClosure for setting a property.
     * @returns 0 if @error is set, otherwise a registration ID (never 0) that can be used with g_dbus_connection_unregister_object() .
     */
    register_object(object_path: string | null, interface_info: DBusInterfaceInfo, method_call_closure: GObject.TClosure | null, get_property_closure: GObject.TClosure | null, set_property_closure: GObject.TClosure | null): number
    /**
     * Registers a whole subtree of dynamic objects.
     * 
     * The `enumerate` and `introspection` functions in `vtable` are used to
     * convey, to remote callers, what nodes exist in the subtree rooted
     * by `object_path`.
     * 
     * When handling remote calls into any node in the subtree, first the
     * `enumerate` function is used to check if the node exists. If the node exists
     * or the %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
     * the `introspection` function is used to check if the node supports the
     * requested method. If so, the `dispatch` function is used to determine
     * where to dispatch the call. The collected #GDBusInterfaceVTable and
     * #gpointer will be used to call into the interface vtable for processing
     * the request.
     * 
     * All calls into user-provided code will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from.
     * 
     * If an existing subtree is already registered at `object_path` or
     * then `error` is set to %G_IO_ERROR_EXISTS.
     * 
     * Note that it is valid to register regular objects (using
     * g_dbus_connection_register_object()) in a subtree registered with
     * g_dbus_connection_register_subtree() - if so, the subtree handler
     * is tried as the last resort. One way to think about a subtree
     * handler is to consider it a fallback handler for object paths not
     * registered via g_dbus_connection_register_object() or other bindings.
     * 
     * Note that `vtable` will be copied so you cannot change it after
     * registration.
     * 
     * See this [server][gdbus-subtree-server] for an example of how to use
     * this method.
     * @param object_path the object path to register the subtree at
     * @param vtable a #GDBusSubtreeVTable to enumerate, introspect and     dispatch nodes in the subtree
     * @param flags flags used to fine tune the behavior of the subtree
     * @param user_data data to pass to functions in `vtable`
     * @param user_data_free_func function to call when the subtree is unregistered
     * @returns 0 if @error is set, otherwise a subtree registration ID (never 0) that can be used with g_dbus_connection_unregister_subtree()
     */
    register_subtree(object_path: string | null, vtable: DBusSubtreeVTable, flags: DBusSubtreeFlags, user_data: any | null, user_data_free_func: GLib.DestroyNotify): number
    /**
     * Removes a filter.
     * 
     * Note that since filters run in a different thread, there is a race
     * condition where it is possible that the filter will be running even
     * after calling g_dbus_connection_remove_filter(), so you cannot just
     * free data that the filter might be using. Instead, you should pass
     * a #GDestroyNotify to g_dbus_connection_add_filter(), which will be
     * called when it is guaranteed that the data is no longer needed.
     * @param filter_id an identifier obtained from g_dbus_connection_add_filter()
     */
    remove_filter(filter_id: number): void
    /**
     * Asynchronously sends `message` to the peer represented by `connection`.
     * 
     * Unless `flags` contain the
     * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
     * will be assigned by `connection` and set on `message` via
     * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
     * serial number used will be written to this location prior to
     * submitting the message to the underlying transport. While it has a `volatile`
     * qualifier, this is a historical artifact and the argument passed to it should
     * not be `volatile`.
     * 
     * If `connection` is closed then the operation will fail with
     * %G_IO_ERROR_CLOSED. If `message` is not well-formed,
     * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
     * 
     * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
     * for an example of how to use this low-level API to send and receive
     * UNIX file descriptors.
     * 
     * Note that `message` must be unlocked, unless `flags` contain the
     * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
     * @param message a #GDBusMessage
     * @param flags flags affecting how the message is sent
     * @returns %TRUE if the message was well-formed and queued for     transmission, %FALSE if @error is set
     */
    send_message(message: DBusMessage, flags: DBusSendMessageFlags): [ /* returnType */ boolean, /* out_serial */ number ]
    /**
     * Asynchronously sends `message` to the peer represented by `connection`.
     * 
     * Unless `flags` contain the
     * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
     * will be assigned by `connection` and set on `message` via
     * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
     * serial number used will be written to this location prior to
     * submitting the message to the underlying transport. While it has a `volatile`
     * qualifier, this is a historical artifact and the argument passed to it should
     * not be `volatile`.
     * 
     * If `connection` is closed then the operation will fail with
     * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
     * fail with %G_IO_ERROR_CANCELLED. If `message` is not well-formed,
     * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
     * 
     * This is an asynchronous method. When the operation is finished, `callback`
     * will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can then call
     * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
     * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
     * 
     * Note that `message` must be unlocked, unless `flags` contain the
     * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
     * 
     * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
     * for an example of how to use this low-level API to send and receive
     * UNIX file descriptors.
     * @param message a #GDBusMessage
     * @param flags flags affecting how the message is sent
     * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request     is satisfied or %NULL if you don't care about the result
     */
    send_message_with_reply(message: DBusMessage, flags: DBusSendMessageFlags, timeout_msec: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): /* out_serial */ number
    /**
     * Finishes an operation started with g_dbus_connection_send_message_with_reply().
     * 
     * Note that `error` is only set if a local in-process error
     * occurred. That is to say that the returned #GDBusMessage object may
     * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
     * g_dbus_message_to_gerror() to transcode this to a #GError.
     * 
     * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
     * for an example of how to use this low-level API to send and receive
     * UNIX file descriptors.
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to     g_dbus_connection_send_message_with_reply()
     * @returns a locked #GDBusMessage or %NULL if @error is set
     */
    send_message_with_reply_finish(res: AsyncResult): DBusMessage
    /**
     * Synchronously sends `message` to the peer represented by `connection`
     * and blocks the calling thread until a reply is received or the
     * timeout is reached. See g_dbus_connection_send_message_with_reply()
     * for the asynchronous version of this method.
     * 
     * Unless `flags` contain the
     * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
     * will be assigned by `connection` and set on `message` via
     * g_dbus_message_set_serial(). If `out_serial` is not %NULL, then the
     * serial number used will be written to this location prior to
     * submitting the message to the underlying transport. While it has a `volatile`
     * qualifier, this is a historical artifact and the argument passed to it should
     * not be `volatile`.
     * 
     * If `connection` is closed then the operation will fail with
     * %G_IO_ERROR_CLOSED. If `cancellable` is canceled, the operation will
     * fail with %G_IO_ERROR_CANCELLED. If `message` is not well-formed,
     * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
     * 
     * Note that `error` is only set if a local in-process error
     * occurred. That is to say that the returned #GDBusMessage object may
     * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
     * g_dbus_message_to_gerror() to transcode this to a #GError.
     * 
     * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
     * for an example of how to use this low-level API to send and receive
     * UNIX file descriptors.
     * 
     * Note that `message` must be unlocked, unless `flags` contain the
     * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
     * @param message a #GDBusMessage
     * @param flags flags affecting how the message is sent.
     * @param timeout_msec the timeout in milliseconds, -1 to use the default     timeout or %G_MAXINT for no timeout
     * @param cancellable a #GCancellable or %NULL
     * @returns a locked #GDBusMessage that is the reply     to @message or %NULL if @error is set
     */
    send_message_with_reply_sync(message: DBusMessage, flags: DBusSendMessageFlags, timeout_msec: number, cancellable: Cancellable | null): [ /* returnType */ DBusMessage, /* out_serial */ number ]
    /**
     * Sets whether the process should be terminated when `connection` is
     * closed by the remote peer. See #GDBusConnection:exit-on-close for
     * more details.
     * 
     * Note that this function should be used with care. Most modern UNIX
     * desktops tie the notion of a user session with the session bus, and expect
     * all of a user's applications to quit when their bus connection goes away.
     * If you are setting `exit_on_close` to %FALSE for the shared session
     * bus connection, you should make sure that your application exits
     * when the user session ends.
     * @param exit_on_close whether the process should be terminated     when `connection` is closed by the remote peer
     */
    set_exit_on_close(exit_on_close: boolean): void
    /**
     * Subscribes to signals on `connection` and invokes `callback` whenever
     * the signal is received. Note that `callback` will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from.
     * 
     * If `connection` is not a message bus connection, `sender` must be
     * %NULL.
     * 
     * If `sender` is a well-known name note that `callback` is invoked with
     * the unique name for the owner of `sender,` not the well-known name
     * as one would expect. This is because the message bus rewrites the
     * name. As such, to avoid certain race conditions, users should be
     * tracking the name owner of the well-known name and use that when
     * processing the received signal.
     * 
     * If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
     * %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, `arg0` is
     * interpreted as part of a namespace or path.  The first argument
     * of a signal is matched against that part as specified by D-Bus.
     * 
     * If `user_data_free_func` is non-%NULL, it will be called (in the
     * thread-default main context of the thread you are calling this
     * method from) at some point after `user_data` is no longer
     * needed. (It is not guaranteed to be called synchronously when the
     * signal is unsubscribed from, and may be called after `connection`
     * has been destroyed.)
     * 
     * As `callback` is potentially invoked in a different thread from where it’s
     * emitted, it’s possible for this to happen after
     * g_dbus_connection_signal_unsubscribe() has been called in another thread.
     * Due to this, `user_data` should have a strong reference which is freed with
     * `user_data_free_func,` rather than pointing to data whose lifecycle is tied
     * to the signal subscription. For example, if a #GObject is used to store the
     * subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
     * to that #GObject must be passed to `user_data,` and g_object_unref() passed to
     * `user_data_free_func`. You are responsible for breaking the resulting
     * reference count cycle by explicitly unsubscribing from the signal when
     * dropping the last external reference to the #GObject. Alternatively, a weak
     * reference may be used.
     * 
     * It is guaranteed that if you unsubscribe from a signal using
     * g_dbus_connection_signal_unsubscribe() from the same thread which made the
     * corresponding g_dbus_connection_signal_subscribe() call, `callback` will not
     * be invoked after g_dbus_connection_signal_unsubscribe() returns.
     * 
     * The returned subscription identifier is an opaque value which is guaranteed
     * to never be zero.
     * 
     * This function can never fail.
     * @param sender sender name to match on (unique or well-known name)     or %NULL to listen from all senders
     * @param interface_name D-Bus interface name to match on or %NULL to     match on all interfaces
     * @param member D-Bus signal name to match on or %NULL to match on     all signals
     * @param object_path object path to match on or %NULL to match on     all object paths
     * @param arg0 contents of first string argument to match on or %NULL     to match on all kinds of arguments
     * @param flags #GDBusSignalFlags describing how arg0 is used in subscribing to the     signal
     * @param callback callback to invoke when there is a signal matching the requested data
     * @returns a subscription identifier that can be used with g_dbus_connection_signal_unsubscribe()
     */
    signal_subscribe(sender: string | null, interface_name: string | null, member: string | null, object_path: string | null, arg0: string | null, flags: DBusSignalFlags, callback: DBusSignalCallback): number
    /**
     * Unsubscribes from signals.
     * 
     * Note that there may still be D-Bus traffic to process (relating to this
     * signal subscription) in the current thread-default #GMainContext after this
     * function has returned. You should continue to iterate the #GMainContext
     * until the #GDestroyNotify function passed to
     * g_dbus_connection_signal_subscribe() is called, in order to avoid memory
     * leaks through callbacks queued on the #GMainContext after it’s stopped being
     * iterated.
     * Alternatively, any idle source with a priority lower than %G_PRIORITY_DEFAULT
     * that was scheduled after unsubscription, also indicates that all resources
     * of this subscription are released.
     * @param subscription_id a subscription id obtained from     g_dbus_connection_signal_subscribe()
     */
    signal_unsubscribe(subscription_id: number): void
    /**
     * If `connection` was created with
     * %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
     * starts processing messages. Does nothing on if `connection` wasn't
     * created with this flag or if the method has already been called.
     */
    start_message_processing(): void
    /**
     * Reverses the effect of a previous call to
     * g_dbus_connection_export_action_group().
     * 
     * It is an error to call this function with an ID that wasn't returned
     * from g_dbus_connection_export_action_group() or to call it with the
     * same ID more than once.
     * @param export_id the ID from g_dbus_connection_export_action_group()
     */
    unexport_action_group(export_id: number): void
    /**
     * Reverses the effect of a previous call to
     * g_dbus_connection_export_menu_model().
     * 
     * It is an error to call this function with an ID that wasn't returned
     * from g_dbus_connection_export_menu_model() or to call it with the
     * same ID more than once.
     * @param export_id the ID from g_dbus_connection_export_menu_model()
     */
    unexport_menu_model(export_id: number): void
    /**
     * Unregisters an object.
     * @param registration_id a registration id obtained from     g_dbus_connection_register_object()
     * @returns %TRUE if the object was unregistered, %FALSE otherwise
     */
    unregister_object(registration_id: number): boolean
    /**
     * Unregisters a subtree.
     * @param registration_id a subtree registration id obtained from     g_dbus_connection_register_subtree()
     * @returns %TRUE if the subtree was unregistered, %FALSE otherwise
     */
    unregister_subtree(registration_id: number): boolean
    watch_name(name: string, flags: BusNameWatcherFlags, name_appeared_closure: GObject.TClosure | null, name_vanished_closure: GObject.TClosure | null): number
    unwatch_name(id: number): void
    own_name(name: string, flags: BusNameOwnerFlags, name_acquired_closure: GObject.TClosure | null, name_lost_closure: GObject.TClosure | null): number
    unown_name(id: number): void

    // Own signals of Gio-2.0.Gio.DBusConnection

    connect(sigName: "closed", callback: DBusConnection.ClosedSignalCallback): number
    connect_after(sigName: "closed", callback: DBusConnection.ClosedSignalCallback): number
    emit(sigName: "closed", remote_peer_vanished: boolean, error: GLib.Error | null, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusConnection

    connect(sigName: "notify::address", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::address", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::address", ...args: any[]): void
    connect(sigName: "notify::authentication-observer", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::authentication-observer", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::authentication-observer", ...args: any[]): void
    connect(sigName: "notify::capabilities", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::capabilities", ...args: any[]): void
    connect(sigName: "notify::closed", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::closed", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: "notify::exit-on-close", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::exit-on-close", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::exit-on-close", ...args: any[]): void
    connect(sigName: "notify::flags", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: "notify::guid", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::guid", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::guid", ...args: any[]): void
    connect(sigName: "notify::stream", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::stream", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::stream", ...args: any[]): void
    connect(sigName: "notify::unique-name", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::unique-name", callback: (($obj: DBusConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::unique-name", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GDBusConnection type is used for D-Bus connections to remote
 * peers such as a message buses. It is a low-level API that offers a
 * lot of flexibility. For instance, it lets you establish a connection
 * over any transport that can by represented as a #GIOStream.
 * 
 * This class is rarely used directly in D-Bus clients. If you are writing
 * a D-Bus client, it is often easier to use the g_bus_own_name(),
 * g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
 * 
 * As an exception to the usual GLib rule that a particular object must not
 * be used by two threads at the same time, #GDBusConnection's methods may be
 * called from any thread. This is so that g_bus_get() and g_bus_get_sync()
 * can safely return the same #GDBusConnection when called from any thread.
 * 
 * Most of the ways to obtain a #GDBusConnection automatically initialize it
 * (i.e. connect to D-Bus): for instance, g_dbus_connection_new() and
 * g_bus_get(), and the synchronous versions of those methods, give you an
 * initialized connection. Language bindings for GIO should use
 * g_initable_new() or g_async_initable_new_async(), which also initialize the
 * connection.
 * 
 * If you construct an uninitialized #GDBusConnection, such as via
 * g_object_new(), you must initialize it via g_initable_init() or
 * g_async_initable_init_async() before using its methods or properties.
 * Calling methods or accessing properties on a #GDBusConnection that has not
 * completed initialization successfully is considered to be invalid, and leads
 * to undefined behaviour. In particular, if initialization fails with a
 * #GError, the only valid thing you can do with that #GDBusConnection is to
 * free it with g_object_unref().
 * 
 * ## An example D-Bus server # {#gdbus-server}
 * 
 * Here is an example for a D-Bus server:
 * [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
 * 
 * ## An example for exporting a subtree # {#gdbus-subtree-server}
 * 
 * Here is an example for exporting a subtree:
 * [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
 * 
 * ## An example for file descriptor passing # {#gdbus-unix-fd-client}
 * 
 * Here is an example for passing UNIX file descriptors:
 * [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
 * 
 * ## An example for exporting a GObject # {#gdbus-export}
 * 
 * Here is an example for exporting a #GObject:
 * [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
 * @class 
 */
class DBusConnection extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusConnection

    static name: string
    static $gtype: GObject.GType<DBusConnection>

    // Constructors of Gio-2.0.Gio.DBusConnection

    constructor(config?: DBusConnection.ConstructorProperties) 
    /**
     * Finishes an operation started with g_dbus_connection_new().
     * @constructor 
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback     passed to g_dbus_connection_new().
     * @returns a #GDBusConnection or %NULL if @error is set. Free     with g_object_unref().
     */
    static new_finish(res: AsyncResult): DBusConnection
    /**
     * Finishes an operation started with g_dbus_connection_new_for_address().
     * @constructor 
     * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed     to g_dbus_connection_new()
     * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
     */
    static new_for_address_finish(res: AsyncResult): DBusConnection
    /**
     * Synchronously connects and sets up a D-Bus client connection for
     * exchanging D-Bus messages with an endpoint specified by `address`
     * which must be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     * 
     * This constructor can only be used to initiate client-side
     * connections - use g_dbus_connection_new_sync() if you need to act
     * as the server. In particular, `flags` cannot contain the
     * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
     * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
     * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
     * 
     * This is a synchronous failable constructor. See
     * g_dbus_connection_new_for_address() for the asynchronous version.
     * 
     * If `observer` is not %NULL it may be used to control the
     * authentication process.
     * @constructor 
     * @param address a D-Bus address
     * @param flags flags describing how to make the connection
     * @param observer a #GDBusAuthObserver or %NULL
     * @param cancellable a #GCancellable or %NULL
     * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
     */
    static new_for_address_sync(address: string | null, flags: DBusConnectionFlags, observer: DBusAuthObserver | null, cancellable: Cancellable | null): DBusConnection
    /**
     * Synchronously sets up a D-Bus connection for exchanging D-Bus messages
     * with the end represented by `stream`.
     * 
     * If `stream` is a #GSocketConnection, then the corresponding #GSocket
     * will be put into non-blocking mode.
     * 
     * The D-Bus connection will interact with `stream` from a worker thread.
     * As a result, the caller should not interact with `stream` after this
     * method has been called, except by calling g_object_unref() on it.
     * 
     * If `observer` is not %NULL it may be used to control the
     * authentication process.
     * 
     * This is a synchronous failable constructor. See
     * g_dbus_connection_new() for the asynchronous version.
     * @constructor 
     * @param stream a #GIOStream
     * @param guid the GUID to use if authenticating as a server or %NULL
     * @param flags flags describing how to make the connection
     * @param observer a #GDBusAuthObserver or %NULL
     * @param cancellable a #GCancellable or %NULL
     * @returns a #GDBusConnection or %NULL if @error is set.     Free with g_object_unref().
     */
    static new_sync(stream: IOStream, guid: string | null, flags: DBusConnectionFlags, observer: DBusAuthObserver | null, cancellable: Cancellable | null): DBusConnection
    _init(config?: DBusConnection.ConstructorProperties): void
    /**
     * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
     * with the end represented by `stream`.
     * 
     * If `stream` is a #GSocketConnection, then the corresponding #GSocket
     * will be put into non-blocking mode.
     * 
     * The D-Bus connection will interact with `stream` from a worker thread.
     * As a result, the caller should not interact with `stream` after this
     * method has been called, except by calling g_object_unref() on it.
     * 
     * If `observer` is not %NULL it may be used to control the
     * authentication process.
     * 
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_dbus_connection_new_finish() to get the result of the
     * operation.
     * 
     * This is an asynchronous failable constructor. See
     * g_dbus_connection_new_sync() for the synchronous
     * version.
     * @param stream a #GIOStream
     * @param guid the GUID to use if authenticating as a server or %NULL
     * @param flags flags describing how to make the connection
     * @param observer a #GDBusAuthObserver or %NULL
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    static new(stream: IOStream, guid: string | null, flags: DBusConnectionFlags, observer: DBusAuthObserver | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<DBusConnection> | null): void
    /**
     * Asynchronously connects and sets up a D-Bus client connection for
     * exchanging D-Bus messages with an endpoint specified by `address`
     * which must be in the
     * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
     * 
     * This constructor can only be used to initiate client-side
     * connections - use g_dbus_connection_new() if you need to act as the
     * server. In particular, `flags` cannot contain the
     * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
     * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
     * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
     * 
     * When the operation is finished, `callback` will be invoked. You can
     * then call g_dbus_connection_new_for_address_finish() to get the result of
     * the operation.
     * 
     * If `observer` is not %NULL it may be used to control the
     * authentication process.
     * 
     * This is an asynchronous failable constructor. See
     * g_dbus_connection_new_for_address_sync() for the synchronous
     * version.
     * @param address a D-Bus address
     * @param flags flags describing how to make the connection
     * @param observer a #GDBusAuthObserver or %NULL
     * @param cancellable a #GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    static new_for_address(address: string | null, flags: DBusConnectionFlags, observer: DBusAuthObserver | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<DBusConnection> | null): void
}

module DBusInterfaceSkeleton {

    // Signal callback interfaces

    /**
     * Signal callback interface for `g-authorize-method`
     */
    interface GAuthorizeMethodSignalCallback {
        ($obj: DBusInterfaceSkeleton, invocation: DBusMethodInvocation): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends DBusInterface.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DBusInterfaceSkeleton

        /**
         * Flags from the #GDBusInterfaceSkeletonFlags enumeration.
         */
        g_flags?: DBusInterfaceSkeletonFlags | null
    }

}

interface DBusInterfaceSkeleton extends DBusInterface {

    // Own properties of Gio-2.0.Gio.DBusInterfaceSkeleton

    /**
     * Flags from the #GDBusInterfaceSkeletonFlags enumeration.
     */
    g_flags: DBusInterfaceSkeletonFlags

    // Owm methods of Gio-2.0.Gio.DBusInterfaceSkeleton

    /**
     * Exports `interface_` at `object_path` on `connection`.
     * 
     * This can be called multiple times to export the same `interface_`
     * onto multiple connections however the `object_path` provided must be
     * the same for all connections.
     * 
     * Use g_dbus_interface_skeleton_unexport() to unexport the object.
     * @param connection A #GDBusConnection to export `interface_` on.
     * @param object_path The path to export the interface at.
     * @returns %TRUE if the interface was exported on @connection, otherwise %FALSE with @error set.
     */
    export(connection: DBusConnection, object_path: string | null): boolean
    /**
     * If `interface_` has outstanding changes, request for these changes to be
     * emitted immediately.
     * 
     * For example, an exported D-Bus interface may queue up property
     * changes and emit the
     * `org.freedesktop.DBus.Properties.PropertiesChanged`
     * signal later (e.g. in an idle handler). This technique is useful
     * for collapsing multiple property changes into one.
     */
    flush(): void
    /**
     * Gets the first connection that `interface_` is exported on, if any.
     * @returns A #GDBusConnection or %NULL if @interface_ is not exported anywhere. Do not free, the object belongs to @interface_.
     */
    get_connection(): DBusConnection | null
    /**
     * Gets a list of the connections that `interface_` is exported on.
     * @returns A list of   all the connections that @interface_ is exported on. The returned   list should be freed with g_list_free() after each element has   been freed with g_object_unref().
     */
    get_connections(): DBusConnection[]
    /**
     * Gets the #GDBusInterfaceSkeletonFlags that describes what the behavior
     * of `interface_`
     * @returns One or more flags from the #GDBusInterfaceSkeletonFlags enumeration.
     */
    get_flags(): DBusInterfaceSkeletonFlags
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    get_info(): DBusInterfaceInfo
    /**
     * Gets the object path that `interface_` is exported on, if any.
     * @returns A string owned by @interface_ or %NULL if @interface_ is not exported anywhere. Do not free, the string belongs to @interface_.
     */
    get_object_path(): string | null
    /**
     * Gets all D-Bus properties for `interface_`.
     * @returns A #GVariant of type ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS]. Free with g_variant_unref().
     */
    get_properties(): GLib.Variant
    /**
     * Checks if `interface_` is exported on `connection`.
     * @param connection A #GDBusConnection.
     * @returns %TRUE if @interface_ is exported on @connection, %FALSE otherwise.
     */
    has_connection(connection: DBusConnection): boolean
    /**
     * Sets flags describing what the behavior of `skeleton` should be.
     * @param flags Flags from the #GDBusInterfaceSkeletonFlags enumeration.
     */
    set_flags(flags: DBusInterfaceSkeletonFlags): void
    /**
     * Stops exporting `interface_` on all connections it is exported on.
     * 
     * To unexport `interface_` from only a single connection, use
     * g_dbus_interface_skeleton_unexport_from_connection()
     */
    unexport(): void
    /**
     * Stops exporting `interface_` on `connection`.
     * 
     * To stop exporting on all connections the interface is exported on,
     * use g_dbus_interface_skeleton_unexport().
     * @param connection A #GDBusConnection.
     */
    unexport_from_connection(connection: DBusConnection): void

    // Own virtual methods of Gio-2.0.Gio.DBusInterfaceSkeleton

    /**
     * If `interface_` has outstanding changes, request for these changes to be
     * emitted immediately.
     * 
     * For example, an exported D-Bus interface may queue up property
     * changes and emit the
     * `org.freedesktop.DBus.Properties.PropertiesChanged`
     * signal later (e.g. in an idle handler). This technique is useful
     * for collapsing multiple property changes into one.
     * @virtual 
     */
    vfunc_flush(): void
    vfunc_g_authorize_method(invocation: DBusMethodInvocation): boolean
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    vfunc_get_info(): DBusInterfaceInfo
    /**
     * Gets all D-Bus properties for `interface_`.
     * @virtual 
     * @returns A #GVariant of type ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS]. Free with g_variant_unref().
     */
    vfunc_get_properties(): GLib.Variant

    // Own signals of Gio-2.0.Gio.DBusInterfaceSkeleton

    connect(sigName: "g-authorize-method", callback: DBusInterfaceSkeleton.GAuthorizeMethodSignalCallback): number
    connect_after(sigName: "g-authorize-method", callback: DBusInterfaceSkeleton.GAuthorizeMethodSignalCallback): number
    emit(sigName: "g-authorize-method", invocation: DBusMethodInvocation, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusInterfaceSkeleton

    connect(sigName: "notify::g-flags", callback: (($obj: DBusInterfaceSkeleton, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-flags", callback: (($obj: DBusInterfaceSkeleton, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract base class for D-Bus interfaces on the service side.
 * @class 
 */
class DBusInterfaceSkeleton extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusInterfaceSkeleton

    static name: string
    static $gtype: GObject.GType<DBusInterfaceSkeleton>

    // Constructors of Gio-2.0.Gio.DBusInterfaceSkeleton

    constructor(config?: DBusInterfaceSkeleton.ConstructorProperties) 
    _init(config?: DBusInterfaceSkeleton.ConstructorProperties): void
}

module DBusMenuModel {

    // Constructor properties interface

    interface ConstructorProperties extends MenuModel.ConstructorProperties {
    }

}

interface DBusMenuModel {

    // Class property signals of Gio-2.0.Gio.DBusMenuModel

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDBusMenuModel is an implementation of #GMenuModel that can be used
 * as a proxy for a menu model that is exported over D-Bus with
 * g_dbus_connection_export_menu_model().
 * @class 
 */
class DBusMenuModel extends MenuModel {

    // Own properties of Gio-2.0.Gio.DBusMenuModel

    static name: string
    static $gtype: GObject.GType<DBusMenuModel>

    // Constructors of Gio-2.0.Gio.DBusMenuModel

    constructor(config?: DBusMenuModel.ConstructorProperties) 
    _init(config?: DBusMenuModel.ConstructorProperties): void
    /**
     * Obtains a #GDBusMenuModel for the menu model which is exported
     * at the given `bus_name` and `object_path`.
     * 
     * The thread default main context is taken at the time of this call.
     * All signals on the menu model (and any linked models) are reported
     * with respect to this context.  All calls on the returned menu model
     * (and linked models) must also originate from this same context, with
     * the thread default main context unchanged.
     * @param connection a #GDBusConnection
     * @param bus_name the bus name which exports the menu model     or %NULL if `connection` is not a message bus connection
     * @param object_path the object path at which the menu model is exported
     * @returns a #GDBusMenuModel object. Free with     g_object_unref().
     */
    static get(connection: DBusConnection, bus_name: string | null, object_path: string | null): DBusMenuModel
}

module DBusMessage {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface DBusMessage {

    // Own properties of Gio-2.0.Gio.DBusMessage

    readonly locked: boolean

    // Owm methods of Gio-2.0.Gio.DBusMessage

    /**
     * Copies `message`. The copy is a deep copy and the returned
     * #GDBusMessage is completely identical except that it is guaranteed
     * to not be locked.
     * 
     * This operation can fail if e.g. `message` contains file descriptors
     * and the per-process or system-wide open files limit is reached.
     * @returns A new #GDBusMessage or %NULL if @error is set.     Free with g_object_unref().
     */
    copy(): DBusMessage
    /**
     * Convenience to get the first item in the body of `message`.
     * @returns The string item or %NULL if the first item in the body of @message is not a string.
     */
    get_arg0(): string | null
    /**
     * Gets the body of a message.
     * @returns A #GVariant or %NULL if the body is empty. Do not free, it is owned by @message.
     */
    get_body(): GLib.Variant | null
    /**
     * Gets the byte order of `message`.
     * @returns The byte order.
     */
    get_byte_order(): DBusMessageByteOrder
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
     * @returns The value.
     */
    get_destination(): string | null
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
     * @returns The value.
     */
    get_error_name(): string | null
    /**
     * Gets the flags for `message`.
     * @returns Flags that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).
     */
    get_flags(): DBusMessageFlags
    /**
     * Gets a header field on `message`.
     * 
     * The caller is responsible for checking the type of the returned #GVariant
     * matches what is expected.
     * @param header_field A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)
     * @returns A #GVariant with the value if the header was found, %NULL otherwise. Do not free, it is owned by @message.
     */
    get_header(header_field: DBusMessageHeaderField): GLib.Variant | null
    /**
     * Gets an array of all header fields on `message` that are set.
     * @returns An array of header fields terminated by %G_DBUS_MESSAGE_HEADER_FIELD_INVALID.  Each element is a #guchar. Free with g_free().
     */
    get_header_fields(): Uint8Array
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
     * @returns The value.
     */
    get_interface(): string | null
    /**
     * Checks whether `message` is locked. To monitor changes to this
     * value, conncet to the #GObject::notify signal to listen for changes
     * on the #GDBusMessage:locked property.
     * @returns %TRUE if @message is locked, %FALSE otherwise.
     */
    get_locked(): boolean
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
     * @returns The value.
     */
    get_member(): string | null
    /**
     * Gets the type of `message`.
     * @returns A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).
     */
    get_message_type(): DBusMessageType
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
     * @returns The value.
     */
    get_num_unix_fds(): number
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
     * @returns The value.
     */
    get_path(): string | null
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
     * @returns The value.
     */
    get_reply_serial(): number
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
     * @returns The value.
     */
    get_sender(): string | null
    /**
     * Gets the serial for `message`.
     * @returns A #guint32.
     */
    get_serial(): number
    /**
     * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
     * 
     * This will always be non-%NULL, but may be an empty string.
     * @returns The value.
     */
    get_signature(): string | null
    /**
     * Gets the UNIX file descriptors associated with `message,` if any.
     * 
     * This method is only available on UNIX.
     * 
     * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
     * values in the body of the message. For example,
     * if g_variant_get_handle() returns 5, that is intended to be a reference
     * to the file descriptor that can be accessed by
     * `g_unix_fd_list_get (list, 5, ...)`.
     * @returns A #GUnixFDList or %NULL if no file descriptors are associated. Do not free, this object is owned by @message.
     */
    get_unix_fd_list(): UnixFDList | null
    /**
     * If `message` is locked, does nothing. Otherwise locks the message.
     */
    lock(): void
    /**
     * Creates a new #GDBusMessage that is an error reply to `method_call_message`.
     * @param error_name A valid D-Bus error name.
     * @param error_message The D-Bus error message.
     * @returns A #GDBusMessage. Free with g_object_unref().
     */
    new_method_error_literal(error_name: string | null, error_message: string | null): DBusMessage
    /**
     * Creates a new #GDBusMessage that is a reply to `method_call_message`.
     * @returns #GDBusMessage. Free with g_object_unref().
     */
    new_method_reply(): DBusMessage
    /**
     * Produces a human-readable multi-line description of `message`.
     * 
     * The contents of the description has no ABI guarantees, the contents
     * and formatting is subject to change at any time. Typical output
     * looks something like this:
     * 
     * ```
     * Flags:   none
     * Version: 0
     * Serial:  4
     * Headers:
     *   path -> objectpath '/org/gtk/GDBus/TestObject'
     *   interface -> 'org.gtk.GDBus.TestInterface'
     *   member -> 'GimmeStdout'
     *   destination -> ':1.146'
     * Body: ()
     * UNIX File Descriptors:
     *   (none)
     * ```
     * 
     * or
     * 
     * ```
     * Flags:   no-reply-expected
     * Version: 0
     * Serial:  477
     * Headers:
     *   reply-serial -> uint32 4
     *   destination -> ':1.159'
     *   sender -> ':1.146'
     *   num-unix-fds -> uint32 1
     * Body: ()
     * UNIX File Descriptors:
     *   fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
     * ```
     * 
     * @param indent Indentation level.
     * @returns A string that should be freed with g_free().
     */
    print(indent: number): string | null
    /**
     * Sets the body `message`. As a side-effect the
     * %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
     * type string of `body` (or cleared if `body` is %NULL).
     * 
     * If `body` is floating, `message` assumes ownership of `body`.
     * @param body Either %NULL or a #GVariant that is a tuple.
     */
    set_body(body: GLib.Variant): void
    /**
     * Sets the byte order of `message`.
     * @param byte_order The byte order.
     */
    set_byte_order(byte_order: DBusMessageByteOrder): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
     * @param value The value to set.
     */
    set_destination(value: string | null): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
     * @param value The value to set.
     */
    set_error_name(value: string | null): void
    /**
     * Sets the flags to set on `message`.
     * @param flags Flags for `message` that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).
     */
    set_flags(flags: DBusMessageFlags): void
    /**
     * Sets a header field on `message`.
     * 
     * If `value` is floating, `message` assumes ownership of `value`.
     * @param header_field A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)
     * @param value A #GVariant to set the header field or %NULL to clear the header field.
     */
    set_header(header_field: DBusMessageHeaderField, value: GLib.Variant | null): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
     * @param value The value to set.
     */
    set_interface(value: string | null): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
     * @param value The value to set.
     */
    set_member(value: string | null): void
    /**
     * Sets `message` to be of `type`.
     * @param type A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).
     */
    set_message_type(type: DBusMessageType): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
     * @param value The value to set.
     */
    set_num_unix_fds(value: number): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
     * @param value The value to set.
     */
    set_path(value: string | null): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
     * @param value The value to set.
     */
    set_reply_serial(value: number): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
     * @param value The value to set.
     */
    set_sender(value: string | null): void
    /**
     * Sets the serial for `message`.
     * @param serial A #guint32.
     */
    set_serial(serial: number): void
    /**
     * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
     * @param value The value to set.
     */
    set_signature(value: string | null): void
    /**
     * Sets the UNIX file descriptors associated with `message`. As a
     * side-effect the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
     * field is set to the number of fds in `fd_list` (or cleared if
     * `fd_list` is %NULL).
     * 
     * This method is only available on UNIX.
     * 
     * When designing D-Bus APIs that are intended to be interoperable,
     * please note that non-GDBus implementations of D-Bus can usually only
     * access file descriptors if they are referenced by a value of type
     * %G_VARIANT_TYPE_HANDLE in the body of the message.
     * @param fd_list A #GUnixFDList or %NULL.
     */
    set_unix_fd_list(fd_list: UnixFDList | null): void
    /**
     * Serializes `message` to a blob. The byte order returned by
     * g_dbus_message_get_byte_order() will be used.
     * @param capabilities A #GDBusCapabilityFlags describing what protocol features are supported.
     * @returns A pointer to a valid binary D-Bus message of @out_size bytes generated by @message or %NULL if @error is set. Free with g_free().
     */
    to_blob(capabilities: DBusCapabilityFlags): Uint8Array
    /**
     * If `message` is not of type %G_DBUS_MESSAGE_TYPE_ERROR does
     * nothing and returns %FALSE.
     * 
     * Otherwise this method encodes the error in `message` as a #GError
     * using g_dbus_error_set_dbus_error() using the information in the
     * %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of `message` as
     * well as the first string item in `message'`s body.
     * @returns %TRUE if @error was set, %FALSE otherwise.
     */
    to_gerror(): boolean

    // Class property signals of Gio-2.0.Gio.DBusMessage

    connect(sigName: "notify::locked", callback: (($obj: DBusMessage, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::locked", callback: (($obj: DBusMessage, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::locked", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A type for representing D-Bus messages that can be sent or received
 * on a #GDBusConnection.
 * @class 
 */
class DBusMessage extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusMessage

    static name: string
    static $gtype: GObject.GType<DBusMessage>

    // Constructors of Gio-2.0.Gio.DBusMessage

    constructor(config?: DBusMessage.ConstructorProperties) 
    /**
     * Creates a new empty #GDBusMessage.
     * @constructor 
     * @returns A #GDBusMessage. Free with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #GDBusMessage.
     * @constructor 
     * @returns A #GDBusMessage. Free with g_object_unref().
     */
    static new(): DBusMessage
    /**
     * Creates a new #GDBusMessage from the data stored at `blob`. The byte
     * order that the message was in can be retrieved using
     * g_dbus_message_get_byte_order().
     * 
     * If the `blob` cannot be parsed, contains invalid fields, or contains invalid
     * headers, %G_IO_ERROR_INVALID_ARGUMENT will be returned.
     * @constructor 
     * @param blob A blob representing a binary D-Bus message.
     * @param capabilities A #GDBusCapabilityFlags describing what protocol features are supported.
     * @returns A new #GDBusMessage or %NULL if @error is set. Free with g_object_unref().
     */
    static new_from_blob(blob: Uint8Array, capabilities: DBusCapabilityFlags): DBusMessage
    /**
     * Creates a new #GDBusMessage for a method call.
     * @constructor 
     * @param name A valid D-Bus name or %NULL.
     * @param path A valid object path.
     * @param interface_ A valid D-Bus interface name or %NULL.
     * @param method A valid method name.
     * @returns A #GDBusMessage. Free with g_object_unref().
     */
    static new_method_call(name: string | null, path: string | null, interface_: string | null, method: string | null): DBusMessage
    /**
     * Creates a new #GDBusMessage for a signal emission.
     * @constructor 
     * @param path A valid object path.
     * @param interface_ A valid D-Bus interface name.
     * @param signal A valid signal name.
     * @returns A #GDBusMessage. Free with g_object_unref().
     */
    static new_signal(path: string | null, interface_: string | null, signal: string | null): DBusMessage
    _init(config?: DBusMessage.ConstructorProperties): void
    /**
     * Utility function to calculate how many bytes are needed to
     * completely deserialize the D-Bus message stored at `blob`.
     * @param blob A blob representing a binary D-Bus message.
     * @returns Number of bytes needed or -1 if @error is set (e.g. if @blob contains invalid data or not enough data is available to determine the size).
     */
    static bytes_needed(blob: Uint8Array): number
}

module DBusMethodInvocation {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface DBusMethodInvocation {

    // Owm methods of Gio-2.0.Gio.DBusMethodInvocation

    /**
     * Gets the #GDBusConnection the method was invoked on.
     * @returns A #GDBusConnection. Do not free, it is owned by @invocation.
     */
    get_connection(): DBusConnection
    /**
     * Gets the name of the D-Bus interface the method was invoked on.
     * 
     * If this method call is a property Get, Set or GetAll call that has
     * been redirected to the method call handler then
     * "org.freedesktop.DBus.Properties" will be returned.  See
     * #GDBusInterfaceVTable for more information.
     * @returns A string. Do not free, it is owned by @invocation.
     */
    get_interface_name(): string | null
    /**
     * Gets the #GDBusMessage for the method invocation. This is useful if
     * you need to use low-level protocol features, such as UNIX file
     * descriptor passing, that cannot be properly expressed in the
     * #GVariant API.
     * 
     * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
     * for an example of how to use this low-level API to send and receive
     * UNIX file descriptors.
     * @returns #GDBusMessage. Do not free, it is owned by @invocation.
     */
    get_message(): DBusMessage
    /**
     * Gets information about the method call, if any.
     * 
     * If this method invocation is a property Get, Set or GetAll call that
     * has been redirected to the method call handler then %NULL will be
     * returned.  See g_dbus_method_invocation_get_property_info() and
     * #GDBusInterfaceVTable for more information.
     * @returns A #GDBusMethodInfo or %NULL. Do not free, it is owned by @invocation.
     */
    get_method_info(): DBusMethodInfo | null
    /**
     * Gets the name of the method that was invoked.
     * @returns A string. Do not free, it is owned by @invocation.
     */
    get_method_name(): string | null
    /**
     * Gets the object path the method was invoked on.
     * @returns A string. Do not free, it is owned by @invocation.
     */
    get_object_path(): string | null
    /**
     * Gets the parameters of the method invocation. If there are no input
     * parameters then this will return a GVariant with 0 children rather than NULL.
     * @returns A #GVariant tuple. Do not unref this because it is owned by @invocation.
     */
    get_parameters(): GLib.Variant
    /**
     * Gets information about the property that this method call is for, if
     * any.
     * 
     * This will only be set in the case of an invocation in response to a
     * property Get or Set call that has been directed to the method call
     * handler for an object on account of its property_get() or
     * property_set() vtable pointers being unset.
     * 
     * See #GDBusInterfaceVTable for more information.
     * 
     * If the call was GetAll, %NULL will be returned.
     * @returns a #GDBusPropertyInfo or %NULL
     */
    get_property_info(): DBusPropertyInfo | null
    /**
     * Gets the bus name that invoked the method.
     * @returns A string. Do not free, it is owned by @invocation.
     */
    get_sender(): string | null
    /**
     * Finishes handling a D-Bus method call by returning an error.
     * 
     * This method will take ownership of `invocation`. See
     * #GDBusInterfaceVTable for more information about the ownership of
     * `invocation`.
     * @param error_name A valid D-Bus error name.
     * @param error_message A valid D-Bus error message.
     */
    return_dbus_error(error_name: string | null, error_message: string | null): void
    /**
     * Like g_dbus_method_invocation_return_error() but without printf()-style formatting.
     * 
     * This method will take ownership of `invocation`. See
     * #GDBusInterfaceVTable for more information about the ownership of
     * `invocation`.
     * @param domain A #GQuark for the #GError error domain.
     * @param code The error code.
     * @param message The error message.
     */
    return_error_literal(domain: GLib.Quark, code: number, message: string | null): void
    /**
     * Like g_dbus_method_invocation_return_error() but takes a #GError
     * instead of the error domain, error code and message.
     * 
     * This method will take ownership of `invocation`. See
     * #GDBusInterfaceVTable for more information about the ownership of
     * `invocation`.
     * @param error A #GError.
     */
    return_gerror(error: GLib.Error): void
    /**
     * Finishes handling a D-Bus method call by returning `parameters`.
     * If the `parameters` GVariant is floating, it is consumed.
     * 
     * It is an error if `parameters` is not of the right format: it must be a tuple
     * containing the out-parameters of the D-Bus method. Even if the method has a
     * single out-parameter, it must be contained in a tuple. If the method has no
     * out-parameters, `parameters` may be %NULL or an empty tuple.
     * 
     * 
     * ```c
     * GDBusMethodInvocation *invocation = some_invocation;
     * g_autofree gchar *result_string = NULL;
     * g_autoptr (GError) error = NULL;
     * 
     * result_string = calculate_result (&error);
     * 
     * if (error != NULL)
     *   g_dbus_method_invocation_return_gerror (invocation, error);
     * else
     *   g_dbus_method_invocation_return_value (invocation,
     *                                          g_variant_new ("(s)", result_string));
     * 
     * // Do not free `invocation` here; returning a value does that
     * ```
     * 
     * 
     * This method will take ownership of `invocation`. See
     * #GDBusInterfaceVTable for more information about the ownership of
     * `invocation`.
     * 
     * Since 2.48, if the method call requested for a reply not to be sent
     * then this call will sink `parameters` and free `invocation,` but
     * otherwise do nothing (as per the recommendations of the D-Bus
     * specification).
     * @param parameters A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.
     */
    return_value(parameters: GLib.Variant | null): void
    /**
     * Like g_dbus_method_invocation_return_value() but also takes a #GUnixFDList.
     * 
     * This method is only available on UNIX.
     * 
     * This method will take ownership of `invocation`. See
     * #GDBusInterfaceVTable for more information about the ownership of
     * `invocation`.
     * @param parameters A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.
     * @param fd_list A #GUnixFDList or %NULL.
     */
    return_value_with_unix_fd_list(parameters: GLib.Variant | null, fd_list: UnixFDList | null): void

    // Class property signals of Gio-2.0.Gio.DBusMethodInvocation

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Instances of the #GDBusMethodInvocation class are used when
 * handling D-Bus method calls. It provides a way to asynchronously
 * return results and errors.
 * 
 * The normal way to obtain a #GDBusMethodInvocation object is to receive
 * it as an argument to the handle_method_call() function in a
 * #GDBusInterfaceVTable that was passed to g_dbus_connection_register_object().
 * @class 
 */
class DBusMethodInvocation extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusMethodInvocation

    static name: string
    static $gtype: GObject.GType<DBusMethodInvocation>

    // Constructors of Gio-2.0.Gio.DBusMethodInvocation

    constructor(config?: DBusMethodInvocation.ConstructorProperties) 
    _init(config?: DBusMethodInvocation.ConstructorProperties): void
}

module DBusObjectManagerClient {

    // Signal callback interfaces

    /**
     * Signal callback interface for `interface-proxy-properties-changed`
     */
    interface InterfaceProxyPropertiesChangedSignalCallback {
        ($obj: DBusObjectManagerClient, object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, changed_properties: GLib.Variant, invalidated_properties: string[]): void
    }

    /**
     * Signal callback interface for `interface-proxy-signal`
     */
    interface InterfaceProxySignalSignalCallback {
        ($obj: DBusObjectManagerClient, object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, sender_name: string | null, signal_name: string | null, parameters: GLib.Variant): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends AsyncInitable.ConstructorProperties, DBusObjectManager.ConstructorProperties, Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DBusObjectManagerClient

        /**
         * If this property is not %G_BUS_TYPE_NONE, then
         * #GDBusObjectManagerClient:connection must be %NULL and will be set to the
         * #GDBusConnection obtained by calling g_bus_get() with the value
         * of this property.
         */
        bus_type?: BusType | null
        /**
         * The #GDBusConnection to use.
         */
        connection?: DBusConnection | null
        /**
         * Flags from the #GDBusObjectManagerClientFlags enumeration.
         */
        flags?: DBusObjectManagerClientFlags | null
        /**
         * A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
         */
        get_proxy_type_destroy_notify?: any | null
        /**
         * The #GDBusProxyTypeFunc to use when determining what #GType to
         * use for interface proxies or %NULL.
         */
        get_proxy_type_func?: any | null
        /**
         * The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
         */
        get_proxy_type_user_data?: any | null
        /**
         * The well-known name or unique name that the manager is for.
         */
        name?: string | null
        /**
         * The object path the manager is for.
         */
        object_path?: string | null
    }

}

interface DBusObjectManagerClient extends AsyncInitable, DBusObjectManager, Initable {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerClient

    /**
     * If this property is not %G_BUS_TYPE_NONE, then
     * #GDBusObjectManagerClient:connection must be %NULL and will be set to the
     * #GDBusConnection obtained by calling g_bus_get() with the value
     * of this property.
     */
    readonly bus_type: BusType
    /**
     * The #GDBusConnection to use.
     */
    readonly connection: DBusConnection
    /**
     * Flags from the #GDBusObjectManagerClientFlags enumeration.
     */
    readonly flags: DBusObjectManagerClientFlags
    /**
     * A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
     */
    readonly get_proxy_type_destroy_notify: any
    /**
     * The #GDBusProxyTypeFunc to use when determining what #GType to
     * use for interface proxies or %NULL.
     */
    readonly get_proxy_type_func: any
    /**
     * The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
     */
    readonly get_proxy_type_user_data: any
    /**
     * The well-known name or unique name that the manager is for.
     */
    readonly name: string | null
    /**
     * The unique name that owns #GDBusObjectManagerClient:name or %NULL if
     * no-one is currently owning the name. Connect to the
     * #GObject::notify signal to track changes to this property.
     */
    readonly name_owner: string | null
    /**
     * The object path the manager is for.
     */
    readonly object_path: string | null

    // Owm methods of Gio-2.0.Gio.DBusObjectManagerClient

    /**
     * Gets the #GDBusConnection used by `manager`.
     * @returns A #GDBusConnection object. Do not free,   the object belongs to @manager.
     */
    get_connection(): DBusConnection
    /**
     * Gets the flags that `manager` was constructed with.
     * @returns Zero of more flags from the #GDBusObjectManagerClientFlags enumeration.
     */
    get_flags(): DBusObjectManagerClientFlags
    /**
     * Gets the name that `manager` is for, or %NULL if not a message bus
     * connection.
     * @returns A unique or well-known name. Do not free, the string belongs to @manager.
     */
    get_name(): string | null
    /**
     * The unique name that owns the name that `manager` is for or %NULL if
     * no-one currently owns that name. You can connect to the
     * #GObject::notify signal to track changes to the
     * #GDBusObjectManagerClient:name-owner property.
     * @returns The name owner or %NULL if no name owner exists. Free with g_free().
     */
    get_name_owner(): string | null

    // Own virtual methods of Gio-2.0.Gio.DBusObjectManagerClient

    vfunc_interface_proxy_properties_changed(object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, changed_properties: GLib.Variant, invalidated_properties: string | null): void
    vfunc_interface_proxy_signal(object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, sender_name: string | null, signal_name: string | null, parameters: GLib.Variant): void

    // Own signals of Gio-2.0.Gio.DBusObjectManagerClient

    connect(sigName: "interface-proxy-properties-changed", callback: DBusObjectManagerClient.InterfaceProxyPropertiesChangedSignalCallback): number
    connect_after(sigName: "interface-proxy-properties-changed", callback: DBusObjectManagerClient.InterfaceProxyPropertiesChangedSignalCallback): number
    emit(sigName: "interface-proxy-properties-changed", object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, changed_properties: GLib.Variant, invalidated_properties: string[], ...args: any[]): void
    connect(sigName: "interface-proxy-signal", callback: DBusObjectManagerClient.InterfaceProxySignalSignalCallback): number
    connect_after(sigName: "interface-proxy-signal", callback: DBusObjectManagerClient.InterfaceProxySignalSignalCallback): number
    emit(sigName: "interface-proxy-signal", object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, sender_name: string | null, signal_name: string | null, parameters: GLib.Variant, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusObjectManagerClient

    connect(sigName: "notify::bus-type", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bus-type", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::bus-type", ...args: any[]): void
    connect(sigName: "notify::connection", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::connection", ...args: any[]): void
    connect(sigName: "notify::flags", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-destroy-notify", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::get-proxy-type-destroy-notify", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::get-proxy-type-destroy-notify", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-func", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::get-proxy-type-func", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::get-proxy-type-func", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-user-data", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::get-proxy-type-user-data", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::get-proxy-type-user-data", ...args: any[]): void
    connect(sigName: "notify::name", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::name", ...args: any[]): void
    connect(sigName: "notify::name-owner", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name-owner", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::name-owner", ...args: any[]): void
    connect(sigName: "notify::object-path", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::object-path", callback: (($obj: DBusObjectManagerClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDBusObjectManagerClient is used to create, monitor and delete object
 * proxies for remote objects exported by a #GDBusObjectManagerServer (or any
 * code implementing the
 * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
 * interface).
 * 
 * Once an instance of this type has been created, you can connect to
 * the #GDBusObjectManager::object-added and
 * #GDBusObjectManager::object-removed signals and inspect the
 * #GDBusObjectProxy objects returned by
 * g_dbus_object_manager_get_objects().
 * 
 * If the name for a #GDBusObjectManagerClient is not owned by anyone at
 * object construction time, the default behavior is to request the
 * message bus to launch an owner for the name. This behavior can be
 * disabled using the %G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START
 * flag. It's also worth noting that this only works if the name of
 * interest is activatable in the first place. E.g. in some cases it
 * is not possible to launch an owner for the requested name. In this
 * case, #GDBusObjectManagerClient object construction still succeeds but
 * there will be no object proxies
 * (e.g. g_dbus_object_manager_get_objects() returns the empty list) and
 * the #GDBusObjectManagerClient:name-owner property is %NULL.
 * 
 * The owner of the requested name can come and go (for example
 * consider a system service being restarted) – #GDBusObjectManagerClient
 * handles this case too; simply connect to the #GObject::notify
 * signal to watch for changes on the #GDBusObjectManagerClient:name-owner
 * property. When the name owner vanishes, the behavior is that
 * #GDBusObjectManagerClient:name-owner is set to %NULL (this includes
 * emission of the #GObject::notify signal) and then
 * #GDBusObjectManager::object-removed signals are synthesized
 * for all currently existing object proxies. Since
 * #GDBusObjectManagerClient:name-owner is %NULL when this happens, you can
 * use this information to disambiguate a synthesized signal from a
 * genuine signal caused by object removal on the remote
 * #GDBusObjectManager. Similarly, when a new name owner appears,
 * #GDBusObjectManager::object-added signals are synthesized
 * while #GDBusObjectManagerClient:name-owner is still %NULL. Only when all
 * object proxies have been added, the #GDBusObjectManagerClient:name-owner
 * is set to the new name owner (this includes emission of the
 * #GObject::notify signal).  Furthermore, you are guaranteed that
 * #GDBusObjectManagerClient:name-owner will alternate between a name owner
 * (e.g. `:1.42`) and %NULL even in the case where
 * the name of interest is atomically replaced
 * 
 * Ultimately, #GDBusObjectManagerClient is used to obtain #GDBusProxy
 * instances. All signals (including the
 * org.freedesktop.DBus.Properties::PropertiesChanged signal)
 * delivered to #GDBusProxy instances are guaranteed to originate
 * from the name owner. This guarantee along with the behavior
 * described above, means that certain race conditions including the
 * "half the proxy is from the old owner and the other half is from
 * the new owner" problem cannot happen.
 * 
 * To avoid having the application connect to signals on the returned
 * #GDBusObjectProxy and #GDBusProxy objects, the
 * #GDBusObject::interface-added,
 * #GDBusObject::interface-removed,
 * #GDBusProxy::g-properties-changed and
 * #GDBusProxy::g-signal signals
 * are also emitted on the #GDBusObjectManagerClient instance managing these
 * objects. The signals emitted are
 * #GDBusObjectManager::interface-added,
 * #GDBusObjectManager::interface-removed,
 * #GDBusObjectManagerClient::interface-proxy-properties-changed and
 * #GDBusObjectManagerClient::interface-proxy-signal.
 * 
 * Note that all callbacks and signals are emitted in the
 * [thread-default main context][g-main-context-push-thread-default]
 * that the #GDBusObjectManagerClient object was constructed
 * in. Additionally, the #GDBusObjectProxy and #GDBusProxy objects
 * originating from the #GDBusObjectManagerClient object will be created in
 * the same context and, consequently, will deliver signals in the
 * same main loop.
 * @class 
 */
class DBusObjectManagerClient extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerClient

    static name: string
    static $gtype: GObject.GType<DBusObjectManagerClient>

    // Constructors of Gio-2.0.Gio.DBusObjectManagerClient

    constructor(config?: DBusObjectManagerClient.ConstructorProperties) 
    /**
     * Finishes an operation started with g_dbus_object_manager_client_new().
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new().
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static new_finish(res: AsyncResult): DBusObjectManagerClient
    /**
     * Finishes an operation started with g_dbus_object_manager_client_new_for_bus().
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new_for_bus().
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static new_for_bus_finish(res: AsyncResult): DBusObjectManagerClient
    /**
     * Like g_dbus_object_manager_client_new_sync() but takes a #GBusType instead
     * of a #GDBusConnection.
     * 
     * This is a synchronous failable constructor - the calling thread is
     * blocked until a reply is received. See g_dbus_object_manager_client_new_for_bus()
     * for the asynchronous version.
     * @constructor 
     * @param bus_type A #GBusType.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param object_path The object path of the control object.
     * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static new_for_bus_sync(bus_type: BusType, flags: DBusObjectManagerClientFlags, name: string | null, object_path: string | null, get_proxy_type_func: DBusProxyTypeFunc | null, cancellable: Cancellable | null): DBusObjectManagerClient
    /**
     * Creates a new #GDBusObjectManagerClient object.
     * 
     * This is a synchronous failable constructor - the calling thread is
     * blocked until a reply is received. See g_dbus_object_manager_client_new()
     * for the asynchronous version.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name), or %NULL when not using a message bus connection.
     * @param object_path The object path of the control object.
     * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static new_sync(connection: DBusConnection, flags: DBusObjectManagerClientFlags, name: string | null, object_path: string | null, get_proxy_type_func: DBusProxyTypeFunc | null, cancellable: Cancellable | null): DBusObjectManagerClient
    _init(config?: DBusObjectManagerClient.ConstructorProperties): void
    /**
     * Asynchronously creates a new #GDBusObjectManagerClient object.
     * 
     * This is an asynchronous failable constructor. When the result is
     * ready, `callback` will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_object_manager_client_new_finish() to get the result. See
     * g_dbus_object_manager_client_new_sync() for the synchronous version.
     * @param connection A #GDBusConnection.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param object_path The object path of the control object.
     * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: DBusConnection, flags: DBusObjectManagerClientFlags, name: string | null, object_path: string | null, get_proxy_type_func: DBusProxyTypeFunc | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<DBusObjectManagerClient> | null): void
    /**
     * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
     * #GDBusConnection.
     * 
     * This is an asynchronous failable constructor. When the result is
     * ready, `callback` will be invoked in the
     * [thread-default main loop][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
     * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
     * @param bus_type A #GBusType.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param object_path The object path of the control object.
     * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new_for_bus(bus_type: BusType, flags: DBusObjectManagerClientFlags, name: string | null, object_path: string | null, get_proxy_type_func: DBusProxyTypeFunc | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<DBusObjectManagerClient> | null): void
}

module DBusObjectManagerServer {

    // Constructor properties interface

    interface ConstructorProperties extends DBusObjectManager.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DBusObjectManagerServer

        /**
         * The #GDBusConnection to export objects on.
         */
        connection?: DBusConnection | null
        /**
         * The object path to register the manager object at.
         */
        object_path?: string | null
    }

}

interface DBusObjectManagerServer extends DBusObjectManager {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerServer

    /**
     * The #GDBusConnection to export objects on.
     */
    connection: DBusConnection
    /**
     * The object path to register the manager object at.
     */
    readonly object_path: string | null

    // Owm methods of Gio-2.0.Gio.DBusObjectManagerServer

    /**
     * Exports `object` on `manager`.
     * 
     * If there is already a #GDBusObject exported at the object path,
     * then the old object is removed.
     * 
     * The object path for `object` must be in the hierarchy rooted by the
     * object path for `manager`.
     * 
     * Note that `manager` will take a reference on `object` for as long as
     * it is exported.
     * @param object A #GDBusObjectSkeleton.
     */
    export(object: DBusObjectSkeleton): void
    /**
     * Like g_dbus_object_manager_server_export() but appends a string of
     * the form _N (with N being a natural number) to `object'`s object path
     * if an object with the given path already exists. As such, the
     * #GDBusObjectProxy:g-object-path property of `object` may be modified.
     * @param object An object.
     */
    export_uniquely(object: DBusObjectSkeleton): void
    /**
     * Gets the #GDBusConnection used by `manager`.
     * @returns A #GDBusConnection object or %NULL if   @manager isn't exported on a connection. The returned object should   be freed with g_object_unref().
     */
    get_connection(): DBusConnection | null
    /**
     * Returns whether `object` is currently exported on `manager`.
     * @param object An object.
     * @returns %TRUE if @object is exported
     */
    is_exported(object: DBusObjectSkeleton): boolean
    /**
     * Exports all objects managed by `manager` on `connection`. If
     * `connection` is %NULL, stops exporting objects.
     * @param connection A #GDBusConnection or %NULL.
     */
    set_connection(connection: DBusConnection | null): void
    /**
     * If `manager` has an object at `path,` removes the object. Otherwise
     * does nothing.
     * 
     * Note that `object_path` must be in the hierarchy rooted by the
     * object path for `manager`.
     * @param object_path An object path.
     * @returns %TRUE if object at @object_path was removed, %FALSE otherwise.
     */
    unexport(object_path: string | null): boolean

    // Class property signals of Gio-2.0.Gio.DBusObjectManagerServer

    connect(sigName: "notify::connection", callback: (($obj: DBusObjectManagerServer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: (($obj: DBusObjectManagerServer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::connection", ...args: any[]): void
    connect(sigName: "notify::object-path", callback: (($obj: DBusObjectManagerServer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::object-path", callback: (($obj: DBusObjectManagerServer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDBusObjectManagerServer is used to export #GDBusObject instances using
 * the standardized
 * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
 * interface. For example, remote D-Bus clients can get all objects
 * and properties in a single call. Additionally, any change in the
 * object hierarchy is broadcast using signals. This means that D-Bus
 * clients can keep caches up to date by only listening to D-Bus
 * signals.
 * 
 * The recommended path to export an object manager at is the path form of the
 * well-known name of a D-Bus service, or below. For example, if a D-Bus service
 * is available at the well-known name `net.example.ExampleService1`, the object
 * manager should typically be exported at `/net/example/ExampleService1`, or
 * below (to allow for multiple object managers in a service).
 * 
 * It is supported, but not recommended, to export an object manager at the root
 * path, `/`.
 * 
 * See #GDBusObjectManagerClient for the client-side code that is
 * intended to be used with #GDBusObjectManagerServer or any D-Bus
 * object implementing the org.freedesktop.DBus.ObjectManager
 * interface.
 * @class 
 */
class DBusObjectManagerServer extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerServer

    static name: string
    static $gtype: GObject.GType<DBusObjectManagerServer>

    // Constructors of Gio-2.0.Gio.DBusObjectManagerServer

    constructor(config?: DBusObjectManagerServer.ConstructorProperties) 
    /**
     * Creates a new #GDBusObjectManagerServer object.
     * 
     * The returned server isn't yet exported on any connection. To do so,
     * use g_dbus_object_manager_server_set_connection(). Normally you
     * want to export all of your objects before doing so to avoid
     * [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
     * signals being emitted.
     * @constructor 
     * @param object_path The object path to export the manager object at.
     * @returns A #GDBusObjectManagerServer object. Free with g_object_unref().
     */
    constructor(object_path: string | null) 
    /**
     * Creates a new #GDBusObjectManagerServer object.
     * 
     * The returned server isn't yet exported on any connection. To do so,
     * use g_dbus_object_manager_server_set_connection(). Normally you
     * want to export all of your objects before doing so to avoid
     * [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
     * signals being emitted.
     * @constructor 
     * @param object_path The object path to export the manager object at.
     * @returns A #GDBusObjectManagerServer object. Free with g_object_unref().
     */
    static new(object_path: string | null): DBusObjectManagerServer
    _init(config?: DBusObjectManagerServer.ConstructorProperties): void
}

module DBusObjectProxy {

    // Constructor properties interface

    interface ConstructorProperties extends DBusObject.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DBusObjectProxy

        /**
         * The connection of the proxy.
         */
        g_connection?: DBusConnection | null
        /**
         * The object path of the proxy.
         */
        g_object_path?: string | null
    }

}

interface DBusObjectProxy extends DBusObject {

    // Own properties of Gio-2.0.Gio.DBusObjectProxy

    /**
     * The connection of the proxy.
     */
    readonly g_connection: DBusConnection
    /**
     * The object path of the proxy.
     */
    readonly g_object_path: string | null

    // Owm methods of Gio-2.0.Gio.DBusObjectProxy

    /**
     * Gets the connection that `proxy` is for.
     * @returns A #GDBusConnection. Do not free, the   object is owned by @proxy.
     */
    get_connection(): DBusConnection

    // Class property signals of Gio-2.0.Gio.DBusObjectProxy

    connect(sigName: "notify::g-connection", callback: (($obj: DBusObjectProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-connection", callback: (($obj: DBusObjectProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (($obj: DBusObjectProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-object-path", callback: (($obj: DBusObjectProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GDBusObjectProxy is an object used to represent a remote object
 * with one or more D-Bus interfaces. Normally, you don't instantiate
 * a #GDBusObjectProxy yourself - typically #GDBusObjectManagerClient
 * is used to obtain it.
 * @class 
 */
class DBusObjectProxy extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusObjectProxy

    static name: string
    static $gtype: GObject.GType<DBusObjectProxy>

    // Constructors of Gio-2.0.Gio.DBusObjectProxy

    constructor(config?: DBusObjectProxy.ConstructorProperties) 
    /**
     * Creates a new #GDBusObjectProxy for the given connection and
     * object path.
     * @constructor 
     * @param connection a #GDBusConnection
     * @param object_path the object path
     * @returns a new #GDBusObjectProxy
     */
    constructor(connection: DBusConnection, object_path: string | null) 
    /**
     * Creates a new #GDBusObjectProxy for the given connection and
     * object path.
     * @constructor 
     * @param connection a #GDBusConnection
     * @param object_path the object path
     * @returns a new #GDBusObjectProxy
     */
    static new(connection: DBusConnection, object_path: string | null): DBusObjectProxy
    _init(config?: DBusObjectProxy.ConstructorProperties): void
}

module DBusObjectSkeleton {

    // Signal callback interfaces

    /**
     * Signal callback interface for `authorize-method`
     */
    interface AuthorizeMethodSignalCallback {
        ($obj: DBusObjectSkeleton, interface: DBusInterfaceSkeleton, invocation: DBusMethodInvocation): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends DBusObject.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DBusObjectSkeleton

        /**
         * The object path where the object is exported.
         */
        g_object_path?: string | null
    }

}

interface DBusObjectSkeleton extends DBusObject {

    // Own properties of Gio-2.0.Gio.DBusObjectSkeleton

    /**
     * The object path where the object is exported.
     */
    g_object_path: string | null

    // Owm methods of Gio-2.0.Gio.DBusObjectSkeleton

    /**
     * Adds `interface_` to `object`.
     * 
     * If `object` already contains a #GDBusInterfaceSkeleton with the same
     * interface name, it is removed before `interface_` is added.
     * 
     * Note that `object` takes its own reference on `interface_` and holds
     * it until removed.
     * @param interface_ A #GDBusInterfaceSkeleton.
     */
    add_interface(interface_: DBusInterfaceSkeleton): void
    /**
     * This method simply calls g_dbus_interface_skeleton_flush() on all
     * interfaces belonging to `object`. See that method for when flushing
     * is useful.
     */
    flush(): void
    /**
     * Removes `interface_` from `object`.
     * @param interface_ A #GDBusInterfaceSkeleton.
     */
    remove_interface(interface_: DBusInterfaceSkeleton): void
    /**
     * Removes the #GDBusInterface with `interface_name` from `object`.
     * 
     * If no D-Bus interface of the given interface exists, this function
     * does nothing.
     * @param interface_name A D-Bus interface name.
     */
    remove_interface_by_name(interface_name: string | null): void
    /**
     * Sets the object path for `object`.
     * @param object_path A valid D-Bus object path.
     */
    set_object_path(object_path: string | null): void

    // Own virtual methods of Gio-2.0.Gio.DBusObjectSkeleton

    vfunc_authorize_method(interface_: DBusInterfaceSkeleton, invocation: DBusMethodInvocation): boolean

    // Own signals of Gio-2.0.Gio.DBusObjectSkeleton

    connect(sigName: "authorize-method", callback: DBusObjectSkeleton.AuthorizeMethodSignalCallback): number
    connect_after(sigName: "authorize-method", callback: DBusObjectSkeleton.AuthorizeMethodSignalCallback): number
    emit(sigName: "authorize-method", interface: DBusInterfaceSkeleton, invocation: DBusMethodInvocation, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusObjectSkeleton

    connect(sigName: "notify::g-object-path", callback: (($obj: DBusObjectSkeleton, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-object-path", callback: (($obj: DBusObjectSkeleton, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GDBusObjectSkeleton instance is essentially a group of D-Bus
 * interfaces. The set of exported interfaces on the object may be
 * dynamic and change at runtime.
 * 
 * This type is intended to be used with #GDBusObjectManager.
 * @class 
 */
class DBusObjectSkeleton extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusObjectSkeleton

    static name: string
    static $gtype: GObject.GType<DBusObjectSkeleton>

    // Constructors of Gio-2.0.Gio.DBusObjectSkeleton

    constructor(config?: DBusObjectSkeleton.ConstructorProperties) 
    /**
     * Creates a new #GDBusObjectSkeleton.
     * @constructor 
     * @param object_path An object path.
     * @returns A #GDBusObjectSkeleton. Free with g_object_unref().
     */
    constructor(object_path: string | null) 
    /**
     * Creates a new #GDBusObjectSkeleton.
     * @constructor 
     * @param object_path An object path.
     * @returns A #GDBusObjectSkeleton. Free with g_object_unref().
     */
    static new(object_path: string | null): DBusObjectSkeleton
    _init(config?: DBusObjectSkeleton.ConstructorProperties): void
}

module DBusProxy {

    // Signal callback interfaces

    /**
     * Signal callback interface for `g-properties-changed`
     */
    interface GPropertiesChangedSignalCallback {
        ($obj: DBusProxy, changed_properties: GLib.Variant, invalidated_properties: string[]): void
    }

    /**
     * Signal callback interface for `g-signal`
     */
    interface GSignalSignalCallback {
        ($obj: DBusProxy, sender_name: string | null, signal_name: string | null, parameters: GLib.Variant): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends AsyncInitable.ConstructorProperties, DBusInterface.ConstructorProperties, Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DBusProxy

        /**
         * If this property is not %G_BUS_TYPE_NONE, then
         * #GDBusProxy:g-connection must be %NULL and will be set to the
         * #GDBusConnection obtained by calling g_bus_get() with the value
         * of this property.
         */
        g_bus_type?: BusType | null
        /**
         * The #GDBusConnection the proxy is for.
         */
        g_connection?: DBusConnection | null
        /**
         * The timeout to use if -1 (specifying default timeout) is passed
         * as `timeout_msec` in the g_dbus_proxy_call() and
         * g_dbus_proxy_call_sync() functions.
         * 
         * This allows applications to set a proxy-wide timeout for all
         * remote method invocations on the proxy. If this property is -1,
         * the default timeout (typically 25 seconds) is used. If set to
         * %G_MAXINT, then no timeout is used.
         */
        g_default_timeout?: number | null
        /**
         * Flags from the #GDBusProxyFlags enumeration.
         */
        g_flags?: DBusProxyFlags | null
        /**
         * Ensure that interactions with this proxy conform to the given
         * interface. This is mainly to ensure that malformed data received
         * from the other peer is ignored. The given #GDBusInterfaceInfo is
         * said to be the "expected interface".
         * 
         * The checks performed are:
         * - When completing a method call, if the type signature of
         *   the reply message isn't what's expected, the reply is
         *   discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.
         * 
         * - Received signals that have a type signature mismatch are dropped and
         *   a warning is logged via g_warning().
         * 
         * - Properties received via the initial `GetAll()` call or via the
         *   `::PropertiesChanged` signal (on the
         *   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
         *   interface) or set using g_dbus_proxy_set_cached_property()
         *   with a type signature mismatch are ignored and a warning is
         *   logged via g_warning().
         * 
         * Note that these checks are never done on methods, signals and
         * properties that are not referenced in the given
         * #GDBusInterfaceInfo, since extending a D-Bus interface on the
         * service-side is not considered an ABI break.
         */
        g_interface_info?: DBusInterfaceInfo | null
        /**
         * The D-Bus interface name the proxy is for.
         */
        g_interface_name?: string | null
        /**
         * The well-known or unique name that the proxy is for.
         */
        g_name?: string | null
        /**
         * The object path the proxy is for.
         */
        g_object_path?: string | null
    }

}

interface DBusProxy extends AsyncInitable, DBusInterface, Initable {

    // Own properties of Gio-2.0.Gio.DBusProxy

    /**
     * If this property is not %G_BUS_TYPE_NONE, then
     * #GDBusProxy:g-connection must be %NULL and will be set to the
     * #GDBusConnection obtained by calling g_bus_get() with the value
     * of this property.
     */
    readonly g_bus_type: BusType
    /**
     * The #GDBusConnection the proxy is for.
     */
    readonly g_connection: DBusConnection
    /**
     * The timeout to use if -1 (specifying default timeout) is passed
     * as `timeout_msec` in the g_dbus_proxy_call() and
     * g_dbus_proxy_call_sync() functions.
     * 
     * This allows applications to set a proxy-wide timeout for all
     * remote method invocations on the proxy. If this property is -1,
     * the default timeout (typically 25 seconds) is used. If set to
     * %G_MAXINT, then no timeout is used.
     */
    g_default_timeout: number
    /**
     * Flags from the #GDBusProxyFlags enumeration.
     */
    readonly g_flags: DBusProxyFlags
    /**
     * Ensure that interactions with this proxy conform to the given
     * interface. This is mainly to ensure that malformed data received
     * from the other peer is ignored. The given #GDBusInterfaceInfo is
     * said to be the "expected interface".
     * 
     * The checks performed are:
     * - When completing a method call, if the type signature of
     *   the reply message isn't what's expected, the reply is
     *   discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.
     * 
     * - Received signals that have a type signature mismatch are dropped and
     *   a warning is logged via g_warning().
     * 
     * - Properties received via the initial `GetAll()` call or via the
     *   `::PropertiesChanged` signal (on the
     *   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
     *   interface) or set using g_dbus_proxy_set_cached_property()
     *   with a type signature mismatch are ignored and a warning is
     *   logged via g_warning().
     * 
     * Note that these checks are never done on methods, signals and
     * properties that are not referenced in the given
     * #GDBusInterfaceInfo, since extending a D-Bus interface on the
     * service-side is not considered an ABI break.
     */
    g_interface_info: DBusInterfaceInfo
    /**
     * The D-Bus interface name the proxy is for.
     */
    readonly g_interface_name: string | null
    /**
     * The well-known or unique name that the proxy is for.
     */
    readonly g_name: string | null
    /**
     * The unique name that owns #GDBusProxy:g-name or %NULL if no-one
     * currently owns that name. You may connect to #GObject::notify signal to
     * track changes to this property.
     */
    readonly g_name_owner: string | null
    /**
     * The object path the proxy is for.
     */
    readonly g_object_path: string | null

    // Owm methods of Gio-2.0.Gio.DBusProxy

    /**
     * Asynchronously invokes the `method_name` method on `proxy`.
     * 
     * If `method_name` contains any dots, then `name` is split into interface and
     * method name parts. This allows using `proxy` for invoking methods on
     * other interfaces.
     * 
     * If the #GDBusConnection associated with `proxy` is closed then
     * the operation will fail with %G_IO_ERROR_CLOSED. If
     * `cancellable` is canceled, the operation will fail with
     * %G_IO_ERROR_CANCELLED. If `parameters` contains a value not
     * compatible with the D-Bus protocol, the operation fails with
     * %G_IO_ERROR_INVALID_ARGUMENT.
     * 
     * If the `parameters` #GVariant is floating, it is consumed. This allows
     * convenient 'inline' use of g_variant_new(), e.g.:
     * 
     * ```c
     *  g_dbus_proxy_call (proxy,
     *                     "TwoStrings",
     *                     g_variant_new ("(ss)",
     *                                    "Thing One",
     *                                    "Thing Two"),
     *                     G_DBUS_CALL_FLAGS_NONE,
     *                     -1,
     *                     NULL,
     *                     (GAsyncReadyCallback) two_strings_done,
     *                     &data);
     * ```
     * 
     * 
     * If `proxy` has an expected interface (see
     * #GDBusProxy:g-interface-info) and `method_name` is referenced by it,
     * then the return value is checked against the return type.
     * 
     * This is an asynchronous method. When the operation is finished,
     * `callback` will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from.
     * You can then call g_dbus_proxy_call_finish() to get the result of
     * the operation. See g_dbus_proxy_call_sync() for the synchronous
     * version of this method.
     * 
     * If `callback` is %NULL then the D-Bus method call message will be sent with
     * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
     * @param method_name Name of method to invoke.
     * @param parameters A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.
     * @param flags Flags from the #GDBusCallFlags enumeration.
     * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result of the method invocation.
     */
    call(method_name: string | null, parameters: GLib.Variant | null, flags: DBusCallFlags, timeout_msec: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an operation started with g_dbus_proxy_call().
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call().
     * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
     */
    call_finish(res: AsyncResult): GLib.Variant
    /**
     * Synchronously invokes the `method_name` method on `proxy`.
     * 
     * If `method_name` contains any dots, then `name` is split into interface and
     * method name parts. This allows using `proxy` for invoking methods on
     * other interfaces.
     * 
     * If the #GDBusConnection associated with `proxy` is disconnected then
     * the operation will fail with %G_IO_ERROR_CLOSED. If
     * `cancellable` is canceled, the operation will fail with
     * %G_IO_ERROR_CANCELLED. If `parameters` contains a value not
     * compatible with the D-Bus protocol, the operation fails with
     * %G_IO_ERROR_INVALID_ARGUMENT.
     * 
     * If the `parameters` #GVariant is floating, it is consumed. This allows
     * convenient 'inline' use of g_variant_new(), e.g.:
     * 
     * ```c
     *  g_dbus_proxy_call_sync (proxy,
     *                          "TwoStrings",
     *                          g_variant_new ("(ss)",
     *                                         "Thing One",
     *                                         "Thing Two"),
     *                          G_DBUS_CALL_FLAGS_NONE,
     *                          -1,
     *                          NULL,
     *                          &error);
     * ```
     * 
     * 
     * The calling thread is blocked until a reply is received. See
     * g_dbus_proxy_call() for the asynchronous version of this
     * method.
     * 
     * If `proxy` has an expected interface (see
     * #GDBusProxy:g-interface-info) and `method_name` is referenced by it,
     * then the return value is checked against the return type.
     * @param method_name Name of method to invoke.
     * @param parameters A #GVariant tuple with parameters for the signal              or %NULL if not passing parameters.
     * @param flags Flags from the #GDBusCallFlags enumeration.
     * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
     */
    call_sync(method_name: string | null, parameters: GLib.Variant | null, flags: DBusCallFlags, timeout_msec: number, cancellable: Cancellable | null): GLib.Variant
    /**
     * Like g_dbus_proxy_call() but also takes a #GUnixFDList object.
     * 
     * This method is only available on UNIX.
     * @param method_name Name of method to invoke.
     * @param parameters A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.
     * @param flags Flags from the #GDBusCallFlags enumeration.
     * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
     * @param fd_list A #GUnixFDList or %NULL.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result of the method invocation.
     */
    call_with_unix_fd_list(method_name: string | null, parameters: GLib.Variant | null, flags: DBusCallFlags, timeout_msec: number, fd_list: UnixFDList | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an operation started with g_dbus_proxy_call_with_unix_fd_list().
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call_with_unix_fd_list().
     * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
     */
    call_with_unix_fd_list_finish(res: AsyncResult): [ /* returnType */ GLib.Variant, /* out_fd_list */ UnixFDList ]
    /**
     * Like g_dbus_proxy_call_sync() but also takes and returns #GUnixFDList objects.
     * 
     * This method is only available on UNIX.
     * @param method_name Name of method to invoke.
     * @param parameters A #GVariant tuple with parameters for the signal              or %NULL if not passing parameters.
     * @param flags Flags from the #GDBusCallFlags enumeration.
     * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning                "infinite") or -1 to use the proxy default timeout.
     * @param fd_list A #GUnixFDList or %NULL.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %NULL if @error is set. Otherwise a #GVariant tuple with return values. Free with g_variant_unref().
     */
    call_with_unix_fd_list_sync(method_name: string | null, parameters: GLib.Variant | null, flags: DBusCallFlags, timeout_msec: number, fd_list: UnixFDList | null, cancellable: Cancellable | null): [ /* returnType */ GLib.Variant, /* out_fd_list */ UnixFDList ]
    /**
     * Looks up the value for a property from the cache. This call does no
     * blocking IO.
     * 
     * If `proxy` has an expected interface (see
     * #GDBusProxy:g-interface-info) and `property_name` is referenced by
     * it, then `value` is checked against the type of the property.
     * @param property_name Property name.
     * @returns A reference to the #GVariant instance    that holds the value for @property_name or %NULL if the value is not in    the cache. The returned reference must be freed with g_variant_unref().
     */
    get_cached_property(property_name: string | null): GLib.Variant | null
    /**
     * Gets the names of all cached properties on `proxy`.
     * @returns A          %NULL-terminated array of strings or %NULL if          @proxy has no cached properties. Free the returned array with          g_strfreev().
     */
    get_cached_property_names(): string[] | null
    /**
     * Gets the connection `proxy` is for.
     * @returns A #GDBusConnection owned by @proxy. Do not free.
     */
    get_connection(): DBusConnection
    /**
     * Gets the timeout to use if -1 (specifying default timeout) is
     * passed as `timeout_msec` in the g_dbus_proxy_call() and
     * g_dbus_proxy_call_sync() functions.
     * 
     * See the #GDBusProxy:g-default-timeout property for more details.
     * @returns Timeout to use for @proxy.
     */
    get_default_timeout(): number
    /**
     * Gets the flags that `proxy` was constructed with.
     * @returns Flags from the #GDBusProxyFlags enumeration.
     */
    get_flags(): DBusProxyFlags
    /**
     * Returns the #GDBusInterfaceInfo, if any, specifying the interface
     * that `proxy` conforms to. See the #GDBusProxy:g-interface-info
     * property for more details.
     * @returns A #GDBusInterfaceInfo or %NULL.    Do not unref the returned object, it is owned by @proxy.
     */
    get_interface_info(): DBusInterfaceInfo | null
    /**
     * Gets the D-Bus interface name `proxy` is for.
     * @returns A string owned by @proxy. Do not free.
     */
    get_interface_name(): string | null
    /**
     * Gets the name that `proxy` was constructed for.
     * 
     * When connected to a message bus, this will usually be non-%NULL.
     * However, it may be %NULL for a proxy that communicates using a peer-to-peer
     * pattern.
     * @returns A string owned by @proxy. Do not free.
     */
    get_name(): string | null
    /**
     * The unique name that owns the name that `proxy` is for or %NULL if
     * no-one currently owns that name. You may connect to the
     * #GObject::notify signal to track changes to the
     * #GDBusProxy:g-name-owner property.
     * @returns The name owner or %NULL if no name    owner exists. Free with g_free().
     */
    get_name_owner(): string | null
    /**
     * Gets the object path `proxy` is for.
     * @returns A string owned by @proxy. Do not free.
     */
    get_object_path(): string | null
    /**
     * If `value` is not %NULL, sets the cached value for the property with
     * name `property_name` to the value in `value`.
     * 
     * If `value` is %NULL, then the cached value is removed from the
     * property cache.
     * 
     * If `proxy` has an expected interface (see
     * #GDBusProxy:g-interface-info) and `property_name` is referenced by
     * it, then `value` is checked against the type of the property.
     * 
     * If the `value` #GVariant is floating, it is consumed. This allows
     * convenient 'inline' use of g_variant_new(), e.g.
     * 
     * ```c
     *  g_dbus_proxy_set_cached_property (proxy,
     *                                    "SomeProperty",
     *                                    g_variant_new ("(si)",
     *                                                  "A String",
     *                                                  42));
     * ```
     * 
     * 
     * Normally you will not need to use this method since `proxy`
     * is tracking changes using the
     * `org.freedesktop.DBus.Properties.PropertiesChanged`
     * D-Bus signal. However, for performance reasons an object may
     * decide to not use this signal for some properties and instead
     * use a proprietary out-of-band mechanism to transmit changes.
     * 
     * As a concrete example, consider an object with a property
     * `ChatroomParticipants` which is an array of strings. Instead of
     * transmitting the same (long) array every time the property changes,
     * it is more efficient to only transmit the delta using e.g. signals
     * `ChatroomParticipantJoined(String name)` and
     * `ChatroomParticipantParted(String name)`.
     * @param property_name Property name.
     * @param value Value for the property or %NULL to remove it from the cache.
     */
    set_cached_property(property_name: string | null, value: GLib.Variant | null): void
    /**
     * Sets the timeout to use if -1 (specifying default timeout) is
     * passed as `timeout_msec` in the g_dbus_proxy_call() and
     * g_dbus_proxy_call_sync() functions.
     * 
     * See the #GDBusProxy:g-default-timeout property for more details.
     * @param timeout_msec Timeout in milliseconds.
     */
    set_default_timeout(timeout_msec: number): void
    /**
     * Ensure that interactions with `proxy` conform to the given
     * interface. See the #GDBusProxy:g-interface-info property for more
     * details.
     * @param info Minimum interface this proxy conforms to    or %NULL to unset.
     */
    set_interface_info(info: DBusInterfaceInfo | null): void
    connectSignal<T = any[]>(name: string, callback: (proxy: DBusProxy, name: string, args: T) => boolean | void): number
    disconnectSignal(id: number): void

    // Own virtual methods of Gio-2.0.Gio.DBusProxy

    vfunc_g_properties_changed(changed_properties: GLib.Variant, invalidated_properties: string | null): void
    vfunc_g_signal(sender_name: string | null, signal_name: string | null, parameters: GLib.Variant): void

    // Own signals of Gio-2.0.Gio.DBusProxy

    connect(sigName: "g-properties-changed", callback: DBusProxy.GPropertiesChangedSignalCallback): number
    connect_after(sigName: "g-properties-changed", callback: DBusProxy.GPropertiesChangedSignalCallback): number
    emit(sigName: "g-properties-changed", changed_properties: GLib.Variant, invalidated_properties: string[], ...args: any[]): void
    connect(sigName: "g-signal", callback: DBusProxy.GSignalSignalCallback): number
    connect_after(sigName: "g-signal", callback: DBusProxy.GSignalSignalCallback): number
    emit(sigName: "g-signal", sender_name: string | null, signal_name: string | null, parameters: GLib.Variant, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusProxy

    connect(sigName: "notify::g-bus-type", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-bus-type", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-connection", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-default-timeout", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-flags", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-interface-info", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-interface-name", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-name", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-name-owner", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::g-object-path", callback: (($obj: DBusProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDBusProxy is a base class used for proxies to access a D-Bus
 * interface on a remote object. A #GDBusProxy can be constructed for
 * both well-known and unique names.
 * 
 * By default, #GDBusProxy will cache all properties (and listen to
 * changes) of the remote object, and proxy all signals that get
 * emitted. This behaviour can be changed by passing suitable
 * #GDBusProxyFlags when the proxy is created. If the proxy is for a
 * well-known name, the property cache is flushed when the name owner
 * vanishes and reloaded when a name owner appears.
 * 
 * The unique name owner of the proxy's name is tracked and can be read from
 * #GDBusProxy:g-name-owner. Connect to the #GObject::notify signal to
 * get notified of changes. Additionally, only signals and property
 * changes emitted from the current name owner are considered and
 * calls are always sent to the current name owner. This avoids a
 * number of race conditions when the name is lost by one owner and
 * claimed by another. However, if no name owner currently exists,
 * then calls will be sent to the well-known name which may result in
 * the message bus launching an owner (unless
 * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is set).
 * 
 * If the proxy is for a stateless D-Bus service, where the name owner may
 * be started and stopped between calls, the #GDBusProxy:g-name-owner tracking
 * of #GDBusProxy will cause the proxy to drop signal and property changes from
 * the service after it has restarted for the first time. When interacting
 * with a stateless D-Bus service, do not use #GDBusProxy — use direct D-Bus
 * method calls and signal connections.
 * 
 * The generic #GDBusProxy::g-properties-changed and
 * #GDBusProxy::g-signal signals are not very convenient to work with.
 * Therefore, the recommended way of working with proxies is to subclass
 * #GDBusProxy, and have more natural properties and signals in your derived
 * class. This [example][gdbus-example-gdbus-codegen] shows how this can
 * easily be done using the [gdbus-codegen][gdbus-codegen] tool.
 * 
 * A #GDBusProxy instance can be used from multiple threads but note
 * that all signals (e.g. #GDBusProxy::g-signal, #GDBusProxy::g-properties-changed
 * and #GObject::notify) are emitted in the
 * [thread-default main context][g-main-context-push-thread-default]
 * of the thread where the instance was constructed.
 * 
 * An example using a proxy for a well-known name can be found in
 * [gdbus-example-watch-proxy.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c)
 * @class 
 */
class DBusProxy extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusProxy

    static name: string
    static $gtype: GObject.GType<DBusProxy>

    // Constructors of Gio-2.0.Gio.DBusProxy

    constructor(config?: DBusProxy.ConstructorProperties) 
    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static new_finish(res: AsyncResult): DBusProxy
    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static new_for_bus_finish(res: AsyncResult): DBusProxy
    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param bus_type A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param object_path An object path.
     * @param interface_name A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static new_for_bus_sync(bus_type: BusType, flags: DBusProxyFlags, info: DBusInterfaceInfo | null, name: string | null, object_path: string | null, interface_name: string | null, cancellable: Cancellable | null): DBusProxy
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param object_path An object path.
     * @param interface_name A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static new_sync(connection: DBusConnection, flags: DBusProxyFlags, info: DBusInterfaceInfo | null, name: string | null, object_path: string | null, interface_name: string | null, cancellable: Cancellable | null): DBusProxy
    _init(config?: DBusProxy.ConstructorProperties): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param object_path An object path.
     * @param interface_name A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: DBusConnection, flags: DBusProxyFlags, info: DBusInterfaceInfo | null, name: string | null, object_path: string | null, interface_name: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<DBusProxy> | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param bus_type A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param object_path An object path.
     * @param interface_name A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new_for_bus(bus_type: BusType, flags: DBusProxyFlags, info: DBusInterfaceInfo | null, name: string | null, object_path: string | null, interface_name: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<DBusProxy> | null): void
    static makeProxyWrapper<T>(interfaceXml: string): (bus: DBusConnection, name: string, object: string, asyncCallback?: (initable: (T & DBusProxy) | null, error: unknown | null) => void, cancellable?: Cancellable | null, flags?: DBusProxyFlags) => T & DBusProxy
}

module DBusServer {

    // Signal callback interfaces

    /**
     * Signal callback interface for `new-connection`
     */
    interface NewConnectionSignalCallback {
        ($obj: DBusServer, connection: DBusConnection): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DBusServer

        /**
         * The D-Bus address to listen on.
         */
        address?: string | null
        /**
         * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
         */
        authentication_observer?: DBusAuthObserver | null
        /**
         * Flags from the #GDBusServerFlags enumeration.
         */
        flags?: DBusServerFlags | null
        /**
         * The GUID of the server.
         * 
         * See #GDBusConnection:guid for more details.
         */
        guid?: string | null
    }

}

interface DBusServer extends Initable {

    // Own properties of Gio-2.0.Gio.DBusServer

    /**
     * Whether the server is currently active.
     */
    readonly active: boolean
    /**
     * The D-Bus address to listen on.
     */
    readonly address: string | null
    /**
     * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
     */
    readonly authentication_observer: DBusAuthObserver
    /**
     * The D-Bus address that clients can use.
     */
    readonly client_address: string | null
    /**
     * Flags from the #GDBusServerFlags enumeration.
     */
    readonly flags: DBusServerFlags
    /**
     * The GUID of the server.
     * 
     * See #GDBusConnection:guid for more details.
     */
    readonly guid: string | null

    // Owm methods of Gio-2.0.Gio.DBusServer

    /**
     * Gets a
     * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
     * string that can be used by clients to connect to `server`.
     * 
     * This is valid and non-empty if initializing the #GDBusServer succeeded.
     * @returns A D-Bus address string. Do not free, the string is owned by @server.
     */
    get_client_address(): string | null
    /**
     * Gets the flags for `server`.
     * @returns A set of flags from the #GDBusServerFlags enumeration.
     */
    get_flags(): DBusServerFlags
    /**
     * Gets the GUID for `server,` as provided to g_dbus_server_new_sync().
     * @returns A D-Bus GUID. Do not free this string, it is owned by @server.
     */
    get_guid(): string | null
    /**
     * Gets whether `server` is active.
     * @returns %TRUE if server is active, %FALSE otherwise.
     */
    is_active(): boolean
    /**
     * Starts `server`.
     */
    start(): void
    /**
     * Stops `server`.
     */
    stop(): void

    // Own signals of Gio-2.0.Gio.DBusServer

    connect(sigName: "new-connection", callback: DBusServer.NewConnectionSignalCallback): number
    connect_after(sigName: "new-connection", callback: DBusServer.NewConnectionSignalCallback): number
    emit(sigName: "new-connection", connection: DBusConnection, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DBusServer

    connect(sigName: "notify::active", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::active", ...args: any[]): void
    connect(sigName: "notify::address", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::address", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::address", ...args: any[]): void
    connect(sigName: "notify::authentication-observer", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::authentication-observer", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::authentication-observer", ...args: any[]): void
    connect(sigName: "notify::client-address", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-address", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::client-address", ...args: any[]): void
    connect(sigName: "notify::flags", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: "notify::guid", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::guid", callback: (($obj: DBusServer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::guid", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDBusServer is a helper for listening to and accepting D-Bus
 * connections. This can be used to create a new D-Bus server, allowing two
 * peers to use the D-Bus protocol for their own specialized communication.
 * A server instance provided in this way will not perform message routing or
 * implement the org.freedesktop.DBus interface.
 * 
 * To just export an object on a well-known name on a message bus, such as the
 * session or system bus, you should instead use g_bus_own_name().
 * 
 * An example of peer-to-peer communication with GDBus can be found
 * in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
 * 
 * Note that a minimal #GDBusServer will accept connections from any
 * peer. In many use-cases it will be necessary to add a #GDBusAuthObserver
 * that only accepts connections that have successfully authenticated
 * as the same user that is running the #GDBusServer. Since GLib 2.68 this can
 * be achieved more simply by passing the
 * %G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the server.
 * @class 
 */
class DBusServer extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DBusServer

    static name: string
    static $gtype: GObject.GType<DBusServer>

    // Constructors of Gio-2.0.Gio.DBusServer

    constructor(config?: DBusServer.ConstructorProperties) 
    /**
     * Creates a new D-Bus server that listens on the first address in
     * `address` that works.
     * 
     * Once constructed, you can use g_dbus_server_get_client_address() to
     * get a D-Bus address string that clients can use to connect.
     * 
     * To have control over the available authentication mechanisms and
     * the users that are authorized to connect, it is strongly recommended
     * to provide a non-%NULL #GDBusAuthObserver.
     * 
     * Connect to the #GDBusServer::new-connection signal to handle
     * incoming connections.
     * 
     * The returned #GDBusServer isn't active - you have to start it with
     * g_dbus_server_start().
     * 
     * #GDBusServer is used in this [example][gdbus-peer-to-peer].
     * 
     * This is a synchronous failable constructor. There is currently no
     * asynchronous version.
     * @constructor 
     * @param address A D-Bus address.
     * @param flags Flags from the #GDBusServerFlags enumeration.
     * @param guid A D-Bus GUID.
     * @param observer A #GDBusAuthObserver or %NULL.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusServer or %NULL if @error is set. Free with g_object_unref().
     */
    static new_sync(address: string | null, flags: DBusServerFlags, guid: string | null, observer: DBusAuthObserver | null, cancellable: Cancellable | null): DBusServer
    _init(config?: DBusServer.ConstructorProperties): void
}

module DataInputStream {

    // Constructor properties interface

    interface ConstructorProperties extends Seekable.ConstructorProperties, BufferedInputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DataInputStream

        /**
         * The :byte-order property determines the byte ordering that
         * is used when reading multi-byte entities (such as integers)
         * from the stream.
         */
        byte_order?: DataStreamByteOrder | null
        /**
         * The :newline-type property determines what is considered
         * as a line ending when reading complete lines from the stream.
         */
        newline_type?: DataStreamNewlineType | null
    }

}

interface DataInputStream extends Seekable {

    // Own properties of Gio-2.0.Gio.DataInputStream

    /**
     * The :byte-order property determines the byte ordering that
     * is used when reading multi-byte entities (such as integers)
     * from the stream.
     */
    byte_order: DataStreamByteOrder
    /**
     * The :newline-type property determines what is considered
     * as a line ending when reading complete lines from the stream.
     */
    newline_type: DataStreamNewlineType

    // Own fields of Gio-2.0.Gio.DataInputStream

    parent_instance: BufferedInputStream & FilterInputStream & InputStream & GObject.Object & GObject.Object

    // Owm methods of Gio-2.0.Gio.DataInputStream

    /**
     * Gets the byte order for the data input stream.
     * @returns the @stream's current #GDataStreamByteOrder.
     */
    get_byte_order(): DataStreamByteOrder
    /**
     * Gets the current newline type for the `stream`.
     * @returns #GDataStreamNewlineType for the given @stream.
     */
    get_newline_type(): DataStreamNewlineType
    /**
     * Reads an unsigned 8-bit/1-byte value from `stream`.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns an unsigned 8-bit/1-byte value read from the @stream or `0` if an error occurred.
     */
    read_byte(cancellable: Cancellable | null): number
    /**
     * Reads a 16-bit/2-byte value from `stream`.
     * 
     * In order to get the correct byte order for this read operation,
     * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a signed 16-bit/2-byte value read from @stream or `0` if an error occurred.
     */
    read_int16(cancellable: Cancellable | null): number
    /**
     * Reads a signed 32-bit/4-byte value from `stream`.
     * 
     * In order to get the correct byte order for this read operation,
     * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a signed 32-bit/4-byte value read from the @stream or `0` if an error occurred.
     */
    read_int32(cancellable: Cancellable | null): number
    /**
     * Reads a 64-bit/8-byte value from `stream`.
     * 
     * In order to get the correct byte order for this read operation,
     * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a signed 64-bit/8-byte value read from @stream or `0` if an error occurred.
     */
    read_int64(cancellable: Cancellable | null): number
    /**
     * Reads a line from the data input stream.  Note that no encoding
     * checks or conversion is performed; the input is not guaranteed to
     * be UTF-8, and may in fact have embedded NUL characters.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns   a NUL terminated byte array with the line that was read in  (without the newlines).  Set @length to a #gsize to get the length  of the read line.  On an error, it will return %NULL and @error  will be set. If there's no content to read, it will still return  %NULL, but @error won't be set.
     */
    read_line(cancellable: Cancellable | null): [ /* returnType */ Uint8Array | null, /* length */ number ]
    /**
     * The asynchronous version of g_data_input_stream_read_line().  It is
     * an error to have two outstanding calls to this function.
     * 
     * When the operation is finished, `callback` will be called. You
     * can then call g_data_input_stream_read_line_finish() to get
     * the result of the operation.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied.
     */
    read_line_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of read_line_async

    /**
     * Promisified version of {@link read_line_async}
     * 
     * The asynchronous version of g_data_input_stream_read_line().  It is
     * an error to have two outstanding calls to this function.
     * 
     * When the operation is finished, `callback` will be called. You
     * can then call g_data_input_stream_read_line_finish() to get
     * the result of the operation.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of:   a NUL-terminated byte array with the line that was read in  (without the newlines).  Set @length to a #gsize to get the length  of the read line.  On an error, it will return %NULL and @error  will be set. If there's no content to read, it will still return  %NULL, but @error won't be set.
     */
    read_line_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* length */ number>
    /**
     * Finish an asynchronous call started by
     * g_data_input_stream_read_line_async().  Note the warning about
     * string encoding in g_data_input_stream_read_line() applies here as
     * well.
     * @param result the #GAsyncResult that was provided to the callback.
     * @returns   a NUL-terminated byte array with the line that was read in  (without the newlines).  Set @length to a #gsize to get the length  of the read line.  On an error, it will return %NULL and @error  will be set. If there's no content to read, it will still return  %NULL, but @error won't be set.
     */
    read_line_finish(result: AsyncResult): [ /* returnType */ Uint8Array | null, /* length */ number ]
    /**
     * Finish an asynchronous call started by
     * g_data_input_stream_read_line_async().
     * @param result the #GAsyncResult that was provided to the callback.
     * @returns a string with the line that  was read in (without the newlines).  Set @length to a #gsize to  get the length of the read line.  On an error, it will return  %NULL and @error will be set. For UTF-8 conversion errors, the set  error domain is %G_CONVERT_ERROR.  If there's no content to read,  it will still return %NULL, but @error won't be set.
     */
    read_line_finish_utf8(result: AsyncResult): [ /* returnType */ string | null, /* length */ number ]
    /**
     * Reads a UTF-8 encoded line from the data input stream.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a NUL terminated UTF-8 string  with the line that was read in (without the newlines).  Set  @length to a #gsize to get the length of the read line.  On an  error, it will return %NULL and @error will be set.  For UTF-8  conversion errors, the set error domain is %G_CONVERT_ERROR.  If  there's no content to read, it will still return %NULL, but @error  won't be set.
     */
    read_line_utf8(cancellable: Cancellable | null): [ /* returnType */ string | null, /* length */ number ]
    /**
     * Reads an unsigned 16-bit/2-byte value from `stream`.
     * 
     * In order to get the correct byte order for this read operation,
     * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns an unsigned 16-bit/2-byte value read from the @stream or `0` if an error occurred.
     */
    read_uint16(cancellable: Cancellable | null): number
    /**
     * Reads an unsigned 32-bit/4-byte value from `stream`.
     * 
     * In order to get the correct byte order for this read operation,
     * see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns an unsigned 32-bit/4-byte value read from the @stream or `0` if an error occurred.
     */
    read_uint32(cancellable: Cancellable | null): number
    /**
     * Reads an unsigned 64-bit/8-byte value from `stream`.
     * 
     * In order to get the correct byte order for this read operation,
     * see g_data_input_stream_get_byte_order().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns an unsigned 64-bit/8-byte read from @stream or `0` if an error occurred.
     */
    read_uint64(cancellable: Cancellable | null): number
    /**
     * Reads a string from the data input stream, up to the first
     * occurrence of any of the stop characters.
     * 
     * Note that, in contrast to g_data_input_stream_read_until_async(),
     * this function consumes the stop character that it finds.
     * 
     * Don't use this function in new code.  Its functionality is
     * inconsistent with g_data_input_stream_read_until_async().  Both
     * functions will be marked as deprecated in a future release.  Use
     * g_data_input_stream_read_upto() instead, but note that that function
     * does not consume the stop character.
     * @param stop_chars characters to terminate the read.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
     */
    read_until(stop_chars: string | null, cancellable: Cancellable | null): [ /* returnType */ string | null, /* length */ number ]
    /**
     * The asynchronous version of g_data_input_stream_read_until().
     * It is an error to have two outstanding calls to this function.
     * 
     * Note that, in contrast to g_data_input_stream_read_until(),
     * this function does not consume the stop character that it finds.  You
     * must read it for yourself.
     * 
     * When the operation is finished, `callback` will be called. You
     * can then call g_data_input_stream_read_until_finish() to get
     * the result of the operation.
     * 
     * Don't use this function in new code.  Its functionality is
     * inconsistent with g_data_input_stream_read_until().  Both functions
     * will be marked as deprecated in a future release.  Use
     * g_data_input_stream_read_upto_async() instead.
     * @param stop_chars characters to terminate the read.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied.
     */
    read_until_async(stop_chars: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of read_until_async

    /**
     * Promisified version of {@link read_until_async}
     * 
     * The asynchronous version of g_data_input_stream_read_until().
     * It is an error to have two outstanding calls to this function.
     * 
     * Note that, in contrast to g_data_input_stream_read_until(),
     * this function does not consume the stop character that it finds.  You
     * must read it for yourself.
     * 
     * When the operation is finished, `callback` will be called. You
     * can then call g_data_input_stream_read_until_finish() to get
     * the result of the operation.
     * 
     * Don't use this function in new code.  Its functionality is
     * inconsistent with g_data_input_stream_read_until().  Both functions
     * will be marked as deprecated in a future release.  Use
     * g_data_input_stream_read_upto_async() instead.
     * @param stop_chars characters to terminate the read.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
     */
    read_until_async(stop_chars: string | null, io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* length */ number>
    /**
     * Finish an asynchronous call started by
     * g_data_input_stream_read_until_async().
     * @param result the #GAsyncResult that was provided to the callback.
     * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
     */
    read_until_finish(result: AsyncResult): [ /* returnType */ string | null, /* length */ number ]
    /**
     * Reads a string from the data input stream, up to the first
     * occurrence of any of the stop characters.
     * 
     * In contrast to g_data_input_stream_read_until(), this function
     * does not consume the stop character. You have to use
     * g_data_input_stream_read_byte() to get it before calling
     * g_data_input_stream_read_upto() again.
     * 
     * Note that `stop_chars` may contain '\0' if `stop_chars_len` is
     * specified.
     * 
     * The returned string will always be nul-terminated on success.
     * @param stop_chars characters to terminate the read
     * @param stop_chars_len length of `stop_chars`. May be -1 if `stop_chars` is     nul-terminated
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error
     */
    read_upto(stop_chars: string | null, stop_chars_len: number, cancellable: Cancellable | null): [ /* returnType */ string | null, /* length */ number ]
    /**
     * The asynchronous version of g_data_input_stream_read_upto().
     * It is an error to have two outstanding calls to this function.
     * 
     * In contrast to g_data_input_stream_read_until(), this function
     * does not consume the stop character. You have to use
     * g_data_input_stream_read_byte() to get it before calling
     * g_data_input_stream_read_upto() again.
     * 
     * Note that `stop_chars` may contain '\0' if `stop_chars_len` is
     * specified.
     * 
     * When the operation is finished, `callback` will be called. You
     * can then call g_data_input_stream_read_upto_finish() to get
     * the result of the operation.
     * @param stop_chars characters to terminate the read
     * @param stop_chars_len length of `stop_chars`. May be -1 if `stop_chars` is     nul-terminated
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback callback to call when the request is satisfied
     */
    read_upto_async(stop_chars: string | null, stop_chars_len: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of read_upto_async

    /**
     * Promisified version of {@link read_upto_async}
     * 
     * The asynchronous version of g_data_input_stream_read_upto().
     * It is an error to have two outstanding calls to this function.
     * 
     * In contrast to g_data_input_stream_read_until(), this function
     * does not consume the stop character. You have to use
     * g_data_input_stream_read_byte() to get it before calling
     * g_data_input_stream_read_upto() again.
     * 
     * Note that `stop_chars` may contain '\0' if `stop_chars_len` is
     * specified.
     * 
     * When the operation is finished, `callback` will be called. You
     * can then call g_data_input_stream_read_upto_finish() to get
     * the result of the operation.
     * @param stop_chars characters to terminate the read
     * @param stop_chars_len length of `stop_chars`. May be -1 if `stop_chars` is     nul-terminated
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
     */
    read_upto_async(stop_chars: string | null, stop_chars_len: number, io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* length */ number>
    /**
     * Finish an asynchronous call started by
     * g_data_input_stream_read_upto_async().
     * 
     * Note that this function does not consume the stop character. You
     * have to use g_data_input_stream_read_byte() to get it before calling
     * g_data_input_stream_read_upto_async() again.
     * 
     * The returned string will always be nul-terminated on success.
     * @param result the #GAsyncResult that was provided to the callback
     * @returns a string with the data that was read     before encountering any of the stop characters. Set @length to     a #gsize to get the length of the string. This function will     return %NULL on an error.
     */
    read_upto_finish(result: AsyncResult): [ /* returnType */ string | null, /* length */ number ]
    /**
     * This function sets the byte order for the given `stream`. All subsequent
     * reads from the `stream` will be read in the given `order`.
     * @param order a #GDataStreamByteOrder to set.
     */
    set_byte_order(order: DataStreamByteOrder): void
    /**
     * Sets the newline type for the `stream`.
     * 
     * Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
     * chunk ends in "CR" we must read an additional byte to know if this is "CR" or
     * "CR LF", and this might block if there is no more data available.
     * @param type the type of new line return as #GDataStreamNewlineType.
     */
    set_newline_type(type: DataStreamNewlineType): void

    // Class property signals of Gio-2.0.Gio.DataInputStream

    connect(sigName: "notify::byte-order", callback: (($obj: DataInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::byte-order", callback: (($obj: DataInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::byte-order", ...args: any[]): void
    connect(sigName: "notify::newline-type", callback: (($obj: DataInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::newline-type", callback: (($obj: DataInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::newline-type", ...args: any[]): void
    connect(sigName: "notify::buffer-size", callback: (($obj: DataInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::buffer-size", callback: (($obj: DataInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::buffer-size", ...args: any[]): void
    connect(sigName: "notify::close-base-stream", callback: (($obj: DataInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-base-stream", callback: (($obj: DataInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-base-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Data input stream implements #GInputStream and includes functions for
 * reading structured data directly from a binary input stream.
 * @class 
 */
class DataInputStream extends BufferedInputStream {

    // Own properties of Gio-2.0.Gio.DataInputStream

    static name: string
    static $gtype: GObject.GType<DataInputStream>

    // Constructors of Gio-2.0.Gio.DataInputStream

    constructor(config?: DataInputStream.ConstructorProperties) 
    /**
     * Creates a new data input stream for the `base_stream`.
     * @constructor 
     * @param base_stream a #GInputStream.
     * @returns a new #GDataInputStream.
     */
    constructor(base_stream: InputStream) 
    /**
     * Creates a new data input stream for the `base_stream`.
     * @constructor 
     * @param base_stream a #GInputStream.
     * @returns a new #GDataInputStream.
     */
    static new(base_stream: InputStream): DataInputStream

    // Overloads of new

    /**
     * Creates a new #GInputStream from the given `base_stream,` with
     * a buffer set to the default size (4 kilobytes).
     * @constructor 
     * @param base_stream a #GInputStream
     * @returns a #GInputStream for the given @base_stream.
     */
    static new(base_stream: InputStream): BufferedInputStream
    _init(config?: DataInputStream.ConstructorProperties): void
}

module DataOutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends Seekable.ConstructorProperties, FilterOutputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DataOutputStream

        /**
         * Determines the byte ordering that is used when writing
         * multi-byte entities (such as integers) to the stream.
         */
        byte_order?: DataStreamByteOrder | null
    }

}

interface DataOutputStream extends Seekable {

    // Own properties of Gio-2.0.Gio.DataOutputStream

    /**
     * Determines the byte ordering that is used when writing
     * multi-byte entities (such as integers) to the stream.
     */
    byte_order: DataStreamByteOrder

    // Own fields of Gio-2.0.Gio.DataOutputStream

    parent_instance: FilterOutputStream & OutputStream & GObject.Object & GObject.Object

    // Owm methods of Gio-2.0.Gio.DataOutputStream

    /**
     * Gets the byte order for the stream.
     * @returns the #GDataStreamByteOrder for the @stream.
     */
    get_byte_order(): DataStreamByteOrder
    /**
     * Puts a byte into the output stream.
     * @param data a #guchar.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if @data was successfully added to the @stream.
     */
    put_byte(data: number, cancellable: Cancellable | null): boolean
    /**
     * Puts a signed 16-bit integer into the output stream.
     * @param data a #gint16.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if @data was successfully added to the @stream.
     */
    put_int16(data: number, cancellable: Cancellable | null): boolean
    /**
     * Puts a signed 32-bit integer into the output stream.
     * @param data a #gint32.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if @data was successfully added to the @stream.
     */
    put_int32(data: number, cancellable: Cancellable | null): boolean
    /**
     * Puts a signed 64-bit integer into the stream.
     * @param data a #gint64.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if @data was successfully added to the @stream.
     */
    put_int64(data: number, cancellable: Cancellable | null): boolean
    /**
     * Puts a string into the output stream.
     * @param str a string.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if @string was successfully added to the @stream.
     */
    put_string(str: string | null, cancellable: Cancellable | null): boolean
    /**
     * Puts an unsigned 16-bit integer into the output stream.
     * @param data a #guint16.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if @data was successfully added to the @stream.
     */
    put_uint16(data: number, cancellable: Cancellable | null): boolean
    /**
     * Puts an unsigned 32-bit integer into the stream.
     * @param data a #guint32.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if @data was successfully added to the @stream.
     */
    put_uint32(data: number, cancellable: Cancellable | null): boolean
    /**
     * Puts an unsigned 64-bit integer into the stream.
     * @param data a #guint64.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE if @data was successfully added to the @stream.
     */
    put_uint64(data: number, cancellable: Cancellable | null): boolean
    /**
     * Sets the byte order of the data output stream to `order`.
     * @param order a %GDataStreamByteOrder.
     */
    set_byte_order(order: DataStreamByteOrder): void

    // Class property signals of Gio-2.0.Gio.DataOutputStream

    connect(sigName: "notify::byte-order", callback: (($obj: DataOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::byte-order", callback: (($obj: DataOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::byte-order", ...args: any[]): void
    connect(sigName: "notify::close-base-stream", callback: (($obj: DataOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-base-stream", callback: (($obj: DataOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-base-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Data output stream implements #GOutputStream and includes functions for
 * writing data directly to an output stream.
 * @class 
 */
class DataOutputStream extends FilterOutputStream {

    // Own properties of Gio-2.0.Gio.DataOutputStream

    static name: string
    static $gtype: GObject.GType<DataOutputStream>

    // Constructors of Gio-2.0.Gio.DataOutputStream

    constructor(config?: DataOutputStream.ConstructorProperties) 
    /**
     * Creates a new data output stream for `base_stream`.
     * @constructor 
     * @param base_stream a #GOutputStream.
     * @returns #GDataOutputStream.
     */
    constructor(base_stream: OutputStream) 
    /**
     * Creates a new data output stream for `base_stream`.
     * @constructor 
     * @param base_stream a #GOutputStream.
     * @returns #GDataOutputStream.
     */
    static new(base_stream: OutputStream): DataOutputStream
    _init(config?: DataOutputStream.ConstructorProperties): void
}

module DebugControllerDBus {

    // Signal callback interfaces

    /**
     * Signal callback interface for `authorize`
     */
    interface AuthorizeSignalCallback {
        ($obj: DebugControllerDBus, invocation: DBusMethodInvocation): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends DebugController.ConstructorProperties, Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DebugControllerDBus

        /**
         * The D-Bus connection to expose the debugging interface on.
         * 
         * Typically this will be the same connection (to the system or session bus)
         * which the rest of the application or service’s D-Bus objects are registered
         * on.
         */
        connection?: DBusConnection | null
    }

}

interface DebugControllerDBus extends DebugController, Initable {

    // Own properties of Gio-2.0.Gio.DebugControllerDBus

    /**
     * The D-Bus connection to expose the debugging interface on.
     * 
     * Typically this will be the same connection (to the system or session bus)
     * which the rest of the application or service’s D-Bus objects are registered
     * on.
     */
    readonly connection: DBusConnection

    // Own fields of Gio-2.0.Gio.DebugControllerDBus

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.DebugControllerDBus

    /**
     * Stop the debug controller, unregistering its object from the bus.
     * 
     * Any pending method calls to the object will complete successfully, but new
     * ones will return an error. This method will block until all pending
     * #GDebugControllerDBus::authorize signals have been handled. This is expected
     * to not take long, as it will just be waiting for threads to join. If any
     * #GDebugControllerDBus::authorize signal handlers are still executing in other
     * threads, this will block until after they have returned.
     * 
     * This method will be called automatically when the final reference to the
     * #GDebugControllerDBus is dropped. You may want to call it explicitly to know
     * when the controller has been fully removed from the bus, or to break
     * reference count cycles.
     * 
     * Calling this method from within a #GDebugControllerDBus::authorize signal
     * handler will cause a deadlock and must not be done.
     */
    stop(): void

    // Own virtual methods of Gio-2.0.Gio.DebugControllerDBus

    vfunc_authorize(invocation: DBusMethodInvocation): boolean

    // Own signals of Gio-2.0.Gio.DebugControllerDBus

    connect(sigName: "authorize", callback: DebugControllerDBus.AuthorizeSignalCallback): number
    connect_after(sigName: "authorize", callback: DebugControllerDBus.AuthorizeSignalCallback): number
    emit(sigName: "authorize", invocation: DBusMethodInvocation, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.DebugControllerDBus

    connect(sigName: "notify::connection", callback: (($obj: DebugControllerDBus, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: (($obj: DebugControllerDBus, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::connection", ...args: any[]): void
    connect(sigName: "notify::debug-enabled", callback: (($obj: DebugControllerDBus, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::debug-enabled", callback: (($obj: DebugControllerDBus, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::debug-enabled", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDebugControllerDBus is an implementation of #GDebugController which exposes
 * debug settings as a D-Bus object.
 * 
 * It is a #GInitable object, and will register an object at
 * `/org/gtk/Debugging` on the bus given as
 * #GDebugControllerDBus:connection once it’s initialized. The object will be
 * unregistered when the last reference to the #GDebugControllerDBus is dropped.
 * 
 * This D-Bus object can be used by remote processes to enable or disable debug
 * output in this process. Remote processes calling
 * `org.gtk.Debugging.SetDebugEnabled()` will affect the value of
 * #GDebugController:debug-enabled and, by default, g_log_get_debug_enabled().
 * default.
 * 
 * By default, all processes will be able to call `SetDebugEnabled()`. If this
 * process is privileged, or might expose sensitive information in its debug
 * output, you may want to restrict the ability to enable debug output to
 * privileged users or processes.
 * 
 * One option is to install a D-Bus security policy which restricts access to
 * `SetDebugEnabled()`, installing something like the following in
 * `$datadir/dbus-1/system.d/`:
 * 
 * ```<!-- language="XML" -->
 * <?xml version="1.0"?> <!--*-nxml-*-->
 * <!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN"
 *      "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
 * <busconfig>
 *   <policy user="root">
 *     <allow send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
 *   </policy>
 *   <policy context="default">
 *     <deny send_destination="com.example.MyService" send_interface="org.gtk.Debugging"/>
 *   </policy>
 * </busconfig>
 * ```
 * 
 * 
 * This will prevent the `SetDebugEnabled()` method from being called by all
 * except root. It will not prevent the `DebugEnabled` property from being read,
 * as it’s accessed through the `org.freedesktop.DBus.Properties` interface.
 * 
 * Another option is to use polkit to allow or deny requests on a case-by-case
 * basis, allowing for the possibility of dynamic authorisation. To do this,
 * connect to the #GDebugControllerDBus::authorize signal and query polkit in
 * it:
 * 
 * ```c
 *   g_autoptr(GError) child_error = NULL;
 *   g_autoptr(GDBusConnection) connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);
 *   gulong debug_controller_authorize_id = 0;
 * 
 *   // Set up the debug controller.
 *   debug_controller = G_DEBUG_CONTROLLER (g_debug_controller_dbus_new (priv->connection, NULL, &child_error));
 *   if (debug_controller == NULL)
 *     {
 *       g_error ("Could not register debug controller on bus: %s"),
 *                child_error->message);
 *     }
 * 
 *   debug_controller_authorize_id = g_signal_connect (debug_controller,
 *                                                     "authorize",
 *                                                     G_CALLBACK (debug_controller_authorize_cb),
 *                                                     self);
 * 
 *   static gboolean
 *   debug_controller_authorize_cb (GDebugControllerDBus  *debug_controller,
 *                                  GDBusMethodInvocation *invocation,
 *                                  gpointer               user_data)
 *   {
 *     g_autoptr(PolkitAuthority) authority = NULL;
 *     g_autoptr(PolkitSubject) subject = NULL;
 *     g_autoptr(PolkitAuthorizationResult) auth_result = NULL;
 *     g_autoptr(GError) local_error = NULL;
 *     GDBusMessage *message;
 *     GDBusMessageFlags message_flags;
 *     PolkitCheckAuthorizationFlags flags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;
 * 
 *     message = g_dbus_method_invocation_get_message (invocation);
 *     message_flags = g_dbus_message_get_flags (message);
 * 
 *     authority = polkit_authority_get_sync (NULL, &local_error);
 *     if (authority == NULL)
 *       {
 *         g_warning ("Failed to get polkit authority: %s", local_error->message);
 *         return FALSE;
 *       }
 * 
 *     if (message_flags & G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION)
 *       flags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;
 * 
 *     subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (invocation));
 * 
 *     auth_result = polkit_authority_check_authorization_sync (authority,
 *                                                              subject,
 *                                                              "com.example.MyService.set-debug-enabled",
 *                                                              NULL,
 *                                                              flags,
 *                                                              NULL,
 *                                                              &local_error);
 *     if (auth_result == NULL)
 *       {
 *         g_warning ("Failed to get check polkit authorization: %s", local_error->message);
 *         return FALSE;
 *       }
 * 
 *     return polkit_authorization_result_get_is_authorized (auth_result);
 *   }
 * ```
 * 
 * @class 
 */
class DebugControllerDBus extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DebugControllerDBus

    static name: string
    static $gtype: GObject.GType<DebugControllerDBus>

    // Constructors of Gio-2.0.Gio.DebugControllerDBus

    constructor(config?: DebugControllerDBus.ConstructorProperties) 
    /**
     * Create a new #GDebugControllerDBus and synchronously initialize it.
     * 
     * Initializing the object will export the debug object on `connection`. The
     * object will remain registered until the last reference to the
     * #GDebugControllerDBus is dropped.
     * 
     * Initialization may fail if registering the object on `connection` fails.
     * @constructor 
     * @param connection a #GDBusConnection to register the debug object on
     * @param cancellable a #GCancellable, or %NULL
     * @returns a new #GDebugControllerDBus, or %NULL   on failure
     */
    constructor(connection: DBusConnection, cancellable: Cancellable | null) 
    /**
     * Create a new #GDebugControllerDBus and synchronously initialize it.
     * 
     * Initializing the object will export the debug object on `connection`. The
     * object will remain registered until the last reference to the
     * #GDebugControllerDBus is dropped.
     * 
     * Initialization may fail if registering the object on `connection` fails.
     * @constructor 
     * @param connection a #GDBusConnection to register the debug object on
     * @param cancellable a #GCancellable, or %NULL
     * @returns a new #GDebugControllerDBus, or %NULL   on failure
     */
    static new(connection: DBusConnection, cancellable: Cancellable | null): DebugControllerDBus
    _init(config?: DebugControllerDBus.ConstructorProperties): void
}

module DesktopAppInfo {

    // Constructor properties interface

    interface ConstructorProperties extends AppInfo.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.DesktopAppInfo

        /**
         * The origin filename of this #GDesktopAppInfo
         */
        filename?: string | null
    }

}

interface DesktopAppInfo extends AppInfo {

    // Own properties of Gio-2.0.Gio.DesktopAppInfo

    /**
     * The origin filename of this #GDesktopAppInfo
     */
    readonly filename: string | null

    // Owm methods of Gio-2.0.Gio.DesktopAppInfo

    /**
     * Gets the user-visible display name of the "additional application
     * action" specified by `action_name`.
     * 
     * This corresponds to the "Name" key within the keyfile group for the
     * action.
     * @param action_name the name of the action as from   g_desktop_app_info_list_actions()
     * @returns the locale-specific action name
     */
    get_action_name(action_name: string | null): string | null
    /**
     * Looks up a boolean value in the keyfile backing `info`.
     * 
     * The `key` is looked up in the "Desktop Entry" group.
     * @param key the key to look up
     * @returns the boolean value, or %FALSE if the key     is not found
     */
    get_boolean(key: string | null): boolean
    /**
     * Gets the categories from the desktop file.
     * @returns The unparsed Categories key from the desktop file;     i.e. no attempt is made to split it by ';' or validate it.
     */
    get_categories(): string | null
    /**
     * When `info` was created from a known filename, return it.  In some
     * situations such as the #GDesktopAppInfo returned from
     * g_desktop_app_info_new_from_keyfile(), this function will return %NULL.
     * @returns The full path to the file for @info,     or %NULL if not known.
     */
    get_filename(): string | null
    /**
     * Gets the generic name from the desktop file.
     * @returns The value of the GenericName key
     */
    get_generic_name(): string | null
    /**
     * A desktop file is hidden if the Hidden key in it is
     * set to True.
     * @returns %TRUE if hidden, %FALSE otherwise.
     */
    get_is_hidden(): boolean
    /**
     * Gets the keywords from the desktop file.
     * @returns The value of the Keywords key
     */
    get_keywords(): string[]
    /**
     * Looks up a localized string value in the keyfile backing `info`
     * translated to the current locale.
     * 
     * The `key` is looked up in the "Desktop Entry" group.
     * @param key the key to look up
     * @returns a newly allocated string, or %NULL if the key     is not found
     */
    get_locale_string(key: string | null): string | null
    /**
     * Gets the value of the NoDisplay key, which helps determine if the
     * application info should be shown in menus. See
     * %G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY and g_app_info_should_show().
     * @returns The value of the NoDisplay key
     */
    get_nodisplay(): boolean
    /**
     * Checks if the application info should be shown in menus that list available
     * applications for a specific name of the desktop, based on the
     * `OnlyShowIn` and `NotShowIn` keys.
     * 
     * `desktop_env` should typically be given as %NULL, in which case the
     * `XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
     * to override the default mechanism then you may specify `desktop_env,`
     * but this is not recommended.
     * 
     * Note that g_app_info_should_show() for `info` will include this check (with
     * %NULL for `desktop_env)` as well as additional checks.
     * @param desktop_env a string specifying a desktop name
     * @returns %TRUE if the @info should be shown in @desktop_env according to the `OnlyShowIn` and `NotShowIn` keys, %FALSE otherwise.
     */
    get_show_in(desktop_env: string | null): boolean
    /**
     * Retrieves the StartupWMClass field from `info`. This represents the
     * WM_CLASS property of the main window of the application, if launched
     * through `info`.
     * @returns the startup WM class, or %NULL if none is set in the desktop file.
     */
    get_startup_wm_class(): string | null
    /**
     * Looks up a string value in the keyfile backing `info`.
     * 
     * The `key` is looked up in the "Desktop Entry" group.
     * @param key the key to look up
     * @returns a newly allocated string, or %NULL if the key     is not found
     */
    get_string(key: string | null): string | null
    /**
     * Looks up a string list value in the keyfile backing `info`.
     * 
     * The `key` is looked up in the "Desktop Entry" group.
     * @param key the key to look up
     * @returns   a %NULL-terminated string array or %NULL if the specified  key cannot be found. The array should be freed with g_strfreev().
     */
    get_string_list(key: string | null): string[]
    /**
     * Returns whether `key` exists in the "Desktop Entry" group
     * of the keyfile backing `info`.
     * @param key the key to look up
     * @returns %TRUE if the @key exists
     */
    has_key(key: string | null): boolean
    /**
     * Activates the named application action.
     * 
     * You may only call this function on action names that were
     * returned from g_desktop_app_info_list_actions().
     * 
     * Note that if the main entry of the desktop file indicates that the
     * application supports startup notification, and `launch_context` is
     * non-%NULL, then startup notification will be used when activating the
     * action (and as such, invocation of the action on the receiving side
     * must signal the end of startup notification when it is completed).
     * This is the expected behaviour of applications declaring additional
     * actions, as per the desktop file specification.
     * 
     * As with g_app_info_launch() there is no way to detect failures that
     * occur while using this function.
     * @param action_name the name of the action as from   g_desktop_app_info_list_actions()
     * @param launch_context a #GAppLaunchContext
     */
    launch_action(action_name: string | null, launch_context: AppLaunchContext | null): void
    /**
     * This function performs the equivalent of g_app_info_launch_uris(),
     * but is intended primarily for operating system components that
     * launch applications.  Ordinary applications should use
     * g_app_info_launch_uris().
     * 
     * If the application is launched via GSpawn, then `spawn_flags,` `user_setup`
     * and `user_setup_data` are used for the call to g_spawn_async().
     * Additionally, `pid_callback` (with `pid_callback_data)` will be called to
     * inform about the PID of the created process. See g_spawn_async_with_pipes()
     * for information on certain parameter conditions that can enable an
     * optimized posix_spawn() codepath to be used.
     * 
     * If application launching occurs via some other mechanism (eg: D-Bus
     * activation) then `spawn_flags,` `user_setup,` `user_setup_data,`
     * `pid_callback` and `pid_callback_data` are ignored.
     * @param uris List of URIs
     * @param launch_context a #GAppLaunchContext
     * @param spawn_flags #GSpawnFlags, used for each process
     * @returns %TRUE on successful launch, %FALSE otherwise.
     */
    launch_uris_as_manager(uris: string[], launch_context: AppLaunchContext | null, spawn_flags: GLib.SpawnFlags): boolean
    /**
     * Equivalent to g_desktop_app_info_launch_uris_as_manager() but allows
     * you to pass in file descriptors for the stdin, stdout and stderr streams
     * of the launched process.
     * 
     * If application launching occurs via some non-spawn mechanism (e.g. D-Bus
     * activation) then `stdin_fd,` `stdout_fd` and `stderr_fd` are ignored.
     * @param uris List of URIs
     * @param launch_context a #GAppLaunchContext
     * @param spawn_flags #GSpawnFlags, used for each process
     * @param user_setup a #GSpawnChildSetupFunc, used once     for each process.
     * @param pid_callback Callback for child processes
     * @param stdin_fd file descriptor to use for child's stdin, or -1
     * @param stdout_fd file descriptor to use for child's stdout, or -1
     * @param stderr_fd file descriptor to use for child's stderr, or -1
     * @returns %TRUE on successful launch, %FALSE otherwise.
     */
    launch_uris_as_manager_with_fds(uris: string[], launch_context: AppLaunchContext | null, spawn_flags: GLib.SpawnFlags, user_setup: GLib.SpawnChildSetupFunc | null, pid_callback: DesktopAppLaunchCallback | null, stdin_fd: number, stdout_fd: number, stderr_fd: number): boolean
    /**
     * Returns the list of "additional application actions" supported on the
     * desktop file, as per the desktop file specification.
     * 
     * As per the specification, this is the list of actions that are
     * explicitly listed in the "Actions" key of the [Desktop Entry] group.
     * @returns a list of strings, always non-%NULL
     */
    list_actions(): string[]

    // Class property signals of Gio-2.0.Gio.DesktopAppInfo

    connect(sigName: "notify::filename", callback: (($obj: DesktopAppInfo, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename", callback: (($obj: DesktopAppInfo, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::filename", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GDesktopAppInfo is an implementation of #GAppInfo based on
 * desktop files.
 * 
 * Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific
 * GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
 * file when using it.
 * @class 
 */
class DesktopAppInfo extends GObject.Object {

    // Own properties of Gio-2.0.Gio.DesktopAppInfo

    static name: string
    static $gtype: GObject.GType<DesktopAppInfo>

    // Constructors of Gio-2.0.Gio.DesktopAppInfo

    constructor(config?: DesktopAppInfo.ConstructorProperties) 
    /**
     * Creates a new #GDesktopAppInfo based on a desktop file id.
     * 
     * A desktop file id is the basename of the desktop file, including the
     * .desktop extension. GIO is looking for a desktop file with this name
     * in the `applications` subdirectories of the XDG
     * data directories (i.e. the directories specified in the `XDG_DATA_HOME`
     * and `XDG_DATA_DIRS` environment variables). GIO also supports the
     * prefix-to-subdirectory mapping that is described in the
     * [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
     * (i.e. a desktop id of kde-foo.desktop will match
     * `/usr/share/applications/kde/foo.desktop`).
     * @constructor 
     * @param desktop_id the desktop file id
     * @returns a new #GDesktopAppInfo, or %NULL if no desktop     file with that id exists.
     */
    constructor(desktop_id: string | null) 
    /**
     * Creates a new #GDesktopAppInfo based on a desktop file id.
     * 
     * A desktop file id is the basename of the desktop file, including the
     * .desktop extension. GIO is looking for a desktop file with this name
     * in the `applications` subdirectories of the XDG
     * data directories (i.e. the directories specified in the `XDG_DATA_HOME`
     * and `XDG_DATA_DIRS` environment variables). GIO also supports the
     * prefix-to-subdirectory mapping that is described in the
     * [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
     * (i.e. a desktop id of kde-foo.desktop will match
     * `/usr/share/applications/kde/foo.desktop`).
     * @constructor 
     * @param desktop_id the desktop file id
     * @returns a new #GDesktopAppInfo, or %NULL if no desktop     file with that id exists.
     */
    static new(desktop_id: string | null): DesktopAppInfo
    /**
     * Creates a new #GDesktopAppInfo.
     * @constructor 
     * @param filename the path of a desktop file, in the GLib      filename encoding
     * @returns a new #GDesktopAppInfo or %NULL on error.
     */
    static new_from_filename(filename: string): DesktopAppInfo
    /**
     * Creates a new #GDesktopAppInfo.
     * @constructor 
     * @param key_file an opened #GKeyFile
     * @returns a new #GDesktopAppInfo or %NULL on error.
     */
    static new_from_keyfile(key_file: GLib.KeyFile): DesktopAppInfo
    _init(config?: DesktopAppInfo.ConstructorProperties): void
    /**
     * Gets all applications that implement `interface`.
     * 
     * An application implements an interface if that interface is listed in
     * the Implements= line of the desktop file of the application.
     * @param interface the name of the interface
     * @returns a list of #GDesktopAppInfo objects.
     */
    static get_implementations(interface: string | null): DesktopAppInfo[]
    /**
     * Searches desktop files for ones that match `search_string`.
     * 
     * The return value is an array of strvs.  Each strv contains a list of
     * applications that matched `search_string` with an equal score.  The
     * outer list is sorted by score so that the first strv contains the
     * best-matching applications, and so on.
     * The algorithm for determining matches is undefined and may change at
     * any time.
     * 
     * None of the search results are subjected to the normal validation
     * checks performed by g_desktop_app_info_new() (for example, checking that
     * the executable referenced by a result exists), and so it is possible for
     * g_desktop_app_info_new() to return %NULL when passed an app ID returned by
     * this function. It is expected that calling code will do this when
     * subsequently creating a #GDesktopAppInfo for each result.
     * @param search_string the search string to use
     * @returns a   list of strvs.  Free each item with g_strfreev() and free the outer   list with g_free().
     */
    static search(search_string: string | null): string[]
    /**
     * Sets the name of the desktop that the application is running in.
     * This is used by g_app_info_should_show() and
     * g_desktop_app_info_get_show_in() to evaluate the
     * `OnlyShowIn` and `NotShowIn`
     * desktop entry fields.
     * 
     * Should be called only once; subsequent calls are ignored.
     * @param desktop_env a string specifying what desktop this is
     */
    static set_desktop_env(desktop_env: string | null): void
}

module Emblem {

    // Constructor properties interface

    interface ConstructorProperties extends Icon.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.Emblem

        icon?: GObject.Object | null
        origin?: EmblemOrigin | null
    }

}

interface Emblem extends Icon {

    // Own properties of Gio-2.0.Gio.Emblem

    readonly icon: GObject.Object
    readonly origin: EmblemOrigin

    // Owm methods of Gio-2.0.Gio.Emblem

    /**
     * Gives back the icon from `emblem`.
     * @returns a #GIcon. The returned object belongs to          the emblem and should not be modified or freed.
     */
    get_icon(): Icon
    /**
     * Gets the origin of the emblem.
     * @returns the origin of the emblem
     */
    get_origin(): EmblemOrigin

    // Class property signals of Gio-2.0.Gio.Emblem

    connect(sigName: "notify::icon", callback: (($obj: Emblem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon", callback: (($obj: Emblem, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::origin", callback: (($obj: Emblem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::origin", callback: (($obj: Emblem, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::origin", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GEmblem is an implementation of #GIcon that supports
 * having an emblem, which is an icon with additional properties.
 * It can than be added to a #GEmblemedIcon.
 * 
 * Currently, only metainformation about the emblem's origin is
 * supported. More may be added in the future.
 * @class 
 */
class Emblem extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Emblem

    static name: string
    static $gtype: GObject.GType<Emblem>

    // Constructors of Gio-2.0.Gio.Emblem

    constructor(config?: Emblem.ConstructorProperties) 
    /**
     * Creates a new emblem for `icon`.
     * @constructor 
     * @param icon a GIcon containing the icon.
     * @returns a new #GEmblem.
     */
    constructor(icon: Icon) 
    /**
     * Creates a new emblem for `icon`.
     * @constructor 
     * @param icon a GIcon containing the icon.
     * @returns a new #GEmblem.
     */
    static new(icon: Icon): Emblem
    /**
     * Creates a new emblem for `icon`.
     * @constructor 
     * @param icon a GIcon containing the icon.
     * @param origin a GEmblemOrigin enum defining the emblem's origin
     * @returns a new #GEmblem.
     */
    static new_with_origin(icon: Icon, origin: EmblemOrigin): Emblem
    _init(config?: Emblem.ConstructorProperties): void
}

module EmblemedIcon {

    // Constructor properties interface

    interface ConstructorProperties extends Icon.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.EmblemedIcon

        gicon?: Icon | null
    }

}

interface EmblemedIcon extends Icon {

    // Own properties of Gio-2.0.Gio.EmblemedIcon

    readonly gicon: Icon

    // Own fields of Gio-2.0.Gio.EmblemedIcon

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.EmblemedIcon

    /**
     * Adds `emblem` to the #GList of #GEmblems.
     * @param emblem a #GEmblem
     */
    add_emblem(emblem: Emblem): void
    /**
     * Removes all the emblems from `icon`.
     */
    clear_emblems(): void
    /**
     * Gets the list of emblems for the `icon`.
     * @returns a #GList of     #GEmblems that is owned by @emblemed
     */
    get_emblems(): Emblem[]
    /**
     * Gets the main icon for `emblemed`.
     * @returns a #GIcon that is owned by @emblemed
     */
    get_icon(): Icon

    // Class property signals of Gio-2.0.Gio.EmblemedIcon

    connect(sigName: "notify::gicon", callback: (($obj: EmblemedIcon, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::gicon", callback: (($obj: EmblemedIcon, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::gicon", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GEmblemedIcon is an implementation of #GIcon that supports
 * adding an emblem to an icon. Adding multiple emblems to an
 * icon is ensured via g_emblemed_icon_add_emblem().
 * 
 * Note that #GEmblemedIcon allows no control over the position
 * of the emblems. See also #GEmblem for more information.
 * @class 
 */
class EmblemedIcon extends GObject.Object {

    // Own properties of Gio-2.0.Gio.EmblemedIcon

    static name: string
    static $gtype: GObject.GType<EmblemedIcon>

    // Constructors of Gio-2.0.Gio.EmblemedIcon

    constructor(config?: EmblemedIcon.ConstructorProperties) 
    /**
     * Creates a new emblemed icon for `icon` with the emblem `emblem`.
     * @constructor 
     * @param icon a #GIcon
     * @param emblem a #GEmblem, or %NULL
     * @returns a new #GIcon
     */
    constructor(icon: Icon, emblem: Emblem | null) 
    /**
     * Creates a new emblemed icon for `icon` with the emblem `emblem`.
     * @constructor 
     * @param icon a #GIcon
     * @param emblem a #GEmblem, or %NULL
     * @returns a new #GIcon
     */
    static new(icon: Icon, emblem: Emblem | null): EmblemedIcon
    _init(config?: EmblemedIcon.ConstructorProperties): void
}

module FileEnumerator {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.FileEnumerator

        container?: File | null
    }

}

interface FileEnumerator {

    // Own properties of Gio-2.0.Gio.FileEnumerator

    readonly container: File

    // Own fields of Gio-2.0.Gio.FileEnumerator

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.FileEnumerator

    /**
     * Releases all resources used by this enumerator, making the
     * enumerator return %G_IO_ERROR_CLOSED on all calls.
     * 
     * This will be automatically called when the last reference
     * is dropped, but you might want to call this function to make
     * sure resources are released as early as possible.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns #TRUE on success or #FALSE on error.
     */
    close(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously closes the file enumerator.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
     * g_file_enumerator_close_finish().
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of close_async

    /**
     * Promisified version of {@link close_async}
     * 
     * Asynchronously closes the file enumerator.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
     * g_file_enumerator_close_finish().
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: %TRUE if the close operation has finished successfully.
     */
    close_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes closing a file enumerator, started from g_file_enumerator_close_async().
     * 
     * If the file enumerator was already closed when g_file_enumerator_close_async()
     * was called, then this function will report %G_IO_ERROR_CLOSED in `error,` and
     * return %FALSE. If the file enumerator had pending operation when the close
     * operation was started, then this function will report %G_IO_ERROR_PENDING, and
     * return %FALSE.  If `cancellable` was not %NULL, then the operation may have been
     * cancelled by triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
     * returned.
     * @param result a #GAsyncResult.
     * @returns %TRUE if the close operation has finished successfully.
     */
    close_finish(result: AsyncResult): boolean
    /**
     * Return a new #GFile which refers to the file named by `info` in the source
     * directory of `enumerator`.  This function is primarily intended to be used
     * inside loops with g_file_enumerator_next_file().
     * 
     * To use this, %G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
     * attributes list used when creating the #GFileEnumerator.
     * 
     * This is a convenience method that's equivalent to:
     * 
     * ```c
     *   gchar *name = g_file_info_get_name (info);
     *   GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
     *                                    name);
     * ```
     * 
     * @param info a #GFileInfo gotten from g_file_enumerator_next_file()   or the async equivalents.
     * @returns a #GFile for the #GFileInfo passed it.
     */
    get_child(info: FileInfo): File
    /**
     * Get the #GFile container which is being enumerated.
     * @returns the #GFile which is being enumerated.
     */
    get_container(): File
    /**
     * Checks if the file enumerator has pending operations.
     * @returns %TRUE if the @enumerator has pending operations.
     */
    has_pending(): boolean
    /**
     * Checks if the file enumerator has been closed.
     * @returns %TRUE if the @enumerator is closed.
     */
    is_closed(): boolean
    /**
     * This is a version of g_file_enumerator_next_file() that's easier to
     * use correctly from C programs.  With g_file_enumerator_next_file(),
     * the gboolean return value signifies "end of iteration or error", which
     * requires allocation of a temporary #GError.
     * 
     * In contrast, with this function, a %FALSE return from
     * g_file_enumerator_iterate() *always* means
     * "error".  End of iteration is signaled by `out_info` or `out_child` being %NULL.
     * 
     * Another crucial difference is that the references for `out_info` and
     * `out_child` are owned by `direnum` (they are cached as hidden
     * properties).  You must not unref them in your own code.  This makes
     * memory management significantly easier for C code in combination
     * with loops.
     * 
     * Finally, this function optionally allows retrieving a #GFile as
     * well.
     * 
     * You must specify at least one of `out_info` or `out_child`.
     * 
     * The code pattern for correctly using g_file_enumerator_iterate() from C
     * is:
     * 
     * 
     * ```
     * direnum = g_file_enumerate_children (file, ...);
     * while (TRUE)
     *   {
     *     GFileInfo *info;
     *     if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
     *       goto out;
     *     if (!info)
     *       break;
     *     ... do stuff with "info"; do not unref it! ...
     *   }
     * 
     * out:
     *   g_object_unref (direnum); // Note: frees the last `info`
     * ```
     * 
     * @param cancellable a #GCancellable
     */
    iterate(cancellable: Cancellable | null): [ /* returnType */ boolean, /* out_info */ FileInfo, /* out_child */ File ]
    /**
     * Returns information for the next file in the enumerated object.
     * Will block until the information is available. The #GFileInfo
     * returned from this function will contain attributes that match the
     * attribute string that was passed when the #GFileEnumerator was created.
     * 
     * See the documentation of #GFileEnumerator for information about the
     * order of returned files.
     * 
     * On error, returns %NULL and sets `error` to the error. If the
     * enumerator is at the end, %NULL will be returned and `error` will
     * be unset.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A #GFileInfo or %NULL on error    or end of enumerator.  Free the returned object with    g_object_unref() when no longer needed.
     */
    next_file(cancellable: Cancellable | null): FileInfo | null
    /**
     * Request information for a number of files from the enumerator asynchronously.
     * When all i/o for the operation is finished the `callback` will be called with
     * the requested information.
     * 
     * See the documentation of #GFileEnumerator for information about the
     * order of returned files.
     * 
     * The callback can be called with less than `num_files` files in case of error
     * or at the end of the enumerator. In case of a partial error the callback will
     * be called with any succeeding items and no error, and on the next request the
     * error will be reported. If a request is cancelled the callback will be called
     * with %G_IO_ERROR_CANCELLED.
     * 
     * During an async request no other sync and async calls are allowed, and will
     * result in %G_IO_ERROR_PENDING errors.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value) will
     * be executed before an outstanding request with lower priority. Default
     * priority is %G_PRIORITY_DEFAULT.
     * @param num_files the number of file info objects to request
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    next_files_async(num_files: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of next_files_async

    /**
     * Promisified version of {@link next_files_async}
     * 
     * Request information for a number of files from the enumerator asynchronously.
     * When all i/o for the operation is finished the `callback` will be called with
     * the requested information.
     * 
     * See the documentation of #GFileEnumerator for information about the
     * order of returned files.
     * 
     * The callback can be called with less than `num_files` files in case of error
     * or at the end of the enumerator. In case of a partial error the callback will
     * be called with any succeeding items and no error, and on the next request the
     * error will be reported. If a request is cancelled the callback will be called
     * with %G_IO_ERROR_CANCELLED.
     * 
     * During an async request no other sync and async calls are allowed, and will
     * result in %G_IO_ERROR_PENDING errors.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value) will
     * be executed before an outstanding request with lower priority. Default
     * priority is %G_PRIORITY_DEFAULT.
     * @param num_files the number of file info objects to request
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: a #GList of #GFileInfos. You must free the list with     g_list_free() and unref the infos with g_object_unref() when you're     done with them.
     */
    next_files_async(num_files: number, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileInfo[]>
    /**
     * Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
     * @param result a #GAsyncResult.
     * @returns a #GList of #GFileInfos. You must free the list with     g_list_free() and unref the infos with g_object_unref() when you're     done with them.
     */
    next_files_finish(result: AsyncResult): FileInfo[]
    /**
     * Sets the file enumerator as having pending operations.
     * @param pending a boolean value.
     */
    set_pending(pending: boolean): void

    // Own virtual methods of Gio-2.0.Gio.FileEnumerator

    /**
     * Asynchronously closes the file enumerator.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
     * g_file_enumerator_close_finish().
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    vfunc_close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes closing a file enumerator, started from g_file_enumerator_close_async().
     * 
     * If the file enumerator was already closed when g_file_enumerator_close_async()
     * was called, then this function will report %G_IO_ERROR_CLOSED in `error,` and
     * return %FALSE. If the file enumerator had pending operation when the close
     * operation was started, then this function will report %G_IO_ERROR_PENDING, and
     * return %FALSE.  If `cancellable` was not %NULL, then the operation may have been
     * cancelled by triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
     * returned.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the close operation has finished successfully.
     */
    vfunc_close_finish(result: AsyncResult): boolean
    vfunc_close_fn(cancellable: Cancellable | null): boolean
    /**
     * Returns information for the next file in the enumerated object.
     * Will block until the information is available. The #GFileInfo
     * returned from this function will contain attributes that match the
     * attribute string that was passed when the #GFileEnumerator was created.
     * 
     * See the documentation of #GFileEnumerator for information about the
     * order of returned files.
     * 
     * On error, returns %NULL and sets `error` to the error. If the
     * enumerator is at the end, %NULL will be returned and `error` will
     * be unset.
     * @virtual 
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A #GFileInfo or %NULL on error    or end of enumerator.  Free the returned object with    g_object_unref() when no longer needed.
     */
    vfunc_next_file(cancellable: Cancellable | null): FileInfo | null
    /**
     * Request information for a number of files from the enumerator asynchronously.
     * When all i/o for the operation is finished the `callback` will be called with
     * the requested information.
     * 
     * See the documentation of #GFileEnumerator for information about the
     * order of returned files.
     * 
     * The callback can be called with less than `num_files` files in case of error
     * or at the end of the enumerator. In case of a partial error the callback will
     * be called with any succeeding items and no error, and on the next request the
     * error will be reported. If a request is cancelled the callback will be called
     * with %G_IO_ERROR_CANCELLED.
     * 
     * During an async request no other sync and async calls are allowed, and will
     * result in %G_IO_ERROR_PENDING errors.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value) will
     * be executed before an outstanding request with lower priority. Default
     * priority is %G_PRIORITY_DEFAULT.
     * @virtual 
     * @param num_files the number of file info objects to request
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    vfunc_next_files_async(num_files: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns a #GList of #GFileInfos. You must free the list with     g_list_free() and unref the infos with g_object_unref() when you're     done with them.
     */
    vfunc_next_files_finish(result: AsyncResult): FileInfo[]

    // Class property signals of Gio-2.0.Gio.FileEnumerator

    connect(sigName: "notify::container", callback: (($obj: FileEnumerator, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::container", callback: (($obj: FileEnumerator, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::container", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GFileEnumerator allows you to operate on a set of #GFiles,
 * returning a #GFileInfo structure for each file enumerated (e.g.
 * g_file_enumerate_children() will return a #GFileEnumerator for each
 * of the children within a directory).
 * 
 * To get the next file's information from a #GFileEnumerator, use
 * g_file_enumerator_next_file() or its asynchronous version,
 * g_file_enumerator_next_files_async(). Note that the asynchronous
 * version will return a list of #GFileInfos, whereas the
 * synchronous will only return the next file in the enumerator.
 * 
 * The ordering of returned files is unspecified for non-Unix
 * platforms; for more information, see g_dir_read_name().  On Unix,
 * when operating on local files, returned files will be sorted by
 * inode number.  Effectively you can assume that the ordering of
 * returned files will be stable between successive calls (and
 * applications) assuming the directory is unchanged.
 * 
 * If your application needs a specific ordering, such as by name or
 * modification time, you will have to implement that in your
 * application code.
 * 
 * To close a #GFileEnumerator, use g_file_enumerator_close(), or
 * its asynchronous version, g_file_enumerator_close_async(). Once
 * a #GFileEnumerator is closed, no further actions may be performed
 * on it, and it should be freed with g_object_unref().
 * @class 
 */
class FileEnumerator extends GObject.Object {

    // Own properties of Gio-2.0.Gio.FileEnumerator

    static name: string
    static $gtype: GObject.GType<FileEnumerator>

    // Constructors of Gio-2.0.Gio.FileEnumerator

    constructor(config?: FileEnumerator.ConstructorProperties) 
    _init(config?: FileEnumerator.ConstructorProperties): void
}

module FileIOStream {

    // Constructor properties interface

    interface ConstructorProperties extends Seekable.ConstructorProperties, IOStream.ConstructorProperties {
    }

}

interface FileIOStream extends Seekable {

    // Own fields of Gio-2.0.Gio.FileIOStream

    parent_instance: IOStream & GObject.Object

    // Owm methods of Gio-2.0.Gio.FileIOStream

    /**
     * Gets the entity tag for the file when it has been written.
     * This must be called after the stream has been written
     * and closed, as the etag can change while writing.
     * @returns the entity tag for the stream.
     */
    get_etag(): string | null
    /**
     * Queries a file io stream for the given `attributes`.
     * This function blocks while querying the stream. For the asynchronous
     * version of this function, see g_file_io_stream_query_info_async().
     * While the stream is blocked, the stream will set the pending flag
     * internally, and any other operations on the stream will fail with
     * %G_IO_ERROR_PENDING.
     * 
     * Can fail if the stream was already closed (with `error` being set to
     * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
     * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
     * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). I
     * all cases of failure, %NULL will be returned.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
     * be returned.
     * @param attributes a file attribute query string.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GFileInfo for the @stream, or %NULL on error.
     */
    query_info(attributes: string | null, cancellable: Cancellable | null): FileInfo
    /**
     * Asynchronously queries the `stream` for a #GFileInfo. When completed,
     * `callback` will be called with a #GAsyncResult which can be used to
     * finish the operation with g_file_io_stream_query_info_finish().
     * 
     * For the synchronous version of this function, see
     * g_file_io_stream_query_info().
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of query_info_async

    /**
     * Promisified version of {@link query_info_async}
     * 
     * Asynchronously queries the `stream` for a #GFileInfo. When completed,
     * `callback` will be called with a #GAsyncResult which can be used to
     * finish the operation with g_file_io_stream_query_info_finish().
     * 
     * For the synchronous version of this function, see
     * g_file_io_stream_query_info().
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: A #GFileInfo for the finished query.
     */
    query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileInfo>
    /**
     * Finalizes the asynchronous query started
     * by g_file_io_stream_query_info_async().
     * @param result a #GAsyncResult.
     * @returns A #GFileInfo for the finished query.
     */
    query_info_finish(result: AsyncResult): FileInfo

    // Own virtual methods of Gio-2.0.Gio.FileIOStream

    vfunc_can_seek(): boolean
    vfunc_can_truncate(): boolean
    /**
     * Gets the entity tag for the file when it has been written.
     * This must be called after the stream has been written
     * and closed, as the etag can change while writing.
     * @virtual 
     * @returns the entity tag for the stream.
     */
    vfunc_get_etag(): string | null
    /**
     * Queries a file io stream for the given `attributes`.
     * This function blocks while querying the stream. For the asynchronous
     * version of this function, see g_file_io_stream_query_info_async().
     * While the stream is blocked, the stream will set the pending flag
     * internally, and any other operations on the stream will fail with
     * %G_IO_ERROR_PENDING.
     * 
     * Can fail if the stream was already closed (with `error` being set to
     * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
     * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
     * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). I
     * all cases of failure, %NULL will be returned.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
     * be returned.
     * @virtual 
     * @param attributes a file attribute query string.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GFileInfo for the @stream, or %NULL on error.
     */
    vfunc_query_info(attributes: string | null, cancellable: Cancellable | null): FileInfo
    /**
     * Asynchronously queries the `stream` for a #GFileInfo. When completed,
     * `callback` will be called with a #GAsyncResult which can be used to
     * finish the operation with g_file_io_stream_query_info_finish().
     * 
     * For the synchronous version of this function, see
     * g_file_io_stream_query_info().
     * @virtual 
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    vfunc_query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finalizes the asynchronous query started
     * by g_file_io_stream_query_info_async().
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns A #GFileInfo for the finished query.
     */
    vfunc_query_info_finish(result: AsyncResult): FileInfo
    vfunc_seek(offset: number, type: GLib.SeekType, cancellable: Cancellable | null): boolean
    vfunc_tell(): number
    vfunc_truncate_fn(size: number, cancellable: Cancellable | null): boolean

    // Class property signals of Gio-2.0.Gio.FileIOStream

    connect(sigName: "notify::closed", callback: (($obj: FileIOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::closed", callback: (($obj: FileIOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: "notify::input-stream", callback: (($obj: FileIOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::input-stream", callback: (($obj: FileIOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::input-stream", ...args: any[]): void
    connect(sigName: "notify::output-stream", callback: (($obj: FileIOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::output-stream", callback: (($obj: FileIOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::output-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * GFileIOStream provides io streams that both read and write to the same
 * file handle.
 * 
 * GFileIOStream implements #GSeekable, which allows the io
 * stream to jump to arbitrary positions in the file and to truncate
 * the file, provided the filesystem of the file supports these
 * operations.
 * 
 * To find the position of a file io stream, use
 * g_seekable_tell().
 * 
 * To find out if a file io stream supports seeking, use g_seekable_can_seek().
 * To position a file io stream, use g_seekable_seek().
 * To find out if a file io stream supports truncating, use
 * g_seekable_can_truncate(). To truncate a file io
 * stream, use g_seekable_truncate().
 * 
 * The default implementation of all the #GFileIOStream operations
 * and the implementation of #GSeekable just call into the same operations
 * on the output stream.
 * @class 
 */
class FileIOStream extends IOStream {

    // Own properties of Gio-2.0.Gio.FileIOStream

    static name: string
    static $gtype: GObject.GType<FileIOStream>

    // Constructors of Gio-2.0.Gio.FileIOStream

    constructor(config?: FileIOStream.ConstructorProperties) 
    _init(config?: FileIOStream.ConstructorProperties): void
}

module FileIcon {

    // Constructor properties interface

    interface ConstructorProperties extends Icon.ConstructorProperties, LoadableIcon.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.FileIcon

        /**
         * The file containing the icon.
         */
        file?: File | null
    }

}

interface FileIcon extends Icon, LoadableIcon {

    // Own properties of Gio-2.0.Gio.FileIcon

    /**
     * The file containing the icon.
     */
    readonly file: File

    // Owm methods of Gio-2.0.Gio.FileIcon

    /**
     * Gets the #GFile associated with the given `icon`.
     * @returns a #GFile.
     */
    get_file(): File

    // Class property signals of Gio-2.0.Gio.FileIcon

    connect(sigName: "notify::file", callback: (($obj: FileIcon, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::file", callback: (($obj: FileIcon, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::file", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GFileIcon specifies an icon by pointing to an image file
 * to be used as icon.
 * @class 
 */
class FileIcon extends GObject.Object {

    // Own properties of Gio-2.0.Gio.FileIcon

    static name: string
    static $gtype: GObject.GType<FileIcon>

    // Constructors of Gio-2.0.Gio.FileIcon

    constructor(config?: FileIcon.ConstructorProperties) 
    /**
     * Creates a new icon for a file.
     * @constructor 
     * @param file a #GFile.
     * @returns a #GIcon for the given   @file, or %NULL on error.
     */
    constructor(file: File) 
    /**
     * Creates a new icon for a file.
     * @constructor 
     * @param file a #GFile.
     * @returns a #GIcon for the given   @file, or %NULL on error.
     */
    static new(file: File): FileIcon
    _init(config?: FileIcon.ConstructorProperties): void
}

module FileInfo {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface FileInfo {

    // Owm methods of Gio-2.0.Gio.FileInfo

    /**
     * Clears the status information from `info`.
     */
    clear_status(): void
    /**
     * First clears all of the [GFileAttribute][gio-GFileAttribute] of `dest_info,`
     * and then copies all of the file attributes from `src_info` to `dest_info`.
     * @param dest_info destination to copy attributes to.
     */
    copy_into(dest_info: FileInfo): void
    /**
     * Duplicates a file info structure.
     * @returns a duplicate #GFileInfo of @other.
     */
    dup(): FileInfo
    /**
     * Gets the access time of the current `info` and returns it as a
     * #GDateTime.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_TIME_ACCESS. If %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC is
     * provided, the resulting #GDateTime will additionally have microsecond
     * precision.
     * 
     * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC must
     * be queried separately using g_file_info_get_attribute_uint32().
     * @returns access time, or %NULL if unknown
     */
    get_access_date_time(): GLib.DateTime | null
    /**
     * Gets the value of an attribute, formatted as a string.
     * This escapes things as needed to make the string valid
     * UTF-8.
     * @param attribute a file attribute key.
     * @returns a UTF-8 string associated with the given @attribute, or    %NULL if the attribute wasn’t set.    When you're done with the string it must be freed with g_free().
     */
    get_attribute_as_string(attribute: string | null): string | null
    /**
     * Gets the value of a boolean attribute. If the attribute does not
     * contain a boolean value, %FALSE will be returned.
     * @param attribute a file attribute key.
     * @returns the boolean value contained within the attribute.
     */
    get_attribute_boolean(attribute: string | null): boolean
    /**
     * Gets the value of a byte string attribute. If the attribute does
     * not contain a byte string, %NULL will be returned.
     * @param attribute a file attribute key.
     * @returns the contents of the @attribute value as a byte string, or %NULL otherwise.
     */
    get_attribute_byte_string(attribute: string | null): string | null
    /**
     * Gets the attribute type, value and status for an attribute key.
     * @param attribute a file attribute key
     * @returns %TRUE if @info has an attribute named @attribute,      %FALSE otherwise.
     */
    get_attribute_data(attribute: string | null): [ /* returnType */ boolean, /* type */ FileAttributeType, /* value_pp */ any, /* status */ FileAttributeStatus ]
    /**
     * Gets a signed 32-bit integer contained within the attribute. If the
     * attribute does not contain a signed 32-bit integer, or is invalid,
     * 0 will be returned.
     * @param attribute a file attribute key.
     * @returns a signed 32-bit integer from the attribute.
     */
    get_attribute_int32(attribute: string | null): number
    /**
     * Gets a signed 64-bit integer contained within the attribute. If the
     * attribute does not contain a signed 64-bit integer, or is invalid,
     * 0 will be returned.
     * @param attribute a file attribute key.
     * @returns a signed 64-bit integer from the attribute.
     */
    get_attribute_int64(attribute: string | null): number
    /**
     * Gets the value of a #GObject attribute. If the attribute does
     * not contain a #GObject, %NULL will be returned.
     * @param attribute a file attribute key.
     * @returns a #GObject associated with the given @attribute, or %NULL otherwise.
     */
    get_attribute_object(attribute: string | null): GObject.Object | null
    /**
     * Gets the attribute status for an attribute key.
     * @param attribute a file attribute key
     * @returns a #GFileAttributeStatus for the given @attribute, or    %G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.
     */
    get_attribute_status(attribute: string | null): FileAttributeStatus
    /**
     * Gets the value of a string attribute. If the attribute does
     * not contain a string, %NULL will be returned.
     * @param attribute a file attribute key.
     * @returns the contents of the @attribute value as a UTF-8 string, or %NULL otherwise.
     */
    get_attribute_string(attribute: string | null): string | null
    /**
     * Gets the value of a stringv attribute. If the attribute does
     * not contain a stringv, %NULL will be returned.
     * @param attribute a file attribute key.
     * @returns the contents of the @attribute value as a stringv, or %NULL otherwise. Do not free. These returned strings are UTF-8.
     */
    get_attribute_stringv(attribute: string | null): string[] | null
    /**
     * Gets the attribute type for an attribute key.
     * @param attribute a file attribute key.
     * @returns a #GFileAttributeType for the given @attribute, or %G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.
     */
    get_attribute_type(attribute: string | null): FileAttributeType
    /**
     * Gets an unsigned 32-bit integer contained within the attribute. If the
     * attribute does not contain an unsigned 32-bit integer, or is invalid,
     * 0 will be returned.
     * @param attribute a file attribute key.
     * @returns an unsigned 32-bit integer from the attribute.
     */
    get_attribute_uint32(attribute: string | null): number
    /**
     * Gets a unsigned 64-bit integer contained within the attribute. If the
     * attribute does not contain an unsigned 64-bit integer, or is invalid,
     * 0 will be returned.
     * @param attribute a file attribute key.
     * @returns a unsigned 64-bit integer from the attribute.
     */
    get_attribute_uint64(attribute: string | null): number
    /**
     * Gets the file's content type.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
     * @returns a string containing the file's content type, or %NULL if unknown.
     */
    get_content_type(): string | null
    /**
     * Gets the creation time of the current `info` and returns it as a
     * #GDateTime.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_TIME_CREATED. If %G_FILE_ATTRIBUTE_TIME_CREATED_USEC is
     * provided, the resulting #GDateTime will additionally have microsecond
     * precision.
     * 
     * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_CREATED_NSEC must
     * be queried separately using g_file_info_get_attribute_uint32().
     * @returns creation time, or %NULL if unknown
     */
    get_creation_date_time(): GLib.DateTime | null
    /**
     * Returns the #GDateTime representing the deletion date of the file, as
     * available in %G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
     * %G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, %NULL is returned.
     * @returns a #GDateTime, or %NULL.
     */
    get_deletion_date(): GLib.DateTime | null
    /**
     * Gets a display name for a file. This is guaranteed to always be set.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
     * @returns a string containing the display name.
     */
    get_display_name(): string | null
    /**
     * Gets the edit name for a file.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
     * @returns a string containing the edit name.
     */
    get_edit_name(): string | null
    /**
     * Gets the [entity tag][gfile-etag] for a given
     * #GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_ETAG_VALUE.
     * @returns a string containing the value of the "etag:value" attribute.
     */
    get_etag(): string | null
    /**
     * Gets a file's type (whether it is a regular file, symlink, etc).
     * This is different from the file's content type, see g_file_info_get_content_type().
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_TYPE.
     * @returns a #GFileType for the given file.
     */
    get_file_type(): FileType
    /**
     * Gets the icon for a file.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_ICON.
     * @returns #GIcon for the given @info.
     */
    get_icon(): Icon | null
    /**
     * Checks if a file is a backup file.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP.
     * @returns %TRUE if file is a backup file, %FALSE otherwise.
     */
    get_is_backup(): boolean
    /**
     * Checks if a file is hidden.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
     * @returns %TRUE if the file is a hidden file, %FALSE otherwise.
     */
    get_is_hidden(): boolean
    /**
     * Checks if a file is a symlink.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
     * @returns %TRUE if the given @info is a symlink.
     */
    get_is_symlink(): boolean
    /**
     * Gets the modification time of the current `info` and returns it as a
     * #GDateTime.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_TIME_MODIFIED. If %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
     * provided, the resulting #GDateTime will additionally have microsecond
     * precision.
     * 
     * If nanosecond precision is needed, %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC must
     * be queried separately using g_file_info_get_attribute_uint32().
     * @returns modification time, or %NULL if unknown
     */
    get_modification_date_time(): GLib.DateTime | null
    /**
     * Gets the modification time of the current `info` and sets it
     * in `result`.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_TIME_MODIFIED. If %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is
     * provided it will be used too.
     */
    get_modification_time(): /* result */ GLib.TimeVal
    /**
     * Gets the name for a file. This is guaranteed to always be set.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_NAME.
     * @returns a string containing the file name.
     */
    get_name(): string
    /**
     * Gets the file's size (in bytes). The size is retrieved through the value of
     * the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
     * from #guint64 to #goffset before returning the result.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_SIZE.
     * @returns a #goffset containing the file's size (in bytes).
     */
    get_size(): number
    /**
     * Gets the value of the sort_order attribute from the #GFileInfo.
     * See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
     * @returns a #gint32 containing the value of the "standard::sort_order" attribute.
     */
    get_sort_order(): number
    /**
     * Gets the symbolic icon for a file.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
     * @returns #GIcon for the given @info.
     */
    get_symbolic_icon(): Icon | null
    /**
     * Gets the symlink target for a given #GFileInfo.
     * 
     * It is an error to call this if the #GFileInfo does not contain
     * %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET.
     * @returns a string containing the symlink target.
     */
    get_symlink_target(): string | null
    /**
     * Checks if a file info structure has an attribute named `attribute`.
     * @param attribute a file attribute key.
     * @returns %TRUE if @info has an attribute named @attribute,     %FALSE otherwise.
     */
    has_attribute(attribute: string | null): boolean
    /**
     * Checks if a file info structure has an attribute in the
     * specified `name_space`.
     * @param name_space a file attribute namespace.
     * @returns %TRUE if @info has an attribute in @name_space,     %FALSE otherwise.
     */
    has_namespace(name_space: string | null): boolean
    /**
     * Lists the file info structure's attributes.
     * @param name_space a file attribute key's namespace, or %NULL to list   all attributes.
     * @returns a null-terminated array of strings of all of the possible attribute types for the given @name_space, or %NULL on error.
     */
    list_attributes(name_space: string | null): string[] | null
    /**
     * Removes all cases of `attribute` from `info` if it exists.
     * @param attribute a file attribute key.
     */
    remove_attribute(attribute: string | null): void
    /**
     * Sets the %G_FILE_ATTRIBUTE_TIME_ACCESS and
     * %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC attributes in the file info to the
     * given date/time value.
     * 
     * %G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC will be cleared.
     * @param atime a #GDateTime.
     */
    set_access_date_time(atime: GLib.DateTime): void
    /**
     * Sets the `attribute` to contain the given value, if possible. To unset the
     * attribute, use %G_FILE_ATTRIBUTE_TYPE_INVALID for `type`.
     * @param attribute a file attribute key.
     * @param type a #GFileAttributeType
     * @param value_p pointer to the value
     */
    set_attribute(attribute: string | null, type: FileAttributeType, value_p: any): void
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * @param attribute a file attribute key.
     * @param attr_value a boolean value.
     */
    set_attribute_boolean(attribute: string | null, attr_value: boolean): void
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * @param attribute a file attribute key.
     * @param attr_value a byte string.
     */
    set_attribute_byte_string(attribute: string | null, attr_value: string | null): void
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * @param attribute a file attribute key.
     * @param attr_value a signed 32-bit integer
     */
    set_attribute_int32(attribute: string | null, attr_value: number): void
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * @param attribute attribute name to set.
     * @param attr_value int64 value to set attribute to.
     */
    set_attribute_int64(attribute: string | null, attr_value: number): void
    /**
     * Sets `mask` on `info` to match specific attribute types.
     * @param mask a #GFileAttributeMatcher.
     */
    set_attribute_mask(mask: FileAttributeMatcher): void
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * @param attribute a file attribute key.
     * @param attr_value a #GObject.
     */
    set_attribute_object(attribute: string | null, attr_value: GObject.Object): void
    /**
     * Sets the attribute status for an attribute key. This is only
     * needed by external code that implement g_file_set_attributes_from_info()
     * or similar functions.
     * 
     * The attribute must exist in `info` for this to work. Otherwise %FALSE
     * is returned and `info` is unchanged.
     * @param attribute a file attribute key
     * @param status a #GFileAttributeStatus
     * @returns %TRUE if the status was changed, %FALSE if the key was not set.
     */
    set_attribute_status(attribute: string | null, status: FileAttributeStatus): boolean
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * @param attribute a file attribute key.
     * @param attr_value a UTF-8 string.
     */
    set_attribute_string(attribute: string | null, attr_value: string | null): void
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * 
     * Sinze: 2.22
     * @param attribute a file attribute key
     * @param attr_value a %NULL   terminated array of UTF-8 strings.
     */
    set_attribute_stringv(attribute: string | null, attr_value: string[]): void
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * @param attribute a file attribute key.
     * @param attr_value an unsigned 32-bit integer.
     */
    set_attribute_uint32(attribute: string | null, attr_value: number): void
    /**
     * Sets the `attribute` to contain the given `attr_value,`
     * if possible.
     * @param attribute a file attribute key.
     * @param attr_value an unsigned 64-bit integer.
     */
    set_attribute_uint64(attribute: string | null, attr_value: number): void
    /**
     * Sets the content type attribute for a given #GFileInfo.
     * See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
     * @param content_type a content type. See [GContentType][gio-GContentType]
     */
    set_content_type(content_type: string | null): void
    /**
     * Sets the %G_FILE_ATTRIBUTE_TIME_CREATED and
     * %G_FILE_ATTRIBUTE_TIME_CREATED_USEC attributes in the file info to the
     * given date/time value.
     * 
     * %G_FILE_ATTRIBUTE_TIME_CREATED_NSEC will be cleared.
     * @param creation_time a #GDateTime.
     */
    set_creation_date_time(creation_time: GLib.DateTime): void
    /**
     * Sets the display name for the current #GFileInfo.
     * See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
     * @param display_name a string containing a display name.
     */
    set_display_name(display_name: string | null): void
    /**
     * Sets the edit name for the current file.
     * See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
     * @param edit_name a string containing an edit name.
     */
    set_edit_name(edit_name: string | null): void
    /**
     * Sets the file type in a #GFileInfo to `type`.
     * See %G_FILE_ATTRIBUTE_STANDARD_TYPE.
     * @param type a #GFileType.
     */
    set_file_type(type: FileType): void
    /**
     * Sets the icon for a given #GFileInfo.
     * See %G_FILE_ATTRIBUTE_STANDARD_ICON.
     * @param icon a #GIcon.
     */
    set_icon(icon: Icon): void
    /**
     * Sets the "is_hidden" attribute in a #GFileInfo according to `is_hidden`.
     * See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
     * @param is_hidden a #gboolean.
     */
    set_is_hidden(is_hidden: boolean): void
    /**
     * Sets the "is_symlink" attribute in a #GFileInfo according to `is_symlink`.
     * See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
     * @param is_symlink a #gboolean.
     */
    set_is_symlink(is_symlink: boolean): void
    /**
     * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
     * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
     * given date/time value.
     * 
     * %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
     * @param mtime a #GDateTime.
     */
    set_modification_date_time(mtime: GLib.DateTime): void
    /**
     * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
     * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
     * given time value.
     * 
     * %G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC will be cleared.
     * @param mtime a #GTimeVal.
     */
    set_modification_time(mtime: GLib.TimeVal): void
    /**
     * Sets the name attribute for the current #GFileInfo.
     * See %G_FILE_ATTRIBUTE_STANDARD_NAME.
     * @param name a string containing a name.
     */
    set_name(name: string): void
    /**
     * Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
     * to the given size.
     * @param size a #goffset containing the file's size.
     */
    set_size(size: number): void
    /**
     * Sets the sort order attribute in the file info structure. See
     * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
     * @param sort_order a sort order integer.
     */
    set_sort_order(sort_order: number): void
    /**
     * Sets the symbolic icon for a given #GFileInfo.
     * See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
     * @param icon a #GIcon.
     */
    set_symbolic_icon(icon: Icon): void
    /**
     * Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
     * to the given symlink target.
     * @param symlink_target a static string containing a path to a symlink target.
     */
    set_symlink_target(symlink_target: string | null): void
    /**
     * Unsets a mask set by g_file_info_set_attribute_mask(), if one
     * is set.
     */
    unset_attribute_mask(): void

    // Class property signals of Gio-2.0.Gio.FileInfo

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Functionality for manipulating basic metadata for files. #GFileInfo
 * implements methods for getting information that all files should
 * contain, and allows for manipulation of extended attributes.
 * 
 * See [GFileAttribute][gio-GFileAttribute] for more information on how
 * GIO handles file attributes.
 * 
 * To obtain a #GFileInfo for a #GFile, use g_file_query_info() (or its
 * async variant). To obtain a #GFileInfo for a file input or output
 * stream, use g_file_input_stream_query_info() or
 * g_file_output_stream_query_info() (or their async variants).
 * 
 * To change the actual attributes of a file, you should then set the
 * attribute in the #GFileInfo and call g_file_set_attributes_from_info()
 * or g_file_set_attributes_async() on a GFile.
 * 
 * However, not all attributes can be changed in the file. For instance,
 * the actual size of a file cannot be changed via g_file_info_set_size().
 * You may call g_file_query_settable_attributes() and
 * g_file_query_writable_namespaces() to discover the settable attributes
 * of a particular file at runtime.
 * 
 * The direct accessors, such as g_file_info_get_name(), are slightly more
 * optimized than the generic attribute accessors, such as
 * g_file_info_get_attribute_byte_string().This optimization will matter
 * only if calling the API in a tight loop.
 * 
 * It is an error to call these accessors without specifying their required file
 * attributes when creating the #GFileInfo. Use g_file_info_has_attribute() or
 * g_file_info_list_attributes() to check what attributes are specified for a
 * #GFileInfo.
 * 
 * #GFileAttributeMatcher allows for searching through a #GFileInfo for
 * attributes.
 * @class 
 */
class FileInfo extends GObject.Object {

    // Own properties of Gio-2.0.Gio.FileInfo

    static name: string
    static $gtype: GObject.GType<FileInfo>

    // Constructors of Gio-2.0.Gio.FileInfo

    constructor(config?: FileInfo.ConstructorProperties) 
    /**
     * Creates a new file info structure.
     * @constructor 
     * @returns a #GFileInfo.
     */
    constructor() 
    /**
     * Creates a new file info structure.
     * @constructor 
     * @returns a #GFileInfo.
     */
    static new(): FileInfo
    _init(config?: FileInfo.ConstructorProperties): void
}

module FileInputStream {

    // Constructor properties interface

    interface ConstructorProperties extends Seekable.ConstructorProperties, InputStream.ConstructorProperties {
    }

}

interface FileInputStream extends Seekable {

    // Own fields of Gio-2.0.Gio.FileInputStream

    parent_instance: InputStream & GObject.Object

    // Owm methods of Gio-2.0.Gio.FileInputStream

    /**
     * Queries a file input stream the given `attributes`. This function blocks
     * while querying the stream. For the asynchronous (non-blocking) version
     * of this function, see g_file_input_stream_query_info_async(). While the
     * stream is blocked, the stream will set the pending flag internally, and
     * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
     * @param attributes a file attribute query string.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GFileInfo, or %NULL on error.
     */
    query_info(attributes: string | null, cancellable: Cancellable | null): FileInfo
    /**
     * Queries the stream information asynchronously.
     * When the operation is finished `callback` will be called.
     * You can then call g_file_input_stream_query_info_finish()
     * to get the result of the operation.
     * 
     * For the synchronous version of this function,
     * see g_file_input_stream_query_info().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of query_info_async

    /**
     * Promisified version of {@link query_info_async}
     * 
     * Queries the stream information asynchronously.
     * When the operation is finished `callback` will be called.
     * You can then call g_file_input_stream_query_info_finish()
     * to get the result of the operation.
     * 
     * For the synchronous version of this function,
     * see g_file_input_stream_query_info().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: #GFileInfo.
     */
    query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileInfo>
    /**
     * Finishes an asynchronous info query operation.
     * @param result a #GAsyncResult.
     * @returns #GFileInfo.
     */
    query_info_finish(result: AsyncResult): FileInfo

    // Own virtual methods of Gio-2.0.Gio.FileInputStream

    vfunc_can_seek(): boolean
    /**
     * Queries a file input stream the given `attributes`. This function blocks
     * while querying the stream. For the asynchronous (non-blocking) version
     * of this function, see g_file_input_stream_query_info_async(). While the
     * stream is blocked, the stream will set the pending flag internally, and
     * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
     * @virtual 
     * @param attributes a file attribute query string.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GFileInfo, or %NULL on error.
     */
    vfunc_query_info(attributes: string | null, cancellable: Cancellable | null): FileInfo
    /**
     * Queries the stream information asynchronously.
     * When the operation is finished `callback` will be called.
     * You can then call g_file_input_stream_query_info_finish()
     * to get the result of the operation.
     * 
     * For the synchronous version of this function,
     * see g_file_input_stream_query_info().
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
     * @virtual 
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    vfunc_query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous info query operation.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns #GFileInfo.
     */
    vfunc_query_info_finish(result: AsyncResult): FileInfo
    vfunc_seek(offset: number, type: GLib.SeekType, cancellable: Cancellable | null): boolean
    vfunc_tell(): number

    // Class property signals of Gio-2.0.Gio.FileInputStream

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * GFileInputStream provides input streams that take their
 * content from a file.
 * 
 * GFileInputStream implements #GSeekable, which allows the input
 * stream to jump to arbitrary positions in the file, provided the
 * filesystem of the file allows it. To find the position of a file
 * input stream, use g_seekable_tell(). To find out if a file input
 * stream supports seeking, use g_seekable_can_seek().
 * To position a file input stream, use g_seekable_seek().
 * @class 
 */
class FileInputStream extends InputStream {

    // Own properties of Gio-2.0.Gio.FileInputStream

    static name: string
    static $gtype: GObject.GType<FileInputStream>

    // Constructors of Gio-2.0.Gio.FileInputStream

    constructor(config?: FileInputStream.ConstructorProperties) 
    _init(config?: FileInputStream.ConstructorProperties): void
}

module FileMonitor {

    // Signal callback interfaces

    /**
     * Signal callback interface for `changed`
     */
    interface ChangedSignalCallback {
        ($obj: FileMonitor, file: File, other_file: File | null, event_type: FileMonitorEvent): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.FileMonitor

        rate_limit?: number | null
    }

}

interface FileMonitor {

    // Own properties of Gio-2.0.Gio.FileMonitor

    readonly cancelled: boolean
    rate_limit: number

    // Own fields of Gio-2.0.Gio.FileMonitor

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.FileMonitor

    /**
     * Cancels a file monitor.
     * @returns always %TRUE
     */
    cancel(): boolean
    /**
     * Emits the #GFileMonitor::changed signal if a change
     * has taken place. Should be called from file monitor
     * implementations only.
     * 
     * Implementations are responsible to call this method from the
     * [thread-default main context][g-main-context-push-thread-default] of the
     * thread that the monitor was created in.
     * @param child a #GFile.
     * @param other_file a #GFile.
     * @param event_type a set of #GFileMonitorEvent flags.
     */
    emit_event(child: File, other_file: File, event_type: FileMonitorEvent): void
    /**
     * Returns whether the monitor is canceled.
     * @returns %TRUE if monitor is canceled. %FALSE otherwise.
     */
    is_cancelled(): boolean
    /**
     * Sets the rate limit to which the `monitor` will report
     * consecutive change events to the same file.
     * @param limit_msecs a non-negative integer with the limit in milliseconds     to poll for changes
     */
    set_rate_limit(limit_msecs: number): void

    // Own virtual methods of Gio-2.0.Gio.FileMonitor

    /**
     * Cancels a file monitor.
     * @virtual 
     * @returns always %TRUE
     */
    vfunc_cancel(): boolean
    vfunc_changed(file: File, other_file: File, event_type: FileMonitorEvent): void

    // Own signals of Gio-2.0.Gio.FileMonitor

    connect(sigName: "changed", callback: FileMonitor.ChangedSignalCallback): number
    connect_after(sigName: "changed", callback: FileMonitor.ChangedSignalCallback): number
    emit(sigName: "changed", file: File, other_file: File | null, event_type: FileMonitorEvent, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.FileMonitor

    connect(sigName: "notify::cancelled", callback: (($obj: FileMonitor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cancelled", callback: (($obj: FileMonitor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::cancelled", ...args: any[]): void
    connect(sigName: "notify::rate-limit", callback: (($obj: FileMonitor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rate-limit", callback: (($obj: FileMonitor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::rate-limit", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Monitors a file or directory for changes.
 * 
 * To obtain a #GFileMonitor for a file or directory, use
 * g_file_monitor(), g_file_monitor_file(), or
 * g_file_monitor_directory().
 * 
 * To get informed about changes to the file or directory you are
 * monitoring, connect to the #GFileMonitor::changed signal. The
 * signal will be emitted in the
 * [thread-default main context][g-main-context-push-thread-default]
 * of the thread that the monitor was created in
 * (though if the global default main context is blocked, this may
 * cause notifications to be blocked even if the thread-default
 * context is still running).
 * @class 
 */
class FileMonitor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.FileMonitor

    static name: string
    static $gtype: GObject.GType<FileMonitor>

    // Constructors of Gio-2.0.Gio.FileMonitor

    constructor(config?: FileMonitor.ConstructorProperties) 
    _init(config?: FileMonitor.ConstructorProperties): void
}

module FileOutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends Seekable.ConstructorProperties, OutputStream.ConstructorProperties {
    }

}

interface FileOutputStream extends Seekable {

    // Own fields of Gio-2.0.Gio.FileOutputStream

    parent_instance: OutputStream & GObject.Object

    // Owm methods of Gio-2.0.Gio.FileOutputStream

    /**
     * Gets the entity tag for the file when it has been written.
     * This must be called after the stream has been written
     * and closed, as the etag can change while writing.
     * @returns the entity tag for the stream.
     */
    get_etag(): string | null
    /**
     * Queries a file output stream for the given `attributes`.
     * This function blocks while querying the stream. For the asynchronous
     * version of this function, see g_file_output_stream_query_info_async().
     * While the stream is blocked, the stream will set the pending flag
     * internally, and any other operations on the stream will fail with
     * %G_IO_ERROR_PENDING.
     * 
     * Can fail if the stream was already closed (with `error` being set to
     * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
     * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
     * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). In
     * all cases of failure, %NULL will be returned.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
     * be returned.
     * @param attributes a file attribute query string.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GFileInfo for the @stream, or %NULL on error.
     */
    query_info(attributes: string | null, cancellable: Cancellable | null): FileInfo
    /**
     * Asynchronously queries the `stream` for a #GFileInfo. When completed,
     * `callback` will be called with a #GAsyncResult which can be used to
     * finish the operation with g_file_output_stream_query_info_finish().
     * 
     * For the synchronous version of this function, see
     * g_file_output_stream_query_info().
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of query_info_async

    /**
     * Promisified version of {@link query_info_async}
     * 
     * Asynchronously queries the `stream` for a #GFileInfo. When completed,
     * `callback` will be called with a #GAsyncResult which can be used to
     * finish the operation with g_file_output_stream_query_info_finish().
     * 
     * For the synchronous version of this function, see
     * g_file_output_stream_query_info().
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: A #GFileInfo for the finished query.
     */
    query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<FileInfo>
    /**
     * Finalizes the asynchronous query started
     * by g_file_output_stream_query_info_async().
     * @param result a #GAsyncResult.
     * @returns A #GFileInfo for the finished query.
     */
    query_info_finish(result: AsyncResult): FileInfo

    // Own virtual methods of Gio-2.0.Gio.FileOutputStream

    vfunc_can_seek(): boolean
    vfunc_can_truncate(): boolean
    /**
     * Gets the entity tag for the file when it has been written.
     * This must be called after the stream has been written
     * and closed, as the etag can change while writing.
     * @virtual 
     * @returns the entity tag for the stream.
     */
    vfunc_get_etag(): string | null
    /**
     * Queries a file output stream for the given `attributes`.
     * This function blocks while querying the stream. For the asynchronous
     * version of this function, see g_file_output_stream_query_info_async().
     * While the stream is blocked, the stream will set the pending flag
     * internally, and any other operations on the stream will fail with
     * %G_IO_ERROR_PENDING.
     * 
     * Can fail if the stream was already closed (with `error` being set to
     * %G_IO_ERROR_CLOSED), the stream has pending operations (with `error` being
     * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
     * the stream's interface (with `error` being set to %G_IO_ERROR_NOT_SUPPORTED). In
     * all cases of failure, %NULL will be returned.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
     * be returned.
     * @virtual 
     * @param attributes a file attribute query string.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GFileInfo for the @stream, or %NULL on error.
     */
    vfunc_query_info(attributes: string | null, cancellable: Cancellable | null): FileInfo
    /**
     * Asynchronously queries the `stream` for a #GFileInfo. When completed,
     * `callback` will be called with a #GAsyncResult which can be used to
     * finish the operation with g_file_output_stream_query_info_finish().
     * 
     * For the synchronous version of this function, see
     * g_file_output_stream_query_info().
     * @virtual 
     * @param attributes a file attribute query string.
     * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    vfunc_query_info_async(attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finalizes the asynchronous query started
     * by g_file_output_stream_query_info_async().
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns A #GFileInfo for the finished query.
     */
    vfunc_query_info_finish(result: AsyncResult): FileInfo
    vfunc_seek(offset: number, type: GLib.SeekType, cancellable: Cancellable | null): boolean
    vfunc_tell(): number
    vfunc_truncate_fn(size: number, cancellable: Cancellable | null): boolean

    // Class property signals of Gio-2.0.Gio.FileOutputStream

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * GFileOutputStream provides output streams that write their
 * content to a file.
 * 
 * GFileOutputStream implements #GSeekable, which allows the output
 * stream to jump to arbitrary positions in the file and to truncate
 * the file, provided the filesystem of the file supports these
 * operations.
 * 
 * To find the position of a file output stream, use g_seekable_tell().
 * To find out if a file output stream supports seeking, use
 * g_seekable_can_seek().To position a file output stream, use
 * g_seekable_seek(). To find out if a file output stream supports
 * truncating, use g_seekable_can_truncate(). To truncate a file output
 * stream, use g_seekable_truncate().
 * @class 
 */
class FileOutputStream extends OutputStream {

    // Own properties of Gio-2.0.Gio.FileOutputStream

    static name: string
    static $gtype: GObject.GType<FileOutputStream>

    // Constructors of Gio-2.0.Gio.FileOutputStream

    constructor(config?: FileOutputStream.ConstructorProperties) 
    _init(config?: FileOutputStream.ConstructorProperties): void
}

module FilenameCompleter {

    // Signal callback interfaces

    /**
     * Signal callback interface for `got-completion-data`
     */
    interface GotCompletionDataSignalCallback {
        ($obj: FilenameCompleter): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface FilenameCompleter {

    // Owm methods of Gio-2.0.Gio.FilenameCompleter

    /**
     * Obtains a completion for `initial_text` from `completer`.
     * @param initial_text text to be completed.
     * @returns a completed string, or %NULL if no     completion exists. This string is not owned by GIO, so remember to g_free()     it when finished.
     */
    get_completion_suffix(initial_text: string | null): string | null
    /**
     * Gets an array of completion strings for a given initial text.
     * @param initial_text text to be completed.
     * @returns array of strings with possible completions for @initial_text. This array must be freed by g_strfreev() when finished.
     */
    get_completions(initial_text: string | null): string[]
    /**
     * If `dirs_only` is %TRUE, `completer` will only
     * complete directory names, and not file names.
     * @param dirs_only a #gboolean.
     */
    set_dirs_only(dirs_only: boolean): void

    // Own virtual methods of Gio-2.0.Gio.FilenameCompleter

    vfunc_got_completion_data(): void

    // Own signals of Gio-2.0.Gio.FilenameCompleter

    connect(sigName: "got-completion-data", callback: FilenameCompleter.GotCompletionDataSignalCallback): number
    connect_after(sigName: "got-completion-data", callback: FilenameCompleter.GotCompletionDataSignalCallback): number
    emit(sigName: "got-completion-data", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.FilenameCompleter

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Completes partial file and directory names given a partial string by
 * looking in the file system for clues. Can return a list of possible
 * completion strings for widget implementations.
 * @class 
 */
class FilenameCompleter extends GObject.Object {

    // Own properties of Gio-2.0.Gio.FilenameCompleter

    static name: string
    static $gtype: GObject.GType<FilenameCompleter>

    // Constructors of Gio-2.0.Gio.FilenameCompleter

    constructor(config?: FilenameCompleter.ConstructorProperties) 
    /**
     * Creates a new filename completer.
     * @constructor 
     * @returns a #GFilenameCompleter.
     */
    constructor() 
    /**
     * Creates a new filename completer.
     * @constructor 
     * @returns a #GFilenameCompleter.
     */
    static new(): FilenameCompleter
    _init(config?: FilenameCompleter.ConstructorProperties): void
}

module FilterInputStream {

    // Constructor properties interface

    interface ConstructorProperties extends InputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.FilterInputStream

        base_stream?: InputStream | null
        close_base_stream?: boolean | null
    }

}

interface FilterInputStream {

    // Own properties of Gio-2.0.Gio.FilterInputStream

    close_base_stream: boolean

    // Own fields of Gio-2.0.Gio.FilterInputStream

    parent_instance: InputStream & GObject.Object
    base_stream: InputStream

    // Owm methods of Gio-2.0.Gio.FilterInputStream

    /**
     * Gets the base stream for the filter stream.
     * @returns a #GInputStream.
     */
    get_base_stream(): InputStream
    /**
     * Returns whether the base stream will be closed when `stream` is
     * closed.
     * @returns %TRUE if the base stream will be closed.
     */
    get_close_base_stream(): boolean
    /**
     * Sets whether the base stream will be closed when `stream` is closed.
     * @param close_base %TRUE to close the base stream.
     */
    set_close_base_stream(close_base: boolean): void

    // Class property signals of Gio-2.0.Gio.FilterInputStream

    connect(sigName: "notify::close-base-stream", callback: (($obj: FilterInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-base-stream", callback: (($obj: FilterInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-base-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Base class for input stream implementations that perform some
 * kind of filtering operation on a base stream. Typical examples
 * of filtering operations are character set conversion, compression
 * and byte order flipping.
 * @class 
 */
class FilterInputStream extends InputStream {

    // Own properties of Gio-2.0.Gio.FilterInputStream

    static name: string
    static $gtype: GObject.GType<FilterInputStream>

    // Constructors of Gio-2.0.Gio.FilterInputStream

    constructor(config?: FilterInputStream.ConstructorProperties) 
    _init(config?: FilterInputStream.ConstructorProperties): void
}

module FilterOutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends OutputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.FilterOutputStream

        base_stream?: OutputStream | null
        close_base_stream?: boolean | null
    }

}

interface FilterOutputStream {

    // Own properties of Gio-2.0.Gio.FilterOutputStream

    readonly close_base_stream: boolean

    // Own fields of Gio-2.0.Gio.FilterOutputStream

    parent_instance: OutputStream & GObject.Object
    base_stream: OutputStream

    // Owm methods of Gio-2.0.Gio.FilterOutputStream

    /**
     * Gets the base stream for the filter stream.
     * @returns a #GOutputStream.
     */
    get_base_stream(): OutputStream
    /**
     * Returns whether the base stream will be closed when `stream` is
     * closed.
     * @returns %TRUE if the base stream will be closed.
     */
    get_close_base_stream(): boolean
    /**
     * Sets whether the base stream will be closed when `stream` is closed.
     * @param close_base %TRUE to close the base stream.
     */
    set_close_base_stream(close_base: boolean): void

    // Class property signals of Gio-2.0.Gio.FilterOutputStream

    connect(sigName: "notify::close-base-stream", callback: (($obj: FilterOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-base-stream", callback: (($obj: FilterOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-base-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Base class for output stream implementations that perform some
 * kind of filtering operation on a base stream. Typical examples
 * of filtering operations are character set conversion, compression
 * and byte order flipping.
 * @class 
 */
class FilterOutputStream extends OutputStream {

    // Own properties of Gio-2.0.Gio.FilterOutputStream

    static name: string
    static $gtype: GObject.GType<FilterOutputStream>

    // Constructors of Gio-2.0.Gio.FilterOutputStream

    constructor(config?: FilterOutputStream.ConstructorProperties) 
    _init(config?: FilterOutputStream.ConstructorProperties): void
}

module IOModule {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.TypePlugin.ConstructorProperties, GObject.TypeModule.ConstructorProperties {
    }

}

interface IOModule extends GObject.TypePlugin {

    // Conflicting methods

    /**
     * Calls the `use_plugin` function from the #GTypePluginClass of
     * `plugin`.  There should be no need to use this function outside of
     * the GObject type system itself.
     */
    use(): void
    /**
     * Increases the use count of a #GTypeModule by one. If the
     * use count was zero before, the plugin will be loaded.
     * If loading the plugin fails, the use count is reset to
     * its prior value.
     * @returns %FALSE if the plugin needed to be loaded and  loading the plugin failed.
     */
    use(): boolean

    // Overloads of use

    /**
     * Calls the `use_plugin` function from the #GTypePluginClass of
     * `plugin`.  There should be no need to use this function outside of
     * the GObject type system itself.
     */
    use(): void

    // Class property signals of Gio-2.0.Gio.IOModule

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Provides an interface and default functions for loading and unloading
 * modules. This is used internally to make GIO extensible, but can also
 * be used by others to implement module loading.
 * @class 
 */
class IOModule extends GObject.TypeModule {

    // Own properties of Gio-2.0.Gio.IOModule

    static name: string
    static $gtype: GObject.GType<IOModule>

    // Constructors of Gio-2.0.Gio.IOModule

    constructor(config?: IOModule.ConstructorProperties) 
    /**
     * Creates a new GIOModule that will load the specific
     * shared library when in use.
     * @constructor 
     * @param filename filename of the shared library module.
     * @returns a #GIOModule from given @filename, or %NULL on error.
     */
    constructor(filename: string) 
    /**
     * Creates a new GIOModule that will load the specific
     * shared library when in use.
     * @constructor 
     * @param filename filename of the shared library module.
     * @returns a #GIOModule from given @filename, or %NULL on error.
     */
    static new(filename: string): IOModule
    _init(config?: IOModule.ConstructorProperties): void
    /**
     * Optional API for GIO modules to implement.
     * 
     * Should return a list of all the extension points that may be
     * implemented in this module.
     * 
     * This method will not be called in normal use, however it may be
     * called when probing existing modules and recording which extension
     * points that this model is used for. This means we won't have to
     * load and initialize this module unless its needed.
     * 
     * If this function is not implemented by the module the module will
     * always be loaded, initialized and then unloaded on application
     * startup so that it can register its extension points during init.
     * 
     * Note that a module need not actually implement all the extension
     * points that g_io_module_query() returns, since the exact list of
     * extension may depend on runtime issues. However all extension
     * points actually implemented must be returned by g_io_module_query()
     * (if defined).
     * 
     * When installing a module that implements g_io_module_query() you must
     * run gio-querymodules in order to build the cache files required for
     * lazy loading.
     * 
     * Since 2.56, this function should be named `g_io_<modulename>_query`, where
     * `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
     * everything after the first dot removed, and with `-` replaced with `_`
     * throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
     * Using the new symbol names avoids name clashes when building modules
     * statically. The old symbol names continue to be supported, but cannot be used
     * for static builds.
     * @returns A %NULL-terminated array of strings,     listing the supported extension points of the module. The array     must be suitable for freeing with g_strfreev().
     */
    static query(): string[]
}

module IOStream {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface IOStream {

    // Own properties of Gio-2.0.Gio.IOStream

    readonly closed: boolean
    readonly input_stream: InputStream
    readonly output_stream: OutputStream

    // Own fields of Gio-2.0.Gio.IOStream

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.IOStream

    /**
     * Clears the pending flag on `stream`.
     */
    clear_pending(): void
    /**
     * Closes the stream, releasing resources related to it. This will also
     * close the individual input and output streams, if they are not already
     * closed.
     * 
     * Once the stream is closed, all other operations will return
     * %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
     * return an error.
     * 
     * Closing a stream will automatically flush any outstanding buffers
     * in the stream.
     * 
     * Streams will be automatically closed when the last reference
     * is dropped, but you might want to call this function to make sure
     * resources are released as early as possible.
     * 
     * Some streams might keep the backing store of the stream (e.g. a file
     * descriptor) open after the stream is closed. See the documentation for
     * the individual stream for details.
     * 
     * On failure the first error that happened will be reported, but the
     * close operation will finish as much as possible. A stream that failed
     * to close will still return %G_IO_ERROR_CLOSED for all operations.
     * Still, it is important to check and report the error to the user,
     * otherwise there might be a loss of data as all data might not be written.
     * 
     * If `cancellable` is not NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * Cancelling a close will still leave the stream closed, but some streams
     * can use a faster close that doesn't block to e.g. check errors.
     * 
     * The default implementation of this method just calls close on the
     * individual input/output streams.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns %TRUE on success, %FALSE on failure
     */
    close(cancellable: Cancellable | null): boolean
    /**
     * Requests an asynchronous close of the stream, releasing resources
     * related to it. When the operation is finished `callback` will be
     * called. You can then call g_io_stream_close_finish() to get
     * the result of the operation.
     * 
     * For behaviour details see g_io_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * @param io_priority the io priority of the request
     * @param cancellable optional cancellable object
     * @param callback callback to call when the request is satisfied
     */
    close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of close_async

    /**
     * Promisified version of {@link close_async}
     * 
     * Requests an asynchronous close of the stream, releasing resources
     * related to it. When the operation is finished `callback` will be
     * called. You can then call g_io_stream_close_finish() to get
     * the result of the operation.
     * 
     * For behaviour details see g_io_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * @param io_priority the io priority of the request
     * @param cancellable optional cancellable object
     * @returns A Promise of: %TRUE if stream was successfully closed, %FALSE otherwise.
     */
    close_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Closes a stream.
     * @param result a #GAsyncResult
     * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
     */
    close_finish(result: AsyncResult): boolean
    /**
     * Gets the input stream for this object. This is used
     * for reading.
     * @returns a #GInputStream, owned by the #GIOStream. Do not free.
     */
    get_input_stream(): InputStream
    /**
     * Gets the output stream for this object. This is used for
     * writing.
     * @returns a #GOutputStream, owned by the #GIOStream. Do not free.
     */
    get_output_stream(): OutputStream
    /**
     * Checks if a stream has pending actions.
     * @returns %TRUE if @stream has pending actions.
     */
    has_pending(): boolean
    /**
     * Checks if a stream is closed.
     * @returns %TRUE if the stream is closed.
     */
    is_closed(): boolean
    /**
     * Sets `stream` to have actions pending. If the pending flag is
     * already set or `stream` is closed, it will return %FALSE and set
     * `error`.
     * @returns %TRUE if pending was previously unset and is now set.
     */
    set_pending(): boolean
    /**
     * Asynchronously splice the output stream of `stream1` to the input stream of
     * `stream2`, and splice the output stream of `stream2` to the input stream of
     * `stream1`.
     * 
     * When the operation is finished `callback` will be called.
     * You can then call g_io_stream_splice_finish() to get the
     * result of the operation.
     * @param stream2 a #GIOStream.
     * @param flags a set of #GIOStreamSpliceFlags.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback.
     */
    splice_async(stream2: IOStream, flags: IOStreamSpliceFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Own virtual methods of Gio-2.0.Gio.IOStream

    /**
     * Requests an asynchronous close of the stream, releasing resources
     * related to it. When the operation is finished `callback` will be
     * called. You can then call g_io_stream_close_finish() to get
     * the result of the operation.
     * 
     * For behaviour details see g_io_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * @virtual 
     * @param io_priority the io priority of the request
     * @param cancellable optional cancellable object
     * @param callback callback to call when the request is satisfied
     */
    vfunc_close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Closes a stream.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
     */
    vfunc_close_finish(result: AsyncResult): boolean
    vfunc_close_fn(cancellable: Cancellable | null): boolean
    /**
     * Gets the input stream for this object. This is used
     * for reading.
     * @virtual 
     * @returns a #GInputStream, owned by the #GIOStream. Do not free.
     */
    vfunc_get_input_stream(): InputStream
    /**
     * Gets the output stream for this object. This is used for
     * writing.
     * @virtual 
     * @returns a #GOutputStream, owned by the #GIOStream. Do not free.
     */
    vfunc_get_output_stream(): OutputStream

    // Class property signals of Gio-2.0.Gio.IOStream

    connect(sigName: "notify::closed", callback: (($obj: IOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::closed", callback: (($obj: IOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: "notify::input-stream", callback: (($obj: IOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::input-stream", callback: (($obj: IOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::input-stream", ...args: any[]): void
    connect(sigName: "notify::output-stream", callback: (($obj: IOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::output-stream", callback: (($obj: IOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::output-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * GIOStream represents an object that has both read and write streams.
 * Generally the two streams act as separate input and output streams,
 * but they share some common resources and state. For instance, for
 * seekable streams, both streams may use the same position.
 * 
 * Examples of #GIOStream objects are #GSocketConnection, which represents
 * a two-way network connection; and #GFileIOStream, which represents a
 * file handle opened in read-write mode.
 * 
 * To do the actual reading and writing you need to get the substreams
 * with g_io_stream_get_input_stream() and g_io_stream_get_output_stream().
 * 
 * The #GIOStream object owns the input and the output streams, not the other
 * way around, so keeping the substreams alive will not keep the #GIOStream
 * object alive. If the #GIOStream object is freed it will be closed, thus
 * closing the substreams, so even if the substreams stay alive they will
 * always return %G_IO_ERROR_CLOSED for all operations.
 * 
 * To close a stream use g_io_stream_close() which will close the common
 * stream object and also the individual substreams. You can also close
 * the substreams themselves. In most cases this only marks the
 * substream as closed, so further I/O on it fails but common state in the
 * #GIOStream may still be open. However, some streams may support
 * "half-closed" states where one direction of the stream is actually shut down.
 * 
 * Operations on #GIOStreams cannot be started while another operation on the
 * #GIOStream or its substreams is in progress. Specifically, an application can
 * read from the #GInputStream and write to the #GOutputStream simultaneously
 * (either in separate threads, or as asynchronous operations in the same
 * thread), but an application cannot start any #GIOStream operation while there
 * is a #GIOStream, #GInputStream or #GOutputStream operation in progress, and
 * an application can’t start any #GInputStream or #GOutputStream operation
 * while there is a #GIOStream operation in progress.
 * 
 * This is a product of individual stream operations being associated with a
 * given #GMainContext (the thread-default context at the time the operation was
 * started), rather than entire streams being associated with a single
 * #GMainContext.
 * 
 * GIO may run operations on #GIOStreams from other (worker) threads, and this
 * may be exposed to application code in the behaviour of wrapper streams, such
 * as #GBufferedInputStream or #GTlsConnection. With such wrapper APIs,
 * application code may only run operations on the base (wrapped) stream when
 * the wrapper stream is idle. Note that the semantics of such operations may
 * not be well-defined due to the state the wrapper stream leaves the base
 * stream in (though they are guaranteed not to crash).
 * @class 
 */
class IOStream extends GObject.Object {

    // Own properties of Gio-2.0.Gio.IOStream

    static name: string
    static $gtype: GObject.GType<IOStream>

    // Constructors of Gio-2.0.Gio.IOStream

    constructor(config?: IOStream.ConstructorProperties) 
    _init(config?: IOStream.ConstructorProperties): void
    /**
     * Finishes an asynchronous io stream splice operation.
     * @param result a #GAsyncResult.
     * @returns %TRUE on success, %FALSE otherwise.
     */
    static splice_finish(result: AsyncResult): boolean
}

module InetAddress {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.InetAddress

        bytes?: any | null
        family?: SocketFamily | null
    }

}

interface InetAddress {

    // Own properties of Gio-2.0.Gio.InetAddress

    readonly bytes: any
    readonly family: SocketFamily
    /**
     * Whether this is the "any" address for its family.
     * See g_inet_address_get_is_any().
     */
    readonly is_any: boolean
    /**
     * Whether this is a link-local address.
     * See g_inet_address_get_is_link_local().
     */
    readonly is_link_local: boolean
    /**
     * Whether this is the loopback address for its family.
     * See g_inet_address_get_is_loopback().
     */
    readonly is_loopback: boolean
    /**
     * Whether this is a global multicast address.
     * See g_inet_address_get_is_mc_global().
     */
    readonly is_mc_global: boolean
    /**
     * Whether this is a link-local multicast address.
     * See g_inet_address_get_is_mc_link_local().
     */
    readonly is_mc_link_local: boolean
    /**
     * Whether this is a node-local multicast address.
     * See g_inet_address_get_is_mc_node_local().
     */
    readonly is_mc_node_local: boolean
    /**
     * Whether this is an organization-local multicast address.
     * See g_inet_address_get_is_mc_org_local().
     */
    readonly is_mc_org_local: boolean
    /**
     * Whether this is a site-local multicast address.
     * See g_inet_address_get_is_mc_site_local().
     */
    readonly is_mc_site_local: boolean
    /**
     * Whether this is a multicast address.
     * See g_inet_address_get_is_multicast().
     */
    readonly is_multicast: boolean
    /**
     * Whether this is a site-local address.
     * See g_inet_address_get_is_loopback().
     */
    readonly is_site_local: boolean

    // Own fields of Gio-2.0.Gio.InetAddress

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.InetAddress

    /**
     * Checks if two #GInetAddress instances are equal, e.g. the same address.
     * @param other_address Another #GInetAddress.
     * @returns %TRUE if @address and @other_address are equal, %FALSE otherwise.
     */
    equal(other_address: InetAddress): boolean
    /**
     * Gets `address'`s family
     * @returns @address's family
     */
    get_family(): SocketFamily
    /**
     * Tests whether `address` is the "any" address for its family.
     * @returns %TRUE if @address is the "any" address for its family.
     */
    get_is_any(): boolean
    /**
     * Tests whether `address` is a link-local address (that is, if it
     * identifies a host on a local network that is not connected to the
     * Internet).
     * @returns %TRUE if @address is a link-local address.
     */
    get_is_link_local(): boolean
    /**
     * Tests whether `address` is the loopback address for its family.
     * @returns %TRUE if @address is the loopback address for its family.
     */
    get_is_loopback(): boolean
    /**
     * Tests whether `address` is a global multicast address.
     * @returns %TRUE if @address is a global multicast address.
     */
    get_is_mc_global(): boolean
    /**
     * Tests whether `address` is a link-local multicast address.
     * @returns %TRUE if @address is a link-local multicast address.
     */
    get_is_mc_link_local(): boolean
    /**
     * Tests whether `address` is a node-local multicast address.
     * @returns %TRUE if @address is a node-local multicast address.
     */
    get_is_mc_node_local(): boolean
    /**
     * Tests whether `address` is an organization-local multicast address.
     * @returns %TRUE if @address is an organization-local multicast address.
     */
    get_is_mc_org_local(): boolean
    /**
     * Tests whether `address` is a site-local multicast address.
     * @returns %TRUE if @address is a site-local multicast address.
     */
    get_is_mc_site_local(): boolean
    /**
     * Tests whether `address` is a multicast address.
     * @returns %TRUE if @address is a multicast address.
     */
    get_is_multicast(): boolean
    /**
     * Tests whether `address` is a site-local address such as 10.0.0.1
     * (that is, the address identifies a host on a local network that can
     * not be reached directly from the Internet, but which may have
     * outgoing Internet connectivity via a NAT or firewall).
     * @returns %TRUE if @address is a site-local address.
     */
    get_is_site_local(): boolean
    /**
     * Gets the size of the native raw binary address for `address`. This
     * is the size of the data that you get from g_inet_address_to_bytes().
     * @returns the number of bytes used for the native version of @address.
     */
    get_native_size(): number
    /**
     * Converts `address` to string form.
     * @returns a representation of @address as a string, which should be freed after use.
     */
    to_string(): string | null

    // Own virtual methods of Gio-2.0.Gio.InetAddress

    /**
     * Converts `address` to string form.
     * @virtual 
     * @returns a representation of @address as a string, which should be freed after use.
     */
    vfunc_to_string(): string | null

    // Class property signals of Gio-2.0.Gio.InetAddress

    connect(sigName: "notify::bytes", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bytes", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::bytes", ...args: any[]): void
    connect(sigName: "notify::family", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: "notify::is-any", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-any", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-any", ...args: any[]): void
    connect(sigName: "notify::is-link-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-link-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-link-local", ...args: any[]): void
    connect(sigName: "notify::is-loopback", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-loopback", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-loopback", ...args: any[]): void
    connect(sigName: "notify::is-mc-global", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-mc-global", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-mc-global", ...args: any[]): void
    connect(sigName: "notify::is-mc-link-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-mc-link-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-mc-link-local", ...args: any[]): void
    connect(sigName: "notify::is-mc-node-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-mc-node-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-mc-node-local", ...args: any[]): void
    connect(sigName: "notify::is-mc-org-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-mc-org-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-mc-org-local", ...args: any[]): void
    connect(sigName: "notify::is-mc-site-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-mc-site-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-mc-site-local", ...args: any[]): void
    connect(sigName: "notify::is-multicast", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-multicast", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-multicast", ...args: any[]): void
    connect(sigName: "notify::is-site-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-site-local", callback: (($obj: InetAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-site-local", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GInetAddress represents an IPv4 or IPv6 internet address. Use
 * g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to
 * look up the #GInetAddress for a hostname. Use
 * g_resolver_lookup_by_address() or
 * g_resolver_lookup_by_address_async() to look up the hostname for a
 * #GInetAddress.
 * 
 * To actually connect to a remote host, you will need a
 * #GInetSocketAddress (which includes a #GInetAddress as well as a
 * port number).
 * @class 
 */
class InetAddress extends GObject.Object {

    // Own properties of Gio-2.0.Gio.InetAddress

    static name: string
    static $gtype: GObject.GType<InetAddress>

    // Constructors of Gio-2.0.Gio.InetAddress

    constructor(config?: InetAddress.ConstructorProperties) 
    /**
     * Creates a #GInetAddress for the "any" address (unassigned/"don't
     * care") for `family`.
     * @constructor 
     * @param family the address family
     * @returns a new #GInetAddress corresponding to the "any" address for @family.     Free the returned object with g_object_unref().
     */
    static new_any(family: SocketFamily): InetAddress
    /**
     * Creates a new #GInetAddress from the given `family` and `bytes`.
     * `bytes` should be 4 bytes for %G_SOCKET_FAMILY_IPV4 and 16 bytes for
     * %G_SOCKET_FAMILY_IPV6.
     * @constructor 
     * @param bytes raw address data
     * @param family the address family of `bytes`
     * @returns a new #GInetAddress corresponding to @family and @bytes.     Free the returned object with g_object_unref().
     */
    static new_from_bytes(bytes: Uint8Array, family: SocketFamily): InetAddress
    /**
     * Parses `string` as an IP address and creates a new #GInetAddress.
     * @constructor 
     * @param string a string representation of an IP address
     * @returns a new #GInetAddress corresponding to @string, or %NULL if @string could not be parsed.     Free the returned object with g_object_unref().
     */
    static new_from_string(string: string | null): InetAddress
    /**
     * Creates a #GInetAddress for the loopback address for `family`.
     * @constructor 
     * @param family the address family
     * @returns a new #GInetAddress corresponding to the loopback address for @family.     Free the returned object with g_object_unref().
     */
    static new_loopback(family: SocketFamily): InetAddress
    _init(config?: InetAddress.ConstructorProperties): void
}

module InetAddressMask {

    // Constructor properties interface

    interface ConstructorProperties extends Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.InetAddressMask

        address?: InetAddress | null
        length?: number | null
    }

}

interface InetAddressMask extends Initable {

    // Own properties of Gio-2.0.Gio.InetAddressMask

    address: InetAddress
    readonly family: SocketFamily
    length: number

    // Own fields of Gio-2.0.Gio.InetAddressMask

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.InetAddressMask

    /**
     * Tests if `mask` and `mask2` are the same mask.
     * @param mask2 another #GInetAddressMask
     * @returns whether @mask and @mask2 are the same mask
     */
    equal(mask2: InetAddressMask): boolean
    /**
     * Gets `mask'`s base address
     * @returns @mask's base address
     */
    get_address(): InetAddress
    /**
     * Gets the #GSocketFamily of `mask'`s address
     * @returns the #GSocketFamily of @mask's address
     */
    get_family(): SocketFamily
    /**
     * Gets `mask'`s length
     * @returns @mask's length
     */
    get_length(): number
    /**
     * Tests if `address` falls within the range described by `mask`.
     * @param address a #GInetAddress
     * @returns whether @address falls within the range described by @mask.
     */
    matches(address: InetAddress): boolean
    /**
     * Converts `mask` back to its corresponding string form.
     * @returns a string corresponding to @mask.
     */
    to_string(): string | null

    // Class property signals of Gio-2.0.Gio.InetAddressMask

    connect(sigName: "notify::address", callback: (($obj: InetAddressMask, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::address", callback: (($obj: InetAddressMask, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::address", ...args: any[]): void
    connect(sigName: "notify::family", callback: (($obj: InetAddressMask, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: InetAddressMask, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: "notify::length", callback: (($obj: InetAddressMask, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::length", callback: (($obj: InetAddressMask, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::length", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GInetAddressMask represents a range of IPv4 or IPv6 addresses
 * described by a base address and a length indicating how many bits
 * of the base address are relevant for matching purposes. These are
 * often given in string form. Eg, "10.0.0.0/8", or "fe80::/10".
 * @class 
 */
class InetAddressMask extends GObject.Object {

    // Own properties of Gio-2.0.Gio.InetAddressMask

    static name: string
    static $gtype: GObject.GType<InetAddressMask>

    // Constructors of Gio-2.0.Gio.InetAddressMask

    constructor(config?: InetAddressMask.ConstructorProperties) 
    /**
     * Creates a new #GInetAddressMask representing all addresses whose
     * first `length` bits match `addr`.
     * @constructor 
     * @param addr a #GInetAddress
     * @param length number of bits of `addr` to use
     * @returns a new #GInetAddressMask, or %NULL on error
     */
    constructor(addr: InetAddress, length: number) 
    /**
     * Creates a new #GInetAddressMask representing all addresses whose
     * first `length` bits match `addr`.
     * @constructor 
     * @param addr a #GInetAddress
     * @param length number of bits of `addr` to use
     * @returns a new #GInetAddressMask, or %NULL on error
     */
    static new(addr: InetAddress, length: number): InetAddressMask
    /**
     * Parses `mask_string` as an IP address and (optional) length, and
     * creates a new #GInetAddressMask. The length, if present, is
     * delimited by a "/". If it is not present, then the length is
     * assumed to be the full length of the address.
     * @constructor 
     * @param mask_string an IP address or address/length string
     * @returns a new #GInetAddressMask corresponding to @string, or %NULL on error.
     */
    static new_from_string(mask_string: string | null): InetAddressMask
    _init(config?: InetAddressMask.ConstructorProperties): void
}

module InetSocketAddress {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnectable.ConstructorProperties, SocketAddress.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.InetSocketAddress

        address?: InetAddress | null
        /**
         * The `sin6_flowinfo` field, for IPv6 addresses.
         */
        flowinfo?: number | null
        port?: number | null
        scope_id?: number | null
    }

}

interface InetSocketAddress extends SocketConnectable {

    // Own properties of Gio-2.0.Gio.InetSocketAddress

    readonly address: InetAddress
    /**
     * The `sin6_flowinfo` field, for IPv6 addresses.
     */
    readonly flowinfo: number
    readonly port: number
    readonly scope_id: number

    // Own fields of Gio-2.0.Gio.InetSocketAddress

    parent_instance: SocketAddress & GObject.Object

    // Owm methods of Gio-2.0.Gio.InetSocketAddress

    /**
     * Gets `address'`s #GInetAddress.
     * @returns the #GInetAddress for @address, which must be g_object_ref()'d if it will be stored
     */
    get_address(): InetAddress
    /**
     * Gets the `sin6_flowinfo` field from `address,`
     * which must be an IPv6 address.
     * @returns the flowinfo field
     */
    get_flowinfo(): number
    /**
     * Gets `address'`s port.
     * @returns the port for @address
     */
    get_port(): number
    /**
     * Gets the `sin6_scope_id` field from `address,`
     * which must be an IPv6 address.
     * @returns the scope id field
     */
    get_scope_id(): number

    // Class property signals of Gio-2.0.Gio.InetSocketAddress

    connect(sigName: "notify::address", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::address", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::address", ...args: any[]): void
    connect(sigName: "notify::flowinfo", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flowinfo", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flowinfo", ...args: any[]): void
    connect(sigName: "notify::port", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::port", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::port", ...args: any[]): void
    connect(sigName: "notify::scope-id", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scope-id", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::scope-id", ...args: any[]): void
    connect(sigName: "notify::family", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: InetSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An IPv4 or IPv6 socket address; that is, the combination of a
 * #GInetAddress and a port number.
 * @class 
 */
class InetSocketAddress extends SocketAddress {

    // Own properties of Gio-2.0.Gio.InetSocketAddress

    static name: string
    static $gtype: GObject.GType<InetSocketAddress>

    // Constructors of Gio-2.0.Gio.InetSocketAddress

    constructor(config?: InetSocketAddress.ConstructorProperties) 
    /**
     * Creates a new #GInetSocketAddress for `address` and `port`.
     * @constructor 
     * @param address a #GInetAddress
     * @param port a port number
     * @returns a new #GInetSocketAddress
     */
    constructor(address: InetAddress, port: number) 
    /**
     * Creates a new #GInetSocketAddress for `address` and `port`.
     * @constructor 
     * @param address a #GInetAddress
     * @param port a port number
     * @returns a new #GInetSocketAddress
     */
    static new(address: InetAddress, port: number): InetSocketAddress
    /**
     * Creates a new #GInetSocketAddress for `address` and `port`.
     * 
     * If `address` is an IPv6 address, it can also contain a scope ID
     * (separated from the address by a `%`).
     * @constructor 
     * @param address the string form of an IP address
     * @param port a port number
     * @returns a new #GInetSocketAddress, or %NULL if @address cannot be parsed.
     */
    static new_from_string(address: string | null, port: number): InetSocketAddress
    _init(config?: InetSocketAddress.ConstructorProperties): void
}

module InputStream {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface InputStream {

    // Own fields of Gio-2.0.Gio.InputStream

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.InputStream

    /**
     * Clears the pending flag on `stream`.
     */
    clear_pending(): void
    /**
     * Closes the stream, releasing resources related to it.
     * 
     * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
     * Closing a stream multiple times will not return an error.
     * 
     * Streams will be automatically closed when the last reference
     * is dropped, but you might want to call this function to make sure
     * resources are released as early as possible.
     * 
     * Some streams might keep the backing store of the stream (e.g. a file descriptor)
     * open after the stream is closed. See the documentation for the individual
     * stream for details.
     * 
     * On failure the first error that happened will be reported, but the close
     * operation will finish as much as possible. A stream that failed to
     * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
     * is important to check and report the error to the user.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * Cancelling a close will still leave the stream closed, but some streams
     * can use a faster close that doesn't block to e.g. check errors.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE on success, %FALSE on failure
     */
    close(cancellable: Cancellable | null): boolean
    /**
     * Requests an asynchronous closes of the stream, releasing resources related to it.
     * When the operation is finished `callback` will be called.
     * You can then call g_input_stream_close_finish() to get the result of the
     * operation.
     * 
     * For behaviour details see g_input_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads to implement
     * asynchronicity, so they are optional for inheriting classes. However, if you
     * override one you must override all.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional cancellable object
     * @param callback callback to call when the request is satisfied
     */
    close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of close_async

    /**
     * Promisified version of {@link close_async}
     * 
     * Requests an asynchronous closes of the stream, releasing resources related to it.
     * When the operation is finished `callback` will be called.
     * You can then call g_input_stream_close_finish() to get the result of the
     * operation.
     * 
     * For behaviour details see g_input_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads to implement
     * asynchronicity, so they are optional for inheriting classes. However, if you
     * override one you must override all.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional cancellable object
     * @returns A Promise of: %TRUE if the stream was closed successfully.
     */
    close_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
     * @param result a #GAsyncResult.
     * @returns %TRUE if the stream was closed successfully.
     */
    close_finish(result: AsyncResult): boolean
    /**
     * Checks if an input stream has pending actions.
     * @returns %TRUE if @stream has pending actions.
     */
    has_pending(): boolean
    /**
     * Checks if an input stream is closed.
     * @returns %TRUE if the stream is closed.
     */
    is_closed(): boolean
    /**
     * Tries to read `count` bytes from the stream into the buffer starting at
     * `buffer`. Will block during this read.
     * 
     * If count is zero returns zero and does nothing. A value of `count`
     * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes read into the buffer is returned.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file. Zero is returned on end of file
     * (or if `count` is zero),  but never otherwise.
     * 
     * The returned `buffer` is not a nul-terminated string, it can contain nul bytes
     * at any position, and this function doesn't nul-terminate the `buffer`.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns Number of bytes read, or -1 on error, or 0 on end of file.
     */
    read(cancellable: Cancellable | null): [ /* returnType */ number, /* buffer */ Uint8Array ]
    /**
     * Tries to read `count` bytes from the stream into the buffer starting at
     * `buffer`. Will block during this read.
     * 
     * This function is similar to g_input_stream_read(), except it tries to
     * read as many bytes as requested, only stopping on an error or end of stream.
     * 
     * On a successful read of `count` bytes, or if we reached the end of the
     * stream,  %TRUE is returned, and `bytes_read` is set to the number of bytes
     * read into `buffer`.
     * 
     * If there is an error during the operation %FALSE is returned and `error`
     * is set to indicate the error status.
     * 
     * As a special exception to the normal conventions for functions that
     * use #GError, if this function returns %FALSE (and sets `error)` then
     * `bytes_read` will be set to the number of bytes that were successfully
     * read before the error was encountered.  This functionality is only
     * available from C.  If you need it from another language then you must
     * write your own loop around g_input_stream_read().
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE on success, %FALSE if there was an error
     */
    read_all(cancellable: Cancellable | null): [ /* returnType */ boolean, /* buffer */ Uint8Array, /* bytes_read */ number ]
    /**
     * Request an asynchronous read of `count` bytes from the stream into the
     * buffer starting at `buffer`.
     * 
     * This is the asynchronous equivalent of g_input_stream_read_all().
     * 
     * Call g_input_stream_read_all_finish() to collect the result.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback callback to call when the request is satisfied
     */
    read_all_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): /* buffer */ Uint8Array

    // Overloads of read_all_async

    /**
     * Promisified version of {@link read_all_async}
     * 
     * Request an asynchronous read of `count` bytes from the stream into the
     * buffer starting at `buffer`.
     * 
     * This is the asynchronous equivalent of g_input_stream_read_all().
     * 
     * Call g_input_stream_read_all_finish() to collect the result.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: %TRUE on success, %FALSE if there was an error
     */
    read_all_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* bytes_read */ number>
    /**
     * Finishes an asynchronous stream read operation started with
     * g_input_stream_read_all_async().
     * 
     * As a special exception to the normal conventions for functions that
     * use #GError, if this function returns %FALSE (and sets `error)` then
     * `bytes_read` will be set to the number of bytes that were successfully
     * read before the error was encountered.  This functionality is only
     * available from C.  If you need it from another language then you must
     * write your own loop around g_input_stream_read_async().
     * @param result a #GAsyncResult
     * @returns %TRUE on success, %FALSE if there was an error
     */
    read_all_finish(result: AsyncResult): [ /* returnType */ boolean, /* bytes_read */ number ]
    /**
     * Request an asynchronous read of `count` bytes from the stream into the buffer
     * starting at `buffer`. When the operation is finished `callback` will be called.
     * You can then call g_input_stream_read_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed on `stream,` and will
     * result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes read into the buffer will be passed to the
     * callback. It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file, but generally we try to read
     * as many bytes as requested. Zero is returned on end of file
     * (or if `count` is zero),  but never otherwise.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value) will
     * be executed before an outstanding request with lower priority. Default
     * priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads to implement
     * asynchronicity, so they are optional for inheriting classes. However, if you
     * override one you must override all.
     * @param io_priority the [I/O priority][io-priority] of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    read_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): /* buffer */ Uint8Array

    // Overloads of read_async

    /**
     * Promisified version of {@link read_async}
     * 
     * Request an asynchronous read of `count` bytes from the stream into the buffer
     * starting at `buffer`. When the operation is finished `callback` will be called.
     * You can then call g_input_stream_read_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed on `stream,` and will
     * result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes read into the buffer will be passed to the
     * callback. It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file, but generally we try to read
     * as many bytes as requested. Zero is returned on end of file
     * (or if `count` is zero),  but never otherwise.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value) will
     * be executed before an outstanding request with lower priority. Default
     * priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads to implement
     * asynchronicity, so they are optional for inheriting classes. However, if you
     * override one you must override all.
     * @param io_priority the [I/O priority][io-priority] of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: number of bytes read in, or -1 on error, or 0 on end of file.
     */
    read_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<number>
    /**
     * Like g_input_stream_read(), this tries to read `count` bytes from
     * the stream in a blocking fashion. However, rather than reading into
     * a user-supplied buffer, this will create a new #GBytes containing
     * the data that was read. This may be easier to use from language
     * bindings.
     * 
     * If count is zero, returns a zero-length #GBytes and does nothing. A
     * value of `count` larger than %G_MAXSSIZE will cause a
     * %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, a new #GBytes is returned. It is not an error if the
     * size of this object is not the same as the requested size, as it
     * can happen e.g. near the end of a file. A zero-length #GBytes is
     * returned on end of file (or if `count` is zero), but never
     * otherwise.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * On error %NULL is returned and `error` is set accordingly.
     * @param count maximum number of bytes that will be read from the stream. Common values include 4096 and 8192.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a new #GBytes, or %NULL on error
     */
    read_bytes(count: number, cancellable: Cancellable | null): GLib.Bytes
    /**
     * Request an asynchronous read of `count` bytes from the stream into a
     * new #GBytes. When the operation is finished `callback` will be
     * called. You can then call g_input_stream_read_bytes_finish() to get the
     * result of the operation.
     * 
     * During an async request no other sync and async calls are allowed
     * on `stream,` and will result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a
     * %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the new #GBytes will be passed to the callback. It is
     * not an error if this is smaller than the requested size, as it can
     * happen e.g. near the end of a file, but generally we try to read as
     * many bytes as requested. Zero is returned on end of file (or if
     * `count` is zero), but never otherwise.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * @param count the number of bytes that will be read from the stream
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    read_bytes_async(count: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of read_bytes_async

    /**
     * Promisified version of {@link read_bytes_async}
     * 
     * Request an asynchronous read of `count` bytes from the stream into a
     * new #GBytes. When the operation is finished `callback` will be
     * called. You can then call g_input_stream_read_bytes_finish() to get the
     * result of the operation.
     * 
     * During an async request no other sync and async calls are allowed
     * on `stream,` and will result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a
     * %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the new #GBytes will be passed to the callback. It is
     * not an error if this is smaller than the requested size, as it can
     * happen e.g. near the end of a file, but generally we try to read as
     * many bytes as requested. Zero is returned on end of file (or if
     * `count` is zero), but never otherwise.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * @param count the number of bytes that will be read from the stream
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: the newly-allocated #GBytes, or %NULL on error
     */
    read_bytes_async(count: number, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<GLib.Bytes>
    /**
     * Finishes an asynchronous stream read-into-#GBytes operation.
     * @param result a #GAsyncResult.
     * @returns the newly-allocated #GBytes, or %NULL on error
     */
    read_bytes_finish(result: AsyncResult): GLib.Bytes
    /**
     * Finishes an asynchronous stream read operation.
     * @param result a #GAsyncResult.
     * @returns number of bytes read in, or -1 on error, or 0 on end of file.
     */
    read_finish(result: AsyncResult): number
    /**
     * Sets `stream` to have actions pending. If the pending flag is
     * already set or `stream` is closed, it will return %FALSE and set
     * `error`.
     * @returns %TRUE if pending was previously unset and is now set.
     */
    set_pending(): boolean
    /**
     * Tries to skip `count` bytes from the stream. Will block during the operation.
     * 
     * This is identical to g_input_stream_read(), from a behaviour standpoint,
     * but the bytes that are skipped are not returned to the user. Some
     * streams have an implementation that is more efficient than reading the data.
     * 
     * This function is optional for inherited classes, as the default implementation
     * emulates it using read.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * @param count the number of bytes that will be skipped from the stream
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns Number of bytes skipped, or -1 on error
     */
    skip(count: number, cancellable: Cancellable | null): number
    /**
     * Request an asynchronous skip of `count` bytes from the stream.
     * When the operation is finished `callback` will be called.
     * You can then call g_input_stream_skip_finish() to get the result
     * of the operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes skipped will be passed to the callback.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file, but generally we try to skip
     * as many bytes as requested. Zero is returned on end of file
     * (or if `count` is zero), but never otherwise.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value)
     * will be executed before an outstanding request with lower priority.
     * Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads to
     * implement asynchronicity, so they are optional for inheriting classes.
     * However, if you override one, you must override all.
     * @param count the number of bytes that will be skipped from the stream
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    skip_async(count: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of skip_async

    /**
     * Promisified version of {@link skip_async}
     * 
     * Request an asynchronous skip of `count` bytes from the stream.
     * When the operation is finished `callback` will be called.
     * You can then call g_input_stream_skip_finish() to get the result
     * of the operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes skipped will be passed to the callback.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file, but generally we try to skip
     * as many bytes as requested. Zero is returned on end of file
     * (or if `count` is zero), but never otherwise.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value)
     * will be executed before an outstanding request with lower priority.
     * Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads to
     * implement asynchronicity, so they are optional for inheriting classes.
     * However, if you override one, you must override all.
     * @param count the number of bytes that will be skipped from the stream
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: the size of the bytes skipped, or `-1` on error.
     */
    skip_async(count: number, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<number>
    /**
     * Finishes a stream skip operation.
     * @param result a #GAsyncResult.
     * @returns the size of the bytes skipped, or `-1` on error.
     */
    skip_finish(result: AsyncResult): number

    // Own virtual methods of Gio-2.0.Gio.InputStream

    /**
     * Requests an asynchronous closes of the stream, releasing resources related to it.
     * When the operation is finished `callback` will be called.
     * You can then call g_input_stream_close_finish() to get the result of the
     * operation.
     * 
     * For behaviour details see g_input_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads to implement
     * asynchronicity, so they are optional for inheriting classes. However, if you
     * override one you must override all.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional cancellable object
     * @param callback callback to call when the request is satisfied
     */
    vfunc_close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes closing a stream asynchronously, started from g_input_stream_close_async().
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if the stream was closed successfully.
     */
    vfunc_close_finish(result: AsyncResult): boolean
    vfunc_close_fn(cancellable: Cancellable | null): boolean
    /**
     * Request an asynchronous read of `count` bytes from the stream into the buffer
     * starting at `buffer`. When the operation is finished `callback` will be called.
     * You can then call g_input_stream_read_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed on `stream,` and will
     * result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes read into the buffer will be passed to the
     * callback. It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file, but generally we try to read
     * as many bytes as requested. Zero is returned on end of file
     * (or if `count` is zero),  but never otherwise.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value) will
     * be executed before an outstanding request with lower priority. Default
     * priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads to implement
     * asynchronicity, so they are optional for inheriting classes. However, if you
     * override one you must override all.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    vfunc_read_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): /* buffer */ Uint8Array | null
    /**
     * Finishes an asynchronous stream read operation.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns number of bytes read in, or -1 on error, or 0 on end of file.
     */
    vfunc_read_finish(result: AsyncResult): number
    vfunc_read_fn(buffer: any | null, count: number, cancellable: Cancellable | null): number
    /**
     * Tries to skip `count` bytes from the stream. Will block during the operation.
     * 
     * This is identical to g_input_stream_read(), from a behaviour standpoint,
     * but the bytes that are skipped are not returned to the user. Some
     * streams have an implementation that is more efficient than reading the data.
     * 
     * This function is optional for inherited classes, as the default implementation
     * emulates it using read.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * @virtual 
     * @param count the number of bytes that will be skipped from the stream
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns Number of bytes skipped, or -1 on error
     */
    vfunc_skip(count: number, cancellable: Cancellable | null): number
    /**
     * Request an asynchronous skip of `count` bytes from the stream.
     * When the operation is finished `callback` will be called.
     * You can then call g_input_stream_skip_finish() to get the result
     * of the operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes skipped will be passed to the callback.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. near the end of a file, but generally we try to skip
     * as many bytes as requested. Zero is returned on end of file
     * (or if `count` is zero), but never otherwise.
     * 
     * Any outstanding i/o request with higher priority (lower numerical value)
     * will be executed before an outstanding request with lower priority.
     * Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads to
     * implement asynchronicity, so they are optional for inheriting classes.
     * However, if you override one, you must override all.
     * @virtual 
     * @param count the number of bytes that will be skipped from the stream
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    vfunc_skip_async(count: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a stream skip operation.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns the size of the bytes skipped, or `-1` on error.
     */
    vfunc_skip_finish(result: AsyncResult): number

    // Class property signals of Gio-2.0.Gio.InputStream

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GInputStream has functions to read from a stream (g_input_stream_read()),
 * to close a stream (g_input_stream_close()) and to skip some content
 * (g_input_stream_skip()).
 * 
 * To copy the content of an input stream to an output stream without
 * manually handling the reads and writes, use g_output_stream_splice().
 * 
 * See the documentation for #GIOStream for details of thread safety of
 * streaming APIs.
 * 
 * All of these functions have async variants too.
 * @class 
 */
class InputStream extends GObject.Object {

    // Own properties of Gio-2.0.Gio.InputStream

    static name: string
    static $gtype: GObject.GType<InputStream>

    // Constructors of Gio-2.0.Gio.InputStream

    constructor(config?: InputStream.ConstructorProperties) 
    _init(config?: InputStream.ConstructorProperties): void
}

module ListStore {

    // Constructor properties interface

    interface ConstructorProperties extends ListModel.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ListStore

        /**
         * The type of items contained in this list store. Items must be
         * subclasses of #GObject.
         */
        item_type?: GObject.GType | null
    }

}

interface ListStore<A extends GObject.Object = GObject.Object> extends ListModel {

    // Own properties of Gio-2.0.Gio.ListStore

    /**
     * The type of items contained in this list store. Items must be
     * subclasses of #GObject.
     */
    readonly item_type: GObject.GType
    /**
     * The number of items contained in this list store.
     */
    readonly n_items: number

    // Owm methods of Gio-2.0.Gio.ListStore

    /**
     * Appends `item` to `store`. `item` must be of type #GListStore:item-type.
     * 
     * This function takes a ref on `item`.
     * 
     * Use g_list_store_splice() to append multiple items at the same time
     * efficiently.
     * @param item the new item
     */
    append(item: GObject.Object): void
    /**
     * Looks up the given `item` in the list store by looping over the items until
     * the first occurrence of `item`. If `item` was not found, then `position` will
     * not be set, and this method will return %FALSE.
     * 
     * If you need to compare the two items with a custom comparison function, use
     * g_list_store_find_with_equal_func() with a custom #GEqualFunc instead.
     * @param item an item
     * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
     */
    find(item: GObject.Object): [ /* returnType */ boolean, /* position */ number ]
    /**
     * Looks up the given `item` in the list store by looping over the items and
     * comparing them with `equal_func` until the first occurrence of `item` which
     * matches. If `item` was not found, then `position` will not be set, and this
     * method will return %FALSE.
     * 
     * `item` is always passed as second parameter to `equal_func`.
     * 
     * Since GLib 2.76 it is possible to pass `NULL` for `item`.
     * @param item an item
     * @param equal_func A custom equality check function
     * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
     */
    find_with_equal_func(item: GObject.Object | null, equal_func: GLib.EqualFunc): [ /* returnType */ boolean, /* position */ number ]
    /**
     * Like g_list_store_find_with_equal_func() but with an additional `user_data`
     * that is passed to `equal_func`.
     * 
     * `item` is always passed as second parameter to `equal_func`.
     * 
     * Since GLib 2.76 it is possible to pass `NULL` for `item`.
     * @param item an item
     * @param equal_func A custom equality check function
     * @returns Whether @store contains @item. If it was found, @position will be set to the position where @item occurred for the first time.
     */
    find_with_equal_func_full(item: GObject.Object | null, equal_func: GLib.EqualFuncFull): [ /* returnType */ boolean, /* position */ number ]
    /**
     * Inserts `item` into `store` at `position`. `item` must be of type
     * #GListStore:item-type or derived from it. `position` must be smaller
     * than the length of the list, or equal to it to append.
     * 
     * This function takes a ref on `item`.
     * 
     * Use g_list_store_splice() to insert multiple items at the same time
     * efficiently.
     * @param position the position at which to insert the new item
     * @param item the new item
     */
    insert(position: number, item: GObject.Object): void
    // Has conflict: insert_sorted(item: GObject.Object, compare_func: GLib.CompareDataFunc): number
    /**
     * Removes the item from `store` that is at `position`. `position` must be
     * smaller than the current length of the list.
     * 
     * Use g_list_store_splice() to remove multiple items at the same time
     * efficiently.
     * @param position the position of the item that is to be removed
     */
    remove(position: number): void
    /**
     * Removes all items from `store`.
     */
    remove_all(): void
    /**
     * Sort the items in `store` according to `compare_func`.
     * @param compare_func pairwise comparison function for sorting
     */
    sort(compare_func: GLib.CompareDataFunc): void
    /**
     * Changes `store` by removing `n_removals` items and adding `n_additions`
     * items to it. `additions` must contain `n_additions` items of type
     * #GListStore:item-type.  %NULL is not permitted.
     * 
     * This function is more efficient than g_list_store_insert() and
     * g_list_store_remove(), because it only emits
     * #GListModel::items-changed once for the change.
     * 
     * This function takes a ref on each item in `additions`.
     * 
     * The parameters `position` and `n_removals` must be correct (ie:
     * `position` + `n_removals` must be less than or equal to the length of
     * the list at the time this function is called).
     * @param position the position at which to make the change
     * @param n_removals the number of items to remove
     * @param additions the items to add
     */
    splice(position: number, n_removals: number, additions: GObject.Object[]): void
    /**
     * Inserts `item` into `store` at a position to be determined by the
     * `compare_func`.
     * 
     * The list must already be sorted before calling this function or the
     * result is undefined.  Usually you would approach this by only ever
     * inserting items by way of this function.
     * 
     * This function takes a ref on `item`.
     * @param item the new item
     * @param compare_func pairwise comparison function for sorting
     * @returns the position at which @item was inserted
     */
    insert_sorted(item: A, compare_func: GLib.CompareDataFunc): number
    sort(compare_func: GLib.CompareDataFunc): void

    // Class property signals of Gio-2.0.Gio.ListStore

    connect(sigName: "notify::item-type", callback: (($obj: ListStore, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::item-type", callback: (($obj: ListStore, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::item-type", ...args: any[]): void
    connect(sigName: "notify::n-items", callback: (($obj: ListStore, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-items", callback: (($obj: ListStore, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::n-items", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GListStore is a simple implementation of #GListModel that stores all
 * items in memory.
 * 
 * It provides insertions, deletions, and lookups in logarithmic time
 * with a fast path for the common case of iterating the list linearly.
 * @class 
 */
class ListStore<A extends GObject.Object = GObject.Object> extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ListStore

    static name: string
    static $gtype: GObject.GType<ListStore>

    // Constructors of Gio-2.0.Gio.ListStore

    constructor(config?: ListStore.ConstructorProperties) 
    /**
     * Creates a new #GListStore with items of type `item_type`. `item_type`
     * must be a subclass of #GObject.
     * @constructor 
     * @param item_type the #GType of items in the list
     * @returns a new #GListStore
     */
    constructor(item_type: GObject.GType) 
    /**
     * Creates a new #GListStore with items of type `item_type`. `item_type`
     * must be a subclass of #GObject.
     * @constructor 
     * @param item_type the #GType of items in the list
     * @returns a new #GListStore
     */
    static new(item_type: GObject.GType): ListStore
    _init(config?: ListStore.ConstructorProperties): void
}

module MemoryInputStream {

    // Constructor properties interface

    interface ConstructorProperties extends PollableInputStream.ConstructorProperties, Seekable.ConstructorProperties, InputStream.ConstructorProperties {
    }

}

interface MemoryInputStream extends PollableInputStream, Seekable {

    // Own fields of Gio-2.0.Gio.MemoryInputStream

    parent_instance: InputStream & GObject.Object

    // Owm methods of Gio-2.0.Gio.MemoryInputStream

    /**
     * Appends `bytes` to data that can be read from the input stream.
     * @param bytes input data
     */
    add_bytes(bytes: GLib.Bytes): void
    /**
     * Appends `data` to data that can be read from the input stream
     * @param data input data
     * @param destroy function that is called to free `data,` or %NULL
     */
    add_data(data: Uint8Array, destroy: GLib.DestroyNotify | null): void

    // Class property signals of Gio-2.0.Gio.MemoryInputStream

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMemoryInputStream is a class for using arbitrary
 * memory chunks as input for GIO streaming input operations.
 * 
 * As of GLib 2.34, #GMemoryInputStream implements
 * #GPollableInputStream.
 * @class 
 */
class MemoryInputStream extends InputStream {

    // Own properties of Gio-2.0.Gio.MemoryInputStream

    static name: string
    static $gtype: GObject.GType<MemoryInputStream>

    // Constructors of Gio-2.0.Gio.MemoryInputStream

    constructor(config?: MemoryInputStream.ConstructorProperties) 
    /**
     * Creates a new empty #GMemoryInputStream.
     * @constructor 
     * @returns a new #GInputStream
     */
    constructor() 
    /**
     * Creates a new empty #GMemoryInputStream.
     * @constructor 
     * @returns a new #GInputStream
     */
    static new(): MemoryInputStream
    /**
     * Creates a new #GMemoryInputStream with data from the given `bytes`.
     * @constructor 
     * @param bytes a #GBytes
     * @returns new #GInputStream read from @bytes
     */
    static new_from_bytes(bytes: GLib.Bytes): MemoryInputStream
    /**
     * Creates a new #GMemoryInputStream with data in memory of a given size.
     * @constructor 
     * @param data input data
     * @param destroy function that is called to free `data,` or %NULL
     * @returns new #GInputStream read from @data of @len bytes.
     */
    static new_from_data(data: Uint8Array, destroy: GLib.DestroyNotify | null): MemoryInputStream
    _init(config?: MemoryInputStream.ConstructorProperties): void
}

module MemoryOutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends PollableOutputStream.ConstructorProperties, Seekable.ConstructorProperties, OutputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.MemoryOutputStream

        /**
         * Pointer to buffer where data will be written.
         */
        data?: any | null
        /**
         * Current size of the data buffer.
         */
        size?: number | null
    }

}

interface MemoryOutputStream extends PollableOutputStream, Seekable {

    // Own properties of Gio-2.0.Gio.MemoryOutputStream

    /**
     * Pointer to buffer where data will be written.
     */
    readonly data: any
    /**
     * Size of data written to the buffer.
     */
    readonly data_size: number
    /**
     * Current size of the data buffer.
     */
    readonly size: number

    // Own fields of Gio-2.0.Gio.MemoryOutputStream

    parent_instance: OutputStream & GObject.Object

    // Owm methods of Gio-2.0.Gio.MemoryOutputStream

    /**
     * Gets any loaded data from the `ostream`.
     * 
     * Note that the returned pointer may become invalid on the next
     * write or truncate operation on the stream.
     * @returns pointer to the stream's data, or %NULL if the data    has been stolen
     */
    get_data(): any | null

    // Overloads of get_data

    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     * @returns the data if found,          or %NULL if no such data exists.
     */
    get_data(key: string | null): any | null
    /**
     * Returns the number of bytes from the start up to including the last
     * byte written in the stream that has not been truncated away.
     * @returns the number of bytes written to the stream
     */
    get_data_size(): number
    /**
     * Gets the size of the currently allocated data area (available from
     * g_memory_output_stream_get_data()).
     * 
     * You probably don't want to use this function on resizable streams.
     * See g_memory_output_stream_get_data_size() instead.  For resizable
     * streams the size returned by this function is an implementation
     * detail and may be change at any time in response to operations on the
     * stream.
     * 
     * If the stream is fixed-sized (ie: no realloc was passed to
     * g_memory_output_stream_new()) then this is the maximum size of the
     * stream and further writes will return %G_IO_ERROR_NO_SPACE.
     * 
     * In any case, if you want the number of bytes currently written to the
     * stream, use g_memory_output_stream_get_data_size().
     * @returns the number of bytes allocated for the data buffer
     */
    get_size(): number
    /**
     * Returns data from the `ostream` as a #GBytes. `ostream` must be
     * closed before calling this function.
     * @returns the stream's data
     */
    steal_as_bytes(): GLib.Bytes
    /**
     * Gets any loaded data from the `ostream`. Ownership of the data
     * is transferred to the caller; when no longer needed it must be
     * freed using the free function set in `ostream'`s
     * #GMemoryOutputStream:destroy-function property.
     * 
     * `ostream` must be closed before calling this function.
     * @returns the stream's data, or %NULL if it has previously    been stolen
     */
    steal_data(): any | null

    // Overloads of steal_data

    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     * @returns the data if found, or %NULL          if no such data exists.
     */
    steal_data(key: string | null): any | null

    // Class property signals of Gio-2.0.Gio.MemoryOutputStream

    connect(sigName: "notify::data", callback: (($obj: MemoryOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::data", callback: (($obj: MemoryOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::data", ...args: any[]): void
    connect(sigName: "notify::data-size", callback: (($obj: MemoryOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::data-size", callback: (($obj: MemoryOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::data-size", ...args: any[]): void
    connect(sigName: "notify::size", callback: (($obj: MemoryOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: (($obj: MemoryOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::size", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMemoryOutputStream is a class for using arbitrary
 * memory chunks as output for GIO streaming output operations.
 * 
 * As of GLib 2.34, #GMemoryOutputStream trivially implements
 * #GPollableOutputStream: it always polls as ready.
 * @class 
 */
class MemoryOutputStream extends OutputStream {

    // Own properties of Gio-2.0.Gio.MemoryOutputStream

    static name: string
    static $gtype: GObject.GType<MemoryOutputStream>

    // Constructors of Gio-2.0.Gio.MemoryOutputStream

    constructor(config?: MemoryOutputStream.ConstructorProperties) 
    /**
     * Creates a new #GMemoryOutputStream, using g_realloc() and g_free()
     * for memory allocation.
     * @constructor 
     */
    static new_resizable(): MemoryOutputStream
    _init(config?: MemoryOutputStream.ConstructorProperties): void
}

module Menu {

    // Constructor properties interface

    interface ConstructorProperties extends MenuModel.ConstructorProperties {
    }

}

interface Menu {

    // Owm methods of Gio-2.0.Gio.Menu

    /**
     * Convenience function for appending a normal menu item to the end of
     * `menu`.  Combine g_menu_item_new() and g_menu_insert_item() for a more
     * flexible alternative.
     * @param label the section label, or %NULL
     * @param detailed_action the detailed action string, or %NULL
     */
    append(label: string | null, detailed_action: string | null): void
    /**
     * Appends `item` to the end of `menu`.
     * 
     * See g_menu_insert_item() for more information.
     * @param item a #GMenuItem to append
     */
    append_item(item: MenuItem): void
    /**
     * Convenience function for appending a section menu item to the end of
     * `menu`.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
     * more flexible alternative.
     * @param label the section label, or %NULL
     * @param section a #GMenuModel with the items of the section
     */
    append_section(label: string | null, section: MenuModel): void
    /**
     * Convenience function for appending a submenu menu item to the end of
     * `menu`.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
     * more flexible alternative.
     * @param label the section label, or %NULL
     * @param submenu a #GMenuModel with the items of the submenu
     */
    append_submenu(label: string | null, submenu: MenuModel): void
    /**
     * Marks `menu` as frozen.
     * 
     * After the menu is frozen, it is an error to attempt to make any
     * changes to it.  In effect this means that the #GMenu API must no
     * longer be used.
     * 
     * This function causes g_menu_model_is_mutable() to begin returning
     * %FALSE, which has some positive performance implications.
     */
    freeze(): void
    /**
     * Convenience function for inserting a normal menu item into `menu`.
     * Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
     * alternative.
     * @param position the position at which to insert the item
     * @param label the section label, or %NULL
     * @param detailed_action the detailed action string, or %NULL
     */
    insert(position: number, label: string | null, detailed_action: string | null): void
    /**
     * Inserts `item` into `menu`.
     * 
     * The "insertion" is actually done by copying all of the attribute and
     * link values of `item` and using them to form a new item within `menu`.
     * As such, `item` itself is not really inserted, but rather, a menu item
     * that is exactly the same as the one presently described by `item`.
     * 
     * This means that `item` is essentially useless after the insertion
     * occurs.  Any changes you make to it are ignored unless it is inserted
     * again (at which point its updated values will be copied).
     * 
     * You should probably just free `item` once you're done.
     * 
     * There are many convenience functions to take care of common cases.
     * See g_menu_insert(), g_menu_insert_section() and
     * g_menu_insert_submenu() as well as "prepend" and "append" variants of
     * each of these functions.
     * @param position the position at which to insert the item
     * @param item the #GMenuItem to insert
     */
    insert_item(position: number, item: MenuItem): void
    /**
     * Convenience function for inserting a section menu item into `menu`.
     * Combine g_menu_item_new_section() and g_menu_insert_item() for a more
     * flexible alternative.
     * @param position the position at which to insert the item
     * @param label the section label, or %NULL
     * @param section a #GMenuModel with the items of the section
     */
    insert_section(position: number, label: string | null, section: MenuModel): void
    /**
     * Convenience function for inserting a submenu menu item into `menu`.
     * Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
     * flexible alternative.
     * @param position the position at which to insert the item
     * @param label the section label, or %NULL
     * @param submenu a #GMenuModel with the items of the submenu
     */
    insert_submenu(position: number, label: string | null, submenu: MenuModel): void
    /**
     * Convenience function for prepending a normal menu item to the start
     * of `menu`.  Combine g_menu_item_new() and g_menu_insert_item() for a more
     * flexible alternative.
     * @param label the section label, or %NULL
     * @param detailed_action the detailed action string, or %NULL
     */
    prepend(label: string | null, detailed_action: string | null): void
    /**
     * Prepends `item` to the start of `menu`.
     * 
     * See g_menu_insert_item() for more information.
     * @param item a #GMenuItem to prepend
     */
    prepend_item(item: MenuItem): void
    /**
     * Convenience function for prepending a section menu item to the start
     * of `menu`.  Combine g_menu_item_new_section() and g_menu_insert_item() for
     * a more flexible alternative.
     * @param label the section label, or %NULL
     * @param section a #GMenuModel with the items of the section
     */
    prepend_section(label: string | null, section: MenuModel): void
    /**
     * Convenience function for prepending a submenu menu item to the start
     * of `menu`.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
     * a more flexible alternative.
     * @param label the section label, or %NULL
     * @param submenu a #GMenuModel with the items of the submenu
     */
    prepend_submenu(label: string | null, submenu: MenuModel): void
    /**
     * Removes an item from the menu.
     * 
     * `position` gives the index of the item to remove.
     * 
     * It is an error if position is not in range the range from 0 to one
     * less than the number of items in the menu.
     * 
     * It is not possible to remove items by identity since items are added
     * to the menu simply by copying their links and attributes (ie:
     * identity of the item itself is not preserved).
     * @param position the position of the item to remove
     */
    remove(position: number): void
    /**
     * Removes all items in the menu.
     */
    remove_all(): void

    // Class property signals of Gio-2.0.Gio.Menu

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMenu is a simple implementation of #GMenuModel.
 * You populate a #GMenu by adding #GMenuItem instances to it.
 * 
 * There are some convenience functions to allow you to directly
 * add items (avoiding #GMenuItem) for the common cases. To add
 * a regular item, use g_menu_insert(). To add a section, use
 * g_menu_insert_section(). To add a submenu, use
 * g_menu_insert_submenu().
 * @class 
 */
class Menu extends MenuModel {

    // Own properties of Gio-2.0.Gio.Menu

    static name: string
    static $gtype: GObject.GType<Menu>

    // Constructors of Gio-2.0.Gio.Menu

    constructor(config?: Menu.ConstructorProperties) 
    /**
     * Creates a new #GMenu.
     * 
     * The new menu has no items.
     * @constructor 
     * @returns a new #GMenu
     */
    constructor() 
    /**
     * Creates a new #GMenu.
     * 
     * The new menu has no items.
     * @constructor 
     * @returns a new #GMenu
     */
    static new(): Menu
    _init(config?: Menu.ConstructorProperties): void
}

module MenuAttributeIter {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface MenuAttributeIter {

    // Own fields of Gio-2.0.Gio.MenuAttributeIter

    parent_instance: GObject.Object
    priv: MenuAttributeIterPrivate

    // Owm methods of Gio-2.0.Gio.MenuAttributeIter

    /**
     * Gets the name of the attribute at the current iterator position, as
     * a string.
     * 
     * The iterator is not advanced.
     * @returns the name of the attribute
     */
    get_name(): string | null
    /**
     * This function combines g_menu_attribute_iter_next() with
     * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
     * 
     * First the iterator is advanced to the next (possibly first) attribute.
     * If that fails, then %FALSE is returned and there are no other
     * effects.
     * 
     * If successful, `name` and `value` are set to the name and value of the
     * attribute that has just been advanced to.  At this point,
     * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
     * return the same values again.
     * 
     * The value returned in `name` remains valid for as long as the iterator
     * remains at the current position.  The value returned in `value` must
     * be unreffed using g_variant_unref() when it is no longer in use.
     * @returns %TRUE on success, or %FALSE if there is no additional     attribute
     */
    get_next(): [ /* returnType */ boolean, /* out_name */ string | null, /* value */ GLib.Variant ]
    /**
     * Gets the value of the attribute at the current iterator position.
     * 
     * The iterator is not advanced.
     * @returns the value of the current attribute
     */
    get_value(): GLib.Variant
    /**
     * Attempts to advance the iterator to the next (possibly first)
     * attribute.
     * 
     * %TRUE is returned on success, or %FALSE if there are no more
     * attributes.
     * 
     * You must call this function when you first acquire the iterator
     * to advance it to the first attribute (and determine if the first
     * attribute exists at all).
     * @returns %TRUE on success, or %FALSE when there are no more attributes
     */
    next(): boolean

    // Own virtual methods of Gio-2.0.Gio.MenuAttributeIter

    /**
     * This function combines g_menu_attribute_iter_next() with
     * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
     * 
     * First the iterator is advanced to the next (possibly first) attribute.
     * If that fails, then %FALSE is returned and there are no other
     * effects.
     * 
     * If successful, `name` and `value` are set to the name and value of the
     * attribute that has just been advanced to.  At this point,
     * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
     * return the same values again.
     * 
     * The value returned in `name` remains valid for as long as the iterator
     * remains at the current position.  The value returned in `value` must
     * be unreffed using g_variant_unref() when it is no longer in use.
     * @virtual 
     * @returns %TRUE on success, or %FALSE if there is no additional     attribute
     */
    vfunc_get_next(): [ /* returnType */ boolean, /* out_name */ string | null, /* value */ GLib.Variant ]

    // Class property signals of Gio-2.0.Gio.MenuAttributeIter

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMenuAttributeIter is an opaque structure type.  You must access it
 * using the functions below.
 * @class 
 */
class MenuAttributeIter extends GObject.Object {

    // Own properties of Gio-2.0.Gio.MenuAttributeIter

    static name: string
    static $gtype: GObject.GType<MenuAttributeIter>

    // Constructors of Gio-2.0.Gio.MenuAttributeIter

    constructor(config?: MenuAttributeIter.ConstructorProperties) 
    _init(config?: MenuAttributeIter.ConstructorProperties): void
}

module MenuItem {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface MenuItem {

    // Owm methods of Gio-2.0.Gio.MenuItem

    /**
     * Queries the named `attribute` on `menu_item`.
     * 
     * If `expected_type` is specified and the attribute does not have this
     * type, %NULL is returned.  %NULL is also returned if the attribute
     * simply does not exist.
     * @param attribute the attribute name to query
     * @param expected_type the expected type of the attribute
     * @returns the attribute value, or %NULL
     */
    get_attribute_value(attribute: string | null, expected_type: GLib.VariantType | null): GLib.Variant | null
    /**
     * Queries the named `link` on `menu_item`.
     * @param link the link name to query
     * @returns the link, or %NULL
     */
    get_link(link: string | null): MenuModel | null
    /**
     * Sets or unsets the "action" and "target" attributes of `menu_item`.
     * 
     * If `action` is %NULL then both the "action" and "target" attributes
     * are unset (and `target_value` is ignored).
     * 
     * If `action` is non-%NULL then the "action" attribute is set.  The
     * "target" attribute is then set to the value of `target_value` if it is
     * non-%NULL or unset otherwise.
     * 
     * Normal menu items (ie: not submenu, section or other custom item
     * types) are expected to have the "action" attribute set to identify
     * the action that they are associated with.  The state type of the
     * action help to determine the disposition of the menu item.  See
     * #GAction and #GActionGroup for an overview of actions.
     * 
     * In general, clicking on the menu item will result in activation of
     * the named action with the "target" attribute given as the parameter
     * to the action invocation.  If the "target" attribute is not set then
     * the action is invoked with no parameter.
     * 
     * If the action has no state then the menu item is usually drawn as a
     * plain menu item (ie: with no additional decoration).
     * 
     * If the action has a boolean state then the menu item is usually drawn
     * as a toggle menu item (ie: with a checkmark or equivalent
     * indication).  The item should be marked as 'toggled' or 'checked'
     * when the boolean state is %TRUE.
     * 
     * If the action has a string state then the menu item is usually drawn
     * as a radio menu item (ie: with a radio bullet or equivalent
     * indication).  The item should be marked as 'selected' when the string
     * state is equal to the value of the `target` property.
     * 
     * See g_menu_item_set_action_and_target() or
     * g_menu_item_set_detailed_action() for two equivalent calls that are
     * probably more convenient for most uses.
     * @param action the name of the action for this item
     * @param target_value a #GVariant to use as the action target
     */
    set_action_and_target_value(action: string | null, target_value: GLib.Variant | null): void
    /**
     * Sets or unsets an attribute on `menu_item`.
     * 
     * The attribute to set or unset is specified by `attribute`. This
     * can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
     * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
     * attribute name.
     * Attribute names are restricted to lowercase characters, numbers
     * and '-'. Furthermore, the names must begin with a lowercase character,
     * must not end with a '-', and must not contain consecutive dashes.
     * 
     * must consist only of lowercase
     * ASCII characters, digits and '-'.
     * 
     * If `value` is non-%NULL then it is used as the new value for the
     * attribute.  If `value` is %NULL then the attribute is unset. If
     * the `value` #GVariant is floating, it is consumed.
     * 
     * See also g_menu_item_set_attribute() for a more convenient way to do
     * the same.
     * @param attribute the attribute to set
     * @param value a #GVariant to use as the value, or %NULL
     */
    set_attribute_value(attribute: string | null, value: GLib.Variant | null): void
    /**
     * Sets the "action" and possibly the "target" attribute of `menu_item`.
     * 
     * The format of `detailed_action` is the same format parsed by
     * g_action_parse_detailed_name().
     * 
     * See g_menu_item_set_action_and_target() or
     * g_menu_item_set_action_and_target_value() for more flexible (but
     * slightly less convenient) alternatives.
     * 
     * See also g_menu_item_set_action_and_target_value() for a description of
     * the semantics of the action and target attributes.
     * @param detailed_action the "detailed" action string
     */
    set_detailed_action(detailed_action: string | null): void
    /**
     * Sets (or unsets) the icon on `menu_item`.
     * 
     * This call is the same as calling g_icon_serialize() and using the
     * result as the value to g_menu_item_set_attribute_value() for
     * %G_MENU_ATTRIBUTE_ICON.
     * 
     * This API is only intended for use with "noun" menu items; things like
     * bookmarks or applications in an "Open With" menu.  Don't use it on
     * menu items corresponding to verbs (eg: stock icons for 'Save' or
     * 'Quit').
     * 
     * If `icon` is %NULL then the icon is unset.
     * @param icon a #GIcon, or %NULL
     */
    set_icon(icon: Icon): void
    /**
     * Sets or unsets the "label" attribute of `menu_item`.
     * 
     * If `label` is non-%NULL it is used as the label for the menu item.  If
     * it is %NULL then the label attribute is unset.
     * @param label the label to set, or %NULL to unset
     */
    set_label(label: string | null): void
    /**
     * Creates a link from `menu_item` to `model` if non-%NULL, or unsets it.
     * 
     * Links are used to establish a relationship between a particular menu
     * item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
     * associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
     * is used to create a section. Other types of link can be used, but there
     * is no guarantee that clients will be able to make sense of them.
     * Link types are restricted to lowercase characters, numbers
     * and '-'. Furthermore, the names must begin with a lowercase character,
     * must not end with a '-', and must not contain consecutive dashes.
     * @param link type of link to establish or unset
     * @param model the #GMenuModel to link to (or %NULL to unset)
     */
    set_link(link: string | null, model: MenuModel | null): void
    /**
     * Sets or unsets the "section" link of `menu_item` to `section`.
     * 
     * The effect of having one menu appear as a section of another is
     * exactly as it sounds: the items from `section` become a direct part of
     * the menu that `menu_item` is added to.  See g_menu_item_new_section()
     * for more information about what it means for a menu item to be a
     * section.
     * @param section a #GMenuModel, or %NULL
     */
    set_section(section: MenuModel | null): void
    /**
     * Sets or unsets the "submenu" link of `menu_item` to `submenu`.
     * 
     * If `submenu` is non-%NULL, it is linked to.  If it is %NULL then the
     * link is unset.
     * 
     * The effect of having one menu appear as a submenu of another is
     * exactly as it sounds.
     * @param submenu a #GMenuModel, or %NULL
     */
    set_submenu(submenu: MenuModel | null): void

    // Class property signals of Gio-2.0.Gio.MenuItem

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMenuItem is an opaque structure type.  You must access it using the
 * functions below.
 * @class 
 */
class MenuItem extends GObject.Object {

    // Own properties of Gio-2.0.Gio.MenuItem

    static name: string
    static $gtype: GObject.GType<MenuItem>

    // Constructors of Gio-2.0.Gio.MenuItem

    constructor(config?: MenuItem.ConstructorProperties) 
    /**
     * Creates a new #GMenuItem.
     * 
     * If `label` is non-%NULL it is used to set the "label" attribute of the
     * new item.
     * 
     * If `detailed_action` is non-%NULL it is used to set the "action" and
     * possibly the "target" attribute of the new item.  See
     * g_menu_item_set_detailed_action() for more information.
     * @constructor 
     * @param label the section label, or %NULL
     * @param detailed_action the detailed action string, or %NULL
     * @returns a new #GMenuItem
     */
    constructor(label: string | null, detailed_action: string | null) 
    /**
     * Creates a new #GMenuItem.
     * 
     * If `label` is non-%NULL it is used to set the "label" attribute of the
     * new item.
     * 
     * If `detailed_action` is non-%NULL it is used to set the "action" and
     * possibly the "target" attribute of the new item.  See
     * g_menu_item_set_detailed_action() for more information.
     * @constructor 
     * @param label the section label, or %NULL
     * @param detailed_action the detailed action string, or %NULL
     * @returns a new #GMenuItem
     */
    static new(label: string | null, detailed_action: string | null): MenuItem
    /**
     * Creates a #GMenuItem as an exact copy of an existing menu item in a
     * #GMenuModel.
     * 
     * `item_index` must be valid (ie: be sure to call
     * g_menu_model_get_n_items() first).
     * @constructor 
     * @param model a #GMenuModel
     * @param item_index the index of an item in `model`
     * @returns a new #GMenuItem.
     */
    static new_from_model(model: MenuModel, item_index: number): MenuItem
    /**
     * Creates a new #GMenuItem representing a section.
     * 
     * This is a convenience API around g_menu_item_new() and
     * g_menu_item_set_section().
     * 
     * The effect of having one menu appear as a section of another is
     * exactly as it sounds: the items from `section` become a direct part of
     * the menu that `menu_item` is added to.
     * 
     * Visual separation is typically displayed between two non-empty
     * sections.  If `label` is non-%NULL then it will be encorporated into
     * this visual indication.  This allows for labeled subsections of a
     * menu.
     * 
     * As a simple example, consider a typical "Edit" menu from a simple
     * program.  It probably contains an "Undo" and "Redo" item, followed by
     * a separator, followed by "Cut", "Copy" and "Paste".
     * 
     * This would be accomplished by creating three #GMenu instances.  The
     * first would be populated with the "Undo" and "Redo" items, and the
     * second with the "Cut", "Copy" and "Paste" items.  The first and
     * second menus would then be added as submenus of the third.  In XML
     * format, this would look something like the following:
     * 
     * ```
     * <menu id='edit-menu'>
     *   <section>
     *     <item label='Undo'/>
     *     <item label='Redo'/>
     *   </section>
     *   <section>
     *     <item label='Cut'/>
     *     <item label='Copy'/>
     *     <item label='Paste'/>
     *   </section>
     * </menu>
     * ```
     * 
     * 
     * The following example is exactly equivalent.  It is more illustrative
     * of the exact relationship between the menus and items (keeping in
     * mind that the 'link' element defines a new menu that is linked to the
     * containing one).  The style of the second example is more verbose and
     * difficult to read (and therefore not recommended except for the
     * purpose of understanding what is really going on).
     * 
     * ```
     * <menu id='edit-menu'>
     *   <item>
     *     <link name='section'>
     *       <item label='Undo'/>
     *       <item label='Redo'/>
     *     </link>
     *   </item>
     *   <item>
     *     <link name='section'>
     *       <item label='Cut'/>
     *       <item label='Copy'/>
     *       <item label='Paste'/>
     *     </link>
     *   </item>
     * </menu>
     * ```
     * 
     * @constructor 
     * @param label the section label, or %NULL
     * @param section a #GMenuModel with the items of the section
     * @returns a new #GMenuItem
     */
    static new_section(label: string | null, section: MenuModel): MenuItem
    /**
     * Creates a new #GMenuItem representing a submenu.
     * 
     * This is a convenience API around g_menu_item_new() and
     * g_menu_item_set_submenu().
     * @constructor 
     * @param label the section label, or %NULL
     * @param submenu a #GMenuModel with the items of the submenu
     * @returns a new #GMenuItem
     */
    static new_submenu(label: string | null, submenu: MenuModel): MenuItem
    _init(config?: MenuItem.ConstructorProperties): void
}

module MenuLinkIter {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface MenuLinkIter {

    // Own fields of Gio-2.0.Gio.MenuLinkIter

    parent_instance: GObject.Object
    priv: MenuLinkIterPrivate

    // Owm methods of Gio-2.0.Gio.MenuLinkIter

    /**
     * Gets the name of the link at the current iterator position.
     * 
     * The iterator is not advanced.
     * @returns the type of the link
     */
    get_name(): string | null
    /**
     * This function combines g_menu_link_iter_next() with
     * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
     * 
     * First the iterator is advanced to the next (possibly first) link.
     * If that fails, then %FALSE is returned and there are no other effects.
     * 
     * If successful, `out_link` and `value` are set to the name and #GMenuModel
     * of the link that has just been advanced to.  At this point,
     * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
     * same values again.
     * 
     * The value returned in `out_link` remains valid for as long as the iterator
     * remains at the current position.  The value returned in `value` must
     * be unreffed using g_object_unref() when it is no longer in use.
     * @returns %TRUE on success, or %FALSE if there is no additional link
     */
    get_next(): [ /* returnType */ boolean, /* out_link */ string | null, /* value */ MenuModel ]
    /**
     * Gets the linked #GMenuModel at the current iterator position.
     * 
     * The iterator is not advanced.
     * @returns the #GMenuModel that is linked to
     */
    get_value(): MenuModel
    /**
     * Attempts to advance the iterator to the next (possibly first)
     * link.
     * 
     * %TRUE is returned on success, or %FALSE if there are no more links.
     * 
     * You must call this function when you first acquire the iterator to
     * advance it to the first link (and determine if the first link exists
     * at all).
     * @returns %TRUE on success, or %FALSE when there are no more links
     */
    next(): boolean

    // Own virtual methods of Gio-2.0.Gio.MenuLinkIter

    /**
     * This function combines g_menu_link_iter_next() with
     * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
     * 
     * First the iterator is advanced to the next (possibly first) link.
     * If that fails, then %FALSE is returned and there are no other effects.
     * 
     * If successful, `out_link` and `value` are set to the name and #GMenuModel
     * of the link that has just been advanced to.  At this point,
     * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
     * same values again.
     * 
     * The value returned in `out_link` remains valid for as long as the iterator
     * remains at the current position.  The value returned in `value` must
     * be unreffed using g_object_unref() when it is no longer in use.
     * @virtual 
     * @returns %TRUE on success, or %FALSE if there is no additional link
     */
    vfunc_get_next(): [ /* returnType */ boolean, /* out_link */ string | null, /* value */ MenuModel ]

    // Class property signals of Gio-2.0.Gio.MenuLinkIter

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMenuLinkIter is an opaque structure type.  You must access it using
 * the functions below.
 * @class 
 */
class MenuLinkIter extends GObject.Object {

    // Own properties of Gio-2.0.Gio.MenuLinkIter

    static name: string
    static $gtype: GObject.GType<MenuLinkIter>

    // Constructors of Gio-2.0.Gio.MenuLinkIter

    constructor(config?: MenuLinkIter.ConstructorProperties) 
    _init(config?: MenuLinkIter.ConstructorProperties): void
}

module MenuModel {

    // Signal callback interfaces

    /**
     * Signal callback interface for `items-changed`
     */
    interface ItemsChangedSignalCallback {
        ($obj: MenuModel, position: number, removed: number, added: number): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface MenuModel {

    // Own fields of Gio-2.0.Gio.MenuModel

    parent_instance: GObject.Object
    priv: MenuModelPrivate

    // Owm methods of Gio-2.0.Gio.MenuModel

    /**
     * Queries the item at position `item_index` in `model` for the attribute
     * specified by `attribute`.
     * 
     * If `expected_type` is non-%NULL then it specifies the expected type of
     * the attribute.  If it is %NULL then any type will be accepted.
     * 
     * If the attribute exists and matches `expected_type` (or if the
     * expected type is unspecified) then the value is returned.
     * 
     * If the attribute does not exist, or does not match the expected type
     * then %NULL is returned.
     * @param item_index the index of the item
     * @param attribute the attribute to query
     * @param expected_type the expected type of the attribute, or     %NULL
     * @returns the value of the attribute
     */
    get_item_attribute_value(item_index: number, attribute: string | null, expected_type: GLib.VariantType | null): GLib.Variant | null
    /**
     * Queries the item at position `item_index` in `model` for the link
     * specified by `link`.
     * 
     * If the link exists, the linked #GMenuModel is returned.  If the link
     * does not exist, %NULL is returned.
     * @param item_index the index of the item
     * @param link the link to query
     * @returns the linked #GMenuModel, or %NULL
     */
    get_item_link(item_index: number, link: string | null): MenuModel | null
    /**
     * Query the number of items in `model`.
     * @returns the number of items
     */
    get_n_items(): number
    /**
     * Queries if `model` is mutable.
     * 
     * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
     * signal. Consumers of the model may make optimisations accordingly.
     * @returns %TRUE if the model is mutable (ie: "items-changed" may be     emitted).
     */
    is_mutable(): boolean
    /**
     * Requests emission of the #GMenuModel::items-changed signal on `model`.
     * 
     * This function should never be called except by #GMenuModel
     * subclasses.  Any other calls to this function will very likely lead
     * to a violation of the interface of the model.
     * 
     * The implementation should update its internal representation of the
     * menu before emitting the signal.  The implementation should further
     * expect to receive queries about the new state of the menu (and
     * particularly added menu items) while signal handlers are running.
     * 
     * The implementation must dispatch this call directly from a mainloop
     * entry and not in response to calls -- particularly those from the
     * #GMenuModel API.  Said another way: the menu must not change while
     * user code is running without returning to the mainloop.
     * @param position the position of the change
     * @param removed the number of items removed
     * @param added the number of items added
     */
    items_changed(position: number, removed: number, added: number): void
    /**
     * Creates a #GMenuAttributeIter to iterate over the attributes of
     * the item at position `item_index` in `model`.
     * 
     * You must free the iterator with g_object_unref() when you are done.
     * @param item_index the index of the item
     * @returns a new #GMenuAttributeIter
     */
    iterate_item_attributes(item_index: number): MenuAttributeIter
    /**
     * Creates a #GMenuLinkIter to iterate over the links of the item at
     * position `item_index` in `model`.
     * 
     * You must free the iterator with g_object_unref() when you are done.
     * @param item_index the index of the item
     * @returns a new #GMenuLinkIter
     */
    iterate_item_links(item_index: number): MenuLinkIter

    // Own virtual methods of Gio-2.0.Gio.MenuModel

    /**
     * Queries the item at position `item_index` in `model` for the attribute
     * specified by `attribute`.
     * 
     * If `expected_type` is non-%NULL then it specifies the expected type of
     * the attribute.  If it is %NULL then any type will be accepted.
     * 
     * If the attribute exists and matches `expected_type` (or if the
     * expected type is unspecified) then the value is returned.
     * 
     * If the attribute does not exist, or does not match the expected type
     * then %NULL is returned.
     * @virtual 
     * @param item_index the index of the item
     * @param attribute the attribute to query
     * @param expected_type the expected type of the attribute, or     %NULL
     * @returns the value of the attribute
     */
    vfunc_get_item_attribute_value(item_index: number, attribute: string | null, expected_type: GLib.VariantType | null): GLib.Variant | null
    /**
     * Gets all the attributes associated with the item in the menu model.
     * @virtual 
     * @param item_index The #GMenuItem to query
     */
    vfunc_get_item_attributes(item_index: number): /* attributes */ GLib.HashTable
    /**
     * Queries the item at position `item_index` in `model` for the link
     * specified by `link`.
     * 
     * If the link exists, the linked #GMenuModel is returned.  If the link
     * does not exist, %NULL is returned.
     * @virtual 
     * @param item_index the index of the item
     * @param link the link to query
     * @returns the linked #GMenuModel, or %NULL
     */
    vfunc_get_item_link(item_index: number, link: string | null): MenuModel | null
    /**
     * Gets all the links associated with the item in the menu model.
     * @virtual 
     * @param item_index The #GMenuItem to query
     */
    vfunc_get_item_links(item_index: number): /* links */ GLib.HashTable
    /**
     * Query the number of items in `model`.
     * @virtual 
     * @returns the number of items
     */
    vfunc_get_n_items(): number
    /**
     * Queries if `model` is mutable.
     * 
     * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
     * signal. Consumers of the model may make optimisations accordingly.
     * @virtual 
     * @returns %TRUE if the model is mutable (ie: "items-changed" may be     emitted).
     */
    vfunc_is_mutable(): boolean
    /**
     * Creates a #GMenuAttributeIter to iterate over the attributes of
     * the item at position `item_index` in `model`.
     * 
     * You must free the iterator with g_object_unref() when you are done.
     * @virtual 
     * @param item_index the index of the item
     * @returns a new #GMenuAttributeIter
     */
    vfunc_iterate_item_attributes(item_index: number): MenuAttributeIter
    /**
     * Creates a #GMenuLinkIter to iterate over the links of the item at
     * position `item_index` in `model`.
     * 
     * You must free the iterator with g_object_unref() when you are done.
     * @virtual 
     * @param item_index the index of the item
     * @returns a new #GMenuLinkIter
     */
    vfunc_iterate_item_links(item_index: number): MenuLinkIter

    // Own signals of Gio-2.0.Gio.MenuModel

    connect(sigName: "items-changed", callback: MenuModel.ItemsChangedSignalCallback): number
    connect_after(sigName: "items-changed", callback: MenuModel.ItemsChangedSignalCallback): number
    emit(sigName: "items-changed", position: number, removed: number, added: number, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.MenuModel

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMenuModel represents the contents of a menu -- an ordered list of
 * menu items. The items are associated with actions, which can be
 * activated through them. Items can be grouped in sections, and may
 * have submenus associated with them. Both items and sections usually
 * have some representation data, such as labels or icons. The type of
 * the associated action (ie whether it is stateful, and what kind of
 * state it has) can influence the representation of the item.
 * 
 * The conceptual model of menus in #GMenuModel is hierarchical:
 * sections and submenus are again represented by #GMenuModels.
 * Menus themselves do not define their own roles. Rather, the role
 * of a particular #GMenuModel is defined by the item that references
 * it (or, in the case of the 'root' menu, is defined by the context
 * in which it is used).
 * 
 * As an example, consider the visible portions of this menu:
 * 
 * ## An example menu # {#menu-example}
 * 
 * ![](menu-example.png)
 * 
 * There are 8 "menus" visible in the screenshot: one menubar, two
 * submenus and 5 sections:
 * 
 * - the toplevel menubar (containing 4 items)
 * - the View submenu (containing 3 sections)
 * - the first section of the View submenu (containing 2 items)
 * - the second section of the View submenu (containing 1 item)
 * - the final section of the View submenu (containing 1 item)
 * - the Highlight Mode submenu (containing 2 sections)
 * - the Sources section (containing 2 items)
 * - the Markup section (containing 2 items)
 * 
 * The [example][menu-model] illustrates the conceptual connection between
 * these 8 menus. Each large block in the figure represents a menu and the
 * smaller blocks within the large block represent items in that menu. Some
 * items contain references to other menus.
 * 
 * ## A menu example # {#menu-model}
 * 
 * ![](menu-model.png)
 * 
 * Notice that the separators visible in the [example][menu-example]
 * appear nowhere in the [menu model][menu-model]. This is because
 * separators are not explicitly represented in the menu model. Instead,
 * a separator is inserted between any two non-empty sections of a menu.
 * Section items can have labels just like any other item. In that case,
 * a display system may show a section header instead of a separator.
 * 
 * The motivation for this abstract model of application controls is
 * that modern user interfaces tend to make these controls available
 * outside the application. Examples include global menus, jumplists,
 * dash boards, etc. To support such uses, it is necessary to 'export'
 * information about actions and their representation in menus, which
 * is exactly what the [GActionGroup exporter][gio-GActionGroup-exporter]
 * and the [GMenuModel exporter][gio-GMenuModel-exporter] do for
 * #GActionGroup and #GMenuModel. The client-side counterparts to
 * make use of the exported information are #GDBusActionGroup and
 * #GDBusMenuModel.
 * 
 * The API of #GMenuModel is very generic, with iterators for the
 * attributes and links of an item, see g_menu_model_iterate_item_attributes()
 * and g_menu_model_iterate_item_links(). The 'standard' attributes and
 * link types have predefined names: %G_MENU_ATTRIBUTE_LABEL,
 * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, %G_MENU_LINK_SECTION
 * and %G_MENU_LINK_SUBMENU.
 * 
 * Items in a #GMenuModel represent active controls if they refer to
 * an action that can get activated when the user interacts with the
 * menu item. The reference to the action is encoded by the string id
 * in the %G_MENU_ATTRIBUTE_ACTION attribute. An action id uniquely
 * identifies an action in an action group. Which action group(s) provide
 * actions depends on the context in which the menu model is used.
 * E.g. when the model is exported as the application menu of a
 * #GtkApplication, actions can be application-wide or window-specific
 * (and thus come from two different action groups). By convention, the
 * application-wide actions have names that start with "app.", while the
 * names of window-specific actions start with "win.".
 * 
 * While a wide variety of stateful actions is possible, the following
 * is the minimum that is expected to be supported by all users of exported
 * menu information:
 * - an action with no parameter type and no state
 * - an action with no parameter type and boolean state
 * - an action with string parameter type and string state
 * 
 * ## Stateless
 * 
 * A stateless action typically corresponds to an ordinary menu item.
 * 
 * Selecting such a menu item will activate the action (with no parameter).
 * 
 * ## Boolean State
 * 
 * An action with a boolean state will most typically be used with a "toggle"
 * or "switch" menu item. The state can be set directly, but activating the
 * action (with no parameter) results in the state being toggled.
 * 
 * Selecting a toggle menu item will activate the action. The menu item should
 * be rendered as "checked" when the state is true.
 * 
 * ## String Parameter and State
 * 
 * Actions with string parameters and state will most typically be used to
 * represent an enumerated choice over the items available for a group of
 * radio menu items. Activating the action with a string parameter is
 * equivalent to setting that parameter as the state.
 * 
 * Radio menu items, in addition to being associated with the action, will
 * have a target value. Selecting that menu item will result in activation
 * of the action with the target value as the parameter. The menu item should
 * be rendered as "selected" when the state of the action is equal to the
 * target value of the menu item.
 * @class 
 */
class MenuModel extends GObject.Object {

    // Own properties of Gio-2.0.Gio.MenuModel

    static name: string
    static $gtype: GObject.GType<MenuModel>

    // Constructors of Gio-2.0.Gio.MenuModel

    constructor(config?: MenuModel.ConstructorProperties) 
    _init(config?: MenuModel.ConstructorProperties): void
}

module MountOperation {

    // Signal callback interfaces

    /**
     * Signal callback interface for `aborted`
     */
    interface AbortedSignalCallback {
        ($obj: MountOperation): void
    }

    /**
     * Signal callback interface for `ask-password`
     */
    interface AskPasswordSignalCallback {
        ($obj: MountOperation, message: string | null, default_user: string | null, default_domain: string | null, flags: AskPasswordFlags): void
    }

    /**
     * Signal callback interface for `ask-question`
     */
    interface AskQuestionSignalCallback {
        ($obj: MountOperation, message: string | null, choices: string[]): void
    }

    /**
     * Signal callback interface for `reply`
     */
    interface ReplySignalCallback {
        ($obj: MountOperation, result: MountOperationResult): void
    }

    /**
     * Signal callback interface for `show-processes`
     */
    interface ShowProcessesSignalCallback {
        ($obj: MountOperation, message: string | null, processes: GLib.Pid[], choices: string[]): void
    }

    /**
     * Signal callback interface for `show-unmount-progress`
     */
    interface ShowUnmountProgressSignalCallback {
        ($obj: MountOperation, message: string | null, time_left: number, bytes_left: number): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.MountOperation

        /**
         * Whether to use an anonymous user when authenticating.
         */
        anonymous?: boolean | null
        /**
         * The index of the user's choice when a question is asked during the
         * mount operation. See the #GMountOperation::ask-question signal.
         */
        choice?: number | null
        /**
         * The domain to use for the mount operation.
         */
        domain?: string | null
        /**
         * Whether the device to be unlocked is a TCRYPT hidden volume.
         * See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden%20Volume.html).
         */
        is_tcrypt_hidden_volume?: boolean | null
        /**
         * Whether the device to be unlocked is a TCRYPT system volume.
         * In this context, a system volume is a volume with a bootloader
         * and operating system installed. This is only supported for Windows
         * operating systems. For further documentation, see
         * [the VeraCrypt documentation](https://www.veracrypt.fr/en/System%20Encryption.html).
         */
        is_tcrypt_system_volume?: boolean | null
        /**
         * The password that is used for authentication when carrying out
         * the mount operation.
         */
        password?: string | null
        /**
         * Determines if and how the password information should be saved.
         */
        password_save?: PasswordSave | null
        /**
         * The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
         * [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20(PIM).html).
         */
        pim?: number | null
        /**
         * The user name that is used for authentication when carrying out
         * the mount operation.
         */
        username?: string | null
    }

}

interface MountOperation {

    // Own properties of Gio-2.0.Gio.MountOperation

    /**
     * Whether to use an anonymous user when authenticating.
     */
    anonymous: boolean
    /**
     * The index of the user's choice when a question is asked during the
     * mount operation. See the #GMountOperation::ask-question signal.
     */
    choice: number
    /**
     * The domain to use for the mount operation.
     */
    domain: string | null
    /**
     * Whether the device to be unlocked is a TCRYPT hidden volume.
     * See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden%20Volume.html).
     */
    is_tcrypt_hidden_volume: boolean
    /**
     * Whether the device to be unlocked is a TCRYPT system volume.
     * In this context, a system volume is a volume with a bootloader
     * and operating system installed. This is only supported for Windows
     * operating systems. For further documentation, see
     * [the VeraCrypt documentation](https://www.veracrypt.fr/en/System%20Encryption.html).
     */
    is_tcrypt_system_volume: boolean
    /**
     * The password that is used for authentication when carrying out
     * the mount operation.
     */
    password: string | null
    /**
     * Determines if and how the password information should be saved.
     */
    password_save: PasswordSave
    /**
     * The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
     * [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20(PIM).html).
     */
    pim: number
    /**
     * The user name that is used for authentication when carrying out
     * the mount operation.
     */
    username: string | null

    // Own fields of Gio-2.0.Gio.MountOperation

    parent_instance: GObject.Object
    priv: MountOperationPrivate

    // Owm methods of Gio-2.0.Gio.MountOperation

    /**
     * Check to see whether the mount operation is being used
     * for an anonymous user.
     * @returns %TRUE if mount operation is anonymous.
     */
    get_anonymous(): boolean
    /**
     * Gets a choice from the mount operation.
     * @returns an integer containing an index of the user's choice from the choice's list, or `0`.
     */
    get_choice(): number
    /**
     * Gets the domain of the mount operation.
     * @returns a string set to the domain.
     */
    get_domain(): string | null
    /**
     * Check to see whether the mount operation is being used
     * for a TCRYPT hidden volume.
     * @returns %TRUE if mount operation is for hidden volume.
     */
    get_is_tcrypt_hidden_volume(): boolean
    /**
     * Check to see whether the mount operation is being used
     * for a TCRYPT system volume.
     * @returns %TRUE if mount operation is for system volume.
     */
    get_is_tcrypt_system_volume(): boolean
    /**
     * Gets a password from the mount operation.
     * @returns a string containing the password within @op.
     */
    get_password(): string | null
    /**
     * Gets the state of saving passwords for the mount operation.
     * @returns a #GPasswordSave flag.
     */
    get_password_save(): PasswordSave
    /**
     * Gets a PIM from the mount operation.
     * @returns The VeraCrypt PIM within @op.
     */
    get_pim(): number
    /**
     * Get the user name from the mount operation.
     * @returns a string containing the user name.
     */
    get_username(): string | null
    /**
     * Emits the #GMountOperation::reply signal.
     * @param result a #GMountOperationResult
     */
    reply(result: MountOperationResult): void
    /**
     * Sets the mount operation to use an anonymous user if `anonymous` is %TRUE.
     * @param anonymous boolean value.
     */
    set_anonymous(anonymous: boolean): void
    /**
     * Sets a default choice for the mount operation.
     * @param choice an integer.
     */
    set_choice(choice: number): void
    /**
     * Sets the mount operation's domain.
     * @param domain the domain to set.
     */
    set_domain(domain: string | null): void
    /**
     * Sets the mount operation to use a hidden volume if `hidden_volume` is %TRUE.
     * @param hidden_volume boolean value.
     */
    set_is_tcrypt_hidden_volume(hidden_volume: boolean): void
    /**
     * Sets the mount operation to use a system volume if `system_volume` is %TRUE.
     * @param system_volume boolean value.
     */
    set_is_tcrypt_system_volume(system_volume: boolean): void
    /**
     * Sets the mount operation's password to `password`.
     * @param password password to set.
     */
    set_password(password: string | null): void
    /**
     * Sets the state of saving passwords for the mount operation.
     * @param save a set of #GPasswordSave flags.
     */
    set_password_save(save: PasswordSave): void
    /**
     * Sets the mount operation's PIM to `pim`.
     * @param pim an unsigned integer.
     */
    set_pim(pim: number): void
    /**
     * Sets the user name within `op` to `username`.
     * @param username input username.
     */
    set_username(username: string | null): void

    // Own virtual methods of Gio-2.0.Gio.MountOperation

    vfunc_aborted(): void
    vfunc_ask_password(message: string | null, default_user: string | null, default_domain: string | null, flags: AskPasswordFlags): void
    /**
     * Virtual implementation of #GMountOperation::ask-question.
     * @virtual 
     * @param message string containing a message to display to the user
     * @param choices an array of    strings for each possible choice
     */
    vfunc_ask_question(message: string | null, choices: string[]): void
    /**
     * Emits the #GMountOperation::reply signal.
     * @virtual 
     * @param result a #GMountOperationResult
     */
    vfunc_reply(result: MountOperationResult): void
    /**
     * Virtual implementation of #GMountOperation::show-processes.
     * @virtual 
     * @param message string containing a message to display to the user
     * @param processes an array of #GPid for processes blocking    the operation
     * @param choices an array of    strings for each possible choice
     */
    vfunc_show_processes(message: string | null, processes: GLib.Pid[], choices: string[]): void
    vfunc_show_unmount_progress(message: string | null, time_left: number, bytes_left: number): void

    // Own signals of Gio-2.0.Gio.MountOperation

    connect(sigName: "aborted", callback: MountOperation.AbortedSignalCallback): number
    connect_after(sigName: "aborted", callback: MountOperation.AbortedSignalCallback): number
    emit(sigName: "aborted", ...args: any[]): void
    connect(sigName: "ask-password", callback: MountOperation.AskPasswordSignalCallback): number
    connect_after(sigName: "ask-password", callback: MountOperation.AskPasswordSignalCallback): number
    emit(sigName: "ask-password", message: string | null, default_user: string | null, default_domain: string | null, flags: AskPasswordFlags, ...args: any[]): void
    connect(sigName: "ask-question", callback: MountOperation.AskQuestionSignalCallback): number
    connect_after(sigName: "ask-question", callback: MountOperation.AskQuestionSignalCallback): number
    emit(sigName: "ask-question", message: string | null, choices: string[], ...args: any[]): void
    connect(sigName: "reply", callback: MountOperation.ReplySignalCallback): number
    connect_after(sigName: "reply", callback: MountOperation.ReplySignalCallback): number
    emit(sigName: "reply", result: MountOperationResult, ...args: any[]): void
    connect(sigName: "show-processes", callback: MountOperation.ShowProcessesSignalCallback): number
    connect_after(sigName: "show-processes", callback: MountOperation.ShowProcessesSignalCallback): number
    emit(sigName: "show-processes", message: string | null, processes: GLib.Pid[], choices: string[], ...args: any[]): void
    connect(sigName: "show-unmount-progress", callback: MountOperation.ShowUnmountProgressSignalCallback): number
    connect_after(sigName: "show-unmount-progress", callback: MountOperation.ShowUnmountProgressSignalCallback): number
    emit(sigName: "show-unmount-progress", message: string | null, time_left: number, bytes_left: number, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.MountOperation

    connect(sigName: "notify::anonymous", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anonymous", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::anonymous", ...args: any[]): void
    connect(sigName: "notify::choice", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice", ...args: any[]): void
    connect(sigName: "notify::domain", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::domain", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::domain", ...args: any[]): void
    connect(sigName: "notify::is-tcrypt-hidden-volume", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-tcrypt-hidden-volume", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-tcrypt-hidden-volume", ...args: any[]): void
    connect(sigName: "notify::is-tcrypt-system-volume", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-tcrypt-system-volume", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::is-tcrypt-system-volume", ...args: any[]): void
    connect(sigName: "notify::password", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password", ...args: any[]): void
    connect(sigName: "notify::password-save", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-save", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-save", ...args: any[]): void
    connect(sigName: "notify::pim", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pim", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::pim", ...args: any[]): void
    connect(sigName: "notify::username", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::username", callback: (($obj: MountOperation, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::username", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GMountOperation provides a mechanism for interacting with the user.
 * It can be used for authenticating mountable operations, such as loop
 * mounting files, hard drive partitions or server locations. It can
 * also be used to ask the user questions or show a list of applications
 * preventing unmount or eject operations from completing.
 * 
 * Note that #GMountOperation is used for more than just #GMount
 * objects – for example it is also used in g_drive_start() and
 * g_drive_stop().
 * 
 * Users should instantiate a subclass of this that implements all the
 * various callbacks to show the required dialogs, such as
 * #GtkMountOperation. If no user interaction is desired (for example
 * when automounting filesystems at login time), usually %NULL can be
 * passed, see each method taking a #GMountOperation for details.
 * 
 * The term ‘TCRYPT’ is used to mean ‘compatible with TrueCrypt and VeraCrypt’.
 * [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
 * encrypting file containers, partitions or whole disks, typically used with Windows.
 * [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
 * improvements and auditing fixes.
 * @class 
 */
class MountOperation extends GObject.Object {

    // Own properties of Gio-2.0.Gio.MountOperation

    static name: string
    static $gtype: GObject.GType<MountOperation>

    // Constructors of Gio-2.0.Gio.MountOperation

    constructor(config?: MountOperation.ConstructorProperties) 
    /**
     * Creates a new mount operation.
     * @constructor 
     * @returns a #GMountOperation.
     */
    constructor() 
    /**
     * Creates a new mount operation.
     * @constructor 
     * @returns a #GMountOperation.
     */
    static new(): MountOperation
    _init(config?: MountOperation.ConstructorProperties): void
}

module NativeSocketAddress {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnectable.ConstructorProperties, SocketAddress.ConstructorProperties {
    }

}

interface NativeSocketAddress extends SocketConnectable {

    // Own fields of Gio-2.0.Gio.NativeSocketAddress

    parent_instance: SocketAddress & GObject.Object

    // Class property signals of Gio-2.0.Gio.NativeSocketAddress

    connect(sigName: "notify::family", callback: (($obj: NativeSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: NativeSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A socket address of some unknown native type.
 * @class 
 */
class NativeSocketAddress extends SocketAddress {

    // Own properties of Gio-2.0.Gio.NativeSocketAddress

    static name: string
    static $gtype: GObject.GType<NativeSocketAddress>

    // Constructors of Gio-2.0.Gio.NativeSocketAddress

    constructor(config?: NativeSocketAddress.ConstructorProperties) 
    /**
     * Creates a new #GNativeSocketAddress for `native` and `len`.
     * @constructor 
     * @param native a native address object
     * @param len the length of `native,` in bytes
     * @returns a new #GNativeSocketAddress
     */
    constructor(native: any | null, len: number) 
    /**
     * Creates a new #GNativeSocketAddress for `native` and `len`.
     * @constructor 
     * @param native a native address object
     * @param len the length of `native,` in bytes
     * @returns a new #GNativeSocketAddress
     */
    static new(native: any | null, len: number): NativeSocketAddress
    _init(config?: NativeSocketAddress.ConstructorProperties): void
}

module NativeVolumeMonitor {

    // Constructor properties interface

    interface ConstructorProperties extends VolumeMonitor.ConstructorProperties {
    }

}

interface NativeVolumeMonitor {

    // Own fields of Gio-2.0.Gio.NativeVolumeMonitor

    parent_instance: VolumeMonitor & GObject.Object

    // Class property signals of Gio-2.0.Gio.NativeVolumeMonitor

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

class NativeVolumeMonitor extends VolumeMonitor {

    // Own properties of Gio-2.0.Gio.NativeVolumeMonitor

    static name: string
    static $gtype: GObject.GType<NativeVolumeMonitor>

    // Constructors of Gio-2.0.Gio.NativeVolumeMonitor

    constructor(config?: NativeVolumeMonitor.ConstructorProperties) 
    _init(config?: NativeVolumeMonitor.ConstructorProperties): void
}

module NetworkAddress {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnectable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.NetworkAddress

        hostname?: string | null
        port?: number | null
        scheme?: string | null
    }

}

interface NetworkAddress extends SocketConnectable {

    // Own properties of Gio-2.0.Gio.NetworkAddress

    readonly hostname: string | null
    readonly port: number
    readonly scheme: string | null

    // Own fields of Gio-2.0.Gio.NetworkAddress

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.NetworkAddress

    /**
     * Gets `addr'`s hostname. This might be either UTF-8 or ASCII-encoded,
     * depending on what `addr` was created with.
     * @returns @addr's hostname
     */
    get_hostname(): string | null
    /**
     * Gets `addr'`s port number
     * @returns @addr's port (which may be 0)
     */
    get_port(): number
    /**
     * Gets `addr'`s scheme
     * @returns @addr's scheme (%NULL if not built from URI)
     */
    get_scheme(): string | null

    // Class property signals of Gio-2.0.Gio.NetworkAddress

    connect(sigName: "notify::hostname", callback: (($obj: NetworkAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hostname", callback: (($obj: NetworkAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::hostname", ...args: any[]): void
    connect(sigName: "notify::port", callback: (($obj: NetworkAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::port", callback: (($obj: NetworkAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::port", ...args: any[]): void
    connect(sigName: "notify::scheme", callback: (($obj: NetworkAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scheme", callback: (($obj: NetworkAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::scheme", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GNetworkAddress provides an easy way to resolve a hostname and
 * then attempt to connect to that host, handling the possibility of
 * multiple IP addresses and multiple address families.
 * 
 * The enumeration results of resolved addresses *may* be cached as long
 * as this object is kept alive which may have unexpected results if
 * alive for too long.
 * 
 * See #GSocketConnectable for an example of using the connectable
 * interface.
 * @class 
 */
class NetworkAddress extends GObject.Object {

    // Own properties of Gio-2.0.Gio.NetworkAddress

    static name: string
    static $gtype: GObject.GType<NetworkAddress>

    // Constructors of Gio-2.0.Gio.NetworkAddress

    constructor(config?: NetworkAddress.ConstructorProperties) 
    /**
     * Creates a new #GSocketConnectable for connecting to the given
     * `hostname` and `port`.
     * 
     * Note that depending on the configuration of the machine, a
     * `hostname` of `localhost` may refer to the IPv4 loopback address
     * only, or to both IPv4 and IPv6; use
     * g_network_address_new_loopback() to create a #GNetworkAddress that
     * is guaranteed to resolve to both addresses.
     * @constructor 
     * @param hostname the hostname
     * @param port the port
     * @returns the new #GNetworkAddress
     */
    constructor(hostname: string | null, port: number) 
    /**
     * Creates a new #GSocketConnectable for connecting to the given
     * `hostname` and `port`.
     * 
     * Note that depending on the configuration of the machine, a
     * `hostname` of `localhost` may refer to the IPv4 loopback address
     * only, or to both IPv4 and IPv6; use
     * g_network_address_new_loopback() to create a #GNetworkAddress that
     * is guaranteed to resolve to both addresses.
     * @constructor 
     * @param hostname the hostname
     * @param port the port
     * @returns the new #GNetworkAddress
     */
    static new(hostname: string | null, port: number): NetworkAddress
    /**
     * Creates a new #GSocketConnectable for connecting to the local host
     * over a loopback connection to the given `port`. This is intended for
     * use in connecting to local services which may be running on IPv4 or
     * IPv6.
     * 
     * The connectable will return IPv4 and IPv6 loopback addresses,
     * regardless of how the host resolves `localhost`. By contrast,
     * g_network_address_new() will often only return an IPv4 address when
     * resolving `localhost`, and an IPv6 address for `localhost6`.
     * 
     * g_network_address_get_hostname() will always return `localhost` for
     * a #GNetworkAddress created with this constructor.
     * @constructor 
     * @param port the port
     * @returns the new #GNetworkAddress
     */
    static new_loopback(port: number): NetworkAddress
    _init(config?: NetworkAddress.ConstructorProperties): void
    /**
     * Creates a new #GSocketConnectable for connecting to the given
     * `hostname` and `port`. May fail and return %NULL in case
     * parsing `host_and_port` fails.
     * 
     * `host_and_port` may be in any of a number of recognised formats; an IPv6
     * address, an IPv4 address, or a domain name (in which case a DNS
     * lookup is performed). Quoting with [] is supported for all address
     * types. A port override may be specified in the usual way with a
     * colon.
     * 
     * If no port is specified in `host_and_port` then `default_port` will be
     * used as the port number to connect to.
     * 
     * In general, `host_and_port` is expected to be provided by the user
     * (allowing them to give the hostname, and a port override if necessary)
     * and `default_port` is expected to be provided by the application.
     * 
     * (The port component of `host_and_port` can also be specified as a
     * service name rather than as a numeric port, but this functionality
     * is deprecated, because it depends on the contents of /etc/services,
     * which is generally quite sparse on platforms other than Linux.)
     * @param host_and_port the hostname and optionally a port
     * @param default_port the default port if not in `host_and_port`
     * @returns the new   #GNetworkAddress, or %NULL on error
     */
    static parse(host_and_port: string | null, default_port: number): NetworkAddress
    /**
     * Creates a new #GSocketConnectable for connecting to the given
     * `uri`. May fail and return %NULL in case parsing `uri` fails.
     * 
     * Using this rather than g_network_address_new() or
     * g_network_address_parse() allows #GSocketClient to determine
     * when to use application-specific proxy protocols.
     * @param uri the hostname and optionally a port
     * @param default_port The default port if none is found in the URI
     * @returns the new   #GNetworkAddress, or %NULL on error
     */
    static parse_uri(uri: string | null, default_port: number): NetworkAddress
}

module NetworkService {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnectable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.NetworkService

        domain?: string | null
        protocol?: string | null
        scheme?: string | null
        service?: string | null
    }

}

interface NetworkService extends SocketConnectable {

    // Own properties of Gio-2.0.Gio.NetworkService

    readonly domain: string | null
    readonly protocol: string | null
    scheme: string | null
    readonly service: string | null

    // Own fields of Gio-2.0.Gio.NetworkService

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.NetworkService

    /**
     * Gets the domain that `srv` serves. This might be either UTF-8 or
     * ASCII-encoded, depending on what `srv` was created with.
     * @returns @srv's domain name
     */
    get_domain(): string | null
    /**
     * Gets `srv'`s protocol name (eg, "tcp").
     * @returns @srv's protocol name
     */
    get_protocol(): string | null
    /**
     * Gets the URI scheme used to resolve proxies. By default, the service name
     * is used as scheme.
     * @returns @srv's scheme name
     */
    get_scheme(): string | null
    /**
     * Gets `srv'`s service name (eg, "ldap").
     * @returns @srv's service name
     */
    get_service(): string | null
    /**
     * Set's the URI scheme used to resolve proxies. By default, the service name
     * is used as scheme.
     * @param scheme a URI scheme
     */
    set_scheme(scheme: string | null): void

    // Class property signals of Gio-2.0.Gio.NetworkService

    connect(sigName: "notify::domain", callback: (($obj: NetworkService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::domain", callback: (($obj: NetworkService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::domain", ...args: any[]): void
    connect(sigName: "notify::protocol", callback: (($obj: NetworkService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: (($obj: NetworkService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol", ...args: any[]): void
    connect(sigName: "notify::scheme", callback: (($obj: NetworkService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scheme", callback: (($obj: NetworkService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::scheme", ...args: any[]): void
    connect(sigName: "notify::service", callback: (($obj: NetworkService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service", callback: (($obj: NetworkService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::service", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Like #GNetworkAddress does with hostnames, #GNetworkService
 * provides an easy way to resolve a SRV record, and then attempt to
 * connect to one of the hosts that implements that service, handling
 * service priority/weighting, multiple IP addresses, and multiple
 * address families.
 * 
 * See #GSrvTarget for more information about SRV records, and see
 * #GSocketConnectable for an example of using the connectable
 * interface.
 * @class 
 */
class NetworkService extends GObject.Object {

    // Own properties of Gio-2.0.Gio.NetworkService

    static name: string
    static $gtype: GObject.GType<NetworkService>

    // Constructors of Gio-2.0.Gio.NetworkService

    constructor(config?: NetworkService.ConstructorProperties) 
    /**
     * Creates a new #GNetworkService representing the given `service,`
     * `protocol,` and `domain`. This will initially be unresolved; use the
     * #GSocketConnectable interface to resolve it.
     * @constructor 
     * @param service the service type to look up (eg, "ldap")
     * @param protocol the networking protocol to use for `service` (eg, "tcp")
     * @param domain the DNS domain to look up the service in
     * @returns a new #GNetworkService
     */
    constructor(service: string | null, protocol: string | null, domain: string | null) 
    /**
     * Creates a new #GNetworkService representing the given `service,`
     * `protocol,` and `domain`. This will initially be unresolved; use the
     * #GSocketConnectable interface to resolve it.
     * @constructor 
     * @param service the service type to look up (eg, "ldap")
     * @param protocol the networking protocol to use for `service` (eg, "tcp")
     * @param domain the DNS domain to look up the service in
     * @returns a new #GNetworkService
     */
    static new(service: string | null, protocol: string | null, domain: string | null): NetworkService
    _init(config?: NetworkService.ConstructorProperties): void
}

module Notification {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Notification {

    // Owm methods of Gio-2.0.Gio.Notification

    /**
     * Adds a button to `notification` that activates the action in
     * `detailed_action` when clicked. That action must be an
     * application-wide action (starting with "app."). If `detailed_action`
     * contains a target, the action will be activated with that target as
     * its parameter.
     * 
     * See g_action_parse_detailed_name() for a description of the format
     * for `detailed_action`.
     * @param label label of the button
     * @param detailed_action a detailed action name
     */
    add_button(label: string | null, detailed_action: string | null): void
    /**
     * Adds a button to `notification` that activates `action` when clicked.
     * `action` must be an application-wide action (it must start with "app.").
     * 
     * If `target` is non-%NULL, `action` will be activated with `target` as
     * its parameter.
     * @param label label of the button
     * @param action an action name
     * @param target a #GVariant to use as `action'`s parameter, or %NULL
     */
    add_button_with_target(label: string | null, action: string | null, target: GLib.Variant | null): void
    /**
     * Sets the body of `notification` to `body`.
     * @param body the new body for `notification,` or %NULL
     */
    set_body(body: string | null): void
    /**
     * Sets the type of `notification` to `category`. Categories have a main
     * type like `email`, `im` or `device` and can have a detail separated
     * by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
     * helps the notification server to select proper feedback to the user.
     * 
     * Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
     * @param category the category for `notification,` or %NULL for no category
     */
    set_category(category: string | null): void
    /**
     * Sets the default action of `notification` to `detailed_action`. This
     * action is activated when the notification is clicked on.
     * 
     * The action in `detailed_action` must be an application-wide action (it
     * must start with "app."). If `detailed_action` contains a target, the
     * given action will be activated with that target as its parameter.
     * See g_action_parse_detailed_name() for a description of the format
     * for `detailed_action`.
     * 
     * When no default action is set, the application that the notification
     * was sent on is activated.
     * @param detailed_action a detailed action name
     */
    set_default_action(detailed_action: string | null): void
    /**
     * Sets the default action of `notification` to `action`. This action is
     * activated when the notification is clicked on. It must be an
     * application-wide action (start with "app.").
     * 
     * If `target` is non-%NULL, `action` will be activated with `target` as
     * its parameter. If `target` is floating, it will be consumed.
     * 
     * When no default action is set, the application that the notification
     * was sent on is activated.
     * @param action an action name
     * @param target a #GVariant to use as `action'`s parameter, or %NULL
     */
    set_default_action_and_target(action: string | null, target: GLib.Variant | null): void
    /**
     * Sets the icon of `notification` to `icon`.
     * @param icon the icon to be shown in `notification,` as a #GIcon
     */
    set_icon(icon: Icon): void
    /**
     * Sets the priority of `notification` to `priority`. See
     * #GNotificationPriority for possible values.
     * @param priority a #GNotificationPriority
     */
    set_priority(priority: NotificationPriority): void
    /**
     * Sets the title of `notification` to `title`.
     * @param title the new title for `notification`
     */
    set_title(title: string | null): void
    /**
     * Deprecated in favor of g_notification_set_priority().
     * @param urgent %TRUE if `notification` is urgent
     */
    set_urgent(urgent: boolean): void

    // Class property signals of Gio-2.0.Gio.Notification

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GNotification is a mechanism for creating a notification to be shown
 * to the user -- typically as a pop-up notification presented by the
 * desktop environment shell.
 * 
 * The key difference between #GNotification and other similar APIs is
 * that, if supported by the desktop environment, notifications sent
 * with #GNotification will persist after the application has exited,
 * and even across system reboots.
 * 
 * Since the user may click on a notification while the application is
 * not running, applications using #GNotification should be able to be
 * started as a D-Bus service, using #GApplication.
 * 
 * In order for #GNotification to work, the application must have installed
 * a `.desktop` file. For example:
 * 
 * ```
 *  [Desktop Entry]
 *   Name=Test Application
 *   Comment=Description of what Test Application does
 *   Exec=gnome-test-application
 *   Icon=org.gnome.TestApplication
 *   Terminal=false
 *   Type=Application
 *   Categories=GNOME;GTK;TestApplication Category;
 *   StartupNotify=true
 *   DBusActivatable=true
 *   X-GNOME-UsesNotifications=true
 * ```
 * 
 * 
 * The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
 * that this application uses notifications, so it can be listed in the
 * Control Center’s ‘Notifications’ panel.
 * 
 * The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
 * where `org.gnome.TestApplication` is the ID passed to g_application_new().
 * 
 * User interaction with a notification (either the default action, or
 * buttons) must be associated with actions on the application (ie:
 * "app." actions).  It is not possible to route user interaction
 * through the notification itself, because the object will not exist if
 * the application is autostarted as a result of a notification being
 * clicked.
 * 
 * A notification can be sent with g_application_send_notification().
 * @class 
 */
class Notification extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Notification

    static name: string
    static $gtype: GObject.GType<Notification>

    // Constructors of Gio-2.0.Gio.Notification

    constructor(config?: Notification.ConstructorProperties) 
    /**
     * Creates a new #GNotification with `title` as its title.
     * 
     * After populating `notification` with more details, it can be sent to
     * the desktop shell with g_application_send_notification(). Changing
     * any properties after this call will not have any effect until
     * resending `notification`.
     * @constructor 
     * @param title the title of the notification
     * @returns a new #GNotification instance
     */
    constructor(title: string | null) 
    /**
     * Creates a new #GNotification with `title` as its title.
     * 
     * After populating `notification` with more details, it can be sent to
     * the desktop shell with g_application_send_notification(). Changing
     * any properties after this call will not have any effect until
     * resending `notification`.
     * @constructor 
     * @param title the title of the notification
     * @returns a new #GNotification instance
     */
    static new(title: string | null): Notification
    _init(config?: Notification.ConstructorProperties): void
}

module OutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface OutputStream {

    // Own fields of Gio-2.0.Gio.OutputStream

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.OutputStream

    /**
     * Clears the pending flag on `stream`.
     */
    clear_pending(): void
    /**
     * Closes the stream, releasing resources related to it.
     * 
     * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
     * Closing a stream multiple times will not return an error.
     * 
     * Closing a stream will automatically flush any outstanding buffers in the
     * stream.
     * 
     * Streams will be automatically closed when the last reference
     * is dropped, but you might want to call this function to make sure
     * resources are released as early as possible.
     * 
     * Some streams might keep the backing store of the stream (e.g. a file descriptor)
     * open after the stream is closed. See the documentation for the individual
     * stream for details.
     * 
     * On failure the first error that happened will be reported, but the close
     * operation will finish as much as possible. A stream that failed to
     * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
     * is important to check and report the error to the user, otherwise
     * there might be a loss of data as all data might not be written.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * Cancelling a close will still leave the stream closed, but there some streams
     * can use a faster close that doesn't block to e.g. check errors. On
     * cancellation (as with any error) there is no guarantee that all written
     * data will reach the target.
     * @param cancellable optional cancellable object
     * @returns %TRUE on success, %FALSE on failure
     */
    close(cancellable: Cancellable | null): boolean
    /**
     * Requests an asynchronous close of the stream, releasing resources
     * related to it. When the operation is finished `callback` will be
     * called. You can then call g_output_stream_close_finish() to get
     * the result of the operation.
     * 
     * For behaviour details see g_output_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * @param io_priority the io priority of the request.
     * @param cancellable optional cancellable object
     * @param callback callback to call when the request is satisfied
     */
    close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of close_async

    /**
     * Promisified version of {@link close_async}
     * 
     * Requests an asynchronous close of the stream, releasing resources
     * related to it. When the operation is finished `callback` will be
     * called. You can then call g_output_stream_close_finish() to get
     * the result of the operation.
     * 
     * For behaviour details see g_output_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * @param io_priority the io priority of the request.
     * @param cancellable optional cancellable object
     * @returns A Promise of: %TRUE if stream was successfully closed, %FALSE otherwise.
     */
    close_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Closes an output stream.
     * @param result a #GAsyncResult.
     * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
     */
    close_finish(result: AsyncResult): boolean
    /**
     * Forces a write of all user-space buffered data for the given
     * `stream`. Will block during the operation. Closing the stream will
     * implicitly cause a flush.
     * 
     * This function is optional for inherited classes.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional cancellable object
     * @returns %TRUE on success, %FALSE on error
     */
    flush(cancellable: Cancellable | null): boolean
    /**
     * Forces an asynchronous write of all user-space buffered data for
     * the given `stream`.
     * For behaviour details see g_output_stream_flush().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_output_stream_flush_finish() to get the
     * result of the operation.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    flush_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of flush_async

    /**
     * Promisified version of {@link flush_async}
     * 
     * Forces an asynchronous write of all user-space buffered data for
     * the given `stream`.
     * For behaviour details see g_output_stream_flush().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_output_stream_flush_finish() to get the
     * result of the operation.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: %TRUE if flush operation succeeded, %FALSE otherwise.
     */
    flush_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes flushing an output stream.
     * @param result a GAsyncResult.
     * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
     */
    flush_finish(result: AsyncResult): boolean
    /**
     * Checks if an output stream has pending actions.
     * @returns %TRUE if @stream has pending actions.
     */
    has_pending(): boolean
    /**
     * Checks if an output stream has already been closed.
     * @returns %TRUE if @stream is closed. %FALSE otherwise.
     */
    is_closed(): boolean
    /**
     * Checks if an output stream is being closed. This can be
     * used inside e.g. a flush implementation to see if the
     * flush (or other i/o operation) is called from within
     * the closing operation.
     * @returns %TRUE if @stream is being closed. %FALSE otherwise.
     */
    is_closing(): boolean
    /**
     * Sets `stream` to have actions pending. If the pending flag is
     * already set or `stream` is closed, it will return %FALSE and set
     * `error`.
     * @returns %TRUE if pending was previously unset and is now set.
     */
    set_pending(): boolean
    /**
     * Splices an input stream into an output stream.
     * @param source a #GInputStream.
     * @param flags a set of #GOutputStreamSpliceFlags.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #gssize containing the size of the data spliced, or     -1 if an error occurred. Note that if the number of bytes     spliced is greater than %G_MAXSSIZE, then that will be     returned, and there is no way to determine the actual number     of bytes spliced.
     */
    splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable: Cancellable | null): number
    /**
     * Splices a stream asynchronously.
     * When the operation is finished `callback` will be called.
     * You can then call g_output_stream_splice_finish() to get the
     * result of the operation.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_splice().
     * @param source a #GInputStream.
     * @param flags a set of #GOutputStreamSpliceFlags.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback.
     */
    splice_async(source: InputStream, flags: OutputStreamSpliceFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of splice_async

    /**
     * Promisified version of {@link splice_async}
     * 
     * Splices a stream asynchronously.
     * When the operation is finished `callback` will be called.
     * You can then call g_output_stream_splice_finish() to get the
     * result of the operation.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_splice().
     * @param source a #GInputStream.
     * @param flags a set of #GOutputStreamSpliceFlags.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
     */
    splice_async(source: InputStream, flags: OutputStreamSpliceFlags, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<number>
    /**
     * Finishes an asynchronous stream splice operation.
     * @param result a #GAsyncResult.
     * @returns a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
     */
    splice_finish(result: AsyncResult): number
    /**
     * Tries to write `count` bytes from `buffer` into the stream. Will block
     * during the operation.
     * 
     * If count is 0, returns 0 and does nothing. A value of `count`
     * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes written to the stream is returned.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. on a partial I/O error, or if there is not enough
     * storage in the stream. All writes block until at least one byte
     * is written or an error occurs; 0 is never returned (unless
     * `count` is 0).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * @param buffer the buffer containing the data to write.
     * @param cancellable optional cancellable object
     * @returns Number of bytes written, or -1 on error
     */
    write(buffer: Uint8Array, cancellable: Cancellable | null): number
    /**
     * Tries to write `count` bytes from `buffer` into the stream. Will block
     * during the operation.
     * 
     * This function is similar to g_output_stream_write(), except it tries to
     * write as many bytes as requested, only stopping on an error.
     * 
     * On a successful write of `count` bytes, %TRUE is returned, and `bytes_written`
     * is set to `count`.
     * 
     * If there is an error during the operation %FALSE is returned and `error`
     * is set to indicate the error status.
     * 
     * As a special exception to the normal conventions for functions that
     * use #GError, if this function returns %FALSE (and sets `error)` then
     * `bytes_written` will be set to the number of bytes that were
     * successfully written before the error was encountered.  This
     * functionality is only available from C.  If you need it from another
     * language then you must write your own loop around
     * g_output_stream_write().
     * @param buffer the buffer containing the data to write.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE on success, %FALSE if there was an error
     */
    write_all(buffer: Uint8Array, cancellable: Cancellable | null): [ /* returnType */ boolean, /* bytes_written */ number ]
    /**
     * Request an asynchronous write of `count` bytes from `buffer` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_write_all_finish() to get the result of the
     * operation.
     * 
     * This is the asynchronous version of g_output_stream_write_all().
     * 
     * Call g_output_stream_write_all_finish() to collect the result.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * Note that no copy of `buffer` will be made, so it must stay valid
     * until `callback` is called.
     * @param buffer the buffer containing the data to write
     * @param io_priority the io priority of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback callback to call when the request is satisfied
     */
    write_all_async(buffer: Uint8Array, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of write_all_async

    /**
     * Promisified version of {@link write_all_async}
     * 
     * Request an asynchronous write of `count` bytes from `buffer` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_write_all_finish() to get the result of the
     * operation.
     * 
     * This is the asynchronous version of g_output_stream_write_all().
     * 
     * Call g_output_stream_write_all_finish() to collect the result.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * Note that no copy of `buffer` will be made, so it must stay valid
     * until `callback` is called.
     * @param buffer the buffer containing the data to write
     * @param io_priority the io priority of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: %TRUE on success, %FALSE if there was an error
     */
    write_all_async(buffer: Uint8Array, io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* bytes_written */ number>
    /**
     * Finishes an asynchronous stream write operation started with
     * g_output_stream_write_all_async().
     * 
     * As a special exception to the normal conventions for functions that
     * use #GError, if this function returns %FALSE (and sets `error)` then
     * `bytes_written` will be set to the number of bytes that were
     * successfully written before the error was encountered.  This
     * functionality is only available from C.  If you need it from another
     * language then you must write your own loop around
     * g_output_stream_write_async().
     * @param result a #GAsyncResult
     * @returns %TRUE on success, %FALSE if there was an error
     */
    write_all_finish(result: AsyncResult): [ /* returnType */ boolean, /* bytes_written */ number ]
    /**
     * Request an asynchronous write of `count` bytes from `buffer` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_write_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a
     * %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes written will be passed to the
     * `callback`. It is not an error if this is not the same as the
     * requested size, as it can happen e.g. on a partial I/O error,
     * but generally we try to write as many bytes as requested.
     * 
     * You are guaranteed that this method will never fail with
     * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
     * method will just wait until this changes.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_write().
     * 
     * Note that no copy of `buffer` will be made, so it must stay valid
     * until `callback` is called. See g_output_stream_write_bytes_async()
     * for a #GBytes version that will automatically hold a reference to
     * the contents (without copying) for the duration of the call.
     * @param buffer the buffer containing the data to write.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    write_async(buffer: Uint8Array, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of write_async

    /**
     * Promisified version of {@link write_async}
     * 
     * Request an asynchronous write of `count` bytes from `buffer` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_write_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a
     * %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes written will be passed to the
     * `callback`. It is not an error if this is not the same as the
     * requested size, as it can happen e.g. on a partial I/O error,
     * but generally we try to write as many bytes as requested.
     * 
     * You are guaranteed that this method will never fail with
     * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
     * method will just wait until this changes.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_write().
     * 
     * Note that no copy of `buffer` will be made, so it must stay valid
     * until `callback` is called. See g_output_stream_write_bytes_async()
     * for a #GBytes version that will automatically hold a reference to
     * the contents (without copying) for the duration of the call.
     * @param buffer the buffer containing the data to write.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: a #gssize containing the number of bytes written to the stream.
     */
    write_async(buffer: Uint8Array, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<number>
    /**
     * A wrapper function for g_output_stream_write() which takes a
     * #GBytes as input.  This can be more convenient for use by language
     * bindings or in other cases where the refcounted nature of #GBytes
     * is helpful over a bare pointer interface.
     * 
     * However, note that this function may still perform partial writes,
     * just like g_output_stream_write().  If that occurs, to continue
     * writing, you will need to create a new #GBytes containing just the
     * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
     * #GBytes instance multiple times potentially can result in duplicated
     * data in the output stream.
     * @param bytes the #GBytes to write
     * @param cancellable optional cancellable object
     * @returns Number of bytes written, or -1 on error
     */
    write_bytes(bytes: GLib.Bytes, cancellable: Cancellable | null): number
    /**
     * This function is similar to g_output_stream_write_async(), but
     * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
     * this allows the stream to avoid taking a copy of the data.
     * 
     * However, note that this function may still perform partial writes,
     * just like g_output_stream_write_async(). If that occurs, to continue
     * writing, you will need to create a new #GBytes containing just the
     * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
     * #GBytes instance multiple times potentially can result in duplicated
     * data in the output stream.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_write_bytes().
     * @param bytes The bytes to write
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    write_bytes_async(bytes: GLib.Bytes, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of write_bytes_async

    /**
     * Promisified version of {@link write_bytes_async}
     * 
     * This function is similar to g_output_stream_write_async(), but
     * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
     * this allows the stream to avoid taking a copy of the data.
     * 
     * However, note that this function may still perform partial writes,
     * just like g_output_stream_write_async(). If that occurs, to continue
     * writing, you will need to create a new #GBytes containing just the
     * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
     * #GBytes instance multiple times potentially can result in duplicated
     * data in the output stream.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_write_bytes().
     * @param bytes The bytes to write
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: a #gssize containing the number of bytes written to the stream.
     */
    write_bytes_async(bytes: GLib.Bytes, io_priority: number, cancellable: Cancellable | null): globalThis.Promise<number>
    /**
     * Finishes a stream write-from-#GBytes operation.
     * @param result a #GAsyncResult.
     * @returns a #gssize containing the number of bytes written to the stream.
     */
    write_bytes_finish(result: AsyncResult): number
    /**
     * Finishes a stream write operation.
     * @param result a #GAsyncResult.
     * @returns a #gssize containing the number of bytes written to the stream.
     */
    write_finish(result: AsyncResult): number
    /**
     * Tries to write the bytes contained in the `n_vectors` `vectors` into the
     * stream. Will block during the operation.
     * 
     * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
     * does nothing.
     * 
     * On success, the number of bytes written to the stream is returned.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. on a partial I/O error, or if there is not enough
     * storage in the stream. All writes block until at least one byte
     * is written or an error occurs; 0 is never returned (unless
     * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * Some implementations of g_output_stream_writev() may have limitations on the
     * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
     * are exceeded. For example, when writing to a local file on UNIX platforms,
     * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param cancellable optional cancellable object
     * @returns %TRUE on success, %FALSE if there was an error
     */
    writev(vectors: OutputVector[], cancellable: Cancellable | null): [ /* returnType */ boolean, /* bytes_written */ number ]
    /**
     * Tries to write the bytes contained in the `n_vectors` `vectors` into the
     * stream. Will block during the operation.
     * 
     * This function is similar to g_output_stream_writev(), except it tries to
     * write as many bytes as requested, only stopping on an error.
     * 
     * On a successful write of all `n_vectors` vectors, %TRUE is returned, and
     * `bytes_written` is set to the sum of all the sizes of `vectors`.
     * 
     * If there is an error during the operation %FALSE is returned and `error`
     * is set to indicate the error status.
     * 
     * As a special exception to the normal conventions for functions that
     * use #GError, if this function returns %FALSE (and sets `error)` then
     * `bytes_written` will be set to the number of bytes that were
     * successfully written before the error was encountered.  This
     * functionality is only available from C. If you need it from another
     * language then you must write your own loop around
     * g_output_stream_write().
     * 
     * The content of the individual elements of `vectors` might be changed by this
     * function.
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns %TRUE on success, %FALSE if there was an error
     */
    writev_all(vectors: OutputVector[], cancellable: Cancellable | null): [ /* returnType */ boolean, /* bytes_written */ number ]
    /**
     * Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_writev_all_finish() to get the result of the
     * operation.
     * 
     * This is the asynchronous version of g_output_stream_writev_all().
     * 
     * Call g_output_stream_writev_all_finish() to collect the result.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * Note that no copy of `vectors` will be made, so it must stay valid
     * until `callback` is called. The content of the individual elements
     * of `vectors` might be changed by this function.
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param io_priority the I/O priority of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @param callback callback to call when the request is satisfied
     */
    writev_all_async(vectors: OutputVector[], io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of writev_all_async

    /**
     * Promisified version of {@link writev_all_async}
     * 
     * Request an asynchronous write of the bytes contained in the `n_vectors` `vectors` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_writev_all_finish() to get the result of the
     * operation.
     * 
     * This is the asynchronous version of g_output_stream_writev_all().
     * 
     * Call g_output_stream_writev_all_finish() to collect the result.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * Note that no copy of `vectors` will be made, so it must stay valid
     * until `callback` is called. The content of the individual elements
     * of `vectors` might be changed by this function.
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param io_priority the I/O priority of the request
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns A Promise of: %TRUE on success, %FALSE if there was an error
     */
    writev_all_async(vectors: OutputVector[], io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* bytes_written */ number>
    /**
     * Finishes an asynchronous stream write operation started with
     * g_output_stream_writev_all_async().
     * 
     * As a special exception to the normal conventions for functions that
     * use #GError, if this function returns %FALSE (and sets `error)` then
     * `bytes_written` will be set to the number of bytes that were
     * successfully written before the error was encountered.  This
     * functionality is only available from C.  If you need it from another
     * language then you must write your own loop around
     * g_output_stream_writev_async().
     * @param result a #GAsyncResult
     * @returns %TRUE on success, %FALSE if there was an error
     */
    writev_all_finish(result: AsyncResult): [ /* returnType */ boolean, /* bytes_written */ number ]
    /**
     * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_writev_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * On success, the number of bytes written will be passed to the
     * `callback`. It is not an error if this is not the same as the
     * requested size, as it can happen e.g. on a partial I/O error,
     * but generally we try to write as many bytes as requested.
     * 
     * You are guaranteed that this method will never fail with
     * %G_IO_ERROR_WOULD_BLOCK — if `stream` can't accept more data, the
     * method will just wait until this changes.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_writev().
     * 
     * Note that no copy of `vectors` will be made, so it must stay valid
     * until `callback` is called.
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param io_priority the I/O priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    writev_async(vectors: OutputVector[], io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of writev_async

    /**
     * Promisified version of {@link writev_async}
     * 
     * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_writev_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * On success, the number of bytes written will be passed to the
     * `callback`. It is not an error if this is not the same as the
     * requested size, as it can happen e.g. on a partial I/O error,
     * but generally we try to write as many bytes as requested.
     * 
     * You are guaranteed that this method will never fail with
     * %G_IO_ERROR_WOULD_BLOCK — if `stream` can't accept more data, the
     * method will just wait until this changes.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_writev().
     * 
     * Note that no copy of `vectors` will be made, so it must stay valid
     * until `callback` is called.
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param io_priority the I/O priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: %TRUE on success, %FALSE if there was an error
     */
    writev_async(vectors: OutputVector[], io_priority: number, cancellable: Cancellable | null): globalThis.Promise</* bytes_written */ number>
    /**
     * Finishes a stream writev operation.
     * @param result a #GAsyncResult.
     * @returns %TRUE on success, %FALSE if there was an error
     */
    writev_finish(result: AsyncResult): [ /* returnType */ boolean, /* bytes_written */ number ]

    // Own virtual methods of Gio-2.0.Gio.OutputStream

    /**
     * Requests an asynchronous close of the stream, releasing resources
     * related to it. When the operation is finished `callback` will be
     * called. You can then call g_output_stream_close_finish() to get
     * the result of the operation.
     * 
     * For behaviour details see g_output_stream_close().
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * @virtual 
     * @param io_priority the io priority of the request.
     * @param cancellable optional cancellable object
     * @param callback callback to call when the request is satisfied
     */
    vfunc_close_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Closes an output stream.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
     */
    vfunc_close_finish(result: AsyncResult): boolean
    vfunc_close_fn(cancellable: Cancellable | null): boolean
    /**
     * Forces a write of all user-space buffered data for the given
     * `stream`. Will block during the operation. Closing the stream will
     * implicitly cause a flush.
     * 
     * This function is optional for inherited classes.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @virtual 
     * @param cancellable optional cancellable object
     * @returns %TRUE on success, %FALSE on error
     */
    vfunc_flush(cancellable: Cancellable | null): boolean
    /**
     * Forces an asynchronous write of all user-space buffered data for
     * the given `stream`.
     * For behaviour details see g_output_stream_flush().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_output_stream_flush_finish() to get the
     * result of the operation.
     * @virtual 
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    vfunc_flush_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes flushing an output stream.
     * @virtual 
     * @param result a GAsyncResult.
     * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
     */
    vfunc_flush_finish(result: AsyncResult): boolean
    /**
     * Splices an input stream into an output stream.
     * @virtual 
     * @param source a #GInputStream.
     * @param flags a set of #GOutputStreamSpliceFlags.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #gssize containing the size of the data spliced, or     -1 if an error occurred. Note that if the number of bytes     spliced is greater than %G_MAXSSIZE, then that will be     returned, and there is no way to determine the actual number     of bytes spliced.
     */
    vfunc_splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable: Cancellable | null): number
    /**
     * Splices a stream asynchronously.
     * When the operation is finished `callback` will be called.
     * You can then call g_output_stream_splice_finish() to get the
     * result of the operation.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_splice().
     * @virtual 
     * @param source a #GInputStream.
     * @param flags a set of #GOutputStreamSpliceFlags.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback.
     */
    vfunc_splice_async(source: InputStream, flags: OutputStreamSpliceFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes an asynchronous stream splice operation.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns a #gssize of the number of bytes spliced. Note that if the     number of bytes spliced is greater than %G_MAXSSIZE, then that     will be returned, and there is no way to determine the actual     number of bytes spliced.
     */
    vfunc_splice_finish(result: AsyncResult): number
    /**
     * Request an asynchronous write of `count` bytes from `buffer` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_write_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * A value of `count` larger than %G_MAXSSIZE will cause a
     * %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes written will be passed to the
     * `callback`. It is not an error if this is not the same as the
     * requested size, as it can happen e.g. on a partial I/O error,
     * but generally we try to write as many bytes as requested.
     * 
     * You are guaranteed that this method will never fail with
     * %G_IO_ERROR_WOULD_BLOCK - if `stream` can't accept more data, the
     * method will just wait until this changes.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_write().
     * 
     * Note that no copy of `buffer` will be made, so it must stay valid
     * until `callback` is called. See g_output_stream_write_bytes_async()
     * for a #GBytes version that will automatically hold a reference to
     * the contents (without copying) for the duration of the call.
     * @virtual 
     * @param buffer the buffer containing the data to write.
     * @param io_priority the io priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    vfunc_write_async(buffer: Uint8Array | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a stream write operation.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns a #gssize containing the number of bytes written to the stream.
     */
    vfunc_write_finish(result: AsyncResult): number
    /**
     * Tries to write `count` bytes from `buffer` into the stream. Will block
     * during the operation.
     * 
     * If count is 0, returns 0 and does nothing. A value of `count`
     * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
     * 
     * On success, the number of bytes written to the stream is returned.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. on a partial I/O error, or if there is not enough
     * storage in the stream. All writes block until at least one byte
     * is written or an error occurs; 0 is never returned (unless
     * `count` is 0).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * @virtual 
     * @param buffer the buffer containing the data to write.
     * @param cancellable optional cancellable object
     * @returns Number of bytes written, or -1 on error
     */
    vfunc_write_fn(buffer: Uint8Array | null, cancellable: Cancellable | null): number
    /**
     * Request an asynchronous write of the bytes contained in `n_vectors` `vectors` into
     * the stream. When the operation is finished `callback` will be called.
     * You can then call g_output_stream_writev_finish() to get the result of the
     * operation.
     * 
     * During an async request no other sync and async calls are allowed,
     * and will result in %G_IO_ERROR_PENDING errors.
     * 
     * On success, the number of bytes written will be passed to the
     * `callback`. It is not an error if this is not the same as the
     * requested size, as it can happen e.g. on a partial I/O error,
     * but generally we try to write as many bytes as requested.
     * 
     * You are guaranteed that this method will never fail with
     * %G_IO_ERROR_WOULD_BLOCK — if `stream` can't accept more data, the
     * method will just wait until this changes.
     * 
     * Any outstanding I/O request with higher priority (lower numerical
     * value) will be executed before an outstanding request with lower
     * priority. Default priority is %G_PRIORITY_DEFAULT.
     * 
     * The asynchronous methods have a default fallback that uses threads
     * to implement asynchronicity, so they are optional for inheriting
     * classes. However, if you override one you must override all.
     * 
     * For the synchronous, blocking version of this function, see
     * g_output_stream_writev().
     * 
     * Note that no copy of `vectors` will be made, so it must stay valid
     * until `callback` is called.
     * @virtual 
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param io_priority the I/O priority of the request.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback callback to call when the request is satisfied
     */
    vfunc_writev_async(vectors: OutputVector[], io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finishes a stream writev operation.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE on success, %FALSE if there was an error
     */
    vfunc_writev_finish(result: AsyncResult): [ /* returnType */ boolean, /* bytes_written */ number ]
    /**
     * Tries to write the bytes contained in the `n_vectors` `vectors` into the
     * stream. Will block during the operation.
     * 
     * If `n_vectors` is 0 or the sum of all bytes in `vectors` is 0, returns 0 and
     * does nothing.
     * 
     * On success, the number of bytes written to the stream is returned.
     * It is not an error if this is not the same as the requested size, as it
     * can happen e.g. on a partial I/O error, or if there is not enough
     * storage in the stream. All writes block until at least one byte
     * is written or an error occurs; 0 is never returned (unless
     * `n_vectors` is 0 or the sum of all bytes in `vectors` is 0).
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
     * operation was partially finished when the operation was cancelled the
     * partial result will be returned, without an error.
     * 
     * Some implementations of g_output_stream_writev() may have limitations on the
     * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
     * are exceeded. For example, when writing to a local file on UNIX platforms,
     * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
     * @virtual 
     * @param vectors the buffer containing the #GOutputVectors to write.
     * @param cancellable optional cancellable object
     * @returns %TRUE on success, %FALSE if there was an error
     */
    vfunc_writev_fn(vectors: OutputVector[], cancellable: Cancellable | null): [ /* returnType */ boolean, /* bytes_written */ number ]

    // Class property signals of Gio-2.0.Gio.OutputStream

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GOutputStream has functions to write to a stream (g_output_stream_write()),
 * to close a stream (g_output_stream_close()) and to flush pending writes
 * (g_output_stream_flush()).
 * 
 * To copy the content of an input stream to an output stream without
 * manually handling the reads and writes, use g_output_stream_splice().
 * 
 * See the documentation for #GIOStream for details of thread safety of
 * streaming APIs.
 * 
 * All of these functions have async variants too.
 * @interface 
 */
class OutputStream extends GObject.Object {

    // Own properties of Gio-2.0.Gio.OutputStream

    static name: string
    static $gtype: GObject.GType<OutputStream>

    // Constructors of Gio-2.0.Gio.OutputStream

    constructor(config?: OutputStream.ConstructorProperties) 
    _init(config?: OutputStream.ConstructorProperties): void
}

module Permission {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Permission {

    // Own properties of Gio-2.0.Gio.Permission

    /**
     * %TRUE if the caller currently has permission to perform the action that
     * `permission` represents the permission to perform.
     */
    readonly allowed: boolean
    /**
     * %TRUE if it is generally possible to acquire the permission by calling
     * g_permission_acquire().
     */
    readonly can_acquire: boolean
    /**
     * %TRUE if it is generally possible to release the permission by calling
     * g_permission_release().
     */
    readonly can_release: boolean

    // Own fields of Gio-2.0.Gio.Permission

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.Permission

    /**
     * Attempts to acquire the permission represented by `permission`.
     * 
     * The precise method by which this happens depends on the permission
     * and the underlying authentication mechanism.  A simple example is
     * that a dialog may appear asking the user to enter their password.
     * 
     * You should check with g_permission_get_can_acquire() before calling
     * this function.
     * 
     * If the permission is acquired then %TRUE is returned.  Otherwise,
     * %FALSE is returned and `error` is set appropriately.
     * 
     * This call is blocking, likely for a very long time (in the case that
     * user interaction is required).  See g_permission_acquire_async() for
     * the non-blocking version.
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if the permission was successfully acquired
     */
    acquire(cancellable: Cancellable | null): boolean
    /**
     * Attempts to acquire the permission represented by `permission`.
     * 
     * This is the first half of the asynchronous version of
     * g_permission_acquire().
     * @param cancellable a #GCancellable, or %NULL
     * @param callback the #GAsyncReadyCallback to call when done
     */
    acquire_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of acquire_async

    /**
     * Promisified version of {@link acquire_async}
     * 
     * Attempts to acquire the permission represented by `permission`.
     * 
     * This is the first half of the asynchronous version of
     * g_permission_acquire().
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE if the permission was successfully acquired
     */
    acquire_async(cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Collects the result of attempting to acquire the permission
     * represented by `permission`.
     * 
     * This is the second half of the asynchronous version of
     * g_permission_acquire().
     * @param result the #GAsyncResult given to the #GAsyncReadyCallback
     * @returns %TRUE if the permission was successfully acquired
     */
    acquire_finish(result: AsyncResult): boolean
    /**
     * Gets the value of the 'allowed' property.  This property is %TRUE if
     * the caller currently has permission to perform the action that
     * `permission` represents the permission to perform.
     * @returns the value of the 'allowed' property
     */
    get_allowed(): boolean
    /**
     * Gets the value of the 'can-acquire' property.  This property is %TRUE
     * if it is generally possible to acquire the permission by calling
     * g_permission_acquire().
     * @returns the value of the 'can-acquire' property
     */
    get_can_acquire(): boolean
    /**
     * Gets the value of the 'can-release' property.  This property is %TRUE
     * if it is generally possible to release the permission by calling
     * g_permission_release().
     * @returns the value of the 'can-release' property
     */
    get_can_release(): boolean
    /**
     * This function is called by the #GPermission implementation to update
     * the properties of the permission.  You should never call this
     * function except from a #GPermission implementation.
     * 
     * GObject notify signals are generated, as appropriate.
     * @param allowed the new value for the 'allowed' property
     * @param can_acquire the new value for the 'can-acquire' property
     * @param can_release the new value for the 'can-release' property
     */
    impl_update(allowed: boolean, can_acquire: boolean, can_release: boolean): void
    /**
     * Attempts to release the permission represented by `permission`.
     * 
     * The precise method by which this happens depends on the permission
     * and the underlying authentication mechanism.  In most cases the
     * permission will be dropped immediately without further action.
     * 
     * You should check with g_permission_get_can_release() before calling
     * this function.
     * 
     * If the permission is released then %TRUE is returned.  Otherwise,
     * %FALSE is returned and `error` is set appropriately.
     * 
     * This call is blocking, likely for a very long time (in the case that
     * user interaction is required).  See g_permission_release_async() for
     * the non-blocking version.
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if the permission was successfully released
     */
    release(cancellable: Cancellable | null): boolean
    /**
     * Attempts to release the permission represented by `permission`.
     * 
     * This is the first half of the asynchronous version of
     * g_permission_release().
     * @param cancellable a #GCancellable, or %NULL
     * @param callback the #GAsyncReadyCallback to call when done
     */
    release_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of release_async

    /**
     * Promisified version of {@link release_async}
     * 
     * Attempts to release the permission represented by `permission`.
     * 
     * This is the first half of the asynchronous version of
     * g_permission_release().
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE if the permission was successfully released
     */
    release_async(cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Collects the result of attempting to release the permission
     * represented by `permission`.
     * 
     * This is the second half of the asynchronous version of
     * g_permission_release().
     * @param result the #GAsyncResult given to the #GAsyncReadyCallback
     * @returns %TRUE if the permission was successfully released
     */
    release_finish(result: AsyncResult): boolean

    // Own virtual methods of Gio-2.0.Gio.Permission

    /**
     * Attempts to acquire the permission represented by `permission`.
     * 
     * The precise method by which this happens depends on the permission
     * and the underlying authentication mechanism.  A simple example is
     * that a dialog may appear asking the user to enter their password.
     * 
     * You should check with g_permission_get_can_acquire() before calling
     * this function.
     * 
     * If the permission is acquired then %TRUE is returned.  Otherwise,
     * %FALSE is returned and `error` is set appropriately.
     * 
     * This call is blocking, likely for a very long time (in the case that
     * user interaction is required).  See g_permission_acquire_async() for
     * the non-blocking version.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if the permission was successfully acquired
     */
    vfunc_acquire(cancellable: Cancellable | null): boolean
    /**
     * Attempts to acquire the permission represented by `permission`.
     * 
     * This is the first half of the asynchronous version of
     * g_permission_acquire().
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @param callback the #GAsyncReadyCallback to call when done
     */
    vfunc_acquire_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Collects the result of attempting to acquire the permission
     * represented by `permission`.
     * 
     * This is the second half of the asynchronous version of
     * g_permission_acquire().
     * @virtual 
     * @param result the #GAsyncResult given to the #GAsyncReadyCallback
     * @returns %TRUE if the permission was successfully acquired
     */
    vfunc_acquire_finish(result: AsyncResult): boolean
    /**
     * Attempts to release the permission represented by `permission`.
     * 
     * The precise method by which this happens depends on the permission
     * and the underlying authentication mechanism.  In most cases the
     * permission will be dropped immediately without further action.
     * 
     * You should check with g_permission_get_can_release() before calling
     * this function.
     * 
     * If the permission is released then %TRUE is returned.  Otherwise,
     * %FALSE is returned and `error` is set appropriately.
     * 
     * This call is blocking, likely for a very long time (in the case that
     * user interaction is required).  See g_permission_release_async() for
     * the non-blocking version.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if the permission was successfully released
     */
    vfunc_release(cancellable: Cancellable | null): boolean
    /**
     * Attempts to release the permission represented by `permission`.
     * 
     * This is the first half of the asynchronous version of
     * g_permission_release().
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @param callback the #GAsyncReadyCallback to call when done
     */
    vfunc_release_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Collects the result of attempting to release the permission
     * represented by `permission`.
     * 
     * This is the second half of the asynchronous version of
     * g_permission_release().
     * @virtual 
     * @param result the #GAsyncResult given to the #GAsyncReadyCallback
     * @returns %TRUE if the permission was successfully released
     */
    vfunc_release_finish(result: AsyncResult): boolean

    // Class property signals of Gio-2.0.Gio.Permission

    connect(sigName: "notify::allowed", callback: (($obj: Permission, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allowed", callback: (($obj: Permission, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::allowed", ...args: any[]): void
    connect(sigName: "notify::can-acquire", callback: (($obj: Permission, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-acquire", callback: (($obj: Permission, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::can-acquire", ...args: any[]): void
    connect(sigName: "notify::can-release", callback: (($obj: Permission, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-release", callback: (($obj: Permission, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::can-release", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GPermission represents the status of the caller's permission to
 * perform a certain action.
 * 
 * You can query if the action is currently allowed and if it is
 * possible to acquire the permission so that the action will be allowed
 * in the future.
 * 
 * There is also an API to actually acquire the permission and one to
 * release it.
 * 
 * As an example, a #GPermission might represent the ability for the
 * user to write to a #GSettings object.  This #GPermission object could
 * then be used to decide if it is appropriate to show a "Click here to
 * unlock" button in a dialog and to provide the mechanism to invoke
 * when that button is clicked.
 * @class 
 */
class Permission extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Permission

    static name: string
    static $gtype: GObject.GType<Permission>

    // Constructors of Gio-2.0.Gio.Permission

    constructor(config?: Permission.ConstructorProperties) 
    _init(config?: Permission.ConstructorProperties): void
}

module PropertyAction {

    // Constructor properties interface

    interface ConstructorProperties extends Action.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.PropertyAction

        /**
         * If %TRUE, the state of the action will be the negation of the
         * property value, provided the property is boolean.
         */
        invert_boolean?: boolean | null
        /**
         * The name of the action.  This is mostly meaningful for identifying
         * the action once it has been added to a #GActionMap.
         */
        name?: string | null
        /**
         * The object to wrap a property on.
         * 
         * The object must be a non-%NULL #GObject with properties.
         */
        object?: GObject.Object | null
        /**
         * The name of the property to wrap on the object.
         * 
         * The property must exist on the passed-in object and it must be
         * readable and writable (and not construct-only).
         */
        property_name?: string | null
    }

}

interface PropertyAction extends Action {

    // Own properties of Gio-2.0.Gio.PropertyAction

    /**
     * If `action` is currently enabled.
     * 
     * If the action is disabled then calls to g_action_activate() and
     * g_action_change_state() have no effect.
     */
    readonly enabled: boolean
    /**
     * If %TRUE, the state of the action will be the negation of the
     * property value, provided the property is boolean.
     */
    readonly invert_boolean: boolean
    /**
     * The name of the action.  This is mostly meaningful for identifying
     * the action once it has been added to a #GActionMap.
     */
    readonly name: string | null
    /**
     * The object to wrap a property on.
     * 
     * The object must be a non-%NULL #GObject with properties.
     */
    readonly object: GObject.Object
    /**
     * The type of the parameter that must be given when activating the
     * action.
     */
    readonly parameter_type: GLib.VariantType
    /**
     * The name of the property to wrap on the object.
     * 
     * The property must exist on the passed-in object and it must be
     * readable and writable (and not construct-only).
     */
    readonly property_name: string | null
    /**
     * The state of the action, or %NULL if the action is stateless.
     */
    readonly state: GLib.Variant
    /**
     * The #GVariantType of the state that the action has, or %NULL if the
     * action is stateless.
     */
    readonly state_type: GLib.VariantType

    // Class property signals of Gio-2.0.Gio.PropertyAction

    connect(sigName: "notify::enabled", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::enabled", ...args: any[]): void
    connect(sigName: "notify::invert-boolean", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::invert-boolean", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::invert-boolean", ...args: any[]): void
    connect(sigName: "notify::name", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::name", ...args: any[]): void
    connect(sigName: "notify::object", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::object", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::object", ...args: any[]): void
    connect(sigName: "notify::parameter-type", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameter-type", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parameter-type", ...args: any[]): void
    connect(sigName: "notify::property-name", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::property-name", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::property-name", ...args: any[]): void
    connect(sigName: "notify::state", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-type", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-type", callback: (($obj: PropertyAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::state-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GPropertyAction is a way to get a #GAction with a state value
 * reflecting and controlling the value of a #GObject property.
 * 
 * The state of the action will correspond to the value of the property.
 * Changing it will change the property (assuming the requested value
 * matches the requirements as specified in the #GParamSpec).
 * 
 * Only the most common types are presently supported.  Booleans are
 * mapped to booleans, strings to strings, signed/unsigned integers to
 * int32/uint32 and floats and doubles to doubles.
 * 
 * If the property is an enum then the state will be string-typed and
 * conversion will automatically be performed between the enum value and
 * "nick" string as per the #GEnumValue table.
 * 
 * Flags types are not currently supported.
 * 
 * Properties of object types, boxed types and pointer types are not
 * supported and probably never will be.
 * 
 * Properties of #GVariant types are not currently supported.
 * 
 * If the property is boolean-valued then the action will have a NULL
 * parameter type, and activating the action (with no parameter) will
 * toggle the value of the property.
 * 
 * In all other cases, the parameter type will correspond to the type of
 * the property.
 * 
 * The general idea here is to reduce the number of locations where a
 * particular piece of state is kept (and therefore has to be synchronised
 * between). #GPropertyAction does not have a separate state that is kept
 * in sync with the property value -- its state is the property value.
 * 
 * For example, it might be useful to create a #GAction corresponding to
 * the "visible-child-name" property of a #GtkStack so that the current
 * page can be switched from a menu.  The active radio indication in the
 * menu is then directly determined from the active page of the
 * #GtkStack.
 * 
 * An anti-example would be binding the "active-id" property on a
 * #GtkComboBox.  This is because the state of the combobox itself is
 * probably uninteresting and is actually being used to control
 * something else.
 * 
 * Another anti-example would be to bind to the "visible-child-name"
 * property of a #GtkStack if this value is actually stored in
 * #GSettings.  In that case, the real source of the value is
 * #GSettings.  If you want a #GAction to control a setting stored in
 * #GSettings, see g_settings_create_action() instead, and possibly
 * combine its use with g_settings_bind().
 * @class 
 */
class PropertyAction extends GObject.Object {

    // Own properties of Gio-2.0.Gio.PropertyAction

    static name: string
    static $gtype: GObject.GType<PropertyAction>

    // Constructors of Gio-2.0.Gio.PropertyAction

    constructor(config?: PropertyAction.ConstructorProperties) 
    /**
     * Creates a #GAction corresponding to the value of property
     * `property_name` on `object`.
     * 
     * The property must be existent and readable and writable (and not
     * construct-only).
     * 
     * This function takes a reference on `object` and doesn't release it
     * until the action is destroyed.
     * @constructor 
     * @param name the name of the action to create
     * @param object the object that has the property   to wrap
     * @param property_name the name of the property
     * @returns a new #GPropertyAction
     */
    constructor(name: string | null, object: GObject.Object, property_name: string | null) 
    /**
     * Creates a #GAction corresponding to the value of property
     * `property_name` on `object`.
     * 
     * The property must be existent and readable and writable (and not
     * construct-only).
     * 
     * This function takes a reference on `object` and doesn't release it
     * until the action is destroyed.
     * @constructor 
     * @param name the name of the action to create
     * @param object the object that has the property   to wrap
     * @param property_name the name of the property
     * @returns a new #GPropertyAction
     */
    static new(name: string | null, object: GObject.Object, property_name: string | null): PropertyAction
    _init(config?: PropertyAction.ConstructorProperties): void
}

module ProxyAddress {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnectable.ConstructorProperties, InetSocketAddress.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ProxyAddress

        destination_hostname?: string | null
        destination_port?: number | null
        /**
         * The protocol being spoke to the destination host, or %NULL if
         * the #GProxyAddress doesn't know.
         */
        destination_protocol?: string | null
        password?: string | null
        protocol?: string | null
        /**
         * The URI string that the proxy was constructed from (or %NULL
         * if the creator didn't specify this).
         */
        uri?: string | null
        username?: string | null
    }

}

interface ProxyAddress extends SocketConnectable {

    // Own properties of Gio-2.0.Gio.ProxyAddress

    readonly destination_hostname: string | null
    readonly destination_port: number
    /**
     * The protocol being spoke to the destination host, or %NULL if
     * the #GProxyAddress doesn't know.
     */
    readonly destination_protocol: string | null
    readonly password: string | null
    readonly protocol: string | null
    /**
     * The URI string that the proxy was constructed from (or %NULL
     * if the creator didn't specify this).
     */
    readonly uri: string | null
    readonly username: string | null

    // Own fields of Gio-2.0.Gio.ProxyAddress

    parent_instance: InetSocketAddress & SocketAddress & GObject.Object & GObject.Object

    // Owm methods of Gio-2.0.Gio.ProxyAddress

    /**
     * Gets `proxy'`s destination hostname; that is, the name of the host
     * that will be connected to via the proxy, not the name of the proxy
     * itself.
     * @returns the @proxy's destination hostname
     */
    get_destination_hostname(): string | null
    /**
     * Gets `proxy'`s destination port; that is, the port on the
     * destination host that will be connected to via the proxy, not the
     * port number of the proxy itself.
     * @returns the @proxy's destination port
     */
    get_destination_port(): number
    /**
     * Gets the protocol that is being spoken to the destination
     * server; eg, "http" or "ftp".
     * @returns the @proxy's destination protocol
     */
    get_destination_protocol(): string | null
    /**
     * Gets `proxy'`s password.
     * @returns the @proxy's password
     */
    get_password(): string | null
    /**
     * Gets `proxy'`s protocol. eg, "socks" or "http"
     * @returns the @proxy's protocol
     */
    get_protocol(): string | null
    /**
     * Gets the proxy URI that `proxy` was constructed from.
     * @returns the @proxy's URI, or %NULL if unknown
     */
    get_uri(): string | null
    /**
     * Gets `proxy'`s username.
     * @returns the @proxy's username
     */
    get_username(): string | null

    // Class property signals of Gio-2.0.Gio.ProxyAddress

    connect(sigName: "notify::destination-hostname", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::destination-hostname", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::destination-hostname", ...args: any[]): void
    connect(sigName: "notify::destination-port", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::destination-port", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::destination-port", ...args: any[]): void
    connect(sigName: "notify::destination-protocol", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::destination-protocol", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::destination-protocol", ...args: any[]): void
    connect(sigName: "notify::password", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password", ...args: any[]): void
    connect(sigName: "notify::protocol", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol", ...args: any[]): void
    connect(sigName: "notify::uri", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uri", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::uri", ...args: any[]): void
    connect(sigName: "notify::username", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::username", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::username", ...args: any[]): void
    connect(sigName: "notify::address", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::address", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::address", ...args: any[]): void
    connect(sigName: "notify::flowinfo", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flowinfo", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flowinfo", ...args: any[]): void
    connect(sigName: "notify::port", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::port", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::port", ...args: any[]): void
    connect(sigName: "notify::scope-id", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scope-id", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::scope-id", ...args: any[]): void
    connect(sigName: "notify::family", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: ProxyAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Support for proxied #GInetSocketAddress.
 * @class 
 */
class ProxyAddress extends InetSocketAddress {

    // Own properties of Gio-2.0.Gio.ProxyAddress

    static name: string
    static $gtype: GObject.GType<ProxyAddress>

    // Constructors of Gio-2.0.Gio.ProxyAddress

    constructor(config?: ProxyAddress.ConstructorProperties) 
    /**
     * Creates a new #GProxyAddress for `inetaddr` with `protocol` that should
     * tunnel through `dest_hostname` and `dest_port`.
     * 
     * (Note that this method doesn't set the #GProxyAddress:uri or
     * #GProxyAddress:destination-protocol fields; use g_object_new()
     * directly if you want to set those.)
     * @constructor 
     * @param inetaddr The proxy server #GInetAddress.
     * @param port The proxy server port.
     * @param protocol The proxy protocol to support, in lower case (e.g. socks, http).
     * @param dest_hostname The destination hostname the proxy should tunnel to.
     * @param dest_port The destination port to tunnel to.
     * @param username The username to authenticate to the proxy server     (or %NULL).
     * @param password The password to authenticate to the proxy server     (or %NULL).
     * @returns a new #GProxyAddress
     */
    constructor(inetaddr: InetAddress, port: number, protocol: string | null, dest_hostname: string | null, dest_port: number, username: string | null, password: string | null) 
    /**
     * Creates a new #GProxyAddress for `inetaddr` with `protocol` that should
     * tunnel through `dest_hostname` and `dest_port`.
     * 
     * (Note that this method doesn't set the #GProxyAddress:uri or
     * #GProxyAddress:destination-protocol fields; use g_object_new()
     * directly if you want to set those.)
     * @constructor 
     * @param inetaddr The proxy server #GInetAddress.
     * @param port The proxy server port.
     * @param protocol The proxy protocol to support, in lower case (e.g. socks, http).
     * @param dest_hostname The destination hostname the proxy should tunnel to.
     * @param dest_port The destination port to tunnel to.
     * @param username The username to authenticate to the proxy server     (or %NULL).
     * @param password The password to authenticate to the proxy server     (or %NULL).
     * @returns a new #GProxyAddress
     */
    static new(inetaddr: InetAddress, port: number, protocol: string | null, dest_hostname: string | null, dest_port: number, username: string | null, password: string | null): ProxyAddress

    // Overloads of new

    /**
     * Creates a new #GInetSocketAddress for `address` and `port`.
     * @constructor 
     * @param address a #GInetAddress
     * @param port a port number
     * @returns a new #GInetSocketAddress
     */
    static new(address: InetAddress, port: number): InetSocketAddress
    _init(config?: ProxyAddress.ConstructorProperties): void
}

module ProxyAddressEnumerator {

    // Constructor properties interface

    interface ConstructorProperties extends SocketAddressEnumerator.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ProxyAddressEnumerator

        connectable?: SocketConnectable | null
        /**
         * The default port to use if #GProxyAddressEnumerator:uri does not
         * specify one.
         */
        default_port?: number | null
        /**
         * The proxy resolver to use.
         */
        proxy_resolver?: ProxyResolver | null
        uri?: string | null
    }

}

interface ProxyAddressEnumerator {

    // Own properties of Gio-2.0.Gio.ProxyAddressEnumerator

    readonly connectable: SocketConnectable
    /**
     * The default port to use if #GProxyAddressEnumerator:uri does not
     * specify one.
     */
    readonly default_port: number
    /**
     * The proxy resolver to use.
     */
    proxy_resolver: ProxyResolver
    readonly uri: string | null

    // Class property signals of Gio-2.0.Gio.ProxyAddressEnumerator

    connect(sigName: "notify::connectable", callback: (($obj: ProxyAddressEnumerator, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connectable", callback: (($obj: ProxyAddressEnumerator, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::connectable", ...args: any[]): void
    connect(sigName: "notify::default-port", callback: (($obj: ProxyAddressEnumerator, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::default-port", callback: (($obj: ProxyAddressEnumerator, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::default-port", ...args: any[]): void
    connect(sigName: "notify::proxy-resolver", callback: (($obj: ProxyAddressEnumerator, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-resolver", callback: (($obj: ProxyAddressEnumerator, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::proxy-resolver", ...args: any[]): void
    connect(sigName: "notify::uri", callback: (($obj: ProxyAddressEnumerator, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uri", callback: (($obj: ProxyAddressEnumerator, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::uri", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GProxyAddressEnumerator is a wrapper around #GSocketAddressEnumerator which
 * takes the #GSocketAddress instances returned by the #GSocketAddressEnumerator
 * and wraps them in #GProxyAddress instances, using the given
 * #GProxyAddressEnumerator:proxy-resolver.
 * 
 * This enumerator will be returned (for example, by
 * g_socket_connectable_enumerate()) as appropriate when a proxy is configured;
 * there should be no need to manually wrap a #GSocketAddressEnumerator instance
 * with one.
 * @class 
 */
class ProxyAddressEnumerator extends SocketAddressEnumerator {

    // Own properties of Gio-2.0.Gio.ProxyAddressEnumerator

    static name: string
    static $gtype: GObject.GType<ProxyAddressEnumerator>

    // Constructors of Gio-2.0.Gio.ProxyAddressEnumerator

    constructor(config?: ProxyAddressEnumerator.ConstructorProperties) 
    _init(config?: ProxyAddressEnumerator.ConstructorProperties): void
}

module Resolver {

    // Signal callback interfaces

    /**
     * Signal callback interface for `reload`
     */
    interface ReloadSignalCallback {
        ($obj: Resolver): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Resolver {

    // Own fields of Gio-2.0.Gio.Resolver

    parent_instance: GObject.Object
    priv: ResolverPrivate

    // Owm methods of Gio-2.0.Gio.Resolver

    /**
     * Synchronously reverse-resolves `address` to determine its
     * associated hostname.
     * 
     * If the DNS resolution fails, `error` (if non-%NULL) will be set to
     * a value from #GResolverError.
     * 
     * If `cancellable` is non-%NULL, it can be used to cancel the
     * operation, in which case `error` (if non-%NULL) will be set to
     * %G_IO_ERROR_CANCELLED.
     * @param address the address to reverse-resolve
     * @param cancellable a #GCancellable, or %NULL
     * @returns a hostname (either ASCII-only, or in ASCII-encoded     form), or %NULL on error.
     */
    lookup_by_address(address: InetAddress, cancellable: Cancellable | null): string | null
    /**
     * Begins asynchronously reverse-resolving `address` to determine its
     * associated hostname, and eventually calls `callback,` which must
     * call g_resolver_lookup_by_address_finish() to get the final result.
     * @param address the address to reverse-resolve
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    lookup_by_address_async(address: InetAddress, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_by_address_async

    /**
     * Promisified version of {@link lookup_by_address_async}
     * 
     * Begins asynchronously reverse-resolving `address` to determine its
     * associated hostname, and eventually calls `callback,` which must
     * call g_resolver_lookup_by_address_finish() to get the final result.
     * @param address the address to reverse-resolve
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a hostname (either ASCII-only, or in ASCII-encoded form), or %NULL on error.
     */
    lookup_by_address_async(address: InetAddress, cancellable: Cancellable | null): globalThis.Promise<string | null>
    /**
     * Retrieves the result of a previous call to
     * g_resolver_lookup_by_address_async().
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a hostname (either ASCII-only, or in ASCII-encoded form), or %NULL on error.
     */
    lookup_by_address_finish(result: AsyncResult): string | null
    /**
     * Synchronously resolves `hostname` to determine its associated IP
     * address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
     * the textual form of an IP address (in which case this just becomes
     * a wrapper around g_inet_address_new_from_string()).
     * 
     * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
     * #GInetAddress, sorted in order of preference and guaranteed to not
     * contain duplicates. That is, if using the result to connect to
     * `hostname,` you should attempt to connect to the first address
     * first, then the second if the first fails, etc. If you are using
     * the result to listen on a socket, it is appropriate to add each
     * result using e.g. g_socket_listener_add_address().
     * 
     * If the DNS resolution fails, `error` (if non-%NULL) will be set to a
     * value from #GResolverError and %NULL will be returned.
     * 
     * If `cancellable` is non-%NULL, it can be used to cancel the
     * operation, in which case `error` (if non-%NULL) will be set to
     * %G_IO_ERROR_CANCELLED.
     * 
     * If you are planning to connect to a socket on the resolved IP
     * address, it may be easier to create a #GNetworkAddress and use its
     * #GSocketConnectable interface.
     * @param hostname the hostname to look up
     * @param cancellable a #GCancellable, or %NULL
     * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
     */
    lookup_by_name(hostname: string | null, cancellable: Cancellable | null): InetAddress[]
    /**
     * Begins asynchronously resolving `hostname` to determine its
     * associated IP address(es), and eventually calls `callback,` which
     * must call g_resolver_lookup_by_name_finish() to get the result.
     * See g_resolver_lookup_by_name() for more details.
     * @param hostname the hostname to look up the address of
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    lookup_by_name_async(hostname: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_by_name_async

    /**
     * Promisified version of {@link lookup_by_name_async}
     * 
     * Begins asynchronously resolving `hostname` to determine its
     * associated IP address(es), and eventually calls `callback,` which
     * must call g_resolver_lookup_by_name_finish() to get the result.
     * See g_resolver_lookup_by_name() for more details.
     * @param hostname the hostname to look up the address of
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
     */
    lookup_by_name_async(hostname: string | null, cancellable: Cancellable | null): globalThis.Promise<InetAddress[]>
    /**
     * Retrieves the result of a call to
     * g_resolver_lookup_by_name_async().
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
     */
    lookup_by_name_finish(result: AsyncResult): InetAddress[]
    /**
     * This differs from g_resolver_lookup_by_name() in that you can modify
     * the lookup behavior with `flags`. For example this can be used to limit
     * results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
     * @param hostname the hostname to look up
     * @param flags extra #GResolverNameLookupFlags for the lookup
     * @param cancellable a #GCancellable, or %NULL
     * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
     */
    lookup_by_name_with_flags(hostname: string | null, flags: ResolverNameLookupFlags, cancellable: Cancellable | null): InetAddress[]
    /**
     * Begins asynchronously resolving `hostname` to determine its
     * associated IP address(es), and eventually calls `callback,` which
     * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
     * See g_resolver_lookup_by_name() for more details.
     * @param hostname the hostname to look up the address of
     * @param flags extra #GResolverNameLookupFlags for the lookup
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    lookup_by_name_with_flags_async(hostname: string | null, flags: ResolverNameLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_by_name_with_flags_async

    /**
     * Promisified version of {@link lookup_by_name_with_flags_async}
     * 
     * Begins asynchronously resolving `hostname` to determine its
     * associated IP address(es), and eventually calls `callback,` which
     * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
     * See g_resolver_lookup_by_name() for more details.
     * @param hostname the hostname to look up the address of
     * @param flags extra #GResolverNameLookupFlags for the lookup
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
     */
    lookup_by_name_with_flags_async(hostname: string | null, flags: ResolverNameLookupFlags, cancellable: Cancellable | null): globalThis.Promise<InetAddress[]>
    /**
     * Retrieves the result of a call to
     * g_resolver_lookup_by_name_with_flags_async().
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
     */
    lookup_by_name_with_flags_finish(result: AsyncResult): InetAddress[]
    /**
     * Synchronously performs a DNS record lookup for the given `rrname` and returns
     * a list of records as #GVariant tuples. See #GResolverRecordType for
     * information on what the records contain for each `record_type`.
     * 
     * If the DNS resolution fails, `error` (if non-%NULL) will be set to
     * a value from #GResolverError and %NULL will be returned.
     * 
     * If `cancellable` is non-%NULL, it can be used to cancel the
     * operation, in which case `error` (if non-%NULL) will be set to
     * %G_IO_ERROR_CANCELLED.
     * @param rrname the DNS name to look up the record for
     * @param record_type the type of DNS record to look up
     * @param cancellable a #GCancellable, or %NULL
     * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
     */
    lookup_records(rrname: string | null, record_type: ResolverRecordType, cancellable: Cancellable | null): GLib.Variant[]
    /**
     * Begins asynchronously performing a DNS lookup for the given
     * `rrname,` and eventually calls `callback,` which must call
     * g_resolver_lookup_records_finish() to get the final result. See
     * g_resolver_lookup_records() for more details.
     * @param rrname the DNS name to look up the record for
     * @param record_type the type of DNS record to look up
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    lookup_records_async(rrname: string | null, record_type: ResolverRecordType, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_records_async

    /**
     * Promisified version of {@link lookup_records_async}
     * 
     * Begins asynchronously performing a DNS lookup for the given
     * `rrname,` and eventually calls `callback,` which must call
     * g_resolver_lookup_records_finish() to get the final result. See
     * g_resolver_lookup_records() for more details.
     * @param rrname the DNS name to look up the record for
     * @param record_type the type of DNS record to look up
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
     */
    lookup_records_async(rrname: string | null, record_type: ResolverRecordType, cancellable: Cancellable | null): globalThis.Promise<GLib.Variant[]>
    /**
     * Retrieves the result of a previous call to
     * g_resolver_lookup_records_async(). Returns a non-empty list of records as
     * #GVariant tuples. See #GResolverRecordType for information on what the
     * records contain.
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
     */
    lookup_records_finish(result: AsyncResult): GLib.Variant[]
    /**
     * Synchronously performs a DNS SRV lookup for the given `service` and
     * `protocol` in the given `domain` and returns an array of #GSrvTarget.
     * `domain` may be an ASCII-only or UTF-8 hostname. Note also that the
     * `service` and `protocol` arguments do not include the leading underscore
     * that appears in the actual DNS entry.
     * 
     * On success, g_resolver_lookup_service() will return a non-empty #GList of
     * #GSrvTarget, sorted in order of preference. (That is, you should
     * attempt to connect to the first target first, then the second if
     * the first fails, etc.)
     * 
     * If the DNS resolution fails, `error` (if non-%NULL) will be set to
     * a value from #GResolverError and %NULL will be returned.
     * 
     * If `cancellable` is non-%NULL, it can be used to cancel the
     * operation, in which case `error` (if non-%NULL) will be set to
     * %G_IO_ERROR_CANCELLED.
     * 
     * If you are planning to connect to the service, it is usually easier
     * to create a #GNetworkService and use its #GSocketConnectable
     * interface.
     * @param service the service type to look up (eg, "ldap")
     * @param protocol the networking protocol to use for `service` (eg, "tcp")
     * @param domain the DNS domain to look up the service in
     * @param cancellable a #GCancellable, or %NULL
     * @returns a non-empty #GList of #GSrvTarget, or %NULL on error. You must free each of the targets and the list when you are done with it. (You can use g_resolver_free_targets() to do this.)
     */
    lookup_service(service: string | null, protocol: string | null, domain: string | null, cancellable: Cancellable | null): SrvTarget[]
    /**
     * Begins asynchronously performing a DNS SRV lookup for the given
     * `service` and `protocol` in the given `domain,` and eventually calls
     * `callback,` which must call g_resolver_lookup_service_finish() to
     * get the final result. See g_resolver_lookup_service() for more
     * details.
     * @param service the service type to look up (eg, "ldap")
     * @param protocol the networking protocol to use for `service` (eg, "tcp")
     * @param domain the DNS domain to look up the service in
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    lookup_service_async(service: string | null, protocol: string | null, domain: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_service_async

    /**
     * Promisified version of {@link lookup_service_async}
     * 
     * Begins asynchronously performing a DNS SRV lookup for the given
     * `service` and `protocol` in the given `domain,` and eventually calls
     * `callback,` which must call g_resolver_lookup_service_finish() to
     * get the final result. See g_resolver_lookup_service() for more
     * details.
     * @param service the service type to look up (eg, "ldap")
     * @param protocol the networking protocol to use for `service` (eg, "tcp")
     * @param domain the DNS domain to look up the service in
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a non-empty #GList of #GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more details.
     */
    lookup_service_async(service: string | null, protocol: string | null, domain: string | null, cancellable: Cancellable | null): globalThis.Promise<SrvTarget[]>
    /**
     * Retrieves the result of a previous call to
     * g_resolver_lookup_service_async().
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a non-empty #GList of #GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more details.
     */
    lookup_service_finish(result: AsyncResult): SrvTarget[]
    /**
     * Sets `resolver` to be the application's default resolver (reffing
     * `resolver,` and unreffing the previous default resolver, if any).
     * Future calls to g_resolver_get_default() will return this resolver.
     * 
     * This can be used if an application wants to perform any sort of DNS
     * caching or "pinning"; it can implement its own #GResolver that
     * calls the original default resolver for DNS operations, and
     * implements its own cache policies on top of that, and then set
     * itself as the default resolver for all later code to use.
     */
    set_default(): void

    // Own virtual methods of Gio-2.0.Gio.Resolver

    /**
     * Synchronously reverse-resolves `address` to determine its
     * associated hostname.
     * 
     * If the DNS resolution fails, `error` (if non-%NULL) will be set to
     * a value from #GResolverError.
     * 
     * If `cancellable` is non-%NULL, it can be used to cancel the
     * operation, in which case `error` (if non-%NULL) will be set to
     * %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param address the address to reverse-resolve
     * @param cancellable a #GCancellable, or %NULL
     * @returns a hostname (either ASCII-only, or in ASCII-encoded     form), or %NULL on error.
     */
    vfunc_lookup_by_address(address: InetAddress, cancellable: Cancellable | null): string | null
    /**
     * Begins asynchronously reverse-resolving `address` to determine its
     * associated hostname, and eventually calls `callback,` which must
     * call g_resolver_lookup_by_address_finish() to get the final result.
     * @virtual 
     * @param address the address to reverse-resolve
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    vfunc_lookup_by_address_async(address: InetAddress, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Retrieves the result of a previous call to
     * g_resolver_lookup_by_address_async().
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a hostname (either ASCII-only, or in ASCII-encoded form), or %NULL on error.
     */
    vfunc_lookup_by_address_finish(result: AsyncResult): string | null
    /**
     * Synchronously resolves `hostname` to determine its associated IP
     * address(es). `hostname` may be an ASCII-only or UTF-8 hostname, or
     * the textual form of an IP address (in which case this just becomes
     * a wrapper around g_inet_address_new_from_string()).
     * 
     * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
     * #GInetAddress, sorted in order of preference and guaranteed to not
     * contain duplicates. That is, if using the result to connect to
     * `hostname,` you should attempt to connect to the first address
     * first, then the second if the first fails, etc. If you are using
     * the result to listen on a socket, it is appropriate to add each
     * result using e.g. g_socket_listener_add_address().
     * 
     * If the DNS resolution fails, `error` (if non-%NULL) will be set to a
     * value from #GResolverError and %NULL will be returned.
     * 
     * If `cancellable` is non-%NULL, it can be used to cancel the
     * operation, in which case `error` (if non-%NULL) will be set to
     * %G_IO_ERROR_CANCELLED.
     * 
     * If you are planning to connect to a socket on the resolved IP
     * address, it may be easier to create a #GNetworkAddress and use its
     * #GSocketConnectable interface.
     * @virtual 
     * @param hostname the hostname to look up
     * @param cancellable a #GCancellable, or %NULL
     * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
     */
    vfunc_lookup_by_name(hostname: string | null, cancellable: Cancellable | null): InetAddress[]
    /**
     * Begins asynchronously resolving `hostname` to determine its
     * associated IP address(es), and eventually calls `callback,` which
     * must call g_resolver_lookup_by_name_finish() to get the result.
     * See g_resolver_lookup_by_name() for more details.
     * @virtual 
     * @param hostname the hostname to look up the address of
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    vfunc_lookup_by_name_async(hostname: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Retrieves the result of a call to
     * g_resolver_lookup_by_name_async().
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
     */
    vfunc_lookup_by_name_finish(result: AsyncResult): InetAddress[]
    /**
     * This differs from g_resolver_lookup_by_name() in that you can modify
     * the lookup behavior with `flags`. For example this can be used to limit
     * results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
     * @virtual 
     * @param hostname the hostname to look up
     * @param flags extra #GResolverNameLookupFlags for the lookup
     * @param cancellable a #GCancellable, or %NULL
     * @returns a non-empty #GList of #GInetAddress, or %NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)
     */
    vfunc_lookup_by_name_with_flags(hostname: string | null, flags: ResolverNameLookupFlags, cancellable: Cancellable | null): InetAddress[]
    /**
     * Begins asynchronously resolving `hostname` to determine its
     * associated IP address(es), and eventually calls `callback,` which
     * must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
     * See g_resolver_lookup_by_name() for more details.
     * @virtual 
     * @param hostname the hostname to look up the address of
     * @param flags extra #GResolverNameLookupFlags for the lookup
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    vfunc_lookup_by_name_with_flags_async(hostname: string | null, flags: ResolverNameLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Retrieves the result of a call to
     * g_resolver_lookup_by_name_with_flags_async().
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a #GList of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name() for more details.
     */
    vfunc_lookup_by_name_with_flags_finish(result: AsyncResult): InetAddress[]
    /**
     * Synchronously performs a DNS record lookup for the given `rrname` and returns
     * a list of records as #GVariant tuples. See #GResolverRecordType for
     * information on what the records contain for each `record_type`.
     * 
     * If the DNS resolution fails, `error` (if non-%NULL) will be set to
     * a value from #GResolverError and %NULL will be returned.
     * 
     * If `cancellable` is non-%NULL, it can be used to cancel the
     * operation, in which case `error` (if non-%NULL) will be set to
     * %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param rrname the DNS name to look up the record for
     * @param record_type the type of DNS record to look up
     * @param cancellable a #GCancellable, or %NULL
     * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
     */
    vfunc_lookup_records(rrname: string | null, record_type: ResolverRecordType, cancellable: Cancellable | null): GLib.Variant[]
    /**
     * Begins asynchronously performing a DNS lookup for the given
     * `rrname,` and eventually calls `callback,` which must call
     * g_resolver_lookup_records_finish() to get the final result. See
     * g_resolver_lookup_records() for more details.
     * @virtual 
     * @param rrname the DNS name to look up the record for
     * @param record_type the type of DNS record to look up
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call after resolution completes
     */
    vfunc_lookup_records_async(rrname: string | null, record_type: ResolverRecordType, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Retrieves the result of a previous call to
     * g_resolver_lookup_records_async(). Returns a non-empty list of records as
     * #GVariant tuples. See #GResolverRecordType for information on what the
     * records contain.
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a non-empty #GList of #GVariant, or %NULL on error. You must free each of the records and the list when you are done with it. (You can use g_list_free_full() with g_variant_unref() to do this.)
     */
    vfunc_lookup_records_finish(result: AsyncResult): GLib.Variant[]
    vfunc_lookup_service_async(rrname: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Retrieves the result of a previous call to
     * g_resolver_lookup_service_async().
     * 
     * If the DNS resolution failed, `error` (if non-%NULL) will be set to
     * a value from #GResolverError. If the operation was cancelled,
     * `error` will be set to %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param result the result passed to your #GAsyncReadyCallback
     * @returns a non-empty #GList of #GSrvTarget, or %NULL on error. See g_resolver_lookup_service() for more details.
     */
    vfunc_lookup_service_finish(result: AsyncResult): SrvTarget[]
    vfunc_reload(): void

    // Own signals of Gio-2.0.Gio.Resolver

    connect(sigName: "reload", callback: Resolver.ReloadSignalCallback): number
    connect_after(sigName: "reload", callback: Resolver.ReloadSignalCallback): number
    emit(sigName: "reload", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.Resolver

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GResolver provides cancellable synchronous and asynchronous DNS
 * resolution, for hostnames (g_resolver_lookup_by_address(),
 * g_resolver_lookup_by_name() and their async variants) and SRV
 * (service) records (g_resolver_lookup_service()).
 * 
 * #GNetworkAddress and #GNetworkService provide wrappers around
 * #GResolver functionality that also implement #GSocketConnectable,
 * making it easy to connect to a remote host/service.
 * @class 
 */
class Resolver extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Resolver

    static name: string
    static $gtype: GObject.GType<Resolver>

    // Constructors of Gio-2.0.Gio.Resolver

    constructor(config?: Resolver.ConstructorProperties) 
    _init(config?: Resolver.ConstructorProperties): void
    /**
     * Gets the default #GResolver. You should unref it when you are done
     * with it. #GResolver may use its reference count as a hint about how
     * many threads it should allocate for concurrent DNS resolutions.
     * @returns the default #GResolver.
     */
    static get_default(): Resolver
}

module Settings {

    // Signal callback interfaces

    /**
     * Signal callback interface for `change-event`
     */
    interface ChangeEventSignalCallback {
        ($obj: Settings, keys: GLib.Quark[] | null): boolean
    }

    /**
     * Signal callback interface for `changed`
     */
    interface ChangedSignalCallback {
        ($obj: Settings, key: string | null): void
    }

    /**
     * Signal callback interface for `writable-change-event`
     */
    interface WritableChangeEventSignalCallback {
        ($obj: Settings, key: number): boolean
    }

    /**
     * Signal callback interface for `writable-changed`
     */
    interface WritableChangedSignalCallback {
        ($obj: Settings, key: string | null): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.Settings

        /**
         * The name of the context that the settings are stored in.
         */
        backend?: SettingsBackend | null
        /**
         * The path within the backend where the settings are stored.
         */
        path?: string | null
        /**
         * The name of the schema that describes the types of keys
         * for this #GSettings object.
         * 
         * The type of this property is *not* #GSettingsSchema.
         * #GSettingsSchema has only existed since version 2.32 and
         * unfortunately this name was used in previous versions to refer to
         * the schema ID rather than the schema itself.  Take care to use the
         * 'settings-schema' property if you wish to pass in a
         * #GSettingsSchema.
         */
        schema?: string | null
        /**
         * The name of the schema that describes the types of keys
         * for this #GSettings object.
         */
        schema_id?: string | null
        /**
         * The #GSettingsSchema describing the types of keys for this
         * #GSettings object.
         * 
         * Ideally, this property would be called 'schema'.  #GSettingsSchema
         * has only existed since version 2.32, however, and before then the
         * 'schema' property was used to refer to the ID of the schema rather
         * than the schema itself.  Take care.
         */
        settings_schema?: SettingsSchema | null
    }

}

interface Settings {

    // Own properties of Gio-2.0.Gio.Settings

    /**
     * The name of the context that the settings are stored in.
     */
    readonly backend: SettingsBackend
    /**
     * Whether the #GSettings object is in 'delay-apply' mode. See
     * g_settings_delay() for details.
     */
    readonly delay_apply: boolean
    /**
     * If this property is %TRUE, the #GSettings object has outstanding
     * changes that will be applied when g_settings_apply() is called.
     */
    readonly has_unapplied: boolean
    /**
     * The path within the backend where the settings are stored.
     */
    readonly path: string | null
    /**
     * The name of the schema that describes the types of keys
     * for this #GSettings object.
     * 
     * The type of this property is *not* #GSettingsSchema.
     * #GSettingsSchema has only existed since version 2.32 and
     * unfortunately this name was used in previous versions to refer to
     * the schema ID rather than the schema itself.  Take care to use the
     * 'settings-schema' property if you wish to pass in a
     * #GSettingsSchema.
     */
    readonly schema: string | null
    /**
     * The name of the schema that describes the types of keys
     * for this #GSettings object.
     */
    readonly schema_id: string | null
    /**
     * The #GSettingsSchema describing the types of keys for this
     * #GSettings object.
     * 
     * Ideally, this property would be called 'schema'.  #GSettingsSchema
     * has only existed since version 2.32, however, and before then the
     * 'schema' property was used to refer to the ID of the schema rather
     * than the schema itself.  Take care.
     */
    readonly settings_schema: SettingsSchema

    // Own fields of Gio-2.0.Gio.Settings

    parent_instance: GObject.Object
    priv: SettingsPrivate

    // Owm methods of Gio-2.0.Gio.Settings

    /**
     * Applies any changes that have been made to the settings.  This
     * function does nothing unless `settings` is in 'delay-apply' mode;
     * see g_settings_delay().  In the normal case settings are always
     * applied immediately.
     */
    apply(): void
    /**
     * Create a binding between the `key` in the `settings` object
     * and the property `property` of `object`.
     * 
     * The binding uses the default GIO mapping functions to map
     * between the settings and property values. These functions
     * handle booleans, numeric types and string types in a
     * straightforward way. Use g_settings_bind_with_mapping() if
     * you need a custom mapping, or map between types that are not
     * supported by the default mapping functions.
     * 
     * Unless the `flags` include %G_SETTINGS_BIND_NO_SENSITIVITY, this
     * function also establishes a binding between the writability of
     * `key` and the "sensitive" property of `object` (if `object` has
     * a boolean property by that name). See g_settings_bind_writable()
     * for more details about writable bindings.
     * 
     * Note that the lifecycle of the binding is tied to `object,`
     * and that you can have only one binding per object property.
     * If you bind the same property twice on the same object, the second
     * binding overrides the first one.
     * @param key the key to bind
     * @param object a #GObject
     * @param property the name of the property to bind
     * @param flags flags for the binding
     */
    bind(key: string | null, object: GObject.Object, property: string | null, flags: SettingsBindFlags): void
    /**
     * Create a binding between the writability of `key` in the
     * `settings` object and the property `property` of `object`.
     * The property must be boolean; "sensitive" or "visible"
     * properties of widgets are the most likely candidates.
     * 
     * Writable bindings are always uni-directional; changes of the
     * writability of the setting will be propagated to the object
     * property, not the other way.
     * 
     * When the `inverted` argument is %TRUE, the binding inverts the
     * value as it passes from the setting to the object, i.e. `property`
     * will be set to %TRUE if the key is not writable.
     * 
     * Note that the lifecycle of the binding is tied to `object,`
     * and that you can have only one binding per object property.
     * If you bind the same property twice on the same object, the second
     * binding overrides the first one.
     * @param key the key to bind
     * @param object a #GObject
     * @param property the name of a boolean property to bind
     * @param inverted whether to 'invert' the value
     */
    bind_writable(key: string | null, object: GObject.Object, property: string | null, inverted: boolean): void
    /**
     * Creates a #GAction corresponding to a given #GSettings key.
     * 
     * The action has the same name as the key.
     * 
     * The value of the key becomes the state of the action and the action
     * is enabled when the key is writable.  Changing the state of the
     * action results in the key being written to.  Changes to the value or
     * writability of the key cause appropriate change notifications to be
     * emitted for the action.
     * 
     * For boolean-valued keys, action activations take no parameter and
     * result in the toggling of the value.  For all other types,
     * activations take the new value for the key (which must have the
     * correct type).
     * @param key the name of a key in `settings`
     * @returns a new #GAction
     */
    create_action(key: string | null): Action
    /**
     * Changes the #GSettings object into 'delay-apply' mode. In this
     * mode, changes to `settings` are not immediately propagated to the
     * backend, but kept locally until g_settings_apply() is called.
     */
    delay(): void
    /**
     * Gets the value that is stored at `key` in `settings`.
     * 
     * A convenience variant of g_settings_get() for booleans.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a boolean type in the schema for `settings`.
     * @param key the key to get the value for
     * @returns a boolean
     */
    get_boolean(key: string | null): boolean
    /**
     * Creates a child settings object which has a base path of
     * `base-path/`name``, where `base-path` is the base path of
     * `settings`.
     * 
     * The schema for the child settings object must have been declared
     * in the schema of `settings` using a `<child>` element.
     * 
     * The created child settings object will inherit the #GSettings:delay-apply
     * mode from `settings`.
     * @param name the name of the child schema
     * @returns a 'child' settings object
     */
    get_child(name: string | null): Settings
    /**
     * Gets the "default value" of a key.
     * 
     * This is the value that would be read if g_settings_reset() were to be
     * called on the key.
     * 
     * Note that this may be a different value than returned by
     * g_settings_schema_key_get_default_value() if the system administrator
     * has provided a default value.
     * 
     * Comparing the return values of g_settings_get_default_value() and
     * g_settings_get_value() is not sufficient for determining if a value
     * has been set because the user may have explicitly set the value to
     * something that happens to be equal to the default.  The difference
     * here is that if the default changes in the future, the user's key
     * will still be set.
     * 
     * This function may be useful for adding an indication to a UI of what
     * the default value was before the user set it.
     * 
     * It is a programmer error to give a `key` that isn't contained in the
     * schema for `settings`.
     * @param key the key to get the default value for
     * @returns the default value
     */
    get_default_value(key: string | null): GLib.Variant | null
    /**
     * Gets the value that is stored at `key` in `settings`.
     * 
     * A convenience variant of g_settings_get() for doubles.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a 'double' type in the schema for `settings`.
     * @param key the key to get the value for
     * @returns a double
     */
    get_double(key: string | null): number
    /**
     * Gets the value that is stored in `settings` for `key` and converts it
     * to the enum value that it represents.
     * 
     * In order to use this function the type of the value must be a string
     * and it must be marked in the schema file as an enumerated type.
     * 
     * It is a programmer error to give a `key` that isn't contained in the
     * schema for `settings` or is not marked as an enumerated type.
     * 
     * If the value stored in the configuration database is not a valid
     * value for the enumerated type then this function will return the
     * default value.
     * @param key the key to get the value for
     * @returns the enum value
     */
    get_enum(key: string | null): number
    /**
     * Gets the value that is stored in `settings` for `key` and converts it
     * to the flags value that it represents.
     * 
     * In order to use this function the type of the value must be an array
     * of strings and it must be marked in the schema file as a flags type.
     * 
     * It is a programmer error to give a `key` that isn't contained in the
     * schema for `settings` or is not marked as a flags type.
     * 
     * If the value stored in the configuration database is not a valid
     * value for the flags type then this function will return the default
     * value.
     * @param key the key to get the value for
     * @returns the flags value
     */
    get_flags(key: string | null): number
    /**
     * Returns whether the #GSettings object has any unapplied
     * changes.  This can only be the case if it is in 'delayed-apply' mode.
     * @returns %TRUE if @settings has unapplied changes
     */
    get_has_unapplied(): boolean
    /**
     * Gets the value that is stored at `key` in `settings`.
     * 
     * A convenience variant of g_settings_get() for 32-bit integers.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a int32 type in the schema for `settings`.
     * @param key the key to get the value for
     * @returns an integer
     */
    get_int(key: string | null): number
    /**
     * Gets the value that is stored at `key` in `settings`.
     * 
     * A convenience variant of g_settings_get() for 64-bit integers.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a int64 type in the schema for `settings`.
     * @param key the key to get the value for
     * @returns a 64-bit integer
     */
    get_int64(key: string | null): number
    /**
     * Gets the value that is stored at `key` in `settings,` subject to
     * application-level validation/mapping.
     * 
     * You should use this function when the application needs to perform
     * some processing on the value of the key (for example, parsing).  The
     * `mapping` function performs that processing.  If the function
     * indicates that the processing was unsuccessful (due to a parse error,
     * for example) then the mapping is tried again with another value.
     * 
     * This allows a robust 'fall back to defaults' behaviour to be
     * implemented somewhat automatically.
     * 
     * The first value that is tried is the user's setting for the key.  If
     * the mapping function fails to map this value, other values may be
     * tried in an unspecified order (system or site defaults, translated
     * schema default values, untranslated schema default values, etc).
     * 
     * If the mapping function fails for all possible values, one additional
     * attempt is made: the mapping function is called with a %NULL value.
     * If the mapping function still indicates failure at this point then
     * the application will be aborted.
     * 
     * The result parameter for the `mapping` function is pointed to a
     * #gpointer which is initially set to %NULL.  The same pointer is given
     * to each invocation of `mapping`.  The final value of that #gpointer is
     * what is returned by this function.  %NULL is valid; it is returned
     * just as any other value would be.
     * @param key the key to get the value for
     * @param mapping the function to map the value in the           settings database to the value used by the application
     * @returns the result, which may be %NULL
     */
    get_mapped(key: string | null, mapping: SettingsGetMapping): any | null
    /**
     * Queries the range of a key.
     * @param key the key to query the range of
     */
    get_range(key: string | null): GLib.Variant
    /**
     * Gets the value that is stored at `key` in `settings`.
     * 
     * A convenience variant of g_settings_get() for strings.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a string type in the schema for `settings`.
     * @param key the key to get the value for
     * @returns a newly-allocated string
     */
    get_string(key: string | null): string | null
    /**
     * A convenience variant of g_settings_get() for string arrays.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having an array of strings type in the schema for `settings`.
     * @param key the key to get the value for
     * @returns a newly-allocated, %NULL-terminated array of strings, the value that is stored at @key in @settings.
     */
    get_strv(key: string | null): string[]
    /**
     * Gets the value that is stored at `key` in `settings`.
     * 
     * A convenience variant of g_settings_get() for 32-bit unsigned
     * integers.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a uint32 type in the schema for `settings`.
     * @param key the key to get the value for
     * @returns an unsigned integer
     */
    get_uint(key: string | null): number
    /**
     * Gets the value that is stored at `key` in `settings`.
     * 
     * A convenience variant of g_settings_get() for 64-bit unsigned
     * integers.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a uint64 type in the schema for `settings`.
     * @param key the key to get the value for
     * @returns a 64-bit unsigned integer
     */
    get_uint64(key: string | null): number
    /**
     * Checks the "user value" of a key, if there is one.
     * 
     * The user value of a key is the last value that was set by the user.
     * 
     * After calling g_settings_reset() this function should always return
     * %NULL (assuming something is not wrong with the system
     * configuration).
     * 
     * It is possible that g_settings_get_value() will return a different
     * value than this function.  This can happen in the case that the user
     * set a value for a key that was subsequently locked down by the system
     * administrator -- this function will return the user's old value.
     * 
     * This function may be useful for adding a "reset" option to a UI or
     * for providing indication that a particular value has been changed.
     * 
     * It is a programmer error to give a `key` that isn't contained in the
     * schema for `settings`.
     * @param key the key to get the user value for
     * @returns the user's value, if set
     */
    get_user_value(key: string | null): GLib.Variant | null
    /**
     * Gets the value that is stored in `settings` for `key`.
     * 
     * It is a programmer error to give a `key` that isn't contained in the
     * schema for `settings`.
     * @param key the key to get the value for
     * @returns a new #GVariant
     */
    get_value(key: string | null): GLib.Variant
    /**
     * Finds out if a key can be written or not
     * @param name the name of a key
     * @returns %TRUE if the key @name is writable
     */
    is_writable(name: string | null): boolean
    /**
     * Gets the list of children on `settings`.
     * 
     * The list is exactly the list of strings for which it is not an error
     * to call g_settings_get_child().
     * 
     * There is little reason to call this function from "normal" code, since
     * you should already know what children are in your schema. This function
     * may still be useful there for introspection reasons, however.
     * 
     * You should free the return value with g_strfreev() when you are done
     * with it.
     * @returns a list of the children    on @settings, in no defined order
     */
    list_children(): string[]
    /**
     * Introspects the list of keys on `settings`.
     * 
     * You should probably not be calling this function from "normal" code
     * (since you should already know what keys are in your schema).  This
     * function is intended for introspection reasons.
     * 
     * You should free the return value with g_strfreev() when you are done
     * with it.
     * @returns a list    of the keys on @settings, in no defined order
     */
    list_keys(): string[]
    /**
     * Checks if the given `value` is of the correct type and within the
     * permitted range for `key`.
     * @param key the key to check
     * @param value the value to check
     * @returns %TRUE if @value is valid for @key
     */
    range_check(key: string | null, value: GLib.Variant): boolean
    /**
     * Resets `key` to its default value.
     * 
     * This call resets the key, as much as possible, to its default value.
     * That might be the value specified in the schema or the one set by the
     * administrator.
     * @param key the name of a key
     */
    reset(key: string | null): void
    /**
     * Reverts all non-applied changes to the settings.  This function
     * does nothing unless `settings` is in 'delay-apply' mode; see
     * g_settings_delay().  In the normal case settings are always applied
     * immediately.
     * 
     * Change notifications will be emitted for affected keys.
     */
    revert(): void
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * A convenience variant of g_settings_set() for booleans.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a boolean type in the schema for `settings`.
     * @param key the name of the key to set
     * @param value the value to set it to
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_boolean(key: string | null, value: boolean): boolean
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * A convenience variant of g_settings_set() for doubles.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a 'double' type in the schema for `settings`.
     * @param key the name of the key to set
     * @param value the value to set it to
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_double(key: string | null, value: number): boolean
    /**
     * Looks up the enumerated type nick for `value` and writes it to `key,`
     * within `settings`.
     * 
     * It is a programmer error to give a `key` that isn't contained in the
     * schema for `settings` or is not marked as an enumerated type, or for
     * `value` not to be a valid value for the named type.
     * 
     * After performing the write, accessing `key` directly with
     * g_settings_get_string() will return the 'nick' associated with
     * `value`.
     * @param key a key, within `settings`
     * @param value an enumerated value
     * @returns %TRUE, if the set succeeds
     */
    set_enum(key: string | null, value: number): boolean
    /**
     * Looks up the flags type nicks for the bits specified by `value,` puts
     * them in an array of strings and writes the array to `key,` within
     * `settings`.
     * 
     * It is a programmer error to give a `key` that isn't contained in the
     * schema for `settings` or is not marked as a flags type, or for `value`
     * to contain any bits that are not value for the named type.
     * 
     * After performing the write, accessing `key` directly with
     * g_settings_get_strv() will return an array of 'nicks'; one for each
     * bit in `value`.
     * @param key a key, within `settings`
     * @param value a flags value
     * @returns %TRUE, if the set succeeds
     */
    set_flags(key: string | null, value: number): boolean
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * A convenience variant of g_settings_set() for 32-bit integers.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a int32 type in the schema for `settings`.
     * @param key the name of the key to set
     * @param value the value to set it to
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_int(key: string | null, value: number): boolean
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * A convenience variant of g_settings_set() for 64-bit integers.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a int64 type in the schema for `settings`.
     * @param key the name of the key to set
     * @param value the value to set it to
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_int64(key: string | null, value: number): boolean
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * A convenience variant of g_settings_set() for strings.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a string type in the schema for `settings`.
     * @param key the name of the key to set
     * @param value the value to set it to
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_string(key: string | null, value: string | null): boolean
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * A convenience variant of g_settings_set() for string arrays.  If
     * `value` is %NULL, then `key` is set to be the empty array.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having an array of strings type in the schema for `settings`.
     * @param key the name of the key to set
     * @param value the value to set it to, or %NULL
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_strv(key: string | null, value: string[] | null): boolean
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * A convenience variant of g_settings_set() for 32-bit unsigned
     * integers.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a uint32 type in the schema for `settings`.
     * @param key the name of the key to set
     * @param value the value to set it to
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_uint(key: string | null, value: number): boolean
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * A convenience variant of g_settings_set() for 64-bit unsigned
     * integers.
     * 
     * It is a programmer error to give a `key` that isn't specified as
     * having a uint64 type in the schema for `settings`.
     * @param key the name of the key to set
     * @param value the value to set it to
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_uint64(key: string | null, value: number): boolean
    /**
     * Sets `key` in `settings` to `value`.
     * 
     * It is a programmer error to give a `key` that isn't contained in the
     * schema for `settings` or for `value` to have the incorrect type, per
     * the schema.
     * 
     * If `value` is floating then this function consumes the reference.
     * @param key the name of the key to set
     * @param value a #GVariant of the correct type
     * @returns %TRUE if setting the key succeeded,     %FALSE if the key was not writable
     */
    set_value(key: string | null, value: GLib.Variant): boolean

    // Own virtual methods of Gio-2.0.Gio.Settings

    vfunc_change_event(keys: GLib.Quark, n_keys: number): boolean
    vfunc_changed(key: string | null): void
    vfunc_writable_change_event(key: GLib.Quark): boolean
    vfunc_writable_changed(key: string | null): void

    // Own signals of Gio-2.0.Gio.Settings

    connect(sigName: "change-event", callback: Settings.ChangeEventSignalCallback): number
    connect_after(sigName: "change-event", callback: Settings.ChangeEventSignalCallback): number
    emit(sigName: "change-event", keys: GLib.Quark[] | null, ...args: any[]): void
    connect(sigName: "changed", callback: Settings.ChangedSignalCallback): number
    connect_after(sigName: "changed", callback: Settings.ChangedSignalCallback): number
    emit(sigName: "changed", key: string | null, ...args: any[]): void
    connect(sigName: "writable-change-event", callback: Settings.WritableChangeEventSignalCallback): number
    connect_after(sigName: "writable-change-event", callback: Settings.WritableChangeEventSignalCallback): number
    emit(sigName: "writable-change-event", key: number, ...args: any[]): void
    connect(sigName: "writable-changed", callback: Settings.WritableChangedSignalCallback): number
    connect_after(sigName: "writable-changed", callback: Settings.WritableChangedSignalCallback): number
    emit(sigName: "writable-changed", key: string | null, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.Settings

    connect(sigName: "notify::backend", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::backend", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::backend", ...args: any[]): void
    connect(sigName: "notify::delay-apply", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delay-apply", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::delay-apply", ...args: any[]): void
    connect(sigName: "notify::has-unapplied", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-unapplied", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::has-unapplied", ...args: any[]): void
    connect(sigName: "notify::path", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::path", ...args: any[]): void
    connect(sigName: "notify::schema", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::schema", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::schema", ...args: any[]): void
    connect(sigName: "notify::schema-id", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::schema-id", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::schema-id", ...args: any[]): void
    connect(sigName: "notify::settings-schema", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::settings-schema", callback: (($obj: Settings, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::settings-schema", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GSettings class provides a convenient API for storing and retrieving
 * application settings.
 * 
 * Reads and writes can be considered to be non-blocking.  Reading
 * settings with #GSettings is typically extremely fast: on
 * approximately the same order of magnitude (but slower than) a
 * #GHashTable lookup.  Writing settings is also extremely fast in terms
 * of time to return to your application, but can be extremely expensive
 * for other threads and other processes.  Many settings backends
 * (including dconf) have lazy initialisation which means in the common
 * case of the user using their computer without modifying any settings
 * a lot of work can be avoided.  For dconf, the D-Bus service doesn't
 * even need to be started in this case.  For this reason, you should
 * only ever modify #GSettings keys in response to explicit user action.
 * Particular care should be paid to ensure that modifications are not
 * made during startup -- for example, when setting the initial value
 * of preferences widgets.  The built-in g_settings_bind() functionality
 * is careful not to write settings in response to notify signals as a
 * result of modifications that it makes to widgets.
 * 
 * When creating a GSettings instance, you have to specify a schema
 * that describes the keys in your settings and their types and default
 * values, as well as some other information.
 * 
 * Normally, a schema has a fixed path that determines where the settings
 * are stored in the conceptual global tree of settings. However, schemas
 * can also be '[relocatable][gsettings-relocatable]', i.e. not equipped with
 * a fixed path. This is
 * useful e.g. when the schema describes an 'account', and you want to be
 * able to store a arbitrary number of accounts.
 * 
 * Paths must start with and end with a forward slash character ('/')
 * and must not contain two sequential slash characters.  Paths should
 * be chosen based on a domain name associated with the program or
 * library to which the settings belong.  Examples of paths are
 * "/org/gtk/settings/file-chooser/" and "/ca/desrt/dconf-editor/".
 * Paths should not start with "/apps/", "/desktop/" or "/system/" as
 * they often did in GConf.
 * 
 * Unlike other configuration systems (like GConf), GSettings does not
 * restrict keys to basic types like strings and numbers. GSettings stores
 * values as #GVariant, and allows any #GVariantType for keys. Key names
 * are restricted to lowercase characters, numbers and '-'. Furthermore,
 * the names must begin with a lowercase character, must not end
 * with a '-', and must not contain consecutive dashes.
 * 
 * Similar to GConf, the default values in GSettings schemas can be
 * localized, but the localized values are stored in gettext catalogs
 * and looked up with the domain that is specified in the
 * `gettext-domain` attribute of the <schemalist> or <schema>
 * elements and the category that is specified in the `l10n` attribute of
 * the <default> element. The string which is translated includes all text in
 * the <default> element, including any surrounding quotation marks.
 * 
 * The `l10n` attribute must be set to `messages` or `time`, and sets the
 * [locale category for
 * translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
 * The `messages` category should be used by default; use `time` for
 * translatable date or time formats. A translation comment can be added as an
 * XML comment immediately above the <default> element — it is recommended to
 * add these comments to aid translators understand the meaning and
 * implications of the default value. An optional translation `context`
 * attribute can be set on the <default> element to disambiguate multiple
 * defaults which use the same string.
 * 
 * For example:
 * 
 * ```
 *  <!-- Translators: A list of words which are not allowed to be typed, in
 *       GVariant serialization syntax.
 *       See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
 *  <default l10n='messages' context='Banned words'>['bad', 'words']</default>
 * ```
 * 
 * 
 * Translations of default values must remain syntactically valid serialized
 * #GVariants (e.g. retaining any surrounding quotation marks) or runtime
 * errors will occur.
 * 
 * GSettings uses schemas in a compact binary form that is created
 * by the [glib-compile-schemas][glib-compile-schemas]
 * utility. The input is a schema description in an XML format.
 * 
 * A DTD for the gschema XML format can be found here:
 * [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
 * 
 * The [glib-compile-schemas][glib-compile-schemas] tool expects schema
 * files to have the extension `.gschema.xml`.
 * 
 * At runtime, schemas are identified by their id (as specified in the
 * id attribute of the <schema> element). The convention for schema
 * ids is to use a dotted name, similar in style to a D-Bus bus name,
 * e.g. "org.gnome.SessionManager". In particular, if the settings are
 * for a specific service that owns a D-Bus bus name, the D-Bus bus name
 * and schema id should match. For schemas which deal with settings not
 * associated with one named application, the id should not use
 * StudlyCaps, e.g. "org.gnome.font-rendering".
 * 
 * In addition to #GVariant types, keys can have types that have
 * enumerated types. These can be described by a <choice>,
 * <enum> or <flags> element, as seen in the
 * [example][schema-enumerated]. The underlying type of such a key
 * is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
 * g_settings_get_flags(), g_settings_set_flags() access the numeric values
 * corresponding to the string value of enum and flags keys.
 * 
 * An example for default value:
 * 
 * ```
 * <schemalist>
 *   <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
 * 
 *     <key name="greeting" type="s">
 *       <default l10n="messages">"Hello, earthlings"</default>
 *       <summary>A greeting</summary>
 *       <description>
 *         Greeting of the invading martians
 *       </description>
 *     </key>
 * 
 *     <key name="box" type="(ii)">
 *       <default>(20,30)</default>
 *     </key>
 * 
 *     <key name="empty-string" type="s">
 *       <default>""</default>
 *       <summary>Empty strings have to be provided in GVariant form</summary>
 *     </key>
 * 
 *   </schema>
 * </schemalist>
 * ```
 * 
 * 
 * An example for ranges, choices and enumerated types:
 * 
 * ```
 * <schemalist>
 * 
 *   <enum id="org.gtk.Test.myenum">
 *     <value nick="first" value="1"/>
 *     <value nick="second" value="2"/>
 *   </enum>
 * 
 *   <flags id="org.gtk.Test.myflags">
 *     <value nick="flag1" value="1"/>
 *     <value nick="flag2" value="2"/>
 *     <value nick="flag3" value="4"/>
 *   </flags>
 * 
 *   <schema id="org.gtk.Test">
 * 
 *     <key name="key-with-range" type="i">
 *       <range min="1" max="100"/>
 *       <default>10</default>
 *     </key>
 * 
 *     <key name="key-with-choices" type="s">
 *       <choices>
 *         <choice value='Elisabeth'/>
 *         <choice value='Annabeth'/>
 *         <choice value='Joe'/>
 *       </choices>
 *       <aliases>
 *         <alias value='Anna' target='Annabeth'/>
 *         <alias value='Beth' target='Elisabeth'/>
 *       </aliases>
 *       <default>'Joe'</default>
 *     </key>
 * 
 *     <key name='enumerated-key' enum='org.gtk.Test.myenum'>
 *       <default>'first'</default>
 *     </key>
 * 
 *     <key name='flags-key' flags='org.gtk.Test.myflags'>
 *       <default>["flag1","flag2"]</default>
 *     </key>
 *   </schema>
 * </schemalist>
 * ```
 * 
 * 
 * ## Vendor overrides
 * 
 * Default values are defined in the schemas that get installed by
 * an application. Sometimes, it is necessary for a vendor or distributor
 * to adjust these defaults. Since patching the XML source for the schema
 * is inconvenient and error-prone,
 * [glib-compile-schemas][glib-compile-schemas] reads so-called vendor
 * override' files. These are keyfiles in the same directory as the XML
 * schema sources which can override default values. The schema id serves
 * as the group name in the key file, and the values are expected in
 * serialized GVariant form, as in the following example:
 * 
 * ```
 *     [org.gtk.Example]
 *     key1='string'
 *     key2=1.5
 * ```
 * 
 * 
 * glib-compile-schemas expects schema files to have the extension
 * `.gschema.override`.
 * 
 * ## Binding
 * 
 * A very convenient feature of GSettings lets you bind #GObject properties
 * directly to settings, using g_settings_bind(). Once a GObject property
 * has been bound to a setting, changes on either side are automatically
 * propagated to the other side. GSettings handles details like mapping
 * between GObject and GVariant types, and preventing infinite cycles.
 * 
 * This makes it very easy to hook up a preferences dialog to the
 * underlying settings. To make this even more convenient, GSettings
 * looks for a boolean property with the name "sensitivity" and
 * automatically binds it to the writability of the bound setting.
 * If this 'magic' gets in the way, it can be suppressed with the
 * %G_SETTINGS_BIND_NO_SENSITIVITY flag.
 * 
 * ## Relocatable schemas # {#gsettings-relocatable}
 * 
 * A relocatable schema is one with no `path` attribute specified on its
 * <schema> element. By using g_settings_new_with_path(), a #GSettings object
 * can be instantiated for a relocatable schema, assigning a path to the
 * instance. Paths passed to g_settings_new_with_path() will typically be
 * constructed dynamically from a constant prefix plus some form of instance
 * identifier; but they must still be valid GSettings paths. Paths could also
 * be constant and used with a globally installed schema originating from a
 * dependency library.
 * 
 * For example, a relocatable schema could be used to store geometry information
 * for different windows in an application. If the schema ID was
 * `org.foo.MyApp.Window`, it could be instantiated for paths
 * `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
 * `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
 * they can be specified as <child> elements in the parent schema, e.g.:
 * 
 * ```
 * <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
 *   <child name="main" schema="org.foo.MyApp.Window"/>
 * </schema>
 * ```
 * 
 * 
 * ## Build system integration # {#gsettings-build-system}
 * 
 * GSettings comes with autotools integration to simplify compiling and
 * installing schemas. To add GSettings support to an application, add the
 * following to your `configure.ac`:
 * 
 * ```
 * GLIB_GSETTINGS
 * ```
 * 
 * 
 * In the appropriate `Makefile.am`, use the following snippet to compile and
 * install the named schema:
 * 
 * ```
 * gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
 * EXTRA_DIST = $(gsettings_SCHEMAS)
 * 
 * `GSETTINGS_RULES@`
 * ```
 * 
 * 
 * No changes are needed to the build system to mark a schema XML file for
 * translation. Assuming it sets the `gettext-domain` attribute, a schema may
 * be marked for translation by adding it to `POTFILES.in`, assuming gettext
 * 0.19 is in use (the preferred method for translation):
 * 
 * ```
 * data/org.foo.MyApp.gschema.xml
 * ```
 * 
 * 
 * Alternatively, if intltool 0.50.1 is in use:
 * 
 * ```
 * [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
 * ```
 * 
 * 
 * GSettings will use gettext to look up translations for the <summary> and
 * <description> elements, and also any <default> elements which have a `l10n`
 * attribute set. Translations must not be included in the `.gschema.xml` file
 * by the build system, for example by using intltool XML rules with a
 * `.gschema.xml.in` template.
 * 
 * If an enumerated type defined in a C header file is to be used in a GSettings
 * schema, it can either be defined manually using an <enum> element in the
 * schema XML, or it can be extracted automatically from the C header. This
 * approach is preferred, as it ensures the two representations are always
 * synchronised. To do so, add the following to the relevant `Makefile.am`:
 * 
 * ```
 * gsettings_ENUM_NAMESPACE = org.foo.MyApp
 * gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
 * ```
 * 
 * 
 * `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
 * which are specified in `gsettings_ENUM_FILES`. This will generate a
 * `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
 * automatically included in the schema compilation, install and uninstall
 * rules. It should not be committed to version control or included in
 * `EXTRA_DIST`.
 * @class 
 */
class Settings extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Settings

    static name: string
    static $gtype: GObject.GType<Settings>

    // Constructors of Gio-2.0.Gio.Settings

    constructor(config?: Settings.ConstructorProperties) 
    /**
     * Creates a new #GSettings object with the schema specified by
     * `schema_id`.
     * 
     * It is an error for the schema to not exist: schemas are an
     * essential part of a program, as they provide type information.
     * If schemas need to be dynamically loaded (for example, from an
     * optional runtime dependency), g_settings_schema_source_lookup()
     * can be used to test for their existence before loading them.
     * 
     * Signals on the newly created #GSettings object will be dispatched
     * via the thread-default #GMainContext in effect at the time of the
     * call to g_settings_new().  The new #GSettings will hold a reference
     * on the context.  See g_main_context_push_thread_default().
     * @constructor 
     * @param schema_id the id of the schema
     * @returns a new #GSettings object
     */
    constructor(schema_id: string | null) 
    /**
     * Creates a new #GSettings object with the schema specified by
     * `schema_id`.
     * 
     * It is an error for the schema to not exist: schemas are an
     * essential part of a program, as they provide type information.
     * If schemas need to be dynamically loaded (for example, from an
     * optional runtime dependency), g_settings_schema_source_lookup()
     * can be used to test for their existence before loading them.
     * 
     * Signals on the newly created #GSettings object will be dispatched
     * via the thread-default #GMainContext in effect at the time of the
     * call to g_settings_new().  The new #GSettings will hold a reference
     * on the context.  See g_main_context_push_thread_default().
     * @constructor 
     * @param schema_id the id of the schema
     * @returns a new #GSettings object
     */
    static new(schema_id: string | null): Settings
    /**
     * Creates a new #GSettings object with a given schema, backend and
     * path.
     * 
     * It should be extremely rare that you ever want to use this function.
     * It is made available for advanced use-cases (such as plugin systems
     * that want to provide access to schemas loaded from custom locations,
     * etc).
     * 
     * At the most basic level, a #GSettings object is a pure composition of
     * 4 things: a #GSettingsSchema, a #GSettingsBackend, a path within that
     * backend, and a #GMainContext to which signals are dispatched.
     * 
     * This constructor therefore gives you full control over constructing
     * #GSettings instances.  The first 3 parameters are given directly as
     * `schema,` `backend` and `path,` and the main context is taken from the
     * thread-default (as per g_settings_new()).
     * 
     * If `backend` is %NULL then the default backend is used.
     * 
     * If `path` is %NULL then the path from the schema is used.  It is an
     * error if `path` is %NULL and the schema has no path of its own or if
     * `path` is non-%NULL and not equal to the path that the schema does
     * have.
     * @constructor 
     * @param schema a #GSettingsSchema
     * @param backend a #GSettingsBackend
     * @param path the path to use
     * @returns a new #GSettings object
     */
    static new_full(schema: SettingsSchema, backend: SettingsBackend | null, path: string | null): Settings
    /**
     * Creates a new #GSettings object with the schema specified by
     * `schema_id` and a given #GSettingsBackend.
     * 
     * Creating a #GSettings object with a different backend allows accessing
     * settings from a database other than the usual one. For example, it may make
     * sense to pass a backend corresponding to the "defaults" settings database on
     * the system to get a settings object that modifies the system default
     * settings instead of the settings for this user.
     * @constructor 
     * @param schema_id the id of the schema
     * @param backend the #GSettingsBackend to use
     * @returns a new #GSettings object
     */
    static new_with_backend(schema_id: string | null, backend: SettingsBackend): Settings
    /**
     * Creates a new #GSettings object with the schema specified by
     * `schema_id` and a given #GSettingsBackend and path.
     * 
     * This is a mix of g_settings_new_with_backend() and
     * g_settings_new_with_path().
     * @constructor 
     * @param schema_id the id of the schema
     * @param backend the #GSettingsBackend to use
     * @param path the path to use
     * @returns a new #GSettings object
     */
    static new_with_backend_and_path(schema_id: string | null, backend: SettingsBackend, path: string | null): Settings
    /**
     * Creates a new #GSettings object with the relocatable schema specified
     * by `schema_id` and a given path.
     * 
     * You only need to do this if you want to directly create a settings
     * object with a schema that doesn't have a specified path of its own.
     * That's quite rare.
     * 
     * It is a programmer error to call this function for a schema that
     * has an explicitly specified path.
     * 
     * It is a programmer error if `path` is not a valid path.  A valid path
     * begins and ends with '/' and does not contain two consecutive '/'
     * characters.
     * @constructor 
     * @param schema_id the id of the schema
     * @param path the path to use
     * @returns a new #GSettings object
     */
    static new_with_path(schema_id: string | null, path: string | null): Settings
    _init(config?: Settings.ConstructorProperties): void
    /**
     * Deprecated.
     * @returns a list of   relocatable #GSettings schemas that are available, in no defined order.   The list must not be modified or freed.
     */
    static list_relocatable_schemas(): string[]
    /**
     * Deprecated.
     * @returns a list of   #GSettings schemas that are available, in no defined order.  The list   must not be modified or freed.
     */
    static list_schemas(): string[]
    /**
     * Ensures that all pending operations are complete for the default backend.
     * 
     * Writes made to a #GSettings are handled asynchronously.  For this
     * reason, it is very unlikely that the changes have it to disk by the
     * time g_settings_set() returns.
     * 
     * This call will block until all of the writes have made it to the
     * backend.  Since the mainloop is not running, no change notifications
     * will be dispatched during this call (but some may be queued by the
     * time the call is done).
     */
    static sync(): void
    /**
     * Removes an existing binding for `property` on `object`.
     * 
     * Note that bindings are automatically removed when the
     * object is finalized, so it is rarely necessary to call this
     * function.
     * @param object the object
     * @param property the property whose binding is removed
     */
    static unbind(object: GObject.Object, property: string | null): void
}

module SettingsBackend {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface SettingsBackend {

    // Own fields of Gio-2.0.Gio.SettingsBackend

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.SettingsBackend

    /**
     * Signals that a single key has possibly changed.  Backend
     * implementations should call this if a key has possibly changed its
     * value.
     * 
     * `key` must be a valid key (ie starting with a slash, not containing
     * '//', and not ending with a slash).
     * 
     * The implementation must call this function during any call to
     * g_settings_backend_write(), before the call returns (except in the
     * case that no keys are actually changed and it cares to detect this
     * fact).  It may not rely on the existence of a mainloop for
     * dispatching the signal later.
     * 
     * The implementation may call this function at any other time it likes
     * in response to other events (such as changes occurring outside of the
     * program).  These calls may originate from a mainloop or may originate
     * in response to any other action (including from calls to
     * g_settings_backend_write()).
     * 
     * In the case that this call is in response to a call to
     * g_settings_backend_write() then `origin_tag` must be set to the same
     * value that was passed to that call.
     * @param key the name of the key
     * @param origin_tag the origin tag
     */
    changed(key: string | null, origin_tag: any | null): void
    /**
     * This call is a convenience wrapper.  It gets the list of changes from
     * `tree,` computes the longest common prefix and calls
     * g_settings_backend_changed().
     * @param tree a #GTree containing the changes
     * @param origin_tag the origin tag
     */
    changed_tree(tree: GLib.Tree, origin_tag: any | null): void
    /**
     * Signals that a list of keys have possibly changed.  Backend
     * implementations should call this if keys have possibly changed their
     * values.
     * 
     * `path` must be a valid path (ie starting and ending with a slash and
     * not containing '//').  Each string in `items` must form a valid key
     * name when `path` is prefixed to it (ie: each item must not start or
     * end with '/' and must not contain '//').
     * 
     * The meaning of this signal is that any of the key names resulting
     * from the contatenation of `path` with each item in `items` may have
     * changed.
     * 
     * The same rules for when notifications must occur apply as per
     * g_settings_backend_changed().  These two calls can be used
     * interchangeably if exactly one item has changed (although in that
     * case g_settings_backend_changed() is definitely preferred).
     * 
     * For efficiency reasons, the implementation should strive for `path` to
     * be as long as possible (ie: the longest common prefix of all of the
     * keys that were changed) but this is not strictly required.
     * @param path the path containing the changes
     * @param items the %NULL-terminated list of changed keys
     * @param origin_tag the origin tag
     */
    keys_changed(path: string | null, items: string[], origin_tag: any | null): void
    /**
     * Signals that all keys below a given path may have possibly changed.
     * Backend implementations should call this if an entire path of keys
     * have possibly changed their values.
     * 
     * `path` must be a valid path (ie starting and ending with a slash and
     * not containing '//').
     * 
     * The meaning of this signal is that any of the key which has a name
     * starting with `path` may have changed.
     * 
     * The same rules for when notifications must occur apply as per
     * g_settings_backend_changed().  This call might be an appropriate
     * reasponse to a 'reset' call but implementations are also free to
     * explicitly list the keys that were affected by that call if they can
     * easily do so.
     * 
     * For efficiency reasons, the implementation should strive for `path` to
     * be as long as possible (ie: the longest common prefix of all of the
     * keys that were changed) but this is not strictly required.  As an
     * example, if this function is called with the path of "/" then every
     * single key in the application will be notified of a possible change.
     * @param path the path containing the changes
     * @param origin_tag the origin tag
     */
    path_changed(path: string | null, origin_tag: any | null): void
    /**
     * Signals that the writability of all keys below a given path may have
     * changed.
     * 
     * Since GSettings performs no locking operations for itself, this call
     * will always be made in response to external events.
     * @param path the name of the path
     */
    path_writable_changed(path: string | null): void
    /**
     * Signals that the writability of a single key has possibly changed.
     * 
     * Since GSettings performs no locking operations for itself, this call
     * will always be made in response to external events.
     * @param key the name of the key
     */
    writable_changed(key: string | null): void

    // Own virtual methods of Gio-2.0.Gio.SettingsBackend

    vfunc_get_writable(key: string | null): boolean
    vfunc_read(key: string | null, expected_type: GLib.VariantType, default_value: boolean): GLib.Variant
    vfunc_read_user_value(key: string | null, expected_type: GLib.VariantType): GLib.Variant
    vfunc_reset(key: string | null, origin_tag: any | null): void
    vfunc_subscribe(name: string | null): void
    vfunc_sync(): void
    vfunc_unsubscribe(name: string | null): void
    vfunc_write(key: string | null, value: GLib.Variant, origin_tag: any | null): boolean
    vfunc_write_tree(tree: GLib.Tree, origin_tag: any | null): boolean

    // Class property signals of Gio-2.0.Gio.SettingsBackend

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #GSettingsBackend interface defines a generic interface for
 * non-strictly-typed data that is stored in a hierarchy. To implement
 * an alternative storage backend for #GSettings, you need to implement
 * the #GSettingsBackend interface and then make it implement the
 * extension point %G_SETTINGS_BACKEND_EXTENSION_POINT_NAME.
 * 
 * The interface defines methods for reading and writing values, a
 * method for determining if writing of certain values will fail
 * (lockdown) and a change notification mechanism.
 * 
 * The semantics of the interface are very precisely defined and
 * implementations must carefully adhere to the expectations of
 * callers that are documented on each of the interface methods.
 * 
 * Some of the #GSettingsBackend functions accept or return a #GTree.
 * These trees always have strings as keys and #GVariant as values.
 * g_settings_backend_create_tree() is a convenience function to create
 * suitable trees.
 * 
 * The #GSettingsBackend API is exported to allow third-party
 * implementations, but does not carry the same stability guarantees
 * as the public GIO API. For this reason, you have to define the
 * C preprocessor symbol %G_SETTINGS_ENABLE_BACKEND before including
 * `gio/gsettingsbackend.h`.
 * @class 
 */
class SettingsBackend extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SettingsBackend

    static name: string
    static $gtype: GObject.GType<SettingsBackend>

    // Constructors of Gio-2.0.Gio.SettingsBackend

    constructor(config?: SettingsBackend.ConstructorProperties) 
    _init(config?: SettingsBackend.ConstructorProperties): void
    /**
     * Calculate the longest common prefix of all keys in a tree and write
     * out an array of the key names relative to that prefix and,
     * optionally, the value to store at each of those keys.
     * 
     * You must free the value returned in `path,` `keys` and `values` using
     * g_free().  You should not attempt to free or unref the contents of
     * `keys` or `values`.
     * @param tree a #GTree containing the changes
     */
    static flatten_tree(tree: GLib.Tree): [ /* path */ string | null, /* keys */ string[], /* values */ GLib.Variant[] ]
    /**
     * Returns the default #GSettingsBackend. It is possible to override
     * the default by setting the `GSETTINGS_BACKEND` environment variable
     * to the name of a settings backend.
     * 
     * The user gets a reference to the backend.
     * @returns the default #GSettingsBackend,     which will be a dummy (memory) settings backend if no other settings     backend is available.
     */
    static get_default(): SettingsBackend
}

module SimpleAction {

    // Signal callback interfaces

    /**
     * Signal callback interface for `activate`
     */
    interface ActivateSignalCallback {
        ($obj: SimpleAction, parameter: GLib.Variant | null): void
    }

    /**
     * Signal callback interface for `change-state`
     */
    interface ChangeStateSignalCallback {
        ($obj: SimpleAction, value: GLib.Variant | null): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends Action.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.SimpleAction

        /**
         * If `action` is currently enabled.
         * 
         * If the action is disabled then calls to g_action_activate() and
         * g_action_change_state() have no effect.
         */
        enabled?: boolean | null
        /**
         * The name of the action. This is mostly meaningful for identifying
         * the action once it has been added to a #GSimpleActionGroup.
         */
        name?: string | null
        /**
         * The type of the parameter that must be given when activating the
         * action.
         */
        parameter_type?: GLib.VariantType | null
        /**
         * The state of the action, or %NULL if the action is stateless.
         */
        state?: GLib.Variant | null
    }

}

interface SimpleAction extends Action {

    // Own properties of Gio-2.0.Gio.SimpleAction

    /**
     * If `action` is currently enabled.
     * 
     * If the action is disabled then calls to g_action_activate() and
     * g_action_change_state() have no effect.
     */
    enabled: any
    /**
     * The name of the action. This is mostly meaningful for identifying
     * the action once it has been added to a #GSimpleActionGroup.
     */
    readonly name: string | null
    /**
     * The type of the parameter that must be given when activating the
     * action.
     */
    readonly parameter_type: GLib.VariantType
    /**
     * The state of the action, or %NULL if the action is stateless.
     */
    state: any
    /**
     * The #GVariantType of the state that the action has, or %NULL if the
     * action is stateless.
     */
    readonly state_type: GLib.VariantType

    // Owm methods of Gio-2.0.Gio.SimpleAction

    /**
     * Sets the action as enabled or not.
     * 
     * An action must be enabled in order to be activated or in order to
     * have its state changed from outside callers.
     * 
     * This should only be called by the implementor of the action.  Users
     * of the action should not attempt to modify its enabled flag.
     * @param enabled whether the action is enabled
     */
    set_enabled(enabled: boolean): void
    /**
     * Sets the state of the action.
     * 
     * This directly updates the 'state' property to the given value.
     * 
     * This should only be called by the implementor of the action.  Users
     * of the action should not attempt to directly modify the 'state'
     * property.  Instead, they should call g_action_change_state() to
     * request the change.
     * 
     * If the `value` GVariant is floating, it is consumed.
     * @param value the new #GVariant for the state
     */
    set_state(value: GLib.Variant): void
    /**
     * Sets the state hint for the action.
     * 
     * See g_action_get_state_hint() for more information about
     * action state hints.
     * @param state_hint a #GVariant representing the state hint
     */
    set_state_hint(state_hint: GLib.Variant | null): void

    // Own signals of Gio-2.0.Gio.SimpleAction

    connect(sigName: "activate", callback: SimpleAction.ActivateSignalCallback): number
    connect_after(sigName: "activate", callback: SimpleAction.ActivateSignalCallback): number
    emit(sigName: "activate", parameter: GLib.Variant | null, ...args: any[]): void
    connect(sigName: "change-state", callback: SimpleAction.ChangeStateSignalCallback): number
    connect_after(sigName: "change-state", callback: SimpleAction.ChangeStateSignalCallback): number
    emit(sigName: "change-state", value: GLib.Variant | null, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.SimpleAction

    connect(sigName: "notify::enabled", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::enabled", ...args: any[]): void
    connect(sigName: "notify::name", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::name", ...args: any[]): void
    connect(sigName: "notify::parameter-type", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameter-type", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parameter-type", ...args: any[]): void
    connect(sigName: "notify::state", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-type", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-type", callback: (($obj: SimpleAction, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::state-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GSimpleAction is the obvious simple implementation of the #GAction
 * interface. This is the easiest way to create an action for purposes of
 * adding it to a #GSimpleActionGroup.
 * 
 * See also #GtkAction.
 * @class 
 */
class SimpleAction extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SimpleAction

    static name: string
    static $gtype: GObject.GType<SimpleAction>

    // Constructors of Gio-2.0.Gio.SimpleAction

    constructor(config?: SimpleAction.ConstructorProperties) 
    /**
     * Creates a new action.
     * 
     * The created action is stateless. See g_simple_action_new_stateful() to create
     * an action that has state.
     * @constructor 
     * @param name the name of the action
     * @param parameter_type the type of parameter that will be passed to   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter
     * @returns a new #GSimpleAction
     */
    constructor(name: string | null, parameter_type: GLib.VariantType | null) 
    /**
     * Creates a new action.
     * 
     * The created action is stateless. See g_simple_action_new_stateful() to create
     * an action that has state.
     * @constructor 
     * @param name the name of the action
     * @param parameter_type the type of parameter that will be passed to   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter
     * @returns a new #GSimpleAction
     */
    static new(name: string | null, parameter_type: GLib.VariantType | null): SimpleAction
    /**
     * Creates a new stateful action.
     * 
     * All future state values must have the same #GVariantType as the initial
     * `state`.
     * 
     * If the `state` #GVariant is floating, it is consumed.
     * @constructor 
     * @param name the name of the action
     * @param parameter_type the type of the parameter that will be passed to   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter
     * @param state the initial state of the action
     * @returns a new #GSimpleAction
     */
    static new_stateful(name: string | null, parameter_type: GLib.VariantType | null, state: GLib.Variant): SimpleAction
    _init(config?: SimpleAction.ConstructorProperties): void
}

module SimpleActionGroup {

    // Constructor properties interface

    interface ConstructorProperties extends ActionGroup.ConstructorProperties, ActionMap.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface SimpleActionGroup extends ActionGroup, ActionMap {

    // Owm methods of Gio-2.0.Gio.SimpleActionGroup

    /**
     * A convenience function for creating multiple #GSimpleAction instances
     * and adding them to the action group.
     * @param entries a pointer to the first item in           an array of #GActionEntry structs
     * @param user_data the user data for signal connections
     */
    add_entries(entries: ActionEntry[], user_data: any | null): void
    /**
     * Adds an action to the action group.
     * 
     * If the action group already contains an action with the same name as
     * `action` then the old action is dropped from the group.
     * 
     * The action group takes its own reference on `action`.
     * @param action a #GAction
     */
    insert(action: Action): void
    /**
     * Looks up the action with the name `action_name` in the group.
     * 
     * If no such action exists, returns %NULL.
     * @param action_name the name of an action
     * @returns a #GAction, or %NULL
     */
    lookup(action_name: string | null): Action
    /**
     * Removes the named action from the action group.
     * 
     * If no action of this name is in the group then nothing happens.
     * @param action_name the name of the action
     */
    remove(action_name: string | null): void

    // Class property signals of Gio-2.0.Gio.SimpleActionGroup

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSimpleActionGroup is a hash table filled with #GAction objects,
 * implementing the #GActionGroup and #GActionMap interfaces.
 * @class 
 */
class SimpleActionGroup extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SimpleActionGroup

    static name: string
    static $gtype: GObject.GType<SimpleActionGroup>

    // Constructors of Gio-2.0.Gio.SimpleActionGroup

    constructor(config?: SimpleActionGroup.ConstructorProperties) 
    /**
     * Creates a new, empty, #GSimpleActionGroup.
     * @constructor 
     * @returns a new #GSimpleActionGroup
     */
    constructor() 
    /**
     * Creates a new, empty, #GSimpleActionGroup.
     * @constructor 
     * @returns a new #GSimpleActionGroup
     */
    static new(): SimpleActionGroup
    _init(config?: SimpleActionGroup.ConstructorProperties): void
}

module SimpleAsyncResult {

    // Constructor properties interface

    interface ConstructorProperties extends AsyncResult.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface SimpleAsyncResult extends AsyncResult {

    // Owm methods of Gio-2.0.Gio.SimpleAsyncResult

    /**
     * Completes an asynchronous I/O job immediately. Must be called in
     * the thread where the asynchronous result was to be delivered, as it
     * invokes the callback directly. If you are in a different thread use
     * g_simple_async_result_complete_in_idle().
     * 
     * Calling this function takes a reference to `simple` for as long as
     * is needed to complete the call.
     */
    complete(): void
    /**
     * Completes an asynchronous function in an idle handler in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread that `simple` was initially created in
     * (and re-pushes that context around the invocation of the callback).
     * 
     * Calling this function takes a reference to `simple` for as long as
     * is needed to complete the call.
     */
    complete_in_idle(): void
    /**
     * Gets the operation result boolean from within the asynchronous result.
     * @returns %TRUE if the operation's result was %TRUE, %FALSE     if the operation's result was %FALSE.
     */
    get_op_res_gboolean(): boolean
    /**
     * Gets a gssize from the asynchronous result.
     * @returns a gssize returned from the asynchronous function.
     */
    get_op_res_gssize(): number
    /**
     * Propagates an error from within the simple asynchronous result to
     * a given destination.
     * 
     * If the #GCancellable given to a prior call to
     * g_simple_async_result_set_check_cancellable() is cancelled then this
     * function will return %TRUE with `dest` set appropriately.
     * @returns %TRUE if the error was propagated to @dest. %FALSE otherwise.
     */
    propagate_error(): boolean
    /**
     * Sets a #GCancellable to check before dispatching results.
     * 
     * This function has one very specific purpose: the provided cancellable
     * is checked at the time of g_simple_async_result_propagate_error() If
     * it is cancelled, these functions will return an "Operation was
     * cancelled" error (%G_IO_ERROR_CANCELLED).
     * 
     * Implementors of cancellable asynchronous functions should use this in
     * order to provide a guarantee to their callers that cancelling an
     * async operation will reliably result in an error being returned for
     * that operation (even if a positive result for the operation has
     * already been sent as an idle to the main context to be dispatched).
     * 
     * The checking described above is done regardless of any call to the
     * unrelated g_simple_async_result_set_handle_cancellation() function.
     * @param check_cancellable a #GCancellable to check, or %NULL to unset
     */
    set_check_cancellable(check_cancellable: Cancellable | null): void
    /**
     * Sets the result from a #GError.
     * @param error #GError.
     */
    set_from_error(error: GLib.Error): void
    /**
     * Sets whether to handle cancellation within the asynchronous operation.
     * 
     * This function has nothing to do with
     * g_simple_async_result_set_check_cancellable().  It only refers to the
     * #GCancellable passed to g_simple_async_result_run_in_thread().
     * @param handle_cancellation a #gboolean.
     */
    set_handle_cancellation(handle_cancellation: boolean): void
    /**
     * Sets the operation result to a boolean within the asynchronous result.
     * @param op_res a #gboolean.
     */
    set_op_res_gboolean(op_res: boolean): void
    /**
     * Sets the operation result within the asynchronous result to
     * the given `op_res`.
     * @param op_res a #gssize.
     */
    set_op_res_gssize(op_res: number): void

    // Class property signals of Gio-2.0.Gio.SimpleAsyncResult

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * As of GLib 2.46, #GSimpleAsyncResult is deprecated in favor of
 * #GTask, which provides a simpler API.
 * 
 * #GSimpleAsyncResult implements #GAsyncResult.
 * 
 * GSimpleAsyncResult handles #GAsyncReadyCallbacks, error
 * reporting, operation cancellation and the final state of an operation,
 * completely transparent to the application. Results can be returned
 * as a pointer e.g. for functions that return data that is collected
 * asynchronously, a boolean value for checking the success or failure
 * of an operation, or a #gssize for operations which return the number
 * of bytes modified by the operation; all of the simple return cases
 * are covered.
 * 
 * Most of the time, an application will not need to know of the details
 * of this API; it is handled transparently, and any necessary operations
 * are handled by #GAsyncResult's interface. However, if implementing a
 * new GIO module, for writing language bindings, or for complex
 * applications that need better control of how asynchronous operations
 * are completed, it is important to understand this functionality.
 * 
 * GSimpleAsyncResults are tagged with the calling function to ensure
 * that asynchronous functions and their finishing functions are used
 * together correctly.
 * 
 * To create a new #GSimpleAsyncResult, call g_simple_async_result_new().
 * If the result needs to be created for a #GError, use
 * g_simple_async_result_new_from_error() or
 * g_simple_async_result_new_take_error(). If a #GError is not available
 * (e.g. the asynchronous operation's doesn't take a #GError argument),
 * but the result still needs to be created for an error condition, use
 * g_simple_async_result_new_error() (or g_simple_async_result_set_error_va()
 * if your application or binding requires passing a variable argument list
 * directly), and the error can then be propagated through the use of
 * g_simple_async_result_propagate_error().
 * 
 * An asynchronous operation can be made to ignore a cancellation event by
 * calling g_simple_async_result_set_handle_cancellation() with a
 * #GSimpleAsyncResult for the operation and %FALSE. This is useful for
 * operations that are dangerous to cancel, such as close (which would
 * cause a leak if cancelled before being run).
 * 
 * GSimpleAsyncResult can integrate into GLib's event loop, #GMainLoop,
 * or it can use #GThreads.
 * g_simple_async_result_complete() will finish an I/O task directly
 * from the point where it is called. g_simple_async_result_complete_in_idle()
 * will finish it from an idle handler in the
 * [thread-default main context][g-main-context-push-thread-default]
 * where the #GSimpleAsyncResult was created.
 * g_simple_async_result_run_in_thread() will run the job in a
 * separate thread and then use
 * g_simple_async_result_complete_in_idle() to deliver the result.
 * 
 * To set the results of an asynchronous function,
 * g_simple_async_result_set_op_res_gpointer(),
 * g_simple_async_result_set_op_res_gboolean(), and
 * g_simple_async_result_set_op_res_gssize()
 * are provided, setting the operation's result to a gpointer, gboolean, or
 * gssize, respectively.
 * 
 * Likewise, to get the result of an asynchronous function,
 * g_simple_async_result_get_op_res_gpointer(),
 * g_simple_async_result_get_op_res_gboolean(), and
 * g_simple_async_result_get_op_res_gssize() are
 * provided, getting the operation's result as a gpointer, gboolean, and
 * gssize, respectively.
 * 
 * For the details of the requirements implementations must respect, see
 * #GAsyncResult.  A typical implementation of an asynchronous operation
 * using GSimpleAsyncResult looks something like this:
 * 
 * 
 * ```c
 * static void
 * baked_cb (Cake    *cake,
 *           gpointer user_data)
 * {
 *   // In this example, this callback is not given a reference to the cake,
 *   // so the GSimpleAsyncResult has to take a reference to it.
 *   GSimpleAsyncResult *result = user_data;
 * 
 *   if (cake == NULL)
 *     g_simple_async_result_set_error (result,
 *                                      BAKER_ERRORS,
 *                                      BAKER_ERROR_NO_FLOUR,
 *                                      "Go to the supermarket");
 *   else
 *     g_simple_async_result_set_op_res_gpointer (result,
 *                                                g_object_ref (cake),
 *                                                g_object_unref);
 * 
 * 
 *   // In this example, we assume that baked_cb is called as a callback from
 *   // the mainloop, so it's safe to complete the operation synchronously here.
 *   // If, however, _baker_prepare_cake () might call its callback without
 *   // first returning to the mainloop — inadvisable, but some APIs do so —
 *   // we would need to use g_simple_async_result_complete_in_idle().
 *   g_simple_async_result_complete (result);
 *   g_object_unref (result);
 * }
 * 
 * void
 * baker_bake_cake_async (Baker              *self,
 *                        guint               radius,
 *                        GAsyncReadyCallback callback,
 *                        gpointer            user_data)
 * {
 *   GSimpleAsyncResult *simple;
 *   Cake               *cake;
 * 
 *   if (radius < 3)
 *     {
 *       g_simple_async_report_error_in_idle (G_OBJECT (self),
 *                                            callback,
 *                                            user_data,
 *                                            BAKER_ERRORS,
 *                                            BAKER_ERROR_TOO_SMALL,
 *                                            "%ucm radius cakes are silly",
 *                                            radius);
 *       return;
 *     }
 * 
 *   simple = g_simple_async_result_new (G_OBJECT (self),
 *                                       callback,
 *                                       user_data,
 *                                       baker_bake_cake_async);
 *   cake = _baker_get_cached_cake (self, radius);
 * 
 *   if (cake != NULL)
 *     {
 *       g_simple_async_result_set_op_res_gpointer (simple,
 *                                                  g_object_ref (cake),
 *                                                  g_object_unref);
 *       g_simple_async_result_complete_in_idle (simple);
 *       g_object_unref (simple);
 *       // Drop the reference returned by _baker_get_cached_cake();
 *       // the GSimpleAsyncResult has taken its own reference.
 *       g_object_unref (cake);
 *       return;
 *     }
 * 
 *   _baker_prepare_cake (self, radius, baked_cb, simple);
 * }
 * 
 * Cake *
 * baker_bake_cake_finish (Baker        *self,
 *                         GAsyncResult *result,
 *                         GError      **error)
 * {
 *   GSimpleAsyncResult *simple;
 *   Cake               *cake;
 * 
 *   g_return_val_if_fail (g_simple_async_result_is_valid (result,
 *                                                         G_OBJECT (self),
 *                                                         baker_bake_cake_async),
 *                         NULL);
 * 
 *   simple = (GSimpleAsyncResult *) result;
 * 
 *   if (g_simple_async_result_propagate_error (simple, error))
 *     return NULL;
 * 
 *   cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
 *   return g_object_ref (cake);
 * }
 * ```
 * 
 * @class 
 */
class SimpleAsyncResult extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SimpleAsyncResult

    static name: string
    static $gtype: GObject.GType<SimpleAsyncResult>

    // Constructors of Gio-2.0.Gio.SimpleAsyncResult

    constructor(config?: SimpleAsyncResult.ConstructorProperties) 
    /**
     * Creates a #GSimpleAsyncResult.
     * 
     * The common convention is to create the #GSimpleAsyncResult in the
     * function that starts the asynchronous operation and use that same
     * function as the `source_tag`.
     * 
     * If your operation supports cancellation with #GCancellable (which it
     * probably should) then you should provide the user's cancellable to
     * g_simple_async_result_set_check_cancellable() immediately after
     * this function returns.
     * @constructor 
     * @param source_object a #GObject, or %NULL.
     * @param callback a #GAsyncReadyCallback.
     * @param source_tag the asynchronous function.
     * @returns a #GSimpleAsyncResult.
     */
    constructor(source_object: GObject.Object | null, callback: AsyncReadyCallback<SimpleAsyncResult> | null, source_tag: any | null) 
    /**
     * Creates a #GSimpleAsyncResult.
     * 
     * The common convention is to create the #GSimpleAsyncResult in the
     * function that starts the asynchronous operation and use that same
     * function as the `source_tag`.
     * 
     * If your operation supports cancellation with #GCancellable (which it
     * probably should) then you should provide the user's cancellable to
     * g_simple_async_result_set_check_cancellable() immediately after
     * this function returns.
     * @constructor 
     * @param source_object a #GObject, or %NULL.
     * @param callback a #GAsyncReadyCallback.
     * @param source_tag the asynchronous function.
     * @returns a #GSimpleAsyncResult.
     */
    static new(source_object: GObject.Object | null, callback: AsyncReadyCallback<SimpleAsyncResult> | null, source_tag: any | null): SimpleAsyncResult
    /**
     * Creates a #GSimpleAsyncResult from an error condition.
     * @constructor 
     * @param source_object a #GObject, or %NULL.
     * @param callback a #GAsyncReadyCallback.
     * @param error a #GError
     * @returns a #GSimpleAsyncResult.
     */
    static new_from_error(source_object: GObject.Object | null, callback: AsyncReadyCallback<SimpleAsyncResult> | null, error: GLib.Error): SimpleAsyncResult
    _init(config?: SimpleAsyncResult.ConstructorProperties): void
    /**
     * Ensures that the data passed to the _finish function of an async
     * operation is consistent.  Three checks are performed.
     * 
     * First, `result` is checked to ensure that it is really a
     * #GSimpleAsyncResult.  Second, `source` is checked to ensure that it
     * matches the source object of `result`.  Third, `source_tag` is
     * checked to ensure that it is equal to the `source_tag` argument given
     * to g_simple_async_result_new() (which, by convention, is a pointer
     * to the _async function corresponding to the _finish function from
     * which this function is called).  (Alternatively, if either
     * `source_tag` or `result'`s source tag is %NULL, then the source tag
     * check is skipped.)
     * @param result the #GAsyncResult passed to the _finish function.
     * @param source the #GObject passed to the _finish function.
     * @param source_tag the asynchronous function.
     * @returns #TRUE if all checks passed or #FALSE if any failed.
     */
    static is_valid(result: AsyncResult, source: GObject.Object | null, source_tag: any | null): boolean
}

module SimpleIOStream {

    // Constructor properties interface

    interface ConstructorProperties extends IOStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.SimpleIOStream

        input_stream?: InputStream | null
        output_stream?: OutputStream | null
    }

}

interface SimpleIOStream {

    // Own properties of Gio-2.0.Gio.SimpleIOStream

    readonly input_stream: InputStream
    readonly output_stream: OutputStream

    // Class property signals of Gio-2.0.Gio.SimpleIOStream

    connect(sigName: "notify::input-stream", callback: (($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::input-stream", callback: (($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::input-stream", ...args: any[]): void
    connect(sigName: "notify::output-stream", callback: (($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::output-stream", callback: (($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::output-stream", ...args: any[]): void
    connect(sigName: "notify::closed", callback: (($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::closed", callback: (($obj: SimpleIOStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * GSimpleIOStream creates a #GIOStream from an arbitrary #GInputStream and
 * #GOutputStream. This allows any pair of input and output streams to be used
 * with #GIOStream methods.
 * 
 * This is useful when you obtained a #GInputStream and a #GOutputStream
 * by other means, for instance creating them with platform specific methods as
 * g_unix_input_stream_new() or g_win32_input_stream_new(), and you want
 * to take advantage of the methods provided by #GIOStream.
 * @class 
 */
class SimpleIOStream extends IOStream {

    // Own properties of Gio-2.0.Gio.SimpleIOStream

    static name: string
    static $gtype: GObject.GType<SimpleIOStream>

    // Constructors of Gio-2.0.Gio.SimpleIOStream

    constructor(config?: SimpleIOStream.ConstructorProperties) 
    /**
     * Creates a new #GSimpleIOStream wrapping `input_stream` and `output_stream`.
     * See also #GIOStream.
     * @constructor 
     * @param input_stream a #GInputStream.
     * @param output_stream a #GOutputStream.
     * @returns a new #GSimpleIOStream instance.
     */
    constructor(input_stream: InputStream, output_stream: OutputStream) 
    /**
     * Creates a new #GSimpleIOStream wrapping `input_stream` and `output_stream`.
     * See also #GIOStream.
     * @constructor 
     * @param input_stream a #GInputStream.
     * @param output_stream a #GOutputStream.
     * @returns a new #GSimpleIOStream instance.
     */
    static new(input_stream: InputStream, output_stream: OutputStream): SimpleIOStream
    _init(config?: SimpleIOStream.ConstructorProperties): void
}

module SimplePermission {

    // Constructor properties interface

    interface ConstructorProperties extends Permission.ConstructorProperties {
    }

}

interface SimplePermission {

    // Class property signals of Gio-2.0.Gio.SimplePermission

    connect(sigName: "notify::allowed", callback: (($obj: SimplePermission, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::allowed", callback: (($obj: SimplePermission, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::allowed", ...args: any[]): void
    connect(sigName: "notify::can-acquire", callback: (($obj: SimplePermission, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-acquire", callback: (($obj: SimplePermission, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::can-acquire", ...args: any[]): void
    connect(sigName: "notify::can-release", callback: (($obj: SimplePermission, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-release", callback: (($obj: SimplePermission, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::can-release", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSimplePermission is a trivial implementation of #GPermission that
 * represents a permission that is either always or never allowed.  The
 * value is given at construction and doesn't change.
 * 
 * Calling request or release will result in errors.
 * @class 
 */
class SimplePermission extends Permission {

    // Own properties of Gio-2.0.Gio.SimplePermission

    static name: string
    static $gtype: GObject.GType<SimplePermission>

    // Constructors of Gio-2.0.Gio.SimplePermission

    constructor(config?: SimplePermission.ConstructorProperties) 
    /**
     * Creates a new #GPermission instance that represents an action that is
     * either always or never allowed.
     * @constructor 
     * @param allowed %TRUE if the action is allowed
     * @returns the #GSimplePermission, as a #GPermission
     */
    constructor(allowed: boolean) 
    /**
     * Creates a new #GPermission instance that represents an action that is
     * either always or never allowed.
     * @constructor 
     * @param allowed %TRUE if the action is allowed
     * @returns the #GSimplePermission, as a #GPermission
     */
    static new(allowed: boolean): SimplePermission
    _init(config?: SimplePermission.ConstructorProperties): void
}

module SimpleProxyResolver {

    // Constructor properties interface

    interface ConstructorProperties extends ProxyResolver.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.SimpleProxyResolver

        /**
         * The default proxy URI that will be used for any URI that doesn't
         * match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
         * of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
         * 
         * Note that as a special case, if this URI starts with
         * "socks://", #GSimpleProxyResolver will treat it as referring
         * to all three of the socks5, socks4a, and socks4 proxy types.
         */
        default_proxy?: string | null
        /**
         * A list of hostnames and IP addresses that the resolver should
         * allow direct connections to.
         * 
         * Entries can be in one of 4 formats:
         * 
         * - A hostname, such as "example.com", ".example.com", or
         *   "*.example.com", any of which match "example.com" or
         *   any subdomain of it.
         * 
         * - An IPv4 or IPv6 address, such as "192.168.1.1",
         *   which matches only that address.
         * 
         * - A hostname or IP address followed by a port, such as
         *   "example.com:80", which matches whatever the hostname or IP
         *   address would match, but only for URLs with the (explicitly)
         *   indicated port. In the case of an IPv6 address, the address
         *   part must appear in brackets: "[::1]:443"
         * 
         * - An IP address range, given by a base address and prefix length,
         *   such as "fe80::/10", which matches any address in that range.
         * 
         * Note that when dealing with Unicode hostnames, the matching is
         * done against the ASCII form of the name.
         * 
         * Also note that hostname exclusions apply only to connections made
         * to hosts identified by name, and IP address exclusions apply only
         * to connections made to hosts identified by address. That is, if
         * example.com has an address of 192.168.1.1, and the :ignore-hosts list
         * contains only "192.168.1.1", then a connection to "example.com"
         * (eg, via a #GNetworkAddress) will use the proxy, and a connection to
         * "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
         * 
         * These rules match the "ignore-hosts"/"noproxy" rules most
         * commonly used by other applications.
         */
        ignore_hosts?: string[] | null
    }

}

interface SimpleProxyResolver extends ProxyResolver {

    // Own properties of Gio-2.0.Gio.SimpleProxyResolver

    /**
     * The default proxy URI that will be used for any URI that doesn't
     * match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
     * of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
     * 
     * Note that as a special case, if this URI starts with
     * "socks://", #GSimpleProxyResolver will treat it as referring
     * to all three of the socks5, socks4a, and socks4 proxy types.
     */
    default_proxy: string | null
    /**
     * A list of hostnames and IP addresses that the resolver should
     * allow direct connections to.
     * 
     * Entries can be in one of 4 formats:
     * 
     * - A hostname, such as "example.com", ".example.com", or
     *   "*.example.com", any of which match "example.com" or
     *   any subdomain of it.
     * 
     * - An IPv4 or IPv6 address, such as "192.168.1.1",
     *   which matches only that address.
     * 
     * - A hostname or IP address followed by a port, such as
     *   "example.com:80", which matches whatever the hostname or IP
     *   address would match, but only for URLs with the (explicitly)
     *   indicated port. In the case of an IPv6 address, the address
     *   part must appear in brackets: "[::1]:443"
     * 
     * - An IP address range, given by a base address and prefix length,
     *   such as "fe80::/10", which matches any address in that range.
     * 
     * Note that when dealing with Unicode hostnames, the matching is
     * done against the ASCII form of the name.
     * 
     * Also note that hostname exclusions apply only to connections made
     * to hosts identified by name, and IP address exclusions apply only
     * to connections made to hosts identified by address. That is, if
     * example.com has an address of 192.168.1.1, and the :ignore-hosts list
     * contains only "192.168.1.1", then a connection to "example.com"
     * (eg, via a #GNetworkAddress) will use the proxy, and a connection to
     * "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
     * 
     * These rules match the "ignore-hosts"/"noproxy" rules most
     * commonly used by other applications.
     */
    ignore_hosts: string[]

    // Own fields of Gio-2.0.Gio.SimpleProxyResolver

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.SimpleProxyResolver

    /**
     * Sets the default proxy on `resolver,` to be used for any URIs that
     * don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
     * via g_simple_proxy_resolver_set_uri_proxy().
     * 
     * If `default_proxy` starts with "socks://",
     * #GSimpleProxyResolver will treat it as referring to all three of
     * the socks5, socks4a, and socks4 proxy types.
     * @param default_proxy the default proxy to use
     */
    set_default_proxy(default_proxy: string | null): void
    /**
     * Sets the list of ignored hosts.
     * 
     * See #GSimpleProxyResolver:ignore-hosts for more details on how the
     * `ignore_hosts` argument is interpreted.
     * @param ignore_hosts %NULL-terminated list of hosts/IP addresses     to not use a proxy for
     */
    set_ignore_hosts(ignore_hosts: string[]): void
    /**
     * Adds a URI-scheme-specific proxy to `resolver;` URIs whose scheme
     * matches `uri_scheme` (and which don't match
     * #GSimpleProxyResolver:ignore-hosts) will be proxied via `proxy`.
     * 
     * As with #GSimpleProxyResolver:default-proxy, if `proxy` starts with
     * "socks://", #GSimpleProxyResolver will treat it
     * as referring to all three of the socks5, socks4a, and socks4 proxy
     * types.
     * @param uri_scheme the URI scheme to add a proxy for
     * @param proxy the proxy to use for `uri_scheme`
     */
    set_uri_proxy(uri_scheme: string | null, proxy: string | null): void

    // Class property signals of Gio-2.0.Gio.SimpleProxyResolver

    connect(sigName: "notify::default-proxy", callback: (($obj: SimpleProxyResolver, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::default-proxy", callback: (($obj: SimpleProxyResolver, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::default-proxy", ...args: any[]): void
    connect(sigName: "notify::ignore-hosts", callback: (($obj: SimpleProxyResolver, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ignore-hosts", callback: (($obj: SimpleProxyResolver, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ignore-hosts", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSimpleProxyResolver is a simple #GProxyResolver implementation
 * that handles a single default proxy, multiple URI-scheme-specific
 * proxies, and a list of hosts that proxies should not be used for.
 * 
 * #GSimpleProxyResolver is never the default proxy resolver, but it
 * can be used as the base class for another proxy resolver
 * implementation, or it can be created and used manually, such as
 * with g_socket_client_set_proxy_resolver().
 * @class 
 */
class SimpleProxyResolver extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SimpleProxyResolver

    static name: string
    static $gtype: GObject.GType<SimpleProxyResolver>

    // Constructors of Gio-2.0.Gio.SimpleProxyResolver

    constructor(config?: SimpleProxyResolver.ConstructorProperties) 
    _init(config?: SimpleProxyResolver.ConstructorProperties): void
    /**
     * Creates a new #GSimpleProxyResolver. See
     * #GSimpleProxyResolver:default-proxy and
     * #GSimpleProxyResolver:ignore-hosts for more details on how the
     * arguments are interpreted.
     * @param default_proxy the default proxy to use, eg     "socks://192.168.1.1"
     * @param ignore_hosts an optional list of hosts/IP addresses     to not use a proxy for.
     * @returns a new #GSimpleProxyResolver
     */
    static new(default_proxy: string | null, ignore_hosts: string[] | null): ProxyResolver
}

module Socket {

    // Constructor properties interface

    interface ConstructorProperties extends DatagramBased.ConstructorProperties, Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.Socket

        blocking?: boolean | null
        /**
         * Whether the socket should allow sending to broadcast addresses.
         */
        broadcast?: boolean | null
        family?: SocketFamily | null
        fd?: number | null
        keepalive?: boolean | null
        listen_backlog?: number | null
        /**
         * Whether outgoing multicast packets loop back to the local host.
         */
        multicast_loopback?: boolean | null
        /**
         * Time-to-live out outgoing multicast packets
         */
        multicast_ttl?: number | null
        protocol?: SocketProtocol | null
        /**
         * The timeout in seconds on socket I/O
         */
        timeout?: number | null
        /**
         * Time-to-live for outgoing unicast packets
         */
        ttl?: number | null
        type?: SocketType | null
    }

}

interface Socket extends DatagramBased, Initable {

    // Own properties of Gio-2.0.Gio.Socket

    blocking: boolean
    /**
     * Whether the socket should allow sending to broadcast addresses.
     */
    broadcast: boolean
    readonly family: SocketFamily
    readonly fd: number
    keepalive: boolean
    listen_backlog: number
    readonly local_address: SocketAddress
    /**
     * Whether outgoing multicast packets loop back to the local host.
     */
    multicast_loopback: boolean
    /**
     * Time-to-live out outgoing multicast packets
     */
    multicast_ttl: number
    readonly protocol: SocketProtocol
    readonly remote_address: SocketAddress
    /**
     * The timeout in seconds on socket I/O
     */
    timeout: number
    /**
     * Time-to-live for outgoing unicast packets
     */
    ttl: number
    readonly type: SocketType

    // Own fields of Gio-2.0.Gio.Socket

    parent_instance: GObject.Object
    priv: SocketPrivate

    // Owm methods of Gio-2.0.Gio.Socket

    /**
     * Accept incoming connections on a connection-based socket. This removes
     * the first outstanding connection request from the listening socket and
     * creates a #GSocket object for it.
     * 
     * The `socket` must be bound to a local address with g_socket_bind() and
     * must be listening for incoming connections (g_socket_listen()).
     * 
     * If there are no outstanding connections then the operation will block
     * or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
     * To be notified of an incoming connection, wait for the %G_IO_IN condition.
     * @param cancellable a %GCancellable or %NULL
     * @returns a new #GSocket, or %NULL on error.     Free the returned object with g_object_unref().
     */
    accept(cancellable: Cancellable | null): Socket
    /**
     * When a socket is created it is attached to an address family, but it
     * doesn't have an address in this family. g_socket_bind() assigns the
     * address (sometimes called name) of the socket.
     * 
     * It is generally required to bind to a local address before you can
     * receive connections. (See g_socket_listen() and g_socket_accept() ).
     * In certain situations, you may also want to bind a socket that will be
     * used to initiate connections, though this is not normally required.
     * 
     * If `socket` is a TCP socket, then `allow_reuse` controls the setting
     * of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
     * server sockets (sockets that you will eventually call
     * g_socket_accept() on), and %FALSE for client sockets. (Failing to
     * set this flag on a server socket may cause g_socket_bind() to return
     * %G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
     * immediately restarted.)
     * 
     * If `socket` is a UDP socket, then `allow_reuse` determines whether or
     * not other UDP sockets can be bound to the same address at the same
     * time. In particular, you can have several UDP sockets bound to the
     * same address, and they will all receive all of the multicast and
     * broadcast packets sent to that address. (The behavior of unicast
     * UDP packets to an address with multiple listeners is not defined.)
     * @param address a #GSocketAddress specifying the local address.
     * @param allow_reuse whether to allow reusing this address
     * @returns %TRUE on success, %FALSE on error.
     */
    bind(address: SocketAddress, allow_reuse: boolean): boolean
    /**
     * Checks and resets the pending connect error for the socket.
     * This is used to check for errors when g_socket_connect() is
     * used in non-blocking mode.
     * @returns %TRUE if no error, %FALSE otherwise, setting @error to the error
     */
    check_connect_result(): boolean
    /**
     * Closes the socket, shutting down any active connection.
     * 
     * Closing a socket does not wait for all outstanding I/O operations
     * to finish, so the caller should not rely on them to be guaranteed
     * to complete even if the close returns with no error.
     * 
     * Once the socket is closed, all other operations will return
     * %G_IO_ERROR_CLOSED. Closing a socket multiple times will not
     * return an error.
     * 
     * Sockets will be automatically closed when the last reference
     * is dropped, but you might want to call this function to make sure
     * resources are released as early as possible.
     * 
     * Beware that due to the way that TCP works, it is possible for
     * recently-sent data to be lost if either you close a socket while the
     * %G_IO_IN condition is set, or else if the remote connection tries to
     * send something to you after you close the socket but before it has
     * finished reading all of the data you sent. There is no easy generic
     * way to avoid this problem; the easiest fix is to design the network
     * protocol such that the client will never send data "out of turn".
     * Another solution is for the server to half-close the connection by
     * calling g_socket_shutdown() with only the `shutdown_write` flag set,
     * and then wait for the client to notice this and close its side of the
     * connection, after which the server can safely call g_socket_close().
     * (This is what #GTcpConnection does if you call
     * g_tcp_connection_set_graceful_disconnect(). But of course, this
     * only works if the client will close its connection after the server
     * does.)
     * @returns %TRUE on success, %FALSE on error
     */
    close(): boolean
    /**
     * Checks on the readiness of `socket` to perform operations.
     * The operations specified in `condition` are checked for and masked
     * against the currently-satisfied conditions on `socket`. The result
     * is returned.
     * 
     * Note that on Windows, it is possible for an operation to return
     * %G_IO_ERROR_WOULD_BLOCK even immediately after
     * g_socket_condition_check() has claimed that the socket is ready for
     * writing. Rather than calling g_socket_condition_check() and then
     * writing to the socket if it succeeds, it is generally better to
     * simply try writing to the socket right away, and try again later if
     * the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
     * 
     * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
     * these conditions will always be set in the output if they are true.
     * 
     * This call never blocks.
     * @param condition a #GIOCondition mask to check
     * @returns the @GIOCondition mask of the current state
     */
    condition_check(condition: GLib.IOCondition): GLib.IOCondition
    /**
     * Waits for up to `timeout_us` microseconds for `condition` to become true
     * on `socket`. If the condition is met, %TRUE is returned.
     * 
     * If `cancellable` is cancelled before the condition is met, or if
     * `timeout_us` (or the socket's #GSocket:timeout) is reached before the
     * condition is met, then %FALSE is returned and `error,` if non-%NULL,
     * is set to the appropriate value (%G_IO_ERROR_CANCELLED or
     * %G_IO_ERROR_TIMED_OUT).
     * 
     * If you don't want a timeout, use g_socket_condition_wait().
     * (Alternatively, you can pass -1 for `timeout_us`.)
     * 
     * Note that although `timeout_us` is in microseconds for consistency with
     * other GLib APIs, this function actually only has millisecond
     * resolution, and the behavior is undefined if `timeout_us` is not an
     * exact number of milliseconds.
     * @param condition a #GIOCondition mask to wait for
     * @param timeout_us the maximum time (in microseconds) to wait, or -1
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if the condition was met, %FALSE otherwise
     */
    condition_timed_wait(condition: GLib.IOCondition, timeout_us: number, cancellable: Cancellable | null): boolean
    /**
     * Waits for `condition` to become true on `socket`. When the condition
     * is met, %TRUE is returned.
     * 
     * If `cancellable` is cancelled before the condition is met, or if the
     * socket has a timeout set and it is reached before the condition is
     * met, then %FALSE is returned and `error,` if non-%NULL, is set to
     * the appropriate value (%G_IO_ERROR_CANCELLED or
     * %G_IO_ERROR_TIMED_OUT).
     * 
     * See also g_socket_condition_timed_wait().
     * @param condition a #GIOCondition mask to wait for
     * @param cancellable a #GCancellable, or %NULL
     * @returns %TRUE if the condition was met, %FALSE otherwise
     */
    condition_wait(condition: GLib.IOCondition, cancellable: Cancellable | null): boolean

    // Overloads of condition_wait

    /**
     * Waits for up to `timeout` microseconds for condition to become true on
     * `datagram_based`. If the condition is met, %TRUE is returned.
     * 
     * If `cancellable` is cancelled before the condition is met, or if `timeout` is
     * reached before the condition is met, then %FALSE is returned and `error` is
     * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
     * @param condition a #GIOCondition mask to wait for
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a #GCancellable
     * @returns %TRUE if the condition was met, %FALSE otherwise
     */
    condition_wait(condition: GLib.IOCondition, timeout: number, cancellable: Cancellable | null): boolean
    /**
     * Connect the socket to the specified remote address.
     * 
     * For connection oriented socket this generally means we attempt to make
     * a connection to the `address`. For a connection-less socket it sets
     * the default address for g_socket_send() and discards all incoming datagrams
     * from other sources.
     * 
     * Generally connection oriented sockets can only connect once, but
     * connection-less sockets can connect multiple times to change the
     * default address.
     * 
     * If the connect call needs to do network I/O it will block, unless
     * non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
     * and the user can be notified of the connection finishing by waiting
     * for the G_IO_OUT condition. The result of the connection must then be
     * checked with g_socket_check_connect_result().
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if connected, %FALSE on error.
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    /**
     * Creates a #GSocketConnection subclass of the right type for
     * `socket`.
     * @returns a #GSocketConnection
     */
    connection_factory_create_connection(): SocketConnection
    /**
     * Get the amount of data pending in the OS input buffer, without blocking.
     * 
     * If `socket` is a UDP or SCTP socket, this will return the size of
     * just the next packet, even if additional packets are buffered after
     * that one.
     * 
     * Note that on Windows, this function is rather inefficient in the
     * UDP case, and so if you know any plausible upper bound on the size
     * of the incoming packet, it is better to just do a
     * g_socket_receive() with a buffer of that size, rather than calling
     * g_socket_get_available_bytes() first and then doing a receive of
     * exactly the right size.
     * @returns the number of bytes that can be read from the socket without blocking or truncating, or -1 on error.
     */
    get_available_bytes(): number
    /**
     * Gets the blocking mode of the socket. For details on blocking I/O,
     * see g_socket_set_blocking().
     * @returns %TRUE if blocking I/O is used, %FALSE otherwise.
     */
    get_blocking(): boolean
    /**
     * Gets the broadcast setting on `socket;` if %TRUE,
     * it is possible to send packets to broadcast
     * addresses.
     * @returns the broadcast setting on @socket
     */
    get_broadcast(): boolean
    /**
     * Returns the credentials of the foreign process connected to this
     * socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
     * sockets).
     * 
     * If this operation isn't supported on the OS, the method fails with
     * the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
     * by reading the %SO_PEERCRED option on the underlying socket.
     * 
     * This method can be expected to be available on the following platforms:
     * 
     * - Linux since GLib 2.26
     * - OpenBSD since GLib 2.30
     * - Solaris, Illumos and OpenSolaris since GLib 2.40
     * - NetBSD since GLib 2.42
     * - macOS, tvOS, iOS since GLib 2.66
     * 
     * Other ways to obtain credentials from a foreign peer includes the
     * #GUnixCredentialsMessage type and
     * g_unix_connection_send_credentials() /
     * g_unix_connection_receive_credentials() functions.
     * @returns %NULL if @error is set, otherwise a #GCredentials object that must be freed with g_object_unref().
     */
    get_credentials(): Credentials
    /**
     * Gets the socket family of the socket.
     * @returns a #GSocketFamily
     */
    get_family(): SocketFamily
    /**
     * Returns the underlying OS socket object. On unix this
     * is a socket file descriptor, and on Windows this is
     * a Winsock2 SOCKET handle. This may be useful for
     * doing platform specific or otherwise unusual operations
     * on the socket.
     * @returns the file descriptor of the socket.
     */
    get_fd(): number
    /**
     * Gets the keepalive mode of the socket. For details on this,
     * see g_socket_set_keepalive().
     * @returns %TRUE if keepalive is active, %FALSE otherwise.
     */
    get_keepalive(): boolean
    /**
     * Gets the listen backlog setting of the socket. For details on this,
     * see g_socket_set_listen_backlog().
     * @returns the maximum number of pending connections.
     */
    get_listen_backlog(): number
    /**
     * Try to get the local address of a bound socket. This is only
     * useful if the socket has been bound to a local address,
     * either explicitly or implicitly when connecting.
     * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
     */
    get_local_address(): SocketAddress
    /**
     * Gets the multicast loopback setting on `socket;` if %TRUE (the
     * default), outgoing multicast packets will be looped back to
     * multicast listeners on the same host.
     * @returns the multicast loopback setting on @socket
     */
    get_multicast_loopback(): boolean
    /**
     * Gets the multicast time-to-live setting on `socket;` see
     * g_socket_set_multicast_ttl() for more details.
     * @returns the multicast time-to-live setting on @socket
     */
    get_multicast_ttl(): number
    /**
     * Gets the value of an integer-valued option on `socket,` as with
     * getsockopt(). (If you need to fetch a  non-integer-valued option,
     * you will need to call getsockopt() directly.)
     * 
     * The [<gio/gnetworking.h>][gio-gnetworking.h]
     * header pulls in system headers that will define most of the
     * standard/portable socket options. For unusual socket protocols or
     * platform-dependent options, you may need to include additional
     * headers.
     * 
     * Note that even for socket options that are a single byte in size,
     * `value` is still a pointer to a #gint variable, not a #guchar;
     * g_socket_get_option() will handle the conversion internally.
     * @param level the "API level" of the option (eg, `SOL_SOCKET`)
     * @param optname the "name" of the option (eg, `SO_BROADCAST`)
     * @returns success or failure. On failure, @error will be set, and   the system error value (`errno` or WSAGetLastError()) will still   be set to the result of the getsockopt() call.
     */
    get_option(level: number, optname: number): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets the socket protocol id the socket was created with.
     * In case the protocol is unknown, -1 is returned.
     * @returns a protocol id, or -1 if unknown
     */
    get_protocol(): SocketProtocol
    /**
     * Try to get the remote address of a connected socket. This is only
     * useful for connection oriented sockets that have been connected.
     * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
     */
    get_remote_address(): SocketAddress
    /**
     * Gets the socket type of the socket.
     * @returns a #GSocketType
     */
    get_socket_type(): SocketType
    /**
     * Gets the timeout setting of the socket. For details on this, see
     * g_socket_set_timeout().
     * @returns the timeout in seconds
     */
    get_timeout(): number
    /**
     * Gets the unicast time-to-live setting on `socket;` see
     * g_socket_set_ttl() for more details.
     * @returns the time-to-live setting on @socket
     */
    get_ttl(): number
    /**
     * Checks whether a socket is closed.
     * @returns %TRUE if socket is closed, %FALSE otherwise
     */
    is_closed(): boolean
    /**
     * Check whether the socket is connected. This is only useful for
     * connection-oriented sockets.
     * 
     * If using g_socket_shutdown(), this function will return %TRUE until the
     * socket has been shut down for reading and writing. If you do a non-blocking
     * connect, this function will not return %TRUE until after you call
     * g_socket_check_connect_result().
     * @returns %TRUE if socket is connected, %FALSE otherwise.
     */
    is_connected(): boolean
    /**
     * Registers `socket` to receive multicast messages sent to `group`.
     * `socket` must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
     * been bound to an appropriate interface and port with
     * g_socket_bind().
     * 
     * If `iface` is %NULL, the system will automatically pick an interface
     * to bind to based on `group`.
     * 
     * If `source_specific` is %TRUE, source-specific multicast as defined
     * in RFC 4604 is used. Note that on older platforms this may fail
     * with a %G_IO_ERROR_NOT_SUPPORTED error.
     * 
     * To bind to a given source-specific multicast address, use
     * g_socket_join_multicast_group_ssm() instead.
     * @param group a #GInetAddress specifying the group address to join.
     * @param source_specific %TRUE if source-specific multicast should be used
     * @param iface Name of the interface to use, or %NULL
     * @returns %TRUE on success, %FALSE on error.
     */
    join_multicast_group(group: InetAddress, source_specific: boolean, iface: string | null): boolean
    /**
     * Registers `socket` to receive multicast messages sent to `group`.
     * `socket` must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
     * been bound to an appropriate interface and port with
     * g_socket_bind().
     * 
     * If `iface` is %NULL, the system will automatically pick an interface
     * to bind to based on `group`.
     * 
     * If `source_specific` is not %NULL, use source-specific multicast as
     * defined in RFC 4604. Note that on older platforms this may fail
     * with a %G_IO_ERROR_NOT_SUPPORTED error.
     * 
     * Note that this function can be called multiple times for the same
     * `group` with different `source_specific` in order to receive multicast
     * packets from more than one source.
     * @param group a #GInetAddress specifying the group address to join.
     * @param source_specific a #GInetAddress specifying the source-specific multicast address or %NULL to ignore.
     * @param iface Name of the interface to use, or %NULL
     * @returns %TRUE on success, %FALSE on error.
     */
    join_multicast_group_ssm(group: InetAddress, source_specific: InetAddress | null, iface: string | null): boolean
    /**
     * Removes `socket` from the multicast group defined by `group,` `iface,`
     * and `source_specific` (which must all have the same values they had
     * when you joined the group).
     * 
     * `socket` remains bound to its address and port, and can still receive
     * unicast messages after calling this.
     * 
     * To unbind to a given source-specific multicast address, use
     * g_socket_leave_multicast_group_ssm() instead.
     * @param group a #GInetAddress specifying the group address to leave.
     * @param source_specific %TRUE if source-specific multicast was used
     * @param iface Interface used
     * @returns %TRUE on success, %FALSE on error.
     */
    leave_multicast_group(group: InetAddress, source_specific: boolean, iface: string | null): boolean
    /**
     * Removes `socket` from the multicast group defined by `group,` `iface,`
     * and `source_specific` (which must all have the same values they had
     * when you joined the group).
     * 
     * `socket` remains bound to its address and port, and can still receive
     * unicast messages after calling this.
     * @param group a #GInetAddress specifying the group address to leave.
     * @param source_specific a #GInetAddress specifying the source-specific multicast address or %NULL to ignore.
     * @param iface Name of the interface to use, or %NULL
     * @returns %TRUE on success, %FALSE on error.
     */
    leave_multicast_group_ssm(group: InetAddress, source_specific: InetAddress | null, iface: string | null): boolean
    /**
     * Marks the socket as a server socket, i.e. a socket that is used
     * to accept incoming requests using g_socket_accept().
     * 
     * Before calling this the socket must be bound to a local address using
     * g_socket_bind().
     * 
     * To set the maximum amount of outstanding clients, use
     * g_socket_set_listen_backlog().
     * @returns %TRUE on success, %FALSE on error.
     */
    listen(): boolean
    /**
     * Receive data (up to `size` bytes) from a socket. This is mainly used by
     * connection-oriented sockets; it is identical to g_socket_receive_from()
     * with `address` set to %NULL.
     * 
     * For %G_SOCKET_TYPE_DATAGRAM and %G_SOCKET_TYPE_SEQPACKET sockets,
     * g_socket_receive() will always read either 0 or 1 complete messages from
     * the socket. If the received message is too large to fit in `buffer,` then
     * the data beyond `size` bytes will be discarded, without any explicit
     * indication that this has occurred.
     * 
     * For %G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
     * number of bytes, up to `size`. If more than `size` bytes have been
     * received, the additional data will be returned in future calls to
     * g_socket_receive().
     * 
     * If the socket is in blocking mode the call will block until there
     * is some data to receive, the connection is closed, or there is an
     * error. If there is no data available and the socket is in
     * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
     * returned. To be notified when data is available, wait for the
     * %G_IO_IN condition.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * @param cancellable a %GCancellable or %NULL
     * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
     */
    receive(cancellable: Cancellable | null): [ /* returnType */ number, /* buffer */ Uint8Array ]
    /**
     * Receive data (up to `size` bytes) from a socket.
     * 
     * If `address` is non-%NULL then `address` will be set equal to the
     * source address of the received packet.
     * `address` is owned by the caller.
     * 
     * See g_socket_receive() for additional information.
     * @param cancellable a %GCancellable or %NULL
     * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
     */
    receive_from(cancellable: Cancellable | null): [ /* returnType */ number, /* address */ SocketAddress, /* buffer */ Uint8Array ]
    /**
     * Receive data from a socket.  For receiving multiple messages, see
     * g_socket_receive_messages(); for easier use, see
     * g_socket_receive() and g_socket_receive_from().
     * 
     * If `address` is non-%NULL then `address` will be set equal to the
     * source address of the received packet.
     * `address` is owned by the caller.
     * 
     * `vector` must point to an array of #GInputVector structs and
     * `num_vectors` must be the length of this array.  These structs
     * describe the buffers that received data will be scattered into.
     * If `num_vectors` is -1, then `vectors` is assumed to be terminated
     * by a #GInputVector with a %NULL buffer pointer.
     * 
     * As a special case, if `num_vectors` is 0 (in which case, `vectors`
     * may of course be %NULL), then a single byte is received and
     * discarded. This is to facilitate the common practice of sending a
     * single '\0' byte for the purposes of transferring ancillary data.
     * 
     * `messages,` if non-%NULL, will be set to point to a newly-allocated
     * array of #GSocketControlMessage instances or %NULL if no such
     * messages was received. These correspond to the control messages
     * received from the kernel, one #GSocketControlMessage per message
     * from the kernel. This array is %NULL-terminated and must be freed
     * by the caller using g_free() after calling g_object_unref() on each
     * element. If `messages` is %NULL, any control messages received will
     * be discarded.
     * 
     * `num_messages,` if non-%NULL, will be set to the number of control
     * messages received.
     * 
     * If both `messages` and `num_messages` are non-%NULL, then
     * `num_messages` gives the number of #GSocketControlMessage instances
     * in `messages` (ie: not including the %NULL terminator).
     * 
     * `flags` is an in/out parameter. The commonly available arguments
     * for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too
     * (and g_socket_receive_message() may pass system-specific flags out).
     * Flags passed in to the parameter affect the receive operation; flags returned
     * out of it are relevant to the specific returned message.
     * 
     * As with g_socket_receive(), data may be discarded if `socket` is
     * %G_SOCKET_TYPE_DATAGRAM or %G_SOCKET_TYPE_SEQPACKET and you do not
     * provide enough buffer space to read a complete message. You can pass
     * %G_SOCKET_MSG_PEEK in `flags` to peek at the current message without
     * removing it from the receive queue, but there is no portable way to find
     * out the length of the message other than by reading it into a
     * sufficiently-large buffer.
     * 
     * If the socket is in blocking mode the call will block until there
     * is some data to receive, the connection is closed, or there is an
     * error. If there is no data available and the socket is in
     * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
     * returned. To be notified when data is available, wait for the
     * %G_IO_IN condition.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * @param vectors an array of #GInputVector structs
     * @param flags a pointer to an int containing #GSocketMsgFlags flags,    which may additionally contain    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
     * @param cancellable a %GCancellable or %NULL
     * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
     */
    receive_message(vectors: InputVector[], flags: number, cancellable: Cancellable | null): [ /* returnType */ number, /* address */ SocketAddress, /* messages */ SocketControlMessage[] | null, /* flags */ number ]
    /**
     * Receive multiple data messages from `socket` in one go.  This is the most
     * complicated and fully-featured version of this call. For easier use, see
     * g_socket_receive(), g_socket_receive_from(), and g_socket_receive_message().
     * 
     * `messages` must point to an array of #GInputMessage structs and
     * `num_messages` must be the length of this array. Each #GInputMessage
     * contains a pointer to an array of #GInputVector structs describing the
     * buffers that the data received in each message will be written to. Using
     * multiple #GInputVectors is more memory-efficient than manually copying data
     * out of a single buffer to multiple sources, and more system-call-efficient
     * than making multiple calls to g_socket_receive(), such as in scenarios where
     * a lot of data packets need to be received (e.g. high-bandwidth video
     * streaming over RTP/UDP).
     * 
     * `flags` modify how all messages are received. The commonly available
     * arguments for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too. These
     * flags affect the overall receive operation. Flags affecting individual
     * messages are returned in #GInputMessage.flags.
     * 
     * The other members of #GInputMessage are treated as described in its
     * documentation.
     * 
     * If #GSocket:blocking is %TRUE the call will block until `num_messages` have
     * been received, or the end of the stream is reached.
     * 
     * If #GSocket:blocking is %FALSE the call will return up to `num_messages`
     * without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
     * operating system to be received.
     * 
     * In blocking mode, if #GSocket:timeout is positive and is reached before any
     * messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
     * `num_messages` are returned. (Note: This is effectively the
     * behaviour of `MSG_WAITFORONE` with recvmmsg().)
     * 
     * To be notified when messages are available, wait for the
     * %G_IO_IN condition. Note though that you may still receive
     * %G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
     * previously notified of a %G_IO_IN condition.
     * 
     * If the remote peer closes the connection, any messages queued in the
     * operating system will be returned, and subsequent calls to
     * g_socket_receive_messages() will return 0 (with no error set).
     * 
     * On error -1 is returned and `error` is set accordingly. An error will only
     * be returned if zero messages could be received; otherwise the number of
     * messages successfully received before the error will be returned.
     * @param messages an array of #GInputMessage structs
     * @param flags an int containing #GSocketMsgFlags flags for the overall operation,    which may additionally contain    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
     * @param cancellable a %GCancellable or %NULL
     * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if in non-blocking     mode, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
     */
    receive_messages(messages: InputMessage[], flags: number, cancellable: Cancellable | null): number

    // Overloads of receive_messages

    /**
     * Receive one or more data messages from `datagram_based` in one go.
     * 
     * `messages` must point to an array of #GInputMessage structs and
     * `num_messages` must be the length of this array. Each #GInputMessage
     * contains a pointer to an array of #GInputVector structs describing the
     * buffers that the data received in each message will be written to.
     * 
     * `flags` modify how all messages are received. The commonly available
     * arguments for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too. These
     * flags affect the overall receive operation. Flags affecting individual
     * messages are returned in #GInputMessage.flags.
     * 
     * The other members of #GInputMessage are treated as described in its
     * documentation.
     * 
     * If `timeout` is negative the call will block until `num_messages` have been
     * received, the connection is closed remotely (EOS), `cancellable` is cancelled,
     * or an error occurs.
     * 
     * If `timeout` is 0 the call will return up to `num_messages` without blocking,
     * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
     * to be received.
     * 
     * If `timeout` is positive the call will block on the same conditions as if
     * `timeout` were negative. If the timeout is reached
     * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
     * otherwise it will return the number of messages received before timing out.
     * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
     * recvmmsg().)
     * 
     * To be notified when messages are available, wait for the %G_IO_IN condition.
     * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
     * g_datagram_based_receive_messages() even if you were previously notified of a
     * %G_IO_IN condition.
     * 
     * If the remote peer closes the connection, any messages queued in the
     * underlying receive buffer will be returned, and subsequent calls to
     * g_datagram_based_receive_messages() will return 0 (with no error set).
     * 
     * If the connection is shut down or closed (by calling g_socket_close() or
     * g_socket_shutdown() with `shutdown_read` set, if it’s a #GSocket, for
     * example), all calls to this function will return %G_IO_ERROR_CLOSED.
     * 
     * On error -1 is returned and `error` is set accordingly. An error will only
     * be returned if zero messages could be received; otherwise the number of
     * messages successfully received before the error will be returned. If
     * `cancellable` is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
     * other error.
     * @param messages an array of #GInputMessage structs
     * @param flags an int containing #GSocketMsgFlags flags for the overall operation
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a %GCancellable
     * @returns number of messages received, or -1 on error. Note that the number     of messages received may be smaller than @num_messages if @timeout is     zero or positive, if the peer closed the connection, or if @num_messages     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try     to receive the remaining messages.
     */
    receive_messages(messages: InputMessage[], flags: number, timeout: number, cancellable: Cancellable | null): number
    /**
     * This behaves exactly the same as g_socket_receive(), except that
     * the choice of blocking or non-blocking behavior is determined by
     * the `blocking` argument rather than by `socket'`s properties.
     * @param blocking whether to do blocking or non-blocking I/O
     * @param cancellable a %GCancellable or %NULL
     * @returns Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error
     */
    receive_with_blocking(blocking: boolean, cancellable: Cancellable | null): [ /* returnType */ number, /* buffer */ Uint8Array ]
    /**
     * Tries to send `size` bytes from `buffer` on the socket. This is
     * mainly used by connection-oriented sockets; it is identical to
     * g_socket_send_to() with `address` set to %NULL.
     * 
     * If the socket is in blocking mode the call will block until there is
     * space for the data in the socket queue. If there is no space available
     * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
     * will be returned. To be notified when space is available, wait for the
     * %G_IO_OUT condition. Note though that you may still receive
     * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
     * notified of a %G_IO_OUT condition. (On Windows in particular, this is
     * very common due to the way the underlying APIs work.)
     * 
     * On error -1 is returned and `error` is set accordingly.
     * @param buffer the buffer     containing the data to send.
     * @param cancellable a %GCancellable or %NULL
     * @returns Number of bytes written (which may be less than @size), or -1 on error
     */
    send(buffer: Uint8Array, cancellable: Cancellable | null): number
    /**
     * Send data to `address` on `socket`.  For sending multiple messages see
     * g_socket_send_messages(); for easier use, see
     * g_socket_send() and g_socket_send_to().
     * 
     * If `address` is %NULL then the message is sent to the default receiver
     * (set by g_socket_connect()).
     * 
     * `vectors` must point to an array of #GOutputVector structs and
     * `num_vectors` must be the length of this array. (If `num_vectors` is -1,
     * then `vectors` is assumed to be terminated by a #GOutputVector with a
     * %NULL buffer pointer.) The #GOutputVector structs describe the buffers
     * that the sent data will be gathered from. Using multiple
     * #GOutputVectors is more memory-efficient than manually copying
     * data from multiple sources into a single buffer, and more
     * network-efficient than making multiple calls to g_socket_send().
     * 
     * `messages,` if non-%NULL, is taken to point to an array of `num_messages`
     * #GSocketControlMessage instances. These correspond to the control
     * messages to be sent on the socket.
     * If `num_messages` is -1 then `messages` is treated as a %NULL-terminated
     * array.
     * 
     * `flags` modify how the message is sent. The commonly available arguments
     * for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too.
     * 
     * If the socket is in blocking mode the call will block until there is
     * space for the data in the socket queue. If there is no space available
     * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
     * will be returned. To be notified when space is available, wait for the
     * %G_IO_OUT condition. Note though that you may still receive
     * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
     * notified of a %G_IO_OUT condition. (On Windows in particular, this is
     * very common due to the way the underlying APIs work.)
     * 
     * The sum of the sizes of each #GOutputVector in vectors must not be
     * greater than %G_MAXSSIZE. If the message can be larger than this,
     * then it is mandatory to use the g_socket_send_message_with_timeout()
     * function.
     * 
     * On error -1 is returned and `error` is set accordingly.
     * @param address a #GSocketAddress, or %NULL
     * @param vectors an array of #GOutputVector structs
     * @param messages a pointer to an   array of #GSocketControlMessages, or %NULL.
     * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
     * @param cancellable a %GCancellable or %NULL
     * @returns Number of bytes written (which may be less than @size), or -1 on error
     */
    send_message(address: SocketAddress | null, vectors: OutputVector[], messages: SocketControlMessage[] | null, flags: number, cancellable: Cancellable | null): number
    /**
     * This behaves exactly the same as g_socket_send_message(), except that
     * the choice of timeout behavior is determined by the `timeout_us` argument
     * rather than by `socket'`s properties.
     * 
     * On error %G_POLLABLE_RETURN_FAILED is returned and `error` is set accordingly, or
     * if the socket is currently not writable %G_POLLABLE_RETURN_WOULD_BLOCK is
     * returned. `bytes_written` will contain 0 in both cases.
     * @param address a #GSocketAddress, or %NULL
     * @param vectors an array of #GOutputVector structs
     * @param messages a pointer to an   array of #GSocketControlMessages, or %NULL.
     * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
     * @param timeout_us the maximum time (in microseconds) to wait, or -1
     * @param cancellable a %GCancellable or %NULL
     * @returns %G_POLLABLE_RETURN_OK if all data was successfully written, %G_POLLABLE_RETURN_WOULD_BLOCK if the socket is currently not writable, or %G_POLLABLE_RETURN_FAILED if an error happened and @error is set.
     */
    send_message_with_timeout(address: SocketAddress | null, vectors: OutputVector[], messages: SocketControlMessage[] | null, flags: number, timeout_us: number, cancellable: Cancellable | null): [ /* returnType */ PollableReturn, /* bytes_written */ number ]
    /**
     * Send multiple data messages from `socket` in one go.  This is the most
     * complicated and fully-featured version of this call. For easier use, see
     * g_socket_send(), g_socket_send_to(), and g_socket_send_message().
     * 
     * `messages` must point to an array of #GOutputMessage structs and
     * `num_messages` must be the length of this array. Each #GOutputMessage
     * contains an address to send the data to, and a pointer to an array of
     * #GOutputVector structs to describe the buffers that the data to be sent
     * for each message will be gathered from. Using multiple #GOutputVectors is
     * more memory-efficient than manually copying data from multiple sources
     * into a single buffer, and more network-efficient than making multiple
     * calls to g_socket_send(). Sending multiple messages in one go avoids the
     * overhead of making a lot of syscalls in scenarios where a lot of data
     * packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
     * or where the same data needs to be sent to multiple recipients.
     * 
     * `flags` modify how the message is sent. The commonly available arguments
     * for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too.
     * 
     * If the socket is in blocking mode the call will block until there is
     * space for all the data in the socket queue. If there is no space available
     * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
     * will be returned if no data was written at all, otherwise the number of
     * messages sent will be returned. To be notified when space is available,
     * wait for the %G_IO_OUT condition. Note though that you may still receive
     * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
     * notified of a %G_IO_OUT condition. (On Windows in particular, this is
     * very common due to the way the underlying APIs work.)
     * 
     * On error -1 is returned and `error` is set accordingly. An error will only
     * be returned if zero messages could be sent; otherwise the number of messages
     * successfully sent before the error will be returned.
     * @param messages an array of #GOutputMessage structs
     * @param flags an int containing #GSocketMsgFlags flags, which may additionally    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
     * @param cancellable a %GCancellable or %NULL
     * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if the socket is     non-blocking or if @num_messages was larger than UIO_MAXIOV (1024),     in which case the caller may re-try to send the remaining messages.
     */
    send_messages(messages: OutputMessage[], flags: number, cancellable: Cancellable | null): number

    // Overloads of send_messages

    /**
     * Send one or more data messages from `datagram_based` in one go.
     * 
     * `messages` must point to an array of #GOutputMessage structs and
     * `num_messages` must be the length of this array. Each #GOutputMessage
     * contains an address to send the data to, and a pointer to an array of
     * #GOutputVector structs to describe the buffers that the data to be sent
     * for each message will be gathered from.
     * 
     * `flags` modify how the message is sent. The commonly available arguments
     * for this are available in the #GSocketMsgFlags enum, but the
     * values there are the same as the system values, and the flags
     * are passed in as-is, so you can pass in system-specific flags too.
     * 
     * The other members of #GOutputMessage are treated as described in its
     * documentation.
     * 
     * If `timeout` is negative the call will block until `num_messages` have been
     * sent, `cancellable` is cancelled, or an error occurs.
     * 
     * If `timeout` is 0 the call will send up to `num_messages` without blocking,
     * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
     * 
     * If `timeout` is positive the call will block on the same conditions as if
     * `timeout` were negative. If the timeout is reached before any messages are
     * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
     * of messages sent before timing out.
     * 
     * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
     * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
     * g_datagram_based_send_messages() even if you were previously notified of a
     * %G_IO_OUT condition. (On Windows in particular, this is very common due to
     * the way the underlying APIs work.)
     * 
     * If the connection is shut down or closed (by calling g_socket_close() or
     * g_socket_shutdown() with `shutdown_write` set, if it’s a #GSocket, for
     * example), all calls to this function will return %G_IO_ERROR_CLOSED.
     * 
     * On error -1 is returned and `error` is set accordingly. An error will only
     * be returned if zero messages could be sent; otherwise the number of messages
     * successfully sent before the error will be returned. If `cancellable` is
     * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
     * @param messages an array of #GOutputMessage structs
     * @param flags an int containing #GSocketMsgFlags flags
     * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1   to block indefinitely
     * @param cancellable a %GCancellable
     * @returns number of messages sent, or -1 on error. Note that the number of     messages sent may be smaller than @num_messages if @timeout is zero     or positive, or if @num_messages was larger than `UIO_MAXIOV` (1024), in     which case the caller may re-try to send the remaining messages.
     */
    send_messages(messages: OutputMessage[], flags: number, timeout: number, cancellable: Cancellable | null): number
    /**
     * Tries to send `size` bytes from `buffer` to `address`. If `address` is
     * %NULL then the message is sent to the default receiver (set by
     * g_socket_connect()).
     * 
     * See g_socket_send() for additional information.
     * @param address a #GSocketAddress, or %NULL
     * @param buffer the buffer     containing the data to send.
     * @param cancellable a %GCancellable or %NULL
     * @returns Number of bytes written (which may be less than @size), or -1 on error
     */
    send_to(address: SocketAddress | null, buffer: Uint8Array, cancellable: Cancellable | null): number
    /**
     * This behaves exactly the same as g_socket_send(), except that
     * the choice of blocking or non-blocking behavior is determined by
     * the `blocking` argument rather than by `socket'`s properties.
     * @param buffer the buffer     containing the data to send.
     * @param blocking whether to do blocking or non-blocking I/O
     * @param cancellable a %GCancellable or %NULL
     * @returns Number of bytes written (which may be less than @size), or -1 on error
     */
    send_with_blocking(buffer: Uint8Array, blocking: boolean, cancellable: Cancellable | null): number
    /**
     * Sets the blocking mode of the socket. In blocking mode
     * all operations (which don’t take an explicit blocking parameter) block until
     * they succeed or there is an error. In
     * non-blocking mode all functions return results immediately or
     * with a %G_IO_ERROR_WOULD_BLOCK error.
     * 
     * All sockets are created in blocking mode. However, note that the
     * platform level socket is always non-blocking, and blocking mode
     * is a GSocket level feature.
     * @param blocking Whether to use blocking I/O or not.
     */
    set_blocking(blocking: boolean): void
    /**
     * Sets whether `socket` should allow sending to broadcast addresses.
     * This is %FALSE by default.
     * @param broadcast whether `socket` should allow sending to broadcast     addresses
     */
    set_broadcast(broadcast: boolean): void
    /**
     * Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
     * this flag is set on a socket, the system will attempt to verify that the
     * remote socket endpoint is still present if a sufficiently long period of
     * time passes with no data being exchanged. If the system is unable to
     * verify the presence of the remote endpoint, it will automatically close
     * the connection.
     * 
     * This option is only functional on certain kinds of sockets. (Notably,
     * %G_SOCKET_PROTOCOL_TCP sockets.)
     * 
     * The exact time between pings is system- and protocol-dependent, but will
     * normally be at least two hours. Most commonly, you would set this flag
     * on a server socket if you want to allow clients to remain idle for long
     * periods of time, but also want to ensure that connections are eventually
     * garbage-collected if clients crash or become unreachable.
     * @param keepalive Value for the keepalive flag
     */
    set_keepalive(keepalive: boolean): void
    /**
     * Sets the maximum number of outstanding connections allowed
     * when listening on this socket. If more clients than this are
     * connecting to the socket and the application is not handling them
     * on time then the new connections will be refused.
     * 
     * Note that this must be called before g_socket_listen() and has no
     * effect if called after that.
     * @param backlog the maximum number of pending connections.
     */
    set_listen_backlog(backlog: number): void
    /**
     * Sets whether outgoing multicast packets will be received by sockets
     * listening on that multicast address on the same host. This is %TRUE
     * by default.
     * @param loopback whether `socket` should receive messages sent to its   multicast groups from the local host
     */
    set_multicast_loopback(loopback: boolean): void
    /**
     * Sets the time-to-live for outgoing multicast datagrams on `socket`.
     * By default, this is 1, meaning that multicast packets will not leave
     * the local network.
     * @param ttl the time-to-live value for all multicast datagrams on `socket`
     */
    set_multicast_ttl(ttl: number): void
    /**
     * Sets the value of an integer-valued option on `socket,` as with
     * setsockopt(). (If you need to set a non-integer-valued option,
     * you will need to call setsockopt() directly.)
     * 
     * The [<gio/gnetworking.h>][gio-gnetworking.h]
     * header pulls in system headers that will define most of the
     * standard/portable socket options. For unusual socket protocols or
     * platform-dependent options, you may need to include additional
     * headers.
     * @param level the "API level" of the option (eg, `SOL_SOCKET`)
     * @param optname the "name" of the option (eg, `SO_BROADCAST`)
     * @param value the value to set the option to
     * @returns success or failure. On failure, @error will be set, and   the system error value (`errno` or WSAGetLastError()) will still   be set to the result of the setsockopt() call.
     */
    set_option(level: number, optname: number, value: number): boolean
    /**
     * Sets the time in seconds after which I/O operations on `socket` will
     * time out if they have not yet completed.
     * 
     * On a blocking socket, this means that any blocking #GSocket
     * operation will time out after `timeout` seconds of inactivity,
     * returning %G_IO_ERROR_TIMED_OUT.
     * 
     * On a non-blocking socket, calls to g_socket_condition_wait() will
     * also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
     * created with g_socket_create_source() will trigger after
     * `timeout` seconds of inactivity, with the requested condition
     * set, at which point calling g_socket_receive(), g_socket_send(),
     * g_socket_check_connect_result(), etc, will fail with
     * %G_IO_ERROR_TIMED_OUT.
     * 
     * If `timeout` is 0 (the default), operations will never time out
     * on their own.
     * 
     * Note that if an I/O operation is interrupted by a signal, this may
     * cause the timeout to be reset.
     * @param timeout the timeout for `socket,` in seconds, or 0 for none
     */
    set_timeout(timeout: number): void
    /**
     * Sets the time-to-live for outgoing unicast packets on `socket`.
     * By default the platform-specific default value is used.
     * @param ttl the time-to-live value for all unicast packets on `socket`
     */
    set_ttl(ttl: number): void
    /**
     * Shut down part or all of a full-duplex connection.
     * 
     * If `shutdown_read` is %TRUE then the receiving side of the connection
     * is shut down, and further reading is disallowed.
     * 
     * If `shutdown_write` is %TRUE then the sending side of the connection
     * is shut down, and further writing is disallowed.
     * 
     * It is allowed for both `shutdown_read` and `shutdown_write` to be %TRUE.
     * 
     * One example where it is useful to shut down only one side of a connection is
     * graceful disconnect for TCP connections where you close the sending side,
     * then wait for the other side to close the connection, thus ensuring that the
     * other side saw all sent data.
     * @param shutdown_read whether to shut down the read side
     * @param shutdown_write whether to shut down the write side
     * @returns %TRUE on success, %FALSE on error
     */
    shutdown(shutdown_read: boolean, shutdown_write: boolean): boolean
    /**
     * Checks if a socket is capable of speaking IPv4.
     * 
     * IPv4 sockets are capable of speaking IPv4.  On some operating systems
     * and under some combinations of circumstances IPv6 sockets are also
     * capable of speaking IPv4.  See RFC 3493 section 3.7 for more
     * information.
     * 
     * No other types of sockets are currently considered as being capable
     * of speaking IPv4.
     * @returns %TRUE if this socket can be used with IPv4.
     */
    speaks_ipv4(): boolean

    // Class property signals of Gio-2.0.Gio.Socket

    connect(sigName: "notify::blocking", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::blocking", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::blocking", ...args: any[]): void
    connect(sigName: "notify::broadcast", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::broadcast", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::broadcast", ...args: any[]): void
    connect(sigName: "notify::family", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: "notify::fd", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fd", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::fd", ...args: any[]): void
    connect(sigName: "notify::keepalive", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::keepalive", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::keepalive", ...args: any[]): void
    connect(sigName: "notify::listen-backlog", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::listen-backlog", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::listen-backlog", ...args: any[]): void
    connect(sigName: "notify::local-address", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::local-address", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::local-address", ...args: any[]): void
    connect(sigName: "notify::multicast-loopback", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-loopback", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::multicast-loopback", ...args: any[]): void
    connect(sigName: "notify::multicast-ttl", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-ttl", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::multicast-ttl", ...args: any[]): void
    connect(sigName: "notify::protocol", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol", ...args: any[]): void
    connect(sigName: "notify::remote-address", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::remote-address", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::remote-address", ...args: any[]): void
    connect(sigName: "notify::timeout", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeout", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::timeout", ...args: any[]): void
    connect(sigName: "notify::ttl", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ttl", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ttl", ...args: any[]): void
    connect(sigName: "notify::type", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type", callback: (($obj: Socket, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GSocket is a low-level networking primitive. It is a more or less
 * direct mapping of the BSD socket API in a portable GObject based API.
 * It supports both the UNIX socket implementations and winsock2 on Windows.
 * 
 * #GSocket is the platform independent base upon which the higher level
 * network primitives are based. Applications are not typically meant to
 * use it directly, but rather through classes like #GSocketClient,
 * #GSocketService and #GSocketConnection. However there may be cases where
 * direct use of #GSocket is useful.
 * 
 * #GSocket implements the #GInitable interface, so if it is manually constructed
 * by e.g. g_object_new() you must call g_initable_init() and check the
 * results before using the object. This is done automatically in
 * g_socket_new() and g_socket_new_from_fd(), so these functions can return
 * %NULL.
 * 
 * Sockets operate in two general modes, blocking or non-blocking. When
 * in blocking mode all operations (which don’t take an explicit blocking
 * parameter) block until the requested operation
 * is finished or there is an error. In non-blocking mode all calls that
 * would block return immediately with a %G_IO_ERROR_WOULD_BLOCK error.
 * To know when a call would successfully run you can call g_socket_condition_check(),
 * or g_socket_condition_wait(). You can also use g_socket_create_source() and
 * attach it to a #GMainContext to get callbacks when I/O is possible.
 * Note that all sockets are always set to non blocking mode in the system, and
 * blocking mode is emulated in GSocket.
 * 
 * When working in non-blocking mode applications should always be able to
 * handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other
 * function said that I/O was possible. This can easily happen in case
 * of a race condition in the application, but it can also happen for other
 * reasons. For instance, on Windows a socket is always seen as writable
 * until a write returns %G_IO_ERROR_WOULD_BLOCK.
 * 
 * #GSockets can be either connection oriented or datagram based.
 * For connection oriented types you must first establish a connection by
 * either connecting to an address or accepting a connection from another
 * address. For connectionless socket types the target/source address is
 * specified or received in each I/O operation.
 * 
 * All socket file descriptors are set to be close-on-exec.
 * 
 * Note that creating a #GSocket causes the signal %SIGPIPE to be
 * ignored for the remainder of the program. If you are writing a
 * command-line utility that uses #GSocket, you may need to take into
 * account the fact that your program will not automatically be killed
 * if it tries to write to %stdout after it has been closed.
 * 
 * Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
 * a #GSocket concurrently from multiple threads, you must implement your own
 * locking.
 * @class 
 */
class Socket extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Socket

    static name: string
    static $gtype: GObject.GType<Socket>

    // Constructors of Gio-2.0.Gio.Socket

    constructor(config?: Socket.ConstructorProperties) 
    /**
     * Creates a new #GSocket with the defined family, type and protocol.
     * If `protocol` is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
     * for the family and type is used.
     * 
     * The `protocol` is a family and type specific int that specifies what
     * kind of protocol to use. #GSocketProtocol lists several common ones.
     * Many families only support one protocol, and use 0 for this, others
     * support several and using 0 means to use the default protocol for
     * the family and type.
     * 
     * The protocol id is passed directly to the operating
     * system, so you can use protocols not listed in #GSocketProtocol if you
     * know the protocol number used for it.
     * @constructor 
     * @param family the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4.
     * @param type the socket type to use.
     * @param protocol the id of the protocol to use, or 0 for default.
     * @returns a #GSocket or %NULL on error.     Free the returned object with g_object_unref().
     */
    constructor(family: SocketFamily, type: SocketType, protocol: SocketProtocol) 
    /**
     * Creates a new #GSocket with the defined family, type and protocol.
     * If `protocol` is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
     * for the family and type is used.
     * 
     * The `protocol` is a family and type specific int that specifies what
     * kind of protocol to use. #GSocketProtocol lists several common ones.
     * Many families only support one protocol, and use 0 for this, others
     * support several and using 0 means to use the default protocol for
     * the family and type.
     * 
     * The protocol id is passed directly to the operating
     * system, so you can use protocols not listed in #GSocketProtocol if you
     * know the protocol number used for it.
     * @constructor 
     * @param family the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4.
     * @param type the socket type to use.
     * @param protocol the id of the protocol to use, or 0 for default.
     * @returns a #GSocket or %NULL on error.     Free the returned object with g_object_unref().
     */
    static new(family: SocketFamily, type: SocketType, protocol: SocketProtocol): Socket
    /**
     * Creates a new #GSocket from a native file descriptor
     * or winsock SOCKET handle.
     * 
     * This reads all the settings from the file descriptor so that
     * all properties should work. Note that the file descriptor
     * will be set to non-blocking mode, independent on the blocking
     * mode of the #GSocket.
     * 
     * On success, the returned #GSocket takes ownership of `fd`. On failure, the
     * caller must close `fd` themselves.
     * 
     * Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
     * descriptor.  Instead, a GError will be set with code %G_IO_ERROR_FAILED
     * @constructor 
     * @param fd a native socket file descriptor.
     * @returns a #GSocket or %NULL on error.     Free the returned object with g_object_unref().
     */
    static new_from_fd(fd: number): Socket
    _init(config?: Socket.ConstructorProperties): void
}

module SocketAddress {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnectable.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface SocketAddress extends SocketConnectable {

    // Own properties of Gio-2.0.Gio.SocketAddress

    readonly family: SocketFamily

    // Own fields of Gio-2.0.Gio.SocketAddress

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.SocketAddress

    /**
     * Gets the socket family type of `address`.
     * @returns the socket family type of @address
     */
    get_family(): SocketFamily
    /**
     * Gets the size of `address'`s native struct sockaddr.
     * You can use this to allocate memory to pass to
     * g_socket_address_to_native().
     * @returns the size of the native struct sockaddr that     @address represents
     */
    get_native_size(): number
    /**
     * Converts a #GSocketAddress to a native struct sockaddr, which can
     * be passed to low-level functions like connect() or bind().
     * 
     * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
     * is returned. If the address type is not known on the system
     * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
     * @param dest a pointer to a memory location that will contain the native struct sockaddr
     * @param destlen the size of `dest`. Must be at least as large as     g_socket_address_get_native_size()
     * @returns %TRUE if @dest was filled in, %FALSE on error
     */
    to_native(dest: any | null, destlen: number): boolean

    // Own virtual methods of Gio-2.0.Gio.SocketAddress

    /**
     * Gets the socket family type of `address`.
     * @virtual 
     * @returns the socket family type of @address
     */
    vfunc_get_family(): SocketFamily
    /**
     * Gets the size of `address'`s native struct sockaddr.
     * You can use this to allocate memory to pass to
     * g_socket_address_to_native().
     * @virtual 
     * @returns the size of the native struct sockaddr that     @address represents
     */
    vfunc_get_native_size(): number
    /**
     * Converts a #GSocketAddress to a native struct sockaddr, which can
     * be passed to low-level functions like connect() or bind().
     * 
     * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
     * is returned. If the address type is not known on the system
     * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
     * @virtual 
     * @param dest a pointer to a memory location that will contain the native struct sockaddr
     * @param destlen the size of `dest`. Must be at least as large as     g_socket_address_get_native_size()
     * @returns %TRUE if @dest was filled in, %FALSE on error
     */
    vfunc_to_native(dest: any | null, destlen: number): boolean

    // Class property signals of Gio-2.0.Gio.SocketAddress

    connect(sigName: "notify::family", callback: (($obj: SocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: SocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSocketAddress is the equivalent of struct sockaddr in the BSD
 * sockets API. This is an abstract class; use #GInetSocketAddress
 * for internet sockets, or #GUnixSocketAddress for UNIX domain sockets.
 * @class 
 */
class SocketAddress extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SocketAddress

    static name: string
    static $gtype: GObject.GType<SocketAddress>

    // Constructors of Gio-2.0.Gio.SocketAddress

    constructor(config?: SocketAddress.ConstructorProperties) 
    /**
     * Creates a #GSocketAddress subclass corresponding to the native
     * struct sockaddr `native`.
     * @constructor 
     * @param native a pointer to a struct sockaddr
     * @param len the size of the memory location pointed to by `native`
     * @returns a new #GSocketAddress if @native could successfully     be converted, otherwise %NULL
     */
    static new_from_native(native: any, len: number): SocketAddress
    _init(config?: SocketAddress.ConstructorProperties): void
}

module SocketAddressEnumerator {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface SocketAddressEnumerator {

    // Owm methods of Gio-2.0.Gio.SocketAddressEnumerator

    /**
     * Retrieves the next #GSocketAddress from `enumerator`. Note that this
     * may block for some amount of time. (Eg, a #GNetworkAddress may need
     * to do a DNS lookup before it can return an address.) Use
     * g_socket_address_enumerator_next_async() if you need to avoid
     * blocking.
     * 
     * If `enumerator` is expected to yield addresses, but for some reason
     * is unable to (eg, because of a DNS error), then the first call to
     * g_socket_address_enumerator_next() will return an appropriate error
     * in *`error`. However, if the first call to
     * g_socket_address_enumerator_next() succeeds, then any further
     * internal errors (other than `cancellable` being triggered) will be
     * ignored.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
     */
    next(cancellable: Cancellable | null): SocketAddress | null
    /**
     * Asynchronously retrieves the next #GSocketAddress from `enumerator`
     * and then calls `callback,` which must call
     * g_socket_address_enumerator_next_finish() to get the result.
     * 
     * It is an error to call this multiple times before the previous callback has finished.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request     is satisfied
     */
    next_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of next_async

    /**
     * Promisified version of {@link next_async}
     * 
     * Asynchronously retrieves the next #GSocketAddress from `enumerator`
     * and then calls `callback,` which must call
     * g_socket_address_enumerator_next_finish() to get the result.
     * 
     * It is an error to call this multiple times before the previous callback has finished.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
     */
    next_async(cancellable: Cancellable | null): globalThis.Promise<SocketAddress | null>
    /**
     * Retrieves the result of a completed call to
     * g_socket_address_enumerator_next_async(). See
     * g_socket_address_enumerator_next() for more information about
     * error handling.
     * @param result a #GAsyncResult
     * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
     */
    next_finish(result: AsyncResult): SocketAddress | null

    // Own virtual methods of Gio-2.0.Gio.SocketAddressEnumerator

    /**
     * Retrieves the next #GSocketAddress from `enumerator`. Note that this
     * may block for some amount of time. (Eg, a #GNetworkAddress may need
     * to do a DNS lookup before it can return an address.) Use
     * g_socket_address_enumerator_next_async() if you need to avoid
     * blocking.
     * 
     * If `enumerator` is expected to yield addresses, but for some reason
     * is unable to (eg, because of a DNS error), then the first call to
     * g_socket_address_enumerator_next() will return an appropriate error
     * in *`error`. However, if the first call to
     * g_socket_address_enumerator_next() succeeds, then any further
     * internal errors (other than `cancellable` being triggered) will be
     * ignored.
     * @virtual 
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
     */
    vfunc_next(cancellable: Cancellable | null): SocketAddress | null
    /**
     * Asynchronously retrieves the next #GSocketAddress from `enumerator`
     * and then calls `callback,` which must call
     * g_socket_address_enumerator_next_finish() to get the result.
     * 
     * It is an error to call this multiple times before the previous callback has finished.
     * @virtual 
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request     is satisfied
     */
    vfunc_next_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Retrieves the result of a completed call to
     * g_socket_address_enumerator_next_async(). See
     * g_socket_address_enumerator_next() for more information about
     * error handling.
     * @virtual 
     * @param result a #GAsyncResult
     * @returns a #GSocketAddress (owned by the caller), or %NULL on     error (in which case *@error will be set) or if there are no     more addresses.
     */
    vfunc_next_finish(result: AsyncResult): SocketAddress | null

    // Class property signals of Gio-2.0.Gio.SocketAddressEnumerator

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSocketAddressEnumerator is an enumerator type for #GSocketAddress
 * instances. It is returned by enumeration functions such as
 * g_socket_connectable_enumerate(), which returns a #GSocketAddressEnumerator
 * to list each #GSocketAddress which could be used to connect to that
 * #GSocketConnectable.
 * 
 * Enumeration is typically a blocking operation, so the asynchronous methods
 * g_socket_address_enumerator_next_async() and
 * g_socket_address_enumerator_next_finish() should be used where possible.
 * 
 * Each #GSocketAddressEnumerator can only be enumerated once. Once
 * g_socket_address_enumerator_next() has returned %NULL, further
 * enumeration with that #GSocketAddressEnumerator is not possible, and it can
 * be unreffed.
 * @class 
 */
class SocketAddressEnumerator extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SocketAddressEnumerator

    static name: string
    static $gtype: GObject.GType<SocketAddressEnumerator>

    // Constructors of Gio-2.0.Gio.SocketAddressEnumerator

    constructor(config?: SocketAddressEnumerator.ConstructorProperties) 
    _init(config?: SocketAddressEnumerator.ConstructorProperties): void
}

module SocketClient {

    // Signal callback interfaces

    /**
     * Signal callback interface for `event`
     */
    interface EventSignalCallback {
        ($obj: SocketClient, event: SocketClientEvent, connectable: SocketConnectable, connection: IOStream | null): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.SocketClient

        enable_proxy?: boolean | null
        family?: SocketFamily | null
        local_address?: SocketAddress | null
        protocol?: SocketProtocol | null
        /**
         * The proxy resolver to use
         */
        proxy_resolver?: ProxyResolver | null
        timeout?: number | null
        tls?: boolean | null
        /**
         * The TLS validation flags used when creating TLS connections. The
         * default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
         * 
         * GLib guarantees that if certificate verification fails, at least one
         * flag will be set, but it does not guarantee that all possible flags
         * will be set. Accordingly, you may not safely decide to ignore any
         * particular type of error. For example, it would be incorrect to mask
         * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
         * because this could potentially be the only error flag set even if
         * other problems exist with the certificate. Therefore, there is no
         * safe way to use this property. This is not a horrible problem,
         * though, because you should not be attempting to ignore validation
         * errors anyway. If you really must ignore TLS certificate errors,
         * connect to the #GSocketClient::event signal, wait for it to be
         * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, and use that to
         * connect to #GTlsConnection::accept-certificate.
         */
        tls_validation_flags?: TlsCertificateFlags | null
        type?: SocketType | null
    }

}

interface SocketClient {

    // Own properties of Gio-2.0.Gio.SocketClient

    enable_proxy: boolean
    family: SocketFamily
    local_address: SocketAddress
    protocol: SocketProtocol
    /**
     * The proxy resolver to use
     */
    proxy_resolver: ProxyResolver
    timeout: number
    tls: boolean
    /**
     * The TLS validation flags used when creating TLS connections. The
     * default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
     * 
     * GLib guarantees that if certificate verification fails, at least one
     * flag will be set, but it does not guarantee that all possible flags
     * will be set. Accordingly, you may not safely decide to ignore any
     * particular type of error. For example, it would be incorrect to mask
     * %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
     * because this could potentially be the only error flag set even if
     * other problems exist with the certificate. Therefore, there is no
     * safe way to use this property. This is not a horrible problem,
     * though, because you should not be attempting to ignore validation
     * errors anyway. If you really must ignore TLS certificate errors,
     * connect to the #GSocketClient::event signal, wait for it to be
     * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, and use that to
     * connect to #GTlsConnection::accept-certificate.
     */
    tls_validation_flags: TlsCertificateFlags
    type: SocketType

    // Own fields of Gio-2.0.Gio.SocketClient

    parent_instance: GObject.Object
    priv: SocketClientPrivate

    // Owm methods of Gio-2.0.Gio.SocketClient

    /**
     * Enable proxy protocols to be handled by the application. When the
     * indicated proxy protocol is returned by the #GProxyResolver,
     * #GSocketClient will consider this protocol as supported but will
     * not try to find a #GProxy instance to handle handshaking. The
     * application must check for this case by calling
     * g_socket_connection_get_remote_address() on the returned
     * #GSocketConnection, and seeing if it's a #GProxyAddress of the
     * appropriate type, to determine whether or not it needs to handle
     * the proxy handshaking itself.
     * 
     * This should be used for proxy protocols that are dialects of
     * another protocol such as HTTP proxy. It also allows cohabitation of
     * proxy protocols that are reused between protocols. A good example
     * is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
     * be use as generic socket proxy through the HTTP CONNECT method.
     * 
     * When the proxy is detected as being an application proxy, TLS handshake
     * will be skipped. This is required to let the application do the proxy
     * specific handshake.
     * @param protocol The proxy protocol
     */
    add_application_proxy(protocol: string | null): void
    /**
     * Tries to resolve the `connectable` and make a network connection to it.
     * 
     * Upon a successful connection, a new #GSocketConnection is constructed
     * and returned.  The caller owns this new object and must drop their
     * reference to it when finished with it.
     * 
     * The type of the #GSocketConnection object returned depends on the type of
     * the underlying socket that is used. For instance, for a TCP/IP connection
     * it will be a #GTcpConnection.
     * 
     * The socket created will be the same family as the address that the
     * `connectable` resolves to, unless family is set with g_socket_client_set_family()
     * or indirectly via g_socket_client_set_local_address(). The socket type
     * defaults to %G_SOCKET_TYPE_STREAM but can be set with
     * g_socket_client_set_socket_type().
     * 
     * If a local address is specified with g_socket_client_set_local_address() the
     * socket will be bound to this address before connecting.
     * @param connectable a #GSocketConnectable specifying the remote address.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    connect(connectable: SocketConnectable, cancellable: Cancellable | null): SocketConnection
    /**
     * This is the asynchronous version of g_socket_client_connect().
     * 
     * You may wish to prefer the asynchronous version even in synchronous
     * command line programs because, since 2.60, it implements
     * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
     * recommendations to work around long connection timeouts in networks
     * where IPv6 is broken by performing an IPv4 connection simultaneously
     * without waiting for IPv6 to time out, which is not supported by the
     * synchronous call. (This is not an API guarantee, and may change in
     * the future.)
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_client_connect_finish() to get
     * the result of the operation.
     * @param connectable a #GSocketConnectable specifying the remote address.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback
     */
    connect_async(connectable: SocketConnectable, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of connect_async

    /**
     * Promisified version of {@link connect_async}
     * 
     * This is the asynchronous version of g_socket_client_connect().
     * 
     * You may wish to prefer the asynchronous version even in synchronous
     * command line programs because, since 2.60, it implements
     * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
     * recommendations to work around long connection timeouts in networks
     * where IPv6 is broken by performing an IPv4 connection simultaneously
     * without waiting for IPv6 to time out, which is not supported by the
     * synchronous call. (This is not an API guarantee, and may change in
     * the future.)
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_client_connect_finish() to get
     * the result of the operation.
     * @param connectable a #GSocketConnectable specifying the remote address.
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
     */
    connect_async(connectable: SocketConnectable, cancellable: Cancellable | null): globalThis.Promise<SocketConnection>
    /**
     * Finishes an async connect operation. See g_socket_client_connect_async()
     * @param result a #GAsyncResult.
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    connect_finish(result: AsyncResult): SocketConnection
    /**
     * This is a helper function for g_socket_client_connect().
     * 
     * Attempts to create a TCP connection to the named host.
     * 
     * `host_and_port` may be in any of a number of recognized formats; an IPv6
     * address, an IPv4 address, or a domain name (in which case a DNS
     * lookup is performed).  Quoting with [] is supported for all address
     * types.  A port override may be specified in the usual way with a
     * colon.  Ports may be given as decimal numbers or symbolic names (in
     * which case an /etc/services lookup is performed).
     * 
     * If no port override is given in `host_and_port` then `default_port` will be
     * used as the port number to connect to.
     * 
     * In general, `host_and_port` is expected to be provided by the user (allowing
     * them to give the hostname, and a port override if necessary) and
     * `default_port` is expected to be provided by the application.
     * 
     * In the case that an IP address is given, a single connection
     * attempt is made.  In the case that a name is given, multiple
     * connection attempts may be made, in turn and according to the
     * number of address records in DNS, until a connection succeeds.
     * 
     * Upon a successful connection, a new #GSocketConnection is constructed
     * and returned.  The caller owns this new object and must drop their
     * reference to it when finished with it.
     * 
     * In the event of any failure (DNS error, service not found, no hosts
     * connectable) %NULL is returned and `error` (if non-%NULL) is set
     * accordingly.
     * @param host_and_port the name and optionally port of the host to connect to
     * @param default_port the default port to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    connect_to_host(host_and_port: string | null, default_port: number, cancellable: Cancellable | null): SocketConnection
    /**
     * This is the asynchronous version of g_socket_client_connect_to_host().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_client_connect_to_host_finish() to get
     * the result of the operation.
     * @param host_and_port the name and optionally the port of the host to connect to
     * @param default_port the default port to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback
     */
    connect_to_host_async(host_and_port: string | null, default_port: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of connect_to_host_async

    /**
     * Promisified version of {@link connect_to_host_async}
     * 
     * This is the asynchronous version of g_socket_client_connect_to_host().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_client_connect_to_host_finish() to get
     * the result of the operation.
     * @param host_and_port the name and optionally the port of the host to connect to
     * @param default_port the default port to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
     */
    connect_to_host_async(host_and_port: string | null, default_port: number, cancellable: Cancellable | null): globalThis.Promise<SocketConnection>
    /**
     * Finishes an async connect operation. See g_socket_client_connect_to_host_async()
     * @param result a #GAsyncResult.
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    connect_to_host_finish(result: AsyncResult): SocketConnection
    /**
     * Attempts to create a TCP connection to a service.
     * 
     * This call looks up the SRV record for `service` at `domain` for the
     * "tcp" protocol.  It then attempts to connect, in turn, to each of
     * the hosts providing the service until either a connection succeeds
     * or there are no hosts remaining.
     * 
     * Upon a successful connection, a new #GSocketConnection is constructed
     * and returned.  The caller owns this new object and must drop their
     * reference to it when finished with it.
     * 
     * In the event of any failure (DNS error, service not found, no hosts
     * connectable) %NULL is returned and `error` (if non-%NULL) is set
     * accordingly.
     * @param domain a domain name
     * @param service the name of the service to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns a #GSocketConnection if successful, or %NULL on error
     */
    connect_to_service(domain: string | null, service: string | null, cancellable: Cancellable | null): SocketConnection
    /**
     * This is the asynchronous version of
     * g_socket_client_connect_to_service().
     * @param domain a domain name
     * @param service the name of the service to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback
     */
    connect_to_service_async(domain: string | null, service: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of connect_to_service_async

    /**
     * Promisified version of {@link connect_to_service_async}
     * 
     * This is the asynchronous version of
     * g_socket_client_connect_to_service().
     * @param domain a domain name
     * @param service the name of the service to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
     */
    connect_to_service_async(domain: string | null, service: string | null, cancellable: Cancellable | null): globalThis.Promise<SocketConnection>
    /**
     * Finishes an async connect operation. See g_socket_client_connect_to_service_async()
     * @param result a #GAsyncResult.
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    connect_to_service_finish(result: AsyncResult): SocketConnection
    /**
     * This is a helper function for g_socket_client_connect().
     * 
     * Attempts to create a TCP connection with a network URI.
     * 
     * `uri` may be any valid URI containing an "authority" (hostname/port)
     * component. If a port is not specified in the URI, `default_port`
     * will be used. TLS will be negotiated if #GSocketClient:tls is %TRUE.
     * (#GSocketClient does not know to automatically assume TLS for
     * certain URI schemes.)
     * 
     * Using this rather than g_socket_client_connect() or
     * g_socket_client_connect_to_host() allows #GSocketClient to
     * determine when to use application-specific proxy protocols.
     * 
     * Upon a successful connection, a new #GSocketConnection is constructed
     * and returned.  The caller owns this new object and must drop their
     * reference to it when finished with it.
     * 
     * In the event of any failure (DNS error, service not found, no hosts
     * connectable) %NULL is returned and `error` (if non-%NULL) is set
     * accordingly.
     * @param uri A network URI
     * @param default_port the default port to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    connect_to_uri(uri: string | null, default_port: number, cancellable: Cancellable | null): SocketConnection
    /**
     * This is the asynchronous version of g_socket_client_connect_to_uri().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_client_connect_to_uri_finish() to get
     * the result of the operation.
     * @param uri a network uri
     * @param default_port the default port to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback
     */
    connect_to_uri_async(uri: string | null, default_port: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of connect_to_uri_async

    /**
     * Promisified version of {@link connect_to_uri_async}
     * 
     * This is the asynchronous version of g_socket_client_connect_to_uri().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_client_connect_to_uri_finish() to get
     * the result of the operation.
     * @param uri a network uri
     * @param default_port the default port to connect to
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
     */
    connect_to_uri_async(uri: string | null, default_port: number, cancellable: Cancellable | null): globalThis.Promise<SocketConnection>
    /**
     * Finishes an async connect operation. See g_socket_client_connect_to_uri_async()
     * @param result a #GAsyncResult.
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    connect_to_uri_finish(result: AsyncResult): SocketConnection
    /**
     * Gets the proxy enable state; see g_socket_client_set_enable_proxy()
     * @returns whether proxying is enabled
     */
    get_enable_proxy(): boolean
    /**
     * Gets the socket family of the socket client.
     * 
     * See g_socket_client_set_family() for details.
     * @returns a #GSocketFamily
     */
    get_family(): SocketFamily
    /**
     * Gets the local address of the socket client.
     * 
     * See g_socket_client_set_local_address() for details.
     * @returns a #GSocketAddress or %NULL. Do not free.
     */
    get_local_address(): SocketAddress | null
    /**
     * Gets the protocol name type of the socket client.
     * 
     * See g_socket_client_set_protocol() for details.
     * @returns a #GSocketProtocol
     */
    get_protocol(): SocketProtocol
    /**
     * Gets the #GProxyResolver being used by `client`. Normally, this will
     * be the resolver returned by g_proxy_resolver_get_default(), but you
     * can override it with g_socket_client_set_proxy_resolver().
     * @returns The #GProxyResolver being used by   @client.
     */
    get_proxy_resolver(): ProxyResolver
    /**
     * Gets the socket type of the socket client.
     * 
     * See g_socket_client_set_socket_type() for details.
     * @returns a #GSocketFamily
     */
    get_socket_type(): SocketType
    /**
     * Gets the I/O timeout time for sockets created by `client`.
     * 
     * See g_socket_client_set_timeout() for details.
     * @returns the timeout in seconds
     */
    get_timeout(): number
    /**
     * Gets whether `client` creates TLS connections. See
     * g_socket_client_set_tls() for details.
     * @returns whether @client uses TLS
     */
    get_tls(): boolean
    /**
     * Gets the TLS validation flags used creating TLS connections via
     * `client`.
     * 
     * This function does not work as originally designed and is impossible
     * to use correctly. See #GSocketClient:tls-validation-flags for more
     * information.
     * @returns the TLS validation flags
     */
    get_tls_validation_flags(): TlsCertificateFlags
    /**
     * Sets whether or not `client` attempts to make connections via a
     * proxy server. When enabled (the default), #GSocketClient will use a
     * #GProxyResolver to determine if a proxy protocol such as SOCKS is
     * needed, and automatically do the necessary proxy negotiation.
     * 
     * See also g_socket_client_set_proxy_resolver().
     * @param enable whether to enable proxies
     */
    set_enable_proxy(enable: boolean): void
    /**
     * Sets the socket family of the socket client.
     * If this is set to something other than %G_SOCKET_FAMILY_INVALID
     * then the sockets created by this object will be of the specified
     * family.
     * 
     * This might be useful for instance if you want to force the local
     * connection to be an ipv4 socket, even though the address might
     * be an ipv6 mapped to ipv4 address.
     * @param family a #GSocketFamily
     */
    set_family(family: SocketFamily): void
    /**
     * Sets the local address of the socket client.
     * The sockets created by this object will bound to the
     * specified address (if not %NULL) before connecting.
     * 
     * This is useful if you want to ensure that the local
     * side of the connection is on a specific port, or on
     * a specific interface.
     * @param address a #GSocketAddress, or %NULL
     */
    set_local_address(address: SocketAddress | null): void
    /**
     * Sets the protocol of the socket client.
     * The sockets created by this object will use of the specified
     * protocol.
     * 
     * If `protocol` is %G_SOCKET_PROTOCOL_DEFAULT that means to use the default
     * protocol for the socket family and type.
     * @param protocol a #GSocketProtocol
     */
    set_protocol(protocol: SocketProtocol): void
    /**
     * Overrides the #GProxyResolver used by `client`. You can call this if
     * you want to use specific proxies, rather than using the system
     * default proxy settings.
     * 
     * Note that whether or not the proxy resolver is actually used
     * depends on the setting of #GSocketClient:enable-proxy, which is not
     * changed by this function (but which is %TRUE by default)
     * @param proxy_resolver a #GProxyResolver, or %NULL for the   default.
     */
    set_proxy_resolver(proxy_resolver: ProxyResolver | null): void
    /**
     * Sets the socket type of the socket client.
     * The sockets created by this object will be of the specified
     * type.
     * 
     * It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
     * as GSocketClient is used for connection oriented services.
     * @param type a #GSocketType
     */
    set_socket_type(type: SocketType): void
    /**
     * Sets the I/O timeout for sockets created by `client`. `timeout` is a
     * time in seconds, or 0 for no timeout (the default).
     * 
     * The timeout value affects the initial connection attempt as well,
     * so setting this may cause calls to g_socket_client_connect(), etc,
     * to fail with %G_IO_ERROR_TIMED_OUT.
     * @param timeout the timeout
     */
    set_timeout(timeout: number): void
    /**
     * Sets whether `client` creates TLS (aka SSL) connections. If `tls` is
     * %TRUE, `client` will wrap its connections in a #GTlsClientConnection
     * and perform a TLS handshake when connecting.
     * 
     * Note that since #GSocketClient must return a #GSocketConnection,
     * but #GTlsClientConnection is not a #GSocketConnection, this
     * actually wraps the resulting #GTlsClientConnection in a
     * #GTcpWrapperConnection when returning it. You can use
     * g_tcp_wrapper_connection_get_base_io_stream() on the return value
     * to extract the #GTlsClientConnection.
     * 
     * If you need to modify the behavior of the TLS handshake (eg, by
     * setting a client-side certificate to use, or connecting to the
     * #GTlsConnection::accept-certificate signal), you can connect to
     * `client'`s #GSocketClient::event signal and wait for it to be
     * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
     * a chance to see the #GTlsClientConnection before the handshake
     * starts.
     * @param tls whether to use TLS
     */
    set_tls(tls: boolean): void
    /**
     * Sets the TLS validation flags used when creating TLS connections
     * via `client`. The default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
     * 
     * This function does not work as originally designed and is impossible
     * to use correctly. See #GSocketClient:tls-validation-flags for more
     * information.
     * @param flags the validation flags
     */
    set_tls_validation_flags(flags: TlsCertificateFlags): void

    // Own virtual methods of Gio-2.0.Gio.SocketClient

    vfunc_event(event: SocketClientEvent, connectable: SocketConnectable, connection: IOStream): void

    // Own signals of Gio-2.0.Gio.SocketClient

    connect(sigName: "event", callback: SocketClient.EventSignalCallback): number
    connect_after(sigName: "event", callback: SocketClient.EventSignalCallback): number
    emit(sigName: "event", event: SocketClientEvent, connectable: SocketConnectable, connection: IOStream | null, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.SocketClient

    connect(sigName: "notify::enable-proxy", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enable-proxy", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::enable-proxy", ...args: any[]): void
    connect(sigName: "notify::family", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: "notify::local-address", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::local-address", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::local-address", ...args: any[]): void
    connect(sigName: "notify::protocol", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol", ...args: any[]): void
    connect(sigName: "notify::proxy-resolver", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy-resolver", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::proxy-resolver", ...args: any[]): void
    connect(sigName: "notify::timeout", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeout", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::timeout", ...args: any[]): void
    connect(sigName: "notify::tls", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tls", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::tls", ...args: any[]): void
    connect(sigName: "notify::tls-validation-flags", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tls-validation-flags", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::tls-validation-flags", ...args: any[]): void
    connect(sigName: "notify::type", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type", callback: (($obj: SocketClient, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSocketClient is a lightweight high-level utility class for connecting to
 * a network host using a connection oriented socket type.
 * 
 * You create a #GSocketClient object, set any options you want, and then
 * call a sync or async connect operation, which returns a #GSocketConnection
 * subclass on success.
 * 
 * The type of the #GSocketConnection object returned depends on the type of
 * the underlying socket that is in use. For instance, for a TCP/IP connection
 * it will be a #GTcpConnection.
 * 
 * As #GSocketClient is a lightweight object, you don't need to cache it. You
 * can just create a new one any time you need one.
 * @class 
 */
class SocketClient extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SocketClient

    static name: string
    static $gtype: GObject.GType<SocketClient>

    // Constructors of Gio-2.0.Gio.SocketClient

    constructor(config?: SocketClient.ConstructorProperties) 
    /**
     * Creates a new #GSocketClient with the default options.
     * @constructor 
     * @returns a #GSocketClient.     Free the returned object with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new #GSocketClient with the default options.
     * @constructor 
     * @returns a #GSocketClient.     Free the returned object with g_object_unref().
     */
    static new(): SocketClient
    _init(config?: SocketClient.ConstructorProperties): void
}

module SocketConnection {

    // Constructor properties interface

    interface ConstructorProperties extends IOStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.SocketConnection

        socket?: Socket | null
    }

}

interface SocketConnection {

    // Own properties of Gio-2.0.Gio.SocketConnection

    readonly socket: Socket

    // Own fields of Gio-2.0.Gio.SocketConnection

    parent_instance: IOStream & GObject.Object
    priv: SocketConnectionPrivate

    // Owm methods of Gio-2.0.Gio.SocketConnection

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    /**
     * Asynchronously connect `connection` to the specified remote address.
     * 
     * This clears the #GSocket:blocking flag on `connection'`s underlying
     * socket if it is currently set.
     * 
     * Use g_socket_connection_connect_finish() to retrieve the result.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @param callback a #GAsyncReadyCallback
     */
    connect_async(address: SocketAddress, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of connect_async

    /**
     * Promisified version of {@link connect_async}
     * 
     * Asynchronously connect `connection` to the specified remote address.
     * 
     * This clears the #GSocket:blocking flag on `connection'`s underlying
     * socket if it is currently set.
     * 
     * Use g_socket_connection_connect_finish() to retrieve the result.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns A Promise of: %TRUE if the connection succeeded, %FALSE on error
     */
    connect_async(address: SocketAddress, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Gets the result of a g_socket_connection_connect_async() call.
     * @param result the #GAsyncResult
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect_finish(result: AsyncResult): boolean
    /**
     * Try to get the local address of a socket connection.
     * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
     */
    get_local_address(): SocketAddress
    /**
     * Try to get the remote address of a socket connection.
     * 
     * Since GLib 2.40, when used with g_socket_client_connect() or
     * g_socket_client_connect_async(), during emission of
     * %G_SOCKET_CLIENT_CONNECTING, this function will return the remote
     * address that will be used for the connection.  This allows
     * applications to print e.g. "Connecting to example.com
     * (10.42.77.3)...".
     * @returns a #GSocketAddress or %NULL on error.     Free the returned object with g_object_unref().
     */
    get_remote_address(): SocketAddress
    /**
     * Gets the underlying #GSocket object of the connection.
     * This can be useful if you want to do something unusual on it
     * not supported by the #GSocketConnection APIs.
     * @returns a #GSocket or %NULL on error.
     */
    get_socket(): Socket
    /**
     * Checks if `connection` is connected. This is equivalent to calling
     * g_socket_is_connected() on `connection'`s underlying #GSocket.
     * @returns whether @connection is connected
     */
    is_connected(): boolean

    // Class property signals of Gio-2.0.Gio.SocketConnection

    connect(sigName: "notify::socket", callback: (($obj: SocketConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::socket", callback: (($obj: SocketConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::socket", ...args: any[]): void
    connect(sigName: "notify::closed", callback: (($obj: SocketConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::closed", callback: (($obj: SocketConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: "notify::input-stream", callback: (($obj: SocketConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::input-stream", callback: (($obj: SocketConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::input-stream", ...args: any[]): void
    connect(sigName: "notify::output-stream", callback: (($obj: SocketConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::output-stream", callback: (($obj: SocketConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::output-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSocketConnection is a #GIOStream for a connected socket. They
 * can be created either by #GSocketClient when connecting to a host,
 * or by #GSocketListener when accepting a new client.
 * 
 * The type of the #GSocketConnection object returned from these calls
 * depends on the type of the underlying socket that is in use. For
 * instance, for a TCP/IP connection it will be a #GTcpConnection.
 * 
 * Choosing what type of object to construct is done with the socket
 * connection factory, and it is possible for 3rd parties to register
 * custom socket connection types for specific combination of socket
 * family/type/protocol using g_socket_connection_factory_register_type().
 * 
 * To close a #GSocketConnection, use g_io_stream_close(). Closing both
 * substreams of the #GIOStream separately will not close the underlying
 * #GSocket.
 * @class 
 */
class SocketConnection extends IOStream {

    // Own properties of Gio-2.0.Gio.SocketConnection

    static name: string
    static $gtype: GObject.GType<SocketConnection>

    // Constructors of Gio-2.0.Gio.SocketConnection

    constructor(config?: SocketConnection.ConstructorProperties) 
    _init(config?: SocketConnection.ConstructorProperties): void
    /**
     * Looks up the #GType to be used when creating socket connections on
     * sockets with the specified `family,` `type` and `protocol_id`.
     * 
     * If no type is registered, the #GSocketConnection base type is returned.
     * @param family a #GSocketFamily
     * @param type a #GSocketType
     * @param protocol_id a protocol id
     * @returns a #GType
     */
    static factory_lookup_type(family: SocketFamily, type: SocketType, protocol_id: number): GObject.GType
    /**
     * Looks up the #GType to be used when creating socket connections on
     * sockets with the specified `family,` `type` and `protocol`.
     * 
     * If no type is registered, the #GSocketConnection base type is returned.
     * @param g_type a #GType, inheriting from %G_TYPE_SOCKET_CONNECTION
     * @param family a #GSocketFamily
     * @param type a #GSocketType
     * @param protocol a protocol id
     */
    static factory_register_type(g_type: GObject.GType, family: SocketFamily, type: SocketType, protocol: number): void
}

module SocketControlMessage {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface SocketControlMessage {

    // Own fields of Gio-2.0.Gio.SocketControlMessage

    parent_instance: GObject.Object
    priv: SocketControlMessagePrivate

    // Owm methods of Gio-2.0.Gio.SocketControlMessage

    /**
     * Returns the "level" (i.e. the originating protocol) of the control message.
     * This is often SOL_SOCKET.
     * @returns an integer describing the level
     */
    get_level(): number
    /**
     * Returns the protocol specific type of the control message.
     * For instance, for UNIX fd passing this would be SCM_RIGHTS.
     * @returns an integer describing the type of control message
     */
    get_msg_type(): number
    /**
     * Returns the space required for the control message, not including
     * headers or alignment.
     * @returns The number of bytes required.
     */
    get_size(): number
    /**
     * Converts the data in the message to bytes placed in the
     * message.
     * 
     * `data` is guaranteed to have enough space to fit the size
     * returned by g_socket_control_message_get_size() on this
     * object.
     * @param data A buffer to write data to
     */
    serialize(data: any): void

    // Own virtual methods of Gio-2.0.Gio.SocketControlMessage

    /**
     * Returns the "level" (i.e. the originating protocol) of the control message.
     * This is often SOL_SOCKET.
     * @virtual 
     * @returns an integer describing the level
     */
    vfunc_get_level(): number
    /**
     * Returns the space required for the control message, not including
     * headers or alignment.
     * @virtual 
     * @returns The number of bytes required.
     */
    vfunc_get_size(): number
    vfunc_get_type(): number
    /**
     * Converts the data in the message to bytes placed in the
     * message.
     * 
     * `data` is guaranteed to have enough space to fit the size
     * returned by g_socket_control_message_get_size() on this
     * object.
     * @virtual 
     * @param data A buffer to write data to
     */
    vfunc_serialize(data: any): void

    // Class property signals of Gio-2.0.Gio.SocketControlMessage

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GSocketControlMessage is a special-purpose utility message that
 * can be sent to or received from a #GSocket. These types of
 * messages are often called "ancillary data".
 * 
 * The message can represent some sort of special instruction to or
 * information from the socket or can represent a special kind of
 * transfer to the peer (for example, sending a file descriptor over
 * a UNIX socket).
 * 
 * These messages are sent with g_socket_send_message() and received
 * with g_socket_receive_message().
 * 
 * To extend the set of control message that can be sent, subclass this
 * class and override the get_size, get_level, get_type and serialize
 * methods.
 * 
 * To extend the set of control messages that can be received, subclass
 * this class and implement the deserialize method. Also, make sure your
 * class is registered with the GType typesystem before calling
 * g_socket_receive_message() to read such a message.
 * @class 
 */
class SocketControlMessage extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SocketControlMessage

    static name: string
    static $gtype: GObject.GType<SocketControlMessage>

    // Constructors of Gio-2.0.Gio.SocketControlMessage

    constructor(config?: SocketControlMessage.ConstructorProperties) 
    _init(config?: SocketControlMessage.ConstructorProperties): void
    /**
     * Tries to deserialize a socket control message of a given
     * `level` and `type`. This will ask all known (to GType) subclasses
     * of #GSocketControlMessage if they can understand this kind
     * of message and if so deserialize it into a #GSocketControlMessage.
     * 
     * If there is no implementation for this kind of control message, %NULL
     * will be returned.
     * @param level a socket level
     * @param type a socket control message type for the given `level`
     * @param data pointer to the message data
     * @returns the deserialized message or %NULL
     */
    static deserialize(level: number, type: number, data: Uint8Array): SocketControlMessage | null
}

module SocketListener {

    // Signal callback interfaces

    /**
     * Signal callback interface for `event`
     */
    interface EventSignalCallback {
        ($obj: SocketListener, event: SocketListenerEvent, socket: Socket): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.SocketListener

        listen_backlog?: number | null
    }

}

interface SocketListener {

    // Own properties of Gio-2.0.Gio.SocketListener

    listen_backlog: number

    // Own fields of Gio-2.0.Gio.SocketListener

    parent_instance: GObject.Object
    priv: SocketListenerPrivate

    // Owm methods of Gio-2.0.Gio.SocketListener

    /**
     * Blocks waiting for a client to connect to any of the sockets added
     * to the listener. Returns a #GSocketConnection for the socket that was
     * accepted.
     * 
     * If `source_object` is not %NULL it will be filled out with the source
     * object specified when the corresponding socket or address was added
     * to the listener.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    accept(cancellable: Cancellable | null): [ /* returnType */ SocketConnection, /* source_object */ GObject.Object | null ]
    /**
     * This is the asynchronous version of g_socket_listener_accept().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_listener_accept_finish()
     * to get the result of the operation.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback
     */
    accept_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of accept_async

    /**
     * Promisified version of {@link accept_async}
     * 
     * This is the asynchronous version of g_socket_listener_accept().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_listener_accept_finish()
     * to get the result of the operation.
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a #GSocketConnection on success, %NULL on error.
     */
    accept_async(cancellable: Cancellable | null): globalThis.Promise</* source_object */ GObject.Object | null>
    /**
     * Finishes an async accept operation. See g_socket_listener_accept_async()
     * @param result a #GAsyncResult.
     * @returns a #GSocketConnection on success, %NULL on error.
     */
    accept_finish(result: AsyncResult): [ /* returnType */ SocketConnection, /* source_object */ GObject.Object | null ]
    /**
     * Blocks waiting for a client to connect to any of the sockets added
     * to the listener. Returns the #GSocket that was accepted.
     * 
     * If you want to accept the high-level #GSocketConnection, not a #GSocket,
     * which is often the case, then you should use g_socket_listener_accept()
     * instead.
     * 
     * If `source_object` is not %NULL it will be filled out with the source
     * object specified when the corresponding socket or address was added
     * to the listener.
     * 
     * If `cancellable` is not %NULL, then the operation can be cancelled by
     * triggering the cancellable object from another thread. If the operation
     * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a #GSocket on success, %NULL on error.
     */
    accept_socket(cancellable: Cancellable | null): [ /* returnType */ Socket, /* source_object */ GObject.Object | null ]
    /**
     * This is the asynchronous version of g_socket_listener_accept_socket().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_listener_accept_socket_finish()
     * to get the result of the operation.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback
     */
    accept_socket_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of accept_socket_async

    /**
     * Promisified version of {@link accept_socket_async}
     * 
     * This is the asynchronous version of g_socket_listener_accept_socket().
     * 
     * When the operation is finished `callback` will be
     * called. You can then call g_socket_listener_accept_socket_finish()
     * to get the result of the operation.
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a #GSocket on success, %NULL on error.
     */
    accept_socket_async(cancellable: Cancellable | null): globalThis.Promise</* source_object */ GObject.Object | null>
    /**
     * Finishes an async accept operation. See g_socket_listener_accept_socket_async()
     * @param result a #GAsyncResult.
     * @returns a #GSocket on success, %NULL on error.
     */
    accept_socket_finish(result: AsyncResult): [ /* returnType */ Socket, /* source_object */ GObject.Object | null ]
    /**
     * Creates a socket of type `type` and protocol `protocol,` binds
     * it to `address` and adds it to the set of sockets we're accepting
     * sockets from.
     * 
     * Note that adding an IPv6 address, depending on the platform,
     * may or may not result in a listener that also accepts IPv4
     * connections.  For more deterministic behavior, see
     * g_socket_listener_add_inet_port().
     * 
     * `source_object` will be passed out in the various calls
     * to accept to identify this particular source, which is
     * useful if you're listening on multiple addresses and do
     * different things depending on what address is connected to.
     * 
     * If successful and `effective_address` is non-%NULL then it will
     * be set to the address that the binding actually occurred at.  This
     * is helpful for determining the port number that was used for when
     * requesting a binding to port 0 (ie: "any port").  This address, if
     * requested, belongs to the caller and must be freed.
     * 
     * Call g_socket_listener_close() to stop listening on `address;` this will not
     * be done automatically when you drop your final reference to `listener,` as
     * references may be held internally.
     * @param address a #GSocketAddress
     * @param type a #GSocketType
     * @param protocol a #GSocketProtocol
     * @param source_object Optional #GObject identifying this source
     * @returns %TRUE on success, %FALSE on error.
     */
    add_address(address: SocketAddress, type: SocketType, protocol: SocketProtocol, source_object: GObject.Object | null): [ /* returnType */ boolean, /* effective_address */ SocketAddress ]
    /**
     * Listens for TCP connections on any available port number for both
     * IPv6 and IPv4 (if each is available).
     * 
     * This is useful if you need to have a socket for incoming connections
     * but don't care about the specific port number.
     * 
     * `source_object` will be passed out in the various calls
     * to accept to identify this particular source, which is
     * useful if you're listening on multiple addresses and do
     * different things depending on what address is connected to.
     * @param source_object Optional #GObject identifying this source
     * @returns the port number, or 0 in case of failure.
     */
    add_any_inet_port(source_object: GObject.Object | null): number
    /**
     * Helper function for g_socket_listener_add_address() that
     * creates a TCP/IP socket listening on IPv4 and IPv6 (if
     * supported) on the specified port on all interfaces.
     * 
     * `source_object` will be passed out in the various calls
     * to accept to identify this particular source, which is
     * useful if you're listening on multiple addresses and do
     * different things depending on what address is connected to.
     * 
     * Call g_socket_listener_close() to stop listening on `port;` this will not
     * be done automatically when you drop your final reference to `listener,` as
     * references may be held internally.
     * @param port an IP port number (non-zero)
     * @param source_object Optional #GObject identifying this source
     * @returns %TRUE on success, %FALSE on error.
     */
    add_inet_port(port: number, source_object: GObject.Object | null): boolean
    /**
     * Adds `socket` to the set of sockets that we try to accept
     * new clients from. The socket must be bound to a local
     * address and listened to.
     * 
     * `source_object` will be passed out in the various calls
     * to accept to identify this particular source, which is
     * useful if you're listening on multiple addresses and do
     * different things depending on what address is connected to.
     * 
     * The `socket` will not be automatically closed when the `listener` is finalized
     * unless the listener held the final reference to the socket. Before GLib 2.42,
     * the `socket` was automatically closed on finalization of the `listener,` even
     * if references to it were held elsewhere.
     * @param socket a listening #GSocket
     * @param source_object Optional #GObject identifying this source
     * @returns %TRUE on success, %FALSE on error.
     */
    add_socket(socket: Socket, source_object: GObject.Object | null): boolean
    /**
     * Closes all the sockets in the listener.
     */
    close(): void
    /**
     * Sets the listen backlog on the sockets in the listener. This must be called
     * before adding any sockets, addresses or ports to the #GSocketListener (for
     * example, by calling g_socket_listener_add_inet_port()) to be effective.
     * 
     * See g_socket_set_listen_backlog() for details
     * @param listen_backlog an integer
     */
    set_backlog(listen_backlog: number): void

    // Own virtual methods of Gio-2.0.Gio.SocketListener

    vfunc_changed(): void
    vfunc_event(event: SocketListenerEvent, socket: Socket): void

    // Own signals of Gio-2.0.Gio.SocketListener

    connect(sigName: "event", callback: SocketListener.EventSignalCallback): number
    connect_after(sigName: "event", callback: SocketListener.EventSignalCallback): number
    emit(sigName: "event", event: SocketListenerEvent, socket: Socket, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.SocketListener

    connect(sigName: "notify::listen-backlog", callback: (($obj: SocketListener, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::listen-backlog", callback: (($obj: SocketListener, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::listen-backlog", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GSocketListener is an object that keeps track of a set
 * of server sockets and helps you accept sockets from any of the
 * socket, either sync or async.
 * 
 * Add addresses and ports to listen on using g_socket_listener_add_address()
 * and g_socket_listener_add_inet_port(). These will be listened on until
 * g_socket_listener_close() is called. Dropping your final reference to the
 * #GSocketListener will not cause g_socket_listener_close() to be called
 * implicitly, as some references to the #GSocketListener may be held
 * internally.
 * 
 * If you want to implement a network server, also look at #GSocketService
 * and #GThreadedSocketService which are subclasses of #GSocketListener
 * that make this even easier.
 * @class 
 */
class SocketListener extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SocketListener

    static name: string
    static $gtype: GObject.GType<SocketListener>

    // Constructors of Gio-2.0.Gio.SocketListener

    constructor(config?: SocketListener.ConstructorProperties) 
    /**
     * Creates a new #GSocketListener with no sockets to listen for.
     * New listeners can be added with e.g. g_socket_listener_add_address()
     * or g_socket_listener_add_inet_port().
     * @constructor 
     * @returns a new #GSocketListener.
     */
    constructor() 
    /**
     * Creates a new #GSocketListener with no sockets to listen for.
     * New listeners can be added with e.g. g_socket_listener_add_address()
     * or g_socket_listener_add_inet_port().
     * @constructor 
     * @returns a new #GSocketListener.
     */
    static new(): SocketListener
    _init(config?: SocketListener.ConstructorProperties): void
}

module SocketService {

    // Signal callback interfaces

    /**
     * Signal callback interface for `incoming`
     */
    interface IncomingSignalCallback {
        ($obj: SocketService, connection: SocketConnection, source_object: GObject.Object | null): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends SocketListener.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.SocketService

        /**
         * Whether the service is currently accepting connections.
         */
        active?: boolean | null
    }

}

interface SocketService {

    // Own properties of Gio-2.0.Gio.SocketService

    /**
     * Whether the service is currently accepting connections.
     */
    active: boolean

    // Own fields of Gio-2.0.Gio.SocketService

    parent_instance: SocketListener & GObject.Object
    priv: any

    // Owm methods of Gio-2.0.Gio.SocketService

    /**
     * Check whether the service is active or not. An active
     * service will accept new clients that connect, while
     * a non-active service will let connecting clients queue
     * up until the service is started.
     * @returns %TRUE if the service is active, %FALSE otherwise
     */
    is_active(): boolean
    /**
     * Restarts the service, i.e. start accepting connections
     * from the added sockets when the mainloop runs. This only needs
     * to be called after the service has been stopped from
     * g_socket_service_stop().
     * 
     * This call is thread-safe, so it may be called from a thread
     * handling an incoming client request.
     */
    start(): void
    /**
     * Stops the service, i.e. stops accepting connections
     * from the added sockets when the mainloop runs.
     * 
     * This call is thread-safe, so it may be called from a thread
     * handling an incoming client request.
     * 
     * Note that this only stops accepting new connections; it does not
     * close the listening sockets, and you can call
     * g_socket_service_start() again later to begin listening again. To
     * close the listening sockets, call g_socket_listener_close(). (This
     * will happen automatically when the #GSocketService is finalized.)
     * 
     * This must be called before calling g_socket_listener_close() as
     * the socket service will start accepting connections immediately
     * when a new socket is added.
     */
    stop(): void

    // Own virtual methods of Gio-2.0.Gio.SocketService

    vfunc_incoming(connection: SocketConnection, source_object: GObject.Object): boolean

    // Own signals of Gio-2.0.Gio.SocketService

    connect(sigName: "incoming", callback: SocketService.IncomingSignalCallback): number
    connect_after(sigName: "incoming", callback: SocketService.IncomingSignalCallback): number
    emit(sigName: "incoming", connection: SocketConnection, source_object: GObject.Object | null, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.SocketService

    connect(sigName: "notify::active", callback: (($obj: SocketService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: SocketService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::active", ...args: any[]): void
    connect(sigName: "notify::listen-backlog", callback: (($obj: SocketService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::listen-backlog", callback: (($obj: SocketService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::listen-backlog", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GSocketService is an object that represents a service that
 * is provided to the network or over local sockets.  When a new
 * connection is made to the service the #GSocketService::incoming
 * signal is emitted.
 * 
 * A #GSocketService is a subclass of #GSocketListener and you need
 * to add the addresses you want to accept connections on with the
 * #GSocketListener APIs.
 * 
 * There are two options for implementing a network service based on
 * #GSocketService. The first is to create the service using
 * g_socket_service_new() and to connect to the #GSocketService::incoming
 * signal. The second is to subclass #GSocketService and override the
 * default signal handler implementation.
 * 
 * In either case, the handler must immediately return, or else it
 * will block additional incoming connections from being serviced.
 * If you are interested in writing connection handlers that contain
 * blocking code then see #GThreadedSocketService.
 * 
 * The socket service runs on the main loop of the
 * [thread-default context][g-main-context-push-thread-default-context]
 * of the thread it is created in, and is not
 * threadsafe in general. However, the calls to start and stop the
 * service are thread-safe so these can be used from threads that
 * handle incoming clients.
 * @class 
 */
class SocketService extends SocketListener {

    // Own properties of Gio-2.0.Gio.SocketService

    static name: string
    static $gtype: GObject.GType<SocketService>

    // Constructors of Gio-2.0.Gio.SocketService

    constructor(config?: SocketService.ConstructorProperties) 
    /**
     * Creates a new #GSocketService with no sockets to listen for.
     * New listeners can be added with e.g. g_socket_listener_add_address()
     * or g_socket_listener_add_inet_port().
     * 
     * New services are created active, there is no need to call
     * g_socket_service_start(), unless g_socket_service_stop() has been
     * called before.
     * @constructor 
     * @returns a new #GSocketService.
     */
    constructor() 
    /**
     * Creates a new #GSocketService with no sockets to listen for.
     * New listeners can be added with e.g. g_socket_listener_add_address()
     * or g_socket_listener_add_inet_port().
     * 
     * New services are created active, there is no need to call
     * g_socket_service_start(), unless g_socket_service_stop() has been
     * called before.
     * @constructor 
     * @returns a new #GSocketService.
     */
    static new(): SocketService

    // Overloads of new

    /**
     * Creates a new #GSocketListener with no sockets to listen for.
     * New listeners can be added with e.g. g_socket_listener_add_address()
     * or g_socket_listener_add_inet_port().
     * @constructor 
     * @returns a new #GSocketListener.
     */
    static new(): SocketListener
    _init(config?: SocketService.ConstructorProperties): void
}

module Subprocess {

    // Constructor properties interface

    interface ConstructorProperties extends Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.Subprocess

        argv?: string[] | null
        flags?: SubprocessFlags | null
    }

}

interface Subprocess extends Initable {

    // Own properties of Gio-2.0.Gio.Subprocess

    readonly argv: string[]
    readonly flags: SubprocessFlags

    // Owm methods of Gio-2.0.Gio.Subprocess

    /**
     * Communicate with the subprocess until it terminates, and all input
     * and output has been completed.
     * 
     * If `stdin_buf` is given, the subprocess must have been created with
     * %G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
     * stdin of the subprocess and the pipe is closed (ie: EOF).
     * 
     * At the same time (as not to cause blocking when dealing with large
     * amounts of data), if %G_SUBPROCESS_FLAGS_STDOUT_PIPE or
     * %G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
     * streams.  The data that was read is returned in `stdout` and/or
     * the `stderr`.
     * 
     * If the subprocess was created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
     * `stdout_buf` will contain the data read from stdout.  Otherwise, for
     * subprocesses not created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
     * `stdout_buf` will be set to %NULL.  Similar provisions apply to
     * `stderr_buf` and %G_SUBPROCESS_FLAGS_STDERR_PIPE.
     * 
     * As usual, any output variable may be given as %NULL to ignore it.
     * 
     * If you desire the stdout and stderr data to be interleaved, create
     * the subprocess with %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
     * %G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
     * in `stdout_buf` and `stderr_buf` will be set to %NULL.
     * 
     * In case of any error (including cancellation), %FALSE will be
     * returned with `error` set.  Some or all of the stdin data may have
     * been written.  Any stdout or stderr data that has been read will be
     * discarded. None of the out variables (aside from `error)` will have
     * been set to anything in particular and should not be inspected.
     * 
     * In the case that %TRUE is returned, the subprocess has exited and the
     * exit status inspection APIs (eg: g_subprocess_get_if_exited(),
     * g_subprocess_get_exit_status()) may be used.
     * 
     * You should not attempt to use any of the subprocess pipes after
     * starting this function, since they may be left in strange states,
     * even if the operation was cancelled.  You should especially not
     * attempt to interact with the pipes while the operation is in progress
     * (either from another thread or if using the asynchronous version).
     * @param stdin_buf data to send to the stdin of the subprocess, or %NULL
     * @param cancellable a #GCancellable
     * @returns %TRUE if successful
     */
    communicate(stdin_buf: GLib.Bytes | null, cancellable: Cancellable | null): [ /* returnType */ boolean, /* stdout_buf */ GLib.Bytes | null, /* stderr_buf */ GLib.Bytes | null ]
    /**
     * Asynchronous version of g_subprocess_communicate().  Complete
     * invocation with g_subprocess_communicate_finish().
     * @param stdin_buf Input data, or %NULL
     * @param cancellable Cancellable
     * @param callback Callback
     */
    communicate_async(stdin_buf: GLib.Bytes | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of communicate_async

    /**
     * Promisified version of {@link communicate_async}
     * 
     * Asynchronous version of g_subprocess_communicate().  Complete
     * invocation with g_subprocess_communicate_finish().
     * @param stdin_buf Input data, or %NULL
     * @param cancellable Cancellable
     * @returns A Promise of the result of {@link communicate_async}
     */
    communicate_async(stdin_buf: GLib.Bytes | null, cancellable: Cancellable | null): globalThis.Promise<[ /* stdout_buf */ GLib.Bytes | null, /* stderr_buf */ GLib.Bytes | null ]>
    /**
     * Complete an invocation of g_subprocess_communicate_async().
     * @param result Result
     */
    communicate_finish(result: AsyncResult): [ /* returnType */ boolean, /* stdout_buf */ GLib.Bytes | null, /* stderr_buf */ GLib.Bytes | null ]
    /**
     * Like g_subprocess_communicate(), but validates the output of the
     * process as UTF-8, and returns it as a regular NUL terminated string.
     * 
     * On error, `stdout_buf` and `stderr_buf` will be set to undefined values and
     * should not be used.
     * @param stdin_buf data to send to the stdin of the subprocess, or %NULL
     * @param cancellable a #GCancellable
     */
    communicate_utf8(stdin_buf: string | null, cancellable: Cancellable | null): [ /* returnType */ boolean, /* stdout_buf */ string | null, /* stderr_buf */ string | null ]
    /**
     * Asynchronous version of g_subprocess_communicate_utf8().  Complete
     * invocation with g_subprocess_communicate_utf8_finish().
     * @param stdin_buf Input data, or %NULL
     * @param cancellable Cancellable
     * @param callback Callback
     */
    communicate_utf8_async(stdin_buf: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of communicate_utf8_async

    /**
     * Promisified version of {@link communicate_utf8_async}
     * 
     * Asynchronous version of g_subprocess_communicate_utf8().  Complete
     * invocation with g_subprocess_communicate_utf8_finish().
     * @param stdin_buf Input data, or %NULL
     * @param cancellable Cancellable
     * @returns A Promise of the result of {@link communicate_utf8_async}
     */
    communicate_utf8_async(stdin_buf: string | null, cancellable: Cancellable | null): globalThis.Promise<[ /* stdout_buf */ string | null, /* stderr_buf */ string | null ]>
    /**
     * Complete an invocation of g_subprocess_communicate_utf8_async().
     * @param result Result
     */
    communicate_utf8_finish(result: AsyncResult): [ /* returnType */ boolean, /* stdout_buf */ string | null, /* stderr_buf */ string | null ]
    /**
     * Use an operating-system specific method to attempt an immediate,
     * forceful termination of the process.  There is no mechanism to
     * determine whether or not the request itself was successful;
     * however, you can use g_subprocess_wait() to monitor the status of
     * the process after calling this function.
     * 
     * On Unix, this function sends %SIGKILL.
     */
    force_exit(): void
    /**
     * Check the exit status of the subprocess, given that it exited
     * normally.  This is the value passed to the exit() system call or the
     * return value from main.
     * 
     * This is equivalent to the system WEXITSTATUS macro.
     * 
     * It is an error to call this function before g_subprocess_wait() and
     * unless g_subprocess_get_if_exited() returned %TRUE.
     * @returns the exit status
     */
    get_exit_status(): number
    /**
     * On UNIX, returns the process ID as a decimal string.
     * On Windows, returns the result of GetProcessId() also as a string.
     * If the subprocess has terminated, this will return %NULL.
     * @returns the subprocess identifier, or %NULL if the subprocess    has terminated
     */
    get_identifier(): string | null
    /**
     * Check if the given subprocess exited normally (ie: by way of exit()
     * or return from main()).
     * 
     * This is equivalent to the system WIFEXITED macro.
     * 
     * It is an error to call this function before g_subprocess_wait() has
     * returned.
     * @returns %TRUE if the case of a normal exit
     */
    get_if_exited(): boolean
    /**
     * Check if the given subprocess terminated in response to a signal.
     * 
     * This is equivalent to the system WIFSIGNALED macro.
     * 
     * It is an error to call this function before g_subprocess_wait() has
     * returned.
     * @returns %TRUE if the case of termination due to a signal
     */
    get_if_signaled(): boolean
    /**
     * Gets the raw status code of the process, as from waitpid().
     * 
     * This value has no particular meaning, but it can be used with the
     * macros defined by the system headers such as WIFEXITED.  It can also
     * be used with g_spawn_check_wait_status().
     * 
     * It is more likely that you want to use g_subprocess_get_if_exited()
     * followed by g_subprocess_get_exit_status().
     * 
     * It is an error to call this function before g_subprocess_wait() has
     * returned.
     * @returns the (meaningless) waitpid() exit status from the kernel
     */
    get_status(): number
    /**
     * Gets the #GInputStream from which to read the stderr output of
     * `subprocess`.
     * 
     * The process must have been created with %G_SUBPROCESS_FLAGS_STDERR_PIPE,
     * otherwise %NULL will be returned.
     * @returns the stderr pipe
     */
    get_stderr_pipe(): InputStream | null
    /**
     * Gets the #GOutputStream that you can write to in order to give data
     * to the stdin of `subprocess`.
     * 
     * The process must have been created with %G_SUBPROCESS_FLAGS_STDIN_PIPE and
     * not %G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise %NULL will be returned.
     * @returns the stdout pipe
     */
    get_stdin_pipe(): OutputStream | null
    /**
     * Gets the #GInputStream from which to read the stdout output of
     * `subprocess`.
     * 
     * The process must have been created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
     * otherwise %NULL will be returned.
     * @returns the stdout pipe
     */
    get_stdout_pipe(): InputStream | null
    /**
     * Checks if the process was "successful".  A process is considered
     * successful if it exited cleanly with an exit status of 0, either by
     * way of the exit() system call or return from main().
     * 
     * It is an error to call this function before g_subprocess_wait() has
     * returned.
     * @returns %TRUE if the process exited cleanly with a exit status of 0
     */
    get_successful(): boolean
    /**
     * Get the signal number that caused the subprocess to terminate, given
     * that it terminated due to a signal.
     * 
     * This is equivalent to the system WTERMSIG macro.
     * 
     * It is an error to call this function before g_subprocess_wait() and
     * unless g_subprocess_get_if_signaled() returned %TRUE.
     * @returns the signal causing termination
     */
    get_term_sig(): number
    /**
     * Sends the UNIX signal `signal_num` to the subprocess, if it is still
     * running.
     * 
     * This API is race-free.  If the subprocess has terminated, it will not
     * be signalled.
     * 
     * This API is not available on Windows.
     * @param signal_num the signal number to send
     */
    send_signal(signal_num: number): void
    /**
     * Synchronously wait for the subprocess to terminate.
     * 
     * After the process terminates you can query its exit status with
     * functions such as g_subprocess_get_if_exited() and
     * g_subprocess_get_exit_status().
     * 
     * This function does not fail in the case of the subprocess having
     * abnormal termination.  See g_subprocess_wait_check() for that.
     * 
     * Cancelling `cancellable` doesn't kill the subprocess.  Call
     * g_subprocess_force_exit() if it is desirable.
     * @param cancellable a #GCancellable
     * @returns %TRUE on success, %FALSE if @cancellable was cancelled
     */
    wait(cancellable: Cancellable | null): boolean
    /**
     * Wait for the subprocess to terminate.
     * 
     * This is the asynchronous version of g_subprocess_wait().
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback to call when the operation is complete
     */
    wait_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of wait_async

    /**
     * Promisified version of {@link wait_async}
     * 
     * Wait for the subprocess to terminate.
     * 
     * This is the asynchronous version of g_subprocess_wait().
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE if successful, or %FALSE with @error set
     */
    wait_async(cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Combines g_subprocess_wait() with g_spawn_check_wait_status().
     * @param cancellable a #GCancellable
     * @returns %TRUE on success, %FALSE if process exited abnormally, or @cancellable was cancelled
     */
    wait_check(cancellable: Cancellable | null): boolean
    /**
     * Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
     * 
     * This is the asynchronous version of g_subprocess_wait_check().
     * @param cancellable a #GCancellable, or %NULL
     * @param callback a #GAsyncReadyCallback to call when the operation is complete
     */
    wait_check_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of wait_check_async

    /**
     * Promisified version of {@link wait_check_async}
     * 
     * Combines g_subprocess_wait_async() with g_spawn_check_wait_status().
     * 
     * This is the asynchronous version of g_subprocess_wait_check().
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE if successful, or %FALSE with @error set
     */
    wait_check_async(cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Collects the result of a previous call to
     * g_subprocess_wait_check_async().
     * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
     * @returns %TRUE if successful, or %FALSE with @error set
     */
    wait_check_finish(result: AsyncResult): boolean
    /**
     * Collects the result of a previous call to
     * g_subprocess_wait_async().
     * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
     * @returns %TRUE if successful, or %FALSE with @error set
     */
    wait_finish(result: AsyncResult): boolean

    // Class property signals of Gio-2.0.Gio.Subprocess

    connect(sigName: "notify::argv", callback: (($obj: Subprocess, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::argv", callback: (($obj: Subprocess, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::argv", ...args: any[]): void
    connect(sigName: "notify::flags", callback: (($obj: Subprocess, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: Subprocess, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GSubprocess allows the creation of and interaction with child
 * processes.
 * 
 * Processes can be communicated with using standard GIO-style APIs (ie:
 * #GInputStream, #GOutputStream).  There are GIO-style APIs to wait for
 * process termination (ie: cancellable and with an asynchronous
 * variant).
 * 
 * There is an API to force a process to terminate, as well as a
 * race-free API for sending UNIX signals to a subprocess.
 * 
 * One major advantage that GIO brings over the core GLib library is
 * comprehensive API for asynchronous I/O, such
 * g_output_stream_splice_async().  This makes GSubprocess
 * significantly more powerful and flexible than equivalent APIs in
 * some other languages such as the `subprocess.py`
 * included with Python.  For example, using #GSubprocess one could
 * create two child processes, reading standard output from the first,
 * processing it, and writing to the input stream of the second, all
 * without blocking the main loop.
 * 
 * A powerful g_subprocess_communicate() API is provided similar to the
 * `communicate()` method of `subprocess.py`. This enables very easy
 * interaction with a subprocess that has been opened with pipes.
 * 
 * #GSubprocess defaults to tight control over the file descriptors open
 * in the child process, avoiding dangling-fd issues that are caused by
 * a simple fork()/exec().  The only open file descriptors in the
 * spawned process are ones that were explicitly specified by the
 * #GSubprocess API (unless %G_SUBPROCESS_FLAGS_INHERIT_FDS was
 * specified).
 * 
 * #GSubprocess will quickly reap all child processes as they exit,
 * avoiding "zombie processes" remaining around for long periods of
 * time.  g_subprocess_wait() can be used to wait for this to happen,
 * but it will happen even without the call being explicitly made.
 * 
 * As a matter of principle, #GSubprocess has no API that accepts
 * shell-style space-separated strings.  It will, however, match the
 * typical shell behaviour of searching the PATH for executables that do
 * not contain a directory separator in their name. By default, the `PATH`
 * of the current process is used.  You can specify
 * %G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP to use the `PATH` of the
 * launcher environment instead.
 * 
 * #GSubprocess attempts to have a very simple API for most uses (ie:
 * spawning a subprocess with arguments and support for most typical
 * kinds of input and output redirection).  See g_subprocess_new(). The
 * #GSubprocessLauncher API is provided for more complicated cases
 * (advanced types of redirection, environment variable manipulation,
 * change of working directory, child setup functions, etc).
 * 
 * A typical use of #GSubprocess will involve calling
 * g_subprocess_new(), followed by g_subprocess_wait_async() or
 * g_subprocess_wait().  After the process exits, the status can be
 * checked using functions such as g_subprocess_get_if_exited() (which
 * are similar to the familiar WIFEXITED-style POSIX macros).
 * @class 
 */
class Subprocess extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Subprocess

    static name: string
    static $gtype: GObject.GType<Subprocess>

    // Constructors of Gio-2.0.Gio.Subprocess

    constructor(config?: Subprocess.ConstructorProperties) 
    /**
     * Create a new process with the given flags and argument list.
     * 
     * The argument list is expected to be %NULL-terminated.
     * @constructor 
     * @param argv commandline arguments for the subprocess
     * @param flags flags that define the behaviour of the subprocess
     * @returns A newly created #GSubprocess, or %NULL on error (and @error   will be set)
     */
    constructor(argv: string[], flags: SubprocessFlags) 
    /**
     * Create a new process with the given flags and argument list.
     * 
     * The argument list is expected to be %NULL-terminated.
     * @constructor 
     * @param argv commandline arguments for the subprocess
     * @param flags flags that define the behaviour of the subprocess
     * @returns A newly created #GSubprocess, or %NULL on error (and @error   will be set)
     */
    static new(argv: string[], flags: SubprocessFlags): Subprocess
    _init(config?: Subprocess.ConstructorProperties): void
}

module SubprocessLauncher {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.SubprocessLauncher

        flags?: SubprocessFlags | null
    }

}

interface SubprocessLauncher {

    // Own properties of Gio-2.0.Gio.SubprocessLauncher

    readonly flags: SubprocessFlags

    // Owm methods of Gio-2.0.Gio.SubprocessLauncher

    /**
     * Closes all the file descriptors previously passed to the object with
     * g_subprocess_launcher_take_fd(), g_subprocess_launcher_take_stderr_fd(), etc.
     * 
     * After calling this method, any subsequent calls to g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
     * return %G_IO_ERROR_CLOSED. This method is idempotent if
     * called more than once.
     * 
     * This function is called automatically when the #GSubprocessLauncher
     * is disposed, but is provided separately so that garbage collected
     * language bindings can call it earlier to guarantee when FDs are closed.
     */
    close(): void
    /**
     * Returns the value of the environment variable `variable` in the
     * environment of processes launched from this launcher.
     * 
     * On UNIX, the returned string can be an arbitrary byte string.
     * On Windows, it will be UTF-8.
     * @param variable the environment variable to get
     * @returns the value of the environment variable,     %NULL if unset
     */
    getenv(variable: string): string | null
    /**
     * Sets the current working directory that processes will be launched
     * with.
     * 
     * By default processes are launched with the current working directory
     * of the launching process at the time of launch.
     * @param cwd the cwd for launched processes
     */
    set_cwd(cwd: string): void
    /**
     * Replace the entire environment of processes launched from this
     * launcher with the given 'environ' variable.
     * 
     * Typically you will build this variable by using g_listenv() to copy
     * the process 'environ' and using the functions g_environ_setenv(),
     * g_environ_unsetenv(), etc.
     * 
     * As an alternative, you can use g_subprocess_launcher_setenv(),
     * g_subprocess_launcher_unsetenv(), etc.
     * 
     * Pass an empty array to set an empty environment. Pass %NULL to inherit the
     * parent process’ environment. As of GLib 2.54, the parent process’ environment
     * will be copied when g_subprocess_launcher_set_environ() is called.
     * Previously, it was copied when the subprocess was executed. This means the
     * copied environment may now be modified (using g_subprocess_launcher_setenv(),
     * etc.) before launching the subprocess.
     * 
     * On UNIX, all strings in this array can be arbitrary byte strings.
     * On Windows, they should be in UTF-8.
     * @param env      the replacement environment
     */
    set_environ(env: string[]): void
    /**
     * Sets the flags on the launcher.
     * 
     * The default flags are %G_SUBPROCESS_FLAGS_NONE.
     * 
     * You may not set flags that specify conflicting options for how to
     * handle a particular stdio stream (eg: specifying both
     * %G_SUBPROCESS_FLAGS_STDIN_PIPE and
     * %G_SUBPROCESS_FLAGS_STDIN_INHERIT).
     * 
     * You may also not set a flag that conflicts with a previous call to a
     * function like g_subprocess_launcher_set_stdin_file_path() or
     * g_subprocess_launcher_take_stdout_fd().
     * @param flags #GSubprocessFlags
     */
    set_flags(flags: SubprocessFlags): void
    /**
     * Sets the file path to use as the stderr for spawned processes.
     * 
     * If `path` is %NULL then any previously given path is unset.
     * 
     * The file will be created or truncated when the process is spawned, as
     * would be the case if using '2>' at the shell.
     * 
     * If you want to send both stdout and stderr to the same file then use
     * %G_SUBPROCESS_FLAGS_STDERR_MERGE.
     * 
     * You may not set a stderr file path if a stderr fd is already set or
     * if the launcher flags contain any flags directing stderr elsewhere.
     * 
     * This feature is only available on UNIX.
     * @param path a filename or %NULL
     */
    set_stderr_file_path(path: string | null): void
    /**
     * Sets the file path to use as the stdin for spawned processes.
     * 
     * If `path` is %NULL then any previously given path is unset.
     * 
     * The file must exist or spawning the process will fail.
     * 
     * You may not set a stdin file path if a stdin fd is already set or if
     * the launcher flags contain any flags directing stdin elsewhere.
     * 
     * This feature is only available on UNIX.
     * @param path 
     */
    set_stdin_file_path(path: string | null): void
    /**
     * Sets the file path to use as the stdout for spawned processes.
     * 
     * If `path` is %NULL then any previously given path is unset.
     * 
     * The file will be created or truncated when the process is spawned, as
     * would be the case if using '>' at the shell.
     * 
     * You may not set a stdout file path if a stdout fd is already set or
     * if the launcher flags contain any flags directing stdout elsewhere.
     * 
     * This feature is only available on UNIX.
     * @param path a filename or %NULL
     */
    set_stdout_file_path(path: string | null): void
    /**
     * Sets the environment variable `variable` in the environment of
     * processes launched from this launcher.
     * 
     * On UNIX, both the variable's name and value can be arbitrary byte
     * strings, except that the variable's name cannot contain '='.
     * On Windows, they should be in UTF-8.
     * @param variable the environment variable to set,     must not contain '='
     * @param value the new value for the variable
     * @param overwrite whether to change the variable if it already exists
     */
    setenv(variable: string, value: string, overwrite: boolean): void
    /**
     * Creates a #GSubprocess given a provided array of arguments.
     * @param argv Command line arguments
     * @returns A new #GSubprocess, or %NULL on error (and @error will be set)
     */
    spawnv(argv: string[]): Subprocess
    /**
     * Transfer an arbitrary file descriptor from parent process to the
     * child.  This function takes ownership of the `source_fd;` it will be closed
     * in the parent when `self` is freed.
     * 
     * By default, all file descriptors from the parent will be closed.
     * This function allows you to create (for example) a custom `pipe()` or
     * `socketpair()` before launching the process, and choose the target
     * descriptor in the child.
     * 
     * An example use case is GNUPG, which has a command line argument
     * `--passphrase-fd` providing a file descriptor number where it expects
     * the passphrase to be written.
     * @param source_fd File descriptor in parent process
     * @param target_fd Target descriptor for child process
     */
    take_fd(source_fd: number, target_fd: number): void
    /**
     * Sets the file descriptor to use as the stderr for spawned processes.
     * 
     * If `fd` is -1 then any previously given fd is unset.
     * 
     * Note that the default behaviour is to pass stderr through to the
     * stderr of the parent process.
     * 
     * The passed `fd` belongs to the #GSubprocessLauncher.  It will be
     * automatically closed when the launcher is finalized.  The file
     * descriptor will also be closed on the child side when executing the
     * spawned process.
     * 
     * You may not set a stderr fd if a stderr file path is already set or
     * if the launcher flags contain any flags directing stderr elsewhere.
     * 
     * This feature is only available on UNIX.
     * @param fd a file descriptor, or -1
     */
    take_stderr_fd(fd: number): void
    /**
     * Sets the file descriptor to use as the stdin for spawned processes.
     * 
     * If `fd` is -1 then any previously given fd is unset.
     * 
     * Note that if your intention is to have the stdin of the calling
     * process inherited by the child then %G_SUBPROCESS_FLAGS_STDIN_INHERIT
     * is a better way to go about doing that.
     * 
     * The passed `fd` is noted but will not be touched in the current
     * process.  It is therefore necessary that it be kept open by the
     * caller until the subprocess is spawned.  The file descriptor will
     * also not be explicitly closed on the child side, so it must be marked
     * O_CLOEXEC if that's what you want.
     * 
     * You may not set a stdin fd if a stdin file path is already set or if
     * the launcher flags contain any flags directing stdin elsewhere.
     * 
     * This feature is only available on UNIX.
     * @param fd a file descriptor, or -1
     */
    take_stdin_fd(fd: number): void
    /**
     * Sets the file descriptor to use as the stdout for spawned processes.
     * 
     * If `fd` is -1 then any previously given fd is unset.
     * 
     * Note that the default behaviour is to pass stdout through to the
     * stdout of the parent process.
     * 
     * The passed `fd` is noted but will not be touched in the current
     * process.  It is therefore necessary that it be kept open by the
     * caller until the subprocess is spawned.  The file descriptor will
     * also not be explicitly closed on the child side, so it must be marked
     * O_CLOEXEC if that's what you want.
     * 
     * You may not set a stdout fd if a stdout file path is already set or
     * if the launcher flags contain any flags directing stdout elsewhere.
     * 
     * This feature is only available on UNIX.
     * @param fd a file descriptor, or -1
     */
    take_stdout_fd(fd: number): void
    /**
     * Removes the environment variable `variable` from the environment of
     * processes launched from this launcher.
     * 
     * On UNIX, the variable's name can be an arbitrary byte string not
     * containing '='. On Windows, it should be in UTF-8.
     * @param variable the environment variable to unset,     must not contain '='
     */
    unsetenv(variable: string): void

    // Class property signals of Gio-2.0.Gio.SubprocessLauncher

    connect(sigName: "notify::flags", callback: (($obj: SubprocessLauncher, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: SubprocessLauncher, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This class contains a set of options for launching child processes,
 * such as where its standard input and output will be directed, the
 * argument list, the environment, and more.
 * 
 * While the #GSubprocess class has high level functions covering
 * popular cases, use of this class allows access to more advanced
 * options.  It can also be used to launch multiple subprocesses with
 * a similar configuration.
 * @class 
 */
class SubprocessLauncher extends GObject.Object {

    // Own properties of Gio-2.0.Gio.SubprocessLauncher

    static name: string
    static $gtype: GObject.GType<SubprocessLauncher>

    // Constructors of Gio-2.0.Gio.SubprocessLauncher

    constructor(config?: SubprocessLauncher.ConstructorProperties) 
    /**
     * Creates a new #GSubprocessLauncher.
     * 
     * The launcher is created with the default options.  A copy of the
     * environment of the calling process is made at the time of this call
     * and will be used as the environment that the process is launched in.
     * @constructor 
     * @param flags #GSubprocessFlags
     */
    constructor(flags: SubprocessFlags) 
    /**
     * Creates a new #GSubprocessLauncher.
     * 
     * The launcher is created with the default options.  A copy of the
     * environment of the calling process is made at the time of this call
     * and will be used as the environment that the process is launched in.
     * @constructor 
     * @param flags #GSubprocessFlags
     */
    static new(flags: SubprocessFlags): SubprocessLauncher
    _init(config?: SubprocessLauncher.ConstructorProperties): void
}

module Task {

    // Constructor properties interface

    interface ConstructorProperties extends AsyncResult.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface Task extends AsyncResult {

    // Own properties of Gio-2.0.Gio.Task

    /**
     * Whether the task has completed, meaning its callback (if set) has been
     * invoked. This can only happen after g_task_return_pointer(),
     * g_task_return_error() or one of the other return functions have been called
     * on the task.
     * 
     * This property is guaranteed to change from %FALSE to %TRUE exactly once.
     * 
     * The #GObject::notify signal for this change is emitted in the same main
     * context as the task’s callback, immediately after that callback is invoked.
     */
    readonly completed: boolean

    // Owm methods of Gio-2.0.Gio.Task

    /**
     * Gets `task'`s #GCancellable
     * @returns @task's #GCancellable
     */
    get_cancellable(): Cancellable | null
    /**
     * Gets `task'`s check-cancellable flag. See
     * g_task_set_check_cancellable() for more details.
     */
    get_check_cancellable(): boolean
    /**
     * Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
     * the task’s callback is invoked, and will return %FALSE if called from inside
     * the callback.
     * @returns %TRUE if the task has completed, %FALSE otherwise.
     */
    get_completed(): boolean
    /**
     * Gets the #GMainContext that `task` will return its result in (that
     * is, the context that was the
     * [thread-default main context][g-main-context-push-thread-default]
     * at the point when `task` was created).
     * 
     * This will always return a non-%NULL value, even if the task's
     * context is the default #GMainContext.
     * @returns @task's #GMainContext
     */
    get_context(): GLib.MainContext
    /**
     * Gets `task’`s name. See g_task_set_name().
     * @returns @task’s name, or %NULL
     */
    get_name(): string | null
    /**
     * Gets `task'`s priority
     * @returns @task's priority
     */
    get_priority(): number
    /**
     * Gets `task'`s return-on-cancel flag. See
     * g_task_set_return_on_cancel() for more details.
     */
    get_return_on_cancel(): boolean
    /**
     * Gets the source object from `task`. Like
     * g_async_result_get_source_object(), but does not ref the object.
     * @returns @task's source object, or %NULL
     */
    get_source_object(): GObject.Object | null
    /**
     * Gets `task'`s source tag. See g_task_set_source_tag().
     * @returns @task's source tag
     */
    get_source_tag(): any | null
    /**
     * Gets `task'`s `task_data`.
     * @returns @task's `task_data`.
     */
    get_task_data(): any | null
    /**
     * Tests if `task` resulted in an error.
     * @returns %TRUE if the task resulted in an error, %FALSE otherwise.
     */
    had_error(): boolean
    /**
     * Gets the result of `task` as a #gboolean.
     * 
     * If the task resulted in an error, or was cancelled, then this will
     * instead return %FALSE and set `error`.
     * 
     * Since this method transfers ownership of the return value (or
     * error) to the caller, you may only call it once.
     * @returns the task result, or %FALSE on error
     */
    propagate_boolean(): boolean
    /**
     * Gets the result of `task` as an integer (#gssize).
     * 
     * If the task resulted in an error, or was cancelled, then this will
     * instead return -1 and set `error`.
     * 
     * Since this method transfers ownership of the return value (or
     * error) to the caller, you may only call it once.
     * @returns the task result, or -1 on error
     */
    propagate_int(): number
    /**
     * Gets the result of `task` as a pointer, and transfers ownership
     * of that value to the caller.
     * 
     * If the task resulted in an error, or was cancelled, then this will
     * instead return %NULL and set `error`.
     * 
     * Since this method transfers ownership of the return value (or
     * error) to the caller, you may only call it once.
     * @returns the task result, or %NULL on error
     */
    propagate_pointer(): any | null
    /**
     * Gets the result of `task` as a #GValue, and transfers ownership of
     * that value to the caller. As with g_task_return_value(), this is
     * a generic low-level method; g_task_propagate_pointer() and the like
     * will usually be more useful for C code.
     * 
     * If the task resulted in an error, or was cancelled, then this will
     * instead set `error` and return %FALSE.
     * 
     * Since this method transfers ownership of the return value (or
     * error) to the caller, you may only call it once.
     * @returns %TRUE if @task succeeded, %FALSE on error.
     */
    propagate_value(): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Sets `task'`s result to `result` and completes the task (see
     * g_task_return_pointer() for more discussion of exactly what this
     * means).
     * @param result the #gboolean result of a task function.
     */
    return_boolean(result: boolean): void
    /**
     * Sets `task'`s result to `error` (which `task` assumes ownership of)
     * and completes the task (see g_task_return_pointer() for more
     * discussion of exactly what this means).
     * 
     * Note that since the task takes ownership of `error,` and since the
     * task may be completed before returning from g_task_return_error(),
     * you cannot assume that `error` is still valid after calling this.
     * Call g_error_copy() on the error if you need to keep a local copy
     * as well.
     * 
     * See also g_task_return_new_error().
     * @param error the #GError result of a task function.
     */
    return_error(error: GLib.Error): void
    /**
     * Checks if `task'`s #GCancellable has been cancelled, and if so, sets
     * `task'`s error accordingly and completes the task (see
     * g_task_return_pointer() for more discussion of exactly what this
     * means).
     * @returns %TRUE if @task has been cancelled, %FALSE if not
     */
    return_error_if_cancelled(): boolean
    /**
     * Sets `task'`s result to `result` and completes the task (see
     * g_task_return_pointer() for more discussion of exactly what this
     * means).
     * @param result the integer (#gssize) result of a task function.
     */
    return_int(result: number): void
    /**
     * Sets `task'`s result to `result` and completes the task. If `result`
     * is not %NULL, then `result_destroy` will be used to free `result` if
     * the caller does not take ownership of it with
     * g_task_propagate_pointer().
     * 
     * "Completes the task" means that for an ordinary asynchronous task
     * it will either invoke the task's callback, or else queue that
     * callback to be invoked in the proper #GMainContext, or in the next
     * iteration of the current #GMainContext. For a task run via
     * g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
     * method will save `result` to be returned to the caller later, but
     * the task will not actually be completed until the #GTaskThreadFunc
     * exits.
     * 
     * Note that since the task may be completed before returning from
     * g_task_return_pointer(), you cannot assume that `result` is still
     * valid after calling this, unless you are still holding another
     * reference on it.
     * @param result the pointer result of a task     function
     * @param result_destroy a #GDestroyNotify function.
     */
    return_pointer(result: any | null, result_destroy: GLib.DestroyNotify | null): void
    /**
     * Sets `task'`s result to `result` (by copying it) and completes the task.
     * 
     * If `result` is %NULL then a #GValue of type %G_TYPE_POINTER
     * with a value of %NULL will be used for the result.
     * 
     * This is a very generic low-level method intended primarily for use
     * by language bindings; for C code, g_task_return_pointer() and the
     * like will normally be much easier to use.
     * @param result the #GValue result of                                      a task function
     */
    return_value(result: any | null): void
    /**
     * Runs `task_func` in another thread. When `task_func` returns, `task'`s
     * #GAsyncReadyCallback will be invoked in `task'`s #GMainContext.
     * 
     * This takes a ref on `task` until the task completes.
     * 
     * See #GTaskThreadFunc for more details about how `task_func` is handled.
     * 
     * Although GLib currently rate-limits the tasks queued via
     * g_task_run_in_thread(), you should not assume that it will always
     * do this. If you have a very large number of tasks to run (several tens of
     * tasks), but don't want them to all run at once, you should only queue a
     * limited number of them (around ten) at a time.
     * @param task_func a #GTaskThreadFunc
     */
    run_in_thread(task_func: TaskThreadFunc): void
    /**
     * Runs `task_func` in another thread, and waits for it to return or be
     * cancelled. You can use g_task_propagate_pointer(), etc, afterward
     * to get the result of `task_func`.
     * 
     * See #GTaskThreadFunc for more details about how `task_func` is handled.
     * 
     * Normally this is used with tasks created with a %NULL
     * `callback`, but note that even if the task does
     * have a callback, it will not be invoked when `task_func` returns.
     * #GTask:completed will be set to %TRUE just before this function returns.
     * 
     * Although GLib currently rate-limits the tasks queued via
     * g_task_run_in_thread_sync(), you should not assume that it will
     * always do this. If you have a very large number of tasks to run,
     * but don't want them to all run at once, you should only queue a
     * limited number of them at a time.
     * @param task_func a #GTaskThreadFunc
     */
    run_in_thread_sync(task_func: TaskThreadFunc): void
    /**
     * Sets or clears `task'`s check-cancellable flag. If this is %TRUE
     * (the default), then g_task_propagate_pointer(), etc, and
     * g_task_had_error() will check the task's #GCancellable first, and
     * if it has been cancelled, then they will consider the task to have
     * returned an "Operation was cancelled" error
     * (%G_IO_ERROR_CANCELLED), regardless of any other error or return
     * value the task may have had.
     * 
     * If `check_cancellable` is %FALSE, then the #GTask will not check the
     * cancellable itself, and it is up to `task'`s owner to do this (eg,
     * via g_task_return_error_if_cancelled()).
     * 
     * If you are using g_task_set_return_on_cancel() as well, then
     * you must leave check-cancellable set %TRUE.
     * @param check_cancellable whether #GTask will check the state of   its #GCancellable for you.
     */
    set_check_cancellable(check_cancellable: boolean): void
    /**
     * Sets `task’`s name, used in debugging and profiling. The name defaults to
     * %NULL.
     * 
     * The task name should describe in a human readable way what the task does.
     * For example, ‘Open file’ or ‘Connect to network host’. It is used to set the
     * name of the #GSource used for idle completion of the task.
     * 
     * This function may only be called before the `task` is first used in a thread
     * other than the one it was constructed in. It is called automatically by
     * g_task_set_source_tag() if not called already.
     * @param name a human readable name for the task, or %NULL to unset it
     */
    set_name(name: string | null): void
    /**
     * Sets `task'`s priority. If you do not call this, it will default to
     * %G_PRIORITY_DEFAULT.
     * 
     * This will affect the priority of #GSources created with
     * g_task_attach_source() and the scheduling of tasks run in threads,
     * and can also be explicitly retrieved later via
     * g_task_get_priority().
     * @param priority the [priority][io-priority] of the request
     */
    set_priority(priority: number): void
    /**
     * Sets or clears `task'`s return-on-cancel flag. This is only
     * meaningful for tasks run via g_task_run_in_thread() or
     * g_task_run_in_thread_sync().
     * 
     * If `return_on_cancel` is %TRUE, then cancelling `task'`s
     * #GCancellable will immediately cause it to return, as though the
     * task's #GTaskThreadFunc had called
     * g_task_return_error_if_cancelled() and then returned.
     * 
     * This allows you to create a cancellable wrapper around an
     * uninterruptible function. The #GTaskThreadFunc just needs to be
     * careful that it does not modify any externally-visible state after
     * it has been cancelled. To do that, the thread should call
     * g_task_set_return_on_cancel() again to (atomically) set
     * return-on-cancel %FALSE before making externally-visible changes;
     * if the task gets cancelled before the return-on-cancel flag could
     * be changed, g_task_set_return_on_cancel() will indicate this by
     * returning %FALSE.
     * 
     * You can disable and re-enable this flag multiple times if you wish.
     * If the task's #GCancellable is cancelled while return-on-cancel is
     * %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
     * again will cause the task to be cancelled at that point.
     * 
     * If the task's #GCancellable is already cancelled before you call
     * g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
     * #GTaskThreadFunc will still be run (for consistency), but the task
     * will also be completed right away.
     * @param return_on_cancel whether the task returns automatically when   it is cancelled.
     * @returns %TRUE if @task's return-on-cancel flag was changed to   match @return_on_cancel. %FALSE if @task has already been   cancelled.
     */
    set_return_on_cancel(return_on_cancel: boolean): boolean
    /**
     * Sets `task'`s source tag.
     * 
     * You can use this to tag a task return
     * value with a particular pointer (usually a pointer to the function
     * doing the tagging) and then later check it using
     * g_task_get_source_tag() (or g_async_result_is_tagged()) in the
     * task's "finish" function, to figure out if the response came from a
     * particular place.
     * 
     * A macro wrapper around this function will automatically set the
     * task’s name to the string form of `source_tag` if it’s not already
     * set, for convenience.
     * @param source_tag an opaque pointer indicating the source of this task
     */
    set_source_tag(source_tag: any | null): void
    /**
     * Sets `task’`s name, used in debugging and profiling.
     * 
     * This is a variant of g_task_set_name() that avoids copying `name`.
     * @param name a human readable name for the task. Must be a string literal
     */
    set_static_name(name: string | null): void
    /**
     * Sets `task'`s task data (freeing the existing task data, if any).
     * @param task_data task-specific data
     * @param task_data_destroy #GDestroyNotify for `task_data`
     */
    set_task_data(task_data: any | null, task_data_destroy: GLib.DestroyNotify | null): void

    // Class property signals of Gio-2.0.Gio.Task

    connect(sigName: "notify::completed", callback: (($obj: Task, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::completed", callback: (($obj: Task, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::completed", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GTask represents and manages a cancellable "task".
 * 
 * ## Asynchronous operations
 * 
 * The most common usage of #GTask is as a #GAsyncResult, to
 * manage data during an asynchronous operation. You call
 * g_task_new() in the "start" method, followed by
 * g_task_set_task_data() and the like if you need to keep some
 * additional data associated with the task, and then pass the
 * task object around through your asynchronous operation.
 * Eventually, you will call a method such as
 * g_task_return_pointer() or g_task_return_error(), which will
 * save the value you give it and then invoke the task's callback
 * function in the
 * [thread-default main context][g-main-context-push-thread-default]
 * where it was created (waiting until the next iteration of the main
 * loop first, if necessary). The caller will pass the #GTask back to
 * the operation's finish function (as a #GAsyncResult), and you can
 * use g_task_propagate_pointer() or the like to extract the
 * return value.
 * 
 * Using #GTask requires the thread-default #GMainContext from when the
 * #GTask was constructed to be running at least until the task has completed
 * and its data has been freed.
 * 
 * If a #GTask has been constructed and its callback set, it is an error to
 * not call `g_task_return_*()` on it. GLib will warn at runtime if this happens
 * (since 2.76).
 * 
 * Here is an example for using GTask as a GAsyncResult:
 * 
 * ```c
 *     typedef struct {
 *       CakeFrostingType frosting;
 *       char *message;
 *     } DecorationData;
 * 
 *     static void
 *     decoration_data_free (DecorationData *decoration)
 *     {
 *       g_free (decoration->message);
 *       g_slice_free (DecorationData, decoration);
 *     }
 * 
 *     static void
 *     baked_cb (Cake     *cake,
 *               gpointer  user_data)
 *     {
 *       GTask *task = user_data;
 *       DecorationData *decoration = g_task_get_task_data (task);
 *       GError *error = NULL;
 * 
 *       if (cake == NULL)
 *         {
 *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
 *                                    "Go to the supermarket");
 *           g_object_unref (task);
 *           return;
 *         }
 * 
 *       if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
 *         {
 *           g_object_unref (cake);
 *           // g_task_return_error() takes ownership of error
 *           g_task_return_error (task, error);
 *           g_object_unref (task);
 *           return;
 *         }
 * 
 *       g_task_return_pointer (task, cake, g_object_unref);
 *       g_object_unref (task);
 *     }
 * 
 *     void
 *     baker_bake_cake_async (Baker               *self,
 *                            guint                radius,
 *                            CakeFlavor           flavor,
 *                            CakeFrostingType     frosting,
 *                            const char          *message,
 *                            GCancellable        *cancellable,
 *                            GAsyncReadyCallback  callback,
 *                            gpointer             user_data)
 *     {
 *       GTask *task;
 *       DecorationData *decoration;
 *       Cake  *cake;
 * 
 *       task = g_task_new (self, cancellable, callback, user_data);
 *       if (radius < 3)
 *         {
 *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
 *                                    "%ucm radius cakes are silly",
 *                                    radius);
 *           g_object_unref (task);
 *           return;
 *         }
 * 
 *       cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
 *       if (cake != NULL)
 *         {
 *           // _baker_get_cached_cake() returns a reffed cake
 *           g_task_return_pointer (task, cake, g_object_unref);
 *           g_object_unref (task);
 *           return;
 *         }
 * 
 *       decoration = g_slice_new (DecorationData);
 *       decoration->frosting = frosting;
 *       decoration->message = g_strdup (message);
 *       g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);
 * 
 *       _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
 *     }
 * 
 *     Cake *
 *     baker_bake_cake_finish (Baker         *self,
 *                             GAsyncResult  *result,
 *                             GError       **error)
 *     {
 *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
 * 
 *       return g_task_propagate_pointer (G_TASK (result), error);
 *     }
 * ```
 * 
 * 
 * ## Chained asynchronous operations
 * 
 * #GTask also tries to simplify asynchronous operations that
 * internally chain together several smaller asynchronous
 * operations. g_task_get_cancellable(), g_task_get_context(),
 * and g_task_get_priority() allow you to get back the task's
 * #GCancellable, #GMainContext, and [I/O priority][io-priority]
 * when starting a new subtask, so you don't have to keep track
 * of them yourself. g_task_attach_source() simplifies the case
 * of waiting for a source to fire (automatically using the correct
 * #GMainContext and priority).
 * 
 * Here is an example for chained asynchronous operations:
 *   
 * ```c
 *     typedef struct {
 *       Cake *cake;
 *       CakeFrostingType frosting;
 *       char *message;
 *     } BakingData;
 * 
 *     static void
 *     decoration_data_free (BakingData *bd)
 *     {
 *       if (bd->cake)
 *         g_object_unref (bd->cake);
 *       g_free (bd->message);
 *       g_slice_free (BakingData, bd);
 *     }
 * 
 *     static void
 *     decorated_cb (Cake         *cake,
 *                   GAsyncResult *result,
 *                   gpointer      user_data)
 *     {
 *       GTask *task = user_data;
 *       GError *error = NULL;
 * 
 *       if (!cake_decorate_finish (cake, result, &error))
 *         {
 *           g_object_unref (cake);
 *           g_task_return_error (task, error);
 *           g_object_unref (task);
 *           return;
 *         }
 * 
 *       // baking_data_free() will drop its ref on the cake, so we have to
 *       // take another here to give to the caller.
 *       g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
 *       g_object_unref (task);
 *     }
 * 
 *     static gboolean
 *     decorator_ready (gpointer user_data)
 *     {
 *       GTask *task = user_data;
 *       BakingData *bd = g_task_get_task_data (task);
 * 
 *       cake_decorate_async (bd->cake, bd->frosting, bd->message,
 *                            g_task_get_cancellable (task),
 *                            decorated_cb, task);
 * 
 *       return G_SOURCE_REMOVE;
 *     }
 * 
 *     static void
 *     baked_cb (Cake     *cake,
 *               gpointer  user_data)
 *     {
 *       GTask *task = user_data;
 *       BakingData *bd = g_task_get_task_data (task);
 *       GError *error = NULL;
 * 
 *       if (cake == NULL)
 *         {
 *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
 *                                    "Go to the supermarket");
 *           g_object_unref (task);
 *           return;
 *         }
 * 
 *       bd->cake = cake;
 * 
 *       // Bail out now if the user has already cancelled
 *       if (g_task_return_error_if_cancelled (task))
 *         {
 *           g_object_unref (task);
 *           return;
 *         }
 * 
 *       if (cake_decorator_available (cake))
 *         decorator_ready (task);
 *       else
 *         {
 *           GSource *source;
 * 
 *           source = cake_decorator_wait_source_new (cake);
 *           // Attach `source` to `task'`s GMainContext and have it call
 *           // decorator_ready() when it is ready.
 *           g_task_attach_source (task, source, decorator_ready);
 *           g_source_unref (source);
 *         }
 *     }
 * 
 *     void
 *     baker_bake_cake_async (Baker               *self,
 *                            guint                radius,
 *                            CakeFlavor           flavor,
 *                            CakeFrostingType     frosting,
 *                            const char          *message,
 *                            gint                 priority,
 *                            GCancellable        *cancellable,
 *                            GAsyncReadyCallback  callback,
 *                            gpointer             user_data)
 *     {
 *       GTask *task;
 *       BakingData *bd;
 * 
 *       task = g_task_new (self, cancellable, callback, user_data);
 *       g_task_set_priority (task, priority);
 * 
 *       bd = g_slice_new0 (BakingData);
 *       bd->frosting = frosting;
 *       bd->message = g_strdup (message);
 *       g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
 * 
 *       _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
 *     }
 * 
 *     Cake *
 *     baker_bake_cake_finish (Baker         *self,
 *                             GAsyncResult  *result,
 *                             GError       **error)
 *     {
 *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
 * 
 *       return g_task_propagate_pointer (G_TASK (result), error);
 *     }
 * ```
 * 
 * 
 * ## Asynchronous operations from synchronous ones
 * 
 * You can use g_task_run_in_thread() to turn a synchronous
 * operation into an asynchronous one, by running it in a thread.
 * When it completes, the result will be dispatched to the
 * [thread-default main context][g-main-context-push-thread-default]
 * where the #GTask was created.
 * 
 * Running a task in a thread:
 *   
 * ```c
 *     typedef struct {
 *       guint radius;
 *       CakeFlavor flavor;
 *       CakeFrostingType frosting;
 *       char *message;
 *     } CakeData;
 * 
 *     static void
 *     cake_data_free (CakeData *cake_data)
 *     {
 *       g_free (cake_data->message);
 *       g_slice_free (CakeData, cake_data);
 *     }
 * 
 *     static void
 *     bake_cake_thread (GTask         *task,
 *                       gpointer       source_object,
 *                       gpointer       task_data,
 *                       GCancellable  *cancellable)
 *     {
 *       Baker *self = source_object;
 *       CakeData *cake_data = task_data;
 *       Cake *cake;
 *       GError *error = NULL;
 * 
 *       cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
 *                         cake_data->frosting, cake_data->message,
 *                         cancellable, &error);
 *       if (cake)
 *         g_task_return_pointer (task, cake, g_object_unref);
 *       else
 *         g_task_return_error (task, error);
 *     }
 * 
 *     void
 *     baker_bake_cake_async (Baker               *self,
 *                            guint                radius,
 *                            CakeFlavor           flavor,
 *                            CakeFrostingType     frosting,
 *                            const char          *message,
 *                            GCancellable        *cancellable,
 *                            GAsyncReadyCallback  callback,
 *                            gpointer             user_data)
 *     {
 *       CakeData *cake_data;
 *       GTask *task;
 * 
 *       cake_data = g_slice_new (CakeData);
 *       cake_data->radius = radius;
 *       cake_data->flavor = flavor;
 *       cake_data->frosting = frosting;
 *       cake_data->message = g_strdup (message);
 *       task = g_task_new (self, cancellable, callback, user_data);
 *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
 *       g_task_run_in_thread (task, bake_cake_thread);
 *       g_object_unref (task);
 *     }
 * 
 *     Cake *
 *     baker_bake_cake_finish (Baker         *self,
 *                             GAsyncResult  *result,
 *                             GError       **error)
 *     {
 *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
 * 
 *       return g_task_propagate_pointer (G_TASK (result), error);
 *     }
 * ```
 * 
 * 
 * ## Adding cancellability to uncancellable tasks
 * 
 * Finally, g_task_run_in_thread() and g_task_run_in_thread_sync()
 * can be used to turn an uncancellable operation into a
 * cancellable one. If you call g_task_set_return_on_cancel(),
 * passing %TRUE, then if the task's #GCancellable is cancelled,
 * it will return control back to the caller immediately, while
 * allowing the task thread to continue running in the background
 * (and simply discarding its result when it finally does finish).
 * Provided that the task thread is careful about how it uses
 * locks and other externally-visible resources, this allows you
 * to make "GLib-friendly" asynchronous and cancellable
 * synchronous variants of blocking APIs.
 * 
 * Cancelling a task:
 *   
 * ```c
 *     static void
 *     bake_cake_thread (GTask         *task,
 *                       gpointer       source_object,
 *                       gpointer       task_data,
 *                       GCancellable  *cancellable)
 *     {
 *       Baker *self = source_object;
 *       CakeData *cake_data = task_data;
 *       Cake *cake;
 *       GError *error = NULL;
 * 
 *       cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
 *                         cake_data->frosting, cake_data->message,
 *                         &error);
 *       if (error)
 *         {
 *           g_task_return_error (task, error);
 *           return;
 *         }
 * 
 *       // If the task has already been cancelled, then we don't want to add
 *       // the cake to the cake cache. Likewise, we don't  want to have the
 *       // task get cancelled in the middle of updating the cache.
 *       // g_task_set_return_on_cancel() will return %TRUE here if it managed
 *       // to disable return-on-cancel, or %FALSE if the task was cancelled
 *       // before it could.
 *       if (g_task_set_return_on_cancel (task, FALSE))
 *         {
 *           // If the caller cancels at this point, their
 *           // GAsyncReadyCallback won't be invoked until we return,
 *           // so we don't have to worry that this code will run at
 *           // the same time as that code does. But if there were
 *           // other functions that might look at the cake cache,
 *           // then we'd probably need a GMutex here as well.
 *           baker_add_cake_to_cache (baker, cake);
 *           g_task_return_pointer (task, cake, g_object_unref);
 *         }
 *     }
 * 
 *     void
 *     baker_bake_cake_async (Baker               *self,
 *                            guint                radius,
 *                            CakeFlavor           flavor,
 *                            CakeFrostingType     frosting,
 *                            const char          *message,
 *                            GCancellable        *cancellable,
 *                            GAsyncReadyCallback  callback,
 *                            gpointer             user_data)
 *     {
 *       CakeData *cake_data;
 *       GTask *task;
 * 
 *       cake_data = g_slice_new (CakeData);
 * 
 *       ...
 * 
 *       task = g_task_new (self, cancellable, callback, user_data);
 *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
 *       g_task_set_return_on_cancel (task, TRUE);
 *       g_task_run_in_thread (task, bake_cake_thread);
 *     }
 * 
 *     Cake *
 *     baker_bake_cake_sync (Baker               *self,
 *                           guint                radius,
 *                           CakeFlavor           flavor,
 *                           CakeFrostingType     frosting,
 *                           const char          *message,
 *                           GCancellable        *cancellable,
 *                           GError             **error)
 *     {
 *       CakeData *cake_data;
 *       GTask *task;
 *       Cake *cake;
 * 
 *       cake_data = g_slice_new (CakeData);
 * 
 *       ...
 * 
 *       task = g_task_new (self, cancellable, NULL, NULL);
 *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
 *       g_task_set_return_on_cancel (task, TRUE);
 *       g_task_run_in_thread_sync (task, bake_cake_thread);
 * 
 *       cake = g_task_propagate_pointer (task, error);
 *       g_object_unref (task);
 *       return cake;
 *     }
 * ```
 * 
 * 
 * ## Porting from GSimpleAsyncResult
 * 
 * #GTask's API attempts to be simpler than #GSimpleAsyncResult's
 * in several ways:
 * - You can save task-specific data with g_task_set_task_data(), and
 *   retrieve it later with g_task_get_task_data(). This replaces the
 *   abuse of g_simple_async_result_set_op_res_gpointer() for the same
 *   purpose with #GSimpleAsyncResult.
 * - In addition to the task data, #GTask also keeps track of the
 *   [priority][io-priority], #GCancellable, and
 *   #GMainContext associated with the task, so tasks that consist of
 *   a chain of simpler asynchronous operations will have easy access
 *   to those values when starting each sub-task.
 * - g_task_return_error_if_cancelled() provides simplified
 *   handling for cancellation. In addition, cancellation
 *   overrides any other #GTask return value by default, like
 *   #GSimpleAsyncResult does when
 *   g_simple_async_result_set_check_cancellable() is called.
 *   (You can use g_task_set_check_cancellable() to turn off that
 *   behavior.) On the other hand, g_task_run_in_thread()
 *   guarantees that it will always run your
 *   `task_func`, even if the task's #GCancellable
 *   is already cancelled before the task gets a chance to run;
 *   you can start your `task_func` with a
 *   g_task_return_error_if_cancelled() check if you need the
 *   old behavior.
 * - The "return" methods (eg, g_task_return_pointer())
 *   automatically cause the task to be "completed" as well, and
 *   there is no need to worry about the "complete" vs "complete
 *   in idle" distinction. (#GTask automatically figures out
 *   whether the task's callback can be invoked directly, or
 *   if it needs to be sent to another #GMainContext, or delayed
 *   until the next iteration of the current #GMainContext.)
 * - The "finish" functions for #GTask based operations are generally
 *   much simpler than #GSimpleAsyncResult ones, normally consisting
 *   of only a single call to g_task_propagate_pointer() or the like.
 *   Since g_task_propagate_pointer() "steals" the return value from
 *   the #GTask, it is not necessary to juggle pointers around to
 *   prevent it from being freed twice.
 * - With #GSimpleAsyncResult, it was common to call
 *   g_simple_async_result_propagate_error() from the
 *   `_finish()` wrapper function, and have
 *   virtual method implementations only deal with successful
 *   returns. This behavior is deprecated, because it makes it
 *   difficult for a subclass to chain to a parent class's async
 *   methods. Instead, the wrapper function should just be a
 *   simple wrapper, and the virtual method should call an
 *   appropriate `g_task_propagate_` function.
 *   Note that wrapper methods can now use
 *   g_async_result_legacy_propagate_error() to do old-style
 *   #GSimpleAsyncResult error-returning behavior, and
 *   g_async_result_is_tagged() to check if a result is tagged as
 *   having come from the `_async()` wrapper
 *   function (for "short-circuit" results, such as when passing
 *   0 to g_input_stream_read_async()).
 * 
 * ## Thread-safety considerations
 * 
 * Due to some infelicities in the API design, there is a
 * thread-safety concern that users of GTask have to be aware of:
 * 
 * If the `main` thread drops its last reference to the source object
 * or the task data before the task is finalized, then the finalizers
 * of these objects may be called on the worker thread.
 * 
 * This is a problem if the finalizers use non-threadsafe API, and
 * can lead to hard-to-debug crashes. Possible workarounds include:
 * 
 * - Clear task data in a signal handler for `notify::completed`
 * 
 * - Keep iterating a main context in the main thread and defer
 *   dropping the reference to the source object to that main
 *   context when the task is finalized
 * @class 
 */
class Task extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Task

    static name: string
    static $gtype: GObject.GType<Task>

    // Constructors of Gio-2.0.Gio.Task

    constructor(config?: Task.ConstructorProperties) 
    /**
     * Creates a #GTask acting on `source_object,` which will eventually be
     * used to invoke `callback` in the current
     * [thread-default main context][g-main-context-push-thread-default].
     * 
     * Call this in the "start" method of your asynchronous method, and
     * pass the #GTask around throughout the asynchronous operation. You
     * can use g_task_set_task_data() to attach task-specific data to the
     * object, which you can retrieve later via g_task_get_task_data().
     * 
     * By default, if `cancellable` is cancelled, then the return value of
     * the task will always be %G_IO_ERROR_CANCELLED, even if the task had
     * already completed before the cancellation. This allows for
     * simplified handling in cases where cancellation may imply that
     * other objects that the task depends on have been destroyed. If you
     * do not want this behavior, you can use
     * g_task_set_check_cancellable() to change it.
     * @constructor 
     * @param source_object the #GObject that owns   this task, or %NULL.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback.
     * @returns a #GTask.
     */
    constructor(source_object: GObject.Object | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<Task> | null) 
    /**
     * Creates a #GTask acting on `source_object,` which will eventually be
     * used to invoke `callback` in the current
     * [thread-default main context][g-main-context-push-thread-default].
     * 
     * Call this in the "start" method of your asynchronous method, and
     * pass the #GTask around throughout the asynchronous operation. You
     * can use g_task_set_task_data() to attach task-specific data to the
     * object, which you can retrieve later via g_task_get_task_data().
     * 
     * By default, if `cancellable` is cancelled, then the return value of
     * the task will always be %G_IO_ERROR_CANCELLED, even if the task had
     * already completed before the cancellation. This allows for
     * simplified handling in cases where cancellation may imply that
     * other objects that the task depends on have been destroyed. If you
     * do not want this behavior, you can use
     * g_task_set_check_cancellable() to change it.
     * @constructor 
     * @param source_object the #GObject that owns   this task, or %NULL.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback.
     * @returns a #GTask.
     */
    static new(source_object: GObject.Object | null, cancellable: Cancellable | null, callback: AsyncReadyCallback<Task> | null): Task
    _init(config?: Task.ConstructorProperties): void
    /**
     * Checks that `result` is a #GTask, and that `source_object` is its
     * source object (or that `source_object` is %NULL and `result` has no
     * source object). This can be used in g_return_if_fail() checks.
     * @param result A #GAsyncResult
     * @param source_object the source object   expected to be associated with the task
     * @returns %TRUE if @result and @source_object are valid, %FALSE if not
     */
    static is_valid(result: AsyncResult, source_object: GObject.Object | null): boolean
    /**
     * Creates a #GTask and then immediately calls g_task_return_error()
     * on it. Use this in the wrapper function of an asynchronous method
     * when you want to avoid even calling the virtual method. You can
     * then use g_async_result_is_tagged() in the finish method wrapper to
     * check if the result there is tagged as having been created by the
     * wrapper method, and deal with it appropriately if so.
     * 
     * See also g_task_report_new_error().
     * @param source_object the #GObject that owns   this task, or %NULL.
     * @param callback a #GAsyncReadyCallback.
     * @param source_tag an opaque pointer indicating the source of this task
     * @param error error to report
     */
    static report_error(source_object: GObject.Object | null, callback: AsyncReadyCallback<Task> | null, source_tag: any | null, error: GLib.Error): void
}

module TcpConnection {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnection.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TcpConnection

        graceful_disconnect?: boolean | null
    }

}

interface TcpConnection {

    // Own properties of Gio-2.0.Gio.TcpConnection

    graceful_disconnect: boolean

    // Own fields of Gio-2.0.Gio.TcpConnection

    parent_instance: SocketConnection & IOStream & GObject.Object & GObject.Object
    priv: any

    // Owm methods of Gio-2.0.Gio.TcpConnection

    /**
     * Checks if graceful disconnects are used. See
     * g_tcp_connection_set_graceful_disconnect().
     * @returns %TRUE if graceful disconnect is used on close, %FALSE otherwise
     */
    get_graceful_disconnect(): boolean
    /**
     * This enables graceful disconnects on close. A graceful disconnect
     * means that we signal the receiving end that the connection is terminated
     * and wait for it to close the connection before closing the connection.
     * 
     * A graceful disconnect means that we can be sure that we successfully sent
     * all the outstanding data to the other end, or get an error reported.
     * However, it also means we have to wait for all the data to reach the
     * other side and for it to acknowledge this by closing the socket, which may
     * take a while. For this reason it is disabled by default.
     * @param graceful_disconnect Whether to do graceful disconnects or not
     */
    set_graceful_disconnect(graceful_disconnect: boolean): void

    // Class property signals of Gio-2.0.Gio.TcpConnection

    connect(sigName: "notify::graceful-disconnect", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::graceful-disconnect", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::graceful-disconnect", ...args: any[]): void
    connect(sigName: "notify::socket", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::socket", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::socket", ...args: any[]): void
    connect(sigName: "notify::closed", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::closed", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: "notify::input-stream", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::input-stream", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::input-stream", ...args: any[]): void
    connect(sigName: "notify::output-stream", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::output-stream", callback: (($obj: TcpConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::output-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This is the subclass of #GSocketConnection that is created
 * for TCP/IP sockets.
 * @class 
 */
class TcpConnection extends SocketConnection {

    // Own properties of Gio-2.0.Gio.TcpConnection

    static name: string
    static $gtype: GObject.GType<TcpConnection>

    // Constructors of Gio-2.0.Gio.TcpConnection

    constructor(config?: TcpConnection.ConstructorProperties) 
    _init(config?: TcpConnection.ConstructorProperties): void
}

module TcpWrapperConnection {

    // Constructor properties interface

    interface ConstructorProperties extends TcpConnection.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TcpWrapperConnection

        base_io_stream?: IOStream | null
    }

}

interface TcpWrapperConnection {

    // Own properties of Gio-2.0.Gio.TcpWrapperConnection

    readonly base_io_stream: IOStream

    // Own fields of Gio-2.0.Gio.TcpWrapperConnection

    parent_instance: TcpConnection & SocketConnection & IOStream & GObject.Object & GObject.Object
    priv: any

    // Owm methods of Gio-2.0.Gio.TcpWrapperConnection

    /**
     * Gets `conn'`s base #GIOStream
     * @returns @conn's base #GIOStream
     */
    get_base_io_stream(): IOStream

    // Class property signals of Gio-2.0.Gio.TcpWrapperConnection

    connect(sigName: "notify::base-io-stream", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::base-io-stream", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::base-io-stream", ...args: any[]): void
    connect(sigName: "notify::graceful-disconnect", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::graceful-disconnect", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::graceful-disconnect", ...args: any[]): void
    connect(sigName: "notify::socket", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::socket", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::socket", ...args: any[]): void
    connect(sigName: "notify::closed", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::closed", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: "notify::input-stream", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::input-stream", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::input-stream", ...args: any[]): void
    connect(sigName: "notify::output-stream", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::output-stream", callback: (($obj: TcpWrapperConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::output-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GTcpWrapperConnection can be used to wrap a #GIOStream that is
 * based on a #GSocket, but which is not actually a
 * #GSocketConnection. This is used by #GSocketClient so that it can
 * always return a #GSocketConnection, even when the connection it has
 * actually created is not directly a #GSocketConnection.
 * @class 
 */
class TcpWrapperConnection extends TcpConnection {

    // Own properties of Gio-2.0.Gio.TcpWrapperConnection

    static name: string
    static $gtype: GObject.GType<TcpWrapperConnection>

    // Constructors of Gio-2.0.Gio.TcpWrapperConnection

    constructor(config?: TcpWrapperConnection.ConstructorProperties) 
    /**
     * Wraps `base_io_stream` and `socket` together as a #GSocketConnection.
     * @constructor 
     * @param base_io_stream the #GIOStream to wrap
     * @param socket the #GSocket associated with `base_io_stream`
     * @returns the new #GSocketConnection.
     */
    constructor(base_io_stream: IOStream, socket: Socket) 
    /**
     * Wraps `base_io_stream` and `socket` together as a #GSocketConnection.
     * @constructor 
     * @param base_io_stream the #GIOStream to wrap
     * @param socket the #GSocket associated with `base_io_stream`
     * @returns the new #GSocketConnection.
     */
    static new(base_io_stream: IOStream, socket: Socket): TcpWrapperConnection
    _init(config?: TcpWrapperConnection.ConstructorProperties): void
}

module TestDBus {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TestDBus

        /**
         * #GTestDBusFlags specifying the behaviour of the D-Bus session.
         */
        flags?: TestDBusFlags | null
    }

}

interface TestDBus {

    // Own properties of Gio-2.0.Gio.TestDBus

    /**
     * #GTestDBusFlags specifying the behaviour of the D-Bus session.
     */
    readonly flags: TestDBusFlags

    // Owm methods of Gio-2.0.Gio.TestDBus

    /**
     * Add a path where dbus-daemon will look up .service files. This can't be
     * called after g_test_dbus_up().
     * @param path path to a directory containing .service files
     */
    add_service_dir(path: string | null): void
    /**
     * Stop the session bus started by g_test_dbus_up().
     * 
     * This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
     * to be destroyed. This is done to ensure that the next unit test won't get a
     * leaked singleton from this test.
     */
    down(): void
    /**
     * Get the address on which dbus-daemon is running. If g_test_dbus_up() has not
     * been called yet, %NULL is returned. This can be used with
     * g_dbus_connection_new_for_address().
     * @returns the address of the bus, or %NULL.
     */
    get_bus_address(): string | null
    /**
     * Get the flags of the #GTestDBus object.
     * @returns the value of #GTestDBus:flags property
     */
    get_flags(): TestDBusFlags
    /**
     * Stop the session bus started by g_test_dbus_up().
     * 
     * Unlike g_test_dbus_down(), this won't verify the #GDBusConnection
     * singleton returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit
     * tests wanting to verify behaviour after the session bus has been stopped
     * can use this function but should still call g_test_dbus_down() when done.
     */
    stop(): void
    /**
     * Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
     * call, it is safe for unit tests to start sending messages on the session bus.
     * 
     * If this function is called from setup callback of g_test_add(),
     * g_test_dbus_down() must be called in its teardown callback.
     * 
     * If this function is called from unit test's main(), then g_test_dbus_down()
     * must be called after g_test_run().
     */
    up(): void

    // Class property signals of Gio-2.0.Gio.TestDBus

    connect(sigName: "notify::flags", callback: (($obj: TestDBus, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: TestDBus, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A helper class for testing code which uses D-Bus without touching the user's
 * session bus.
 * 
 * Note that #GTestDBus modifies the user’s environment, calling setenv().
 * This is not thread-safe, so all #GTestDBus calls should be completed before
 * threads are spawned, or should have appropriate locking to ensure no access
 * conflicts to environment variables shared between #GTestDBus and other
 * threads.
 * 
 * ## Creating unit tests using GTestDBus
 * 
 * Testing of D-Bus services can be tricky because normally we only ever run
 * D-Bus services over an existing instance of the D-Bus daemon thus we
 * usually don't activate D-Bus services that are not yet installed into the
 * target system. The #GTestDBus object makes this easier for us by taking care
 * of the lower level tasks such as running a private D-Bus daemon and looking
 * up uninstalled services in customizable locations, typically in your source
 * code tree.
 * 
 * The first thing you will need is a separate service description file for the
 * D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
 * is a good place to put this file.
 * 
 * The service file should list your service along with an absolute path to the
 * uninstalled service executable in your source tree. Using autotools we would
 * achieve this by adding a file such as `my-server.service.in` in the services
 * directory and have it processed by configure.
 * 
 * ```
 *     [D-BUS Service]
 *     Name=org.gtk.GDBus.Examples.ObjectManager
 *     Exec=`abs_top_builddir@`/gio/tests/gdbus-example-objectmanager-server
 * ```
 * 
 * You will also need to indicate this service directory in your test
 * fixtures, so you will need to pass the path while compiling your
 * test cases. Typically this is done with autotools with an added
 * preprocessor flag specified to compile your tests such as:
 * 
 * ```
 *     -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
 * ```
 * 
 *     Once you have a service definition file which is local to your source tree,
 * you can proceed to set up a GTest fixture using the #GTestDBus scaffolding.
 * 
 * An example of a test fixture for D-Bus services can be found
 * here:
 * [gdbus-test-fixture.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)
 * 
 * Note that these examples only deal with isolating the D-Bus aspect of your
 * service. To successfully run isolated unit tests on your service you may need
 * some additional modifications to your test case fixture. For example; if your
 * service uses GSettings and installs a schema then it is important that your test service
 * not load the schema in the ordinary installed location (chances are that your service
 * and schema files are not yet installed, or worse; there is an older version of the
 * schema file sitting in the install location).
 * 
 * Most of the time we can work around these obstacles using the
 * environment. Since the environment is inherited by the D-Bus daemon
 * created by #GTestDBus and then in turn inherited by any services the
 * D-Bus daemon activates, using the setup routine for your fixture is
 * a practical place to help sandbox your runtime environment. For the
 * rather typical GSettings case we can work around this by setting
 * `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
 * in the above fixture_setup() routine.
 * 
 * The GSettings schemas need to be locally pre-compiled for this to work. This can be achieved
 * by compiling the schemas locally as a step before running test cases, an autotools setup might
 * do the following in the directory holding schemas:
 * 
 * ```
 *     all-am:
 *             $(GLIB_COMPILE_SCHEMAS) .
 * 
 *     CLEANFILES += gschemas.compiled
 * ```
 * 
 * @class 
 */
class TestDBus extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TestDBus

    static name: string
    static $gtype: GObject.GType<TestDBus>

    // Constructors of Gio-2.0.Gio.TestDBus

    constructor(config?: TestDBus.ConstructorProperties) 
    /**
     * Create a new #GTestDBus object.
     * @constructor 
     * @param flags a #GTestDBusFlags
     * @returns a new #GTestDBus.
     */
    constructor(flags: TestDBusFlags) 
    /**
     * Create a new #GTestDBus object.
     * @constructor 
     * @param flags a #GTestDBusFlags
     * @returns a new #GTestDBus.
     */
    static new(flags: TestDBusFlags): TestDBus
    _init(config?: TestDBus.ConstructorProperties): void
    /**
     * Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
     * won't use user's session bus.
     * 
     * This is useful for unit tests that want to verify behaviour when no session
     * bus is running. It is not necessary to call this if unit test already calls
     * g_test_dbus_up() before acquiring the session bus.
     */
    static unset(): void
}

module ThemedIcon {

    // Constructor properties interface

    interface ConstructorProperties extends Icon.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ThemedIcon

        /**
         * The icon name.
         */
        name?: string | null
        /**
         * A %NULL-terminated array of icon names.
         */
        names?: string[] | null
        /**
         * Whether to use the default fallbacks found by shortening the icon name
         * at '-' characters. If the "names" array has more than one element,
         * ignores any past the first.
         * 
         * For example, if the icon name was "gnome-dev-cdrom-audio", the array
         * would become
         * 
         * ```c
         * {
         *   "gnome-dev-cdrom-audio",
         *   "gnome-dev-cdrom",
         *   "gnome-dev",
         *   "gnome",
         *   NULL
         * };
         * ```
         * 
         */
        use_default_fallbacks?: boolean | null
    }

}

interface ThemedIcon extends Icon {

    // Own properties of Gio-2.0.Gio.ThemedIcon

    /**
     * The icon name.
     */
    readonly name: string | null
    /**
     * A %NULL-terminated array of icon names.
     */
    readonly names: string[]
    /**
     * Whether to use the default fallbacks found by shortening the icon name
     * at '-' characters. If the "names" array has more than one element,
     * ignores any past the first.
     * 
     * For example, if the icon name was "gnome-dev-cdrom-audio", the array
     * would become
     * 
     * ```c
     * {
     *   "gnome-dev-cdrom-audio",
     *   "gnome-dev-cdrom",
     *   "gnome-dev",
     *   "gnome",
     *   NULL
     * };
     * ```
     * 
     */
    readonly use_default_fallbacks: boolean

    // Owm methods of Gio-2.0.Gio.ThemedIcon

    /**
     * Append a name to the list of icons from within `icon`.
     * 
     * Note that doing so invalidates the hash computed by prior calls
     * to g_icon_hash().
     * @param iconname name of icon to append to list of icons from within `icon`.
     */
    append_name(iconname: string | null): void
    /**
     * Gets the names of icons from within `icon`.
     * @returns a list of icon names.
     */
    get_names(): string[]
    /**
     * Prepend a name to the list of icons from within `icon`.
     * 
     * Note that doing so invalidates the hash computed by prior calls
     * to g_icon_hash().
     * @param iconname name of icon to prepend to list of icons from within `icon`.
     */
    prepend_name(iconname: string | null): void

    // Class property signals of Gio-2.0.Gio.ThemedIcon

    connect(sigName: "notify::name", callback: (($obj: ThemedIcon, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: ThemedIcon, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::name", ...args: any[]): void
    connect(sigName: "notify::names", callback: (($obj: ThemedIcon, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::names", callback: (($obj: ThemedIcon, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::names", ...args: any[]): void
    connect(sigName: "notify::use-default-fallbacks", callback: (($obj: ThemedIcon, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-default-fallbacks", callback: (($obj: ThemedIcon, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::use-default-fallbacks", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GThemedIcon is an implementation of #GIcon that supports icon themes.
 * #GThemedIcon contains a list of all of the icons present in an icon
 * theme, so that icons can be looked up quickly. #GThemedIcon does
 * not provide actual pixmaps for icons, just the icon names.
 * Ideally something like gtk_icon_theme_choose_icon() should be used to
 * resolve the list of names so that fallback icons work nicely with
 * themes that inherit other themes.
 * @class 
 */
class ThemedIcon extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ThemedIcon

    static name: string
    static $gtype: GObject.GType<ThemedIcon>

    // Constructors of Gio-2.0.Gio.ThemedIcon

    constructor(config?: ThemedIcon.ConstructorProperties) 
    /**
     * Creates a new themed icon for `iconname`.
     * @constructor 
     * @param iconname a string containing an icon name.
     * @returns a new #GThemedIcon.
     */
    constructor(iconname: string | null) 
    /**
     * Creates a new themed icon for `iconname`.
     * @constructor 
     * @param iconname a string containing an icon name.
     * @returns a new #GThemedIcon.
     */
    static new(iconname: string | null): ThemedIcon
    /**
     * Creates a new themed icon for `iconnames`.
     * @constructor 
     * @param iconnames an array of strings containing icon names.
     * @returns a new #GThemedIcon
     */
    static new_from_names(iconnames: string[]): ThemedIcon
    /**
     * Creates a new themed icon for `iconname,` and all the names
     * that can be created by shortening `iconname` at '-' characters.
     * 
     * In the following example, `icon1` and `icon2` are equivalent:
     * 
     * ```c
     * const char *names[] = {
     *   "gnome-dev-cdrom-audio",
     *   "gnome-dev-cdrom",
     *   "gnome-dev",
     *   "gnome"
     * };
     * 
     * icon1 = g_themed_icon_new_from_names (names, 4);
     * icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
     * ```
     * 
     * @constructor 
     * @param iconname a string containing an icon name
     * @returns a new #GThemedIcon.
     */
    static new_with_default_fallbacks(iconname: string | null): ThemedIcon
    _init(config?: ThemedIcon.ConstructorProperties): void
}

module ThreadedSocketService {

    // Signal callback interfaces

    /**
     * Signal callback interface for `run`
     */
    interface RunSignalCallback {
        ($obj: ThreadedSocketService, connection: SocketConnection, source_object: GObject.Object | null): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends SocketService.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ThreadedSocketService

        max_threads?: number | null
    }

}

interface ThreadedSocketService {

    // Own properties of Gio-2.0.Gio.ThreadedSocketService

    readonly max_threads: number

    // Own fields of Gio-2.0.Gio.ThreadedSocketService

    parent_instance: SocketService & SocketListener & GObject.Object & GObject.Object
    priv: any

    // Own virtual methods of Gio-2.0.Gio.ThreadedSocketService

    vfunc_run(connection: SocketConnection, source_object: GObject.Object): boolean

    // Own signals of Gio-2.0.Gio.ThreadedSocketService

    connect(sigName: "run", callback: ThreadedSocketService.RunSignalCallback): number
    connect_after(sigName: "run", callback: ThreadedSocketService.RunSignalCallback): number
    emit(sigName: "run", connection: SocketConnection, source_object: GObject.Object | null, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.ThreadedSocketService

    connect(sigName: "notify::max-threads", callback: (($obj: ThreadedSocketService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-threads", callback: (($obj: ThreadedSocketService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::max-threads", ...args: any[]): void
    connect(sigName: "notify::active", callback: (($obj: ThreadedSocketService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active", callback: (($obj: ThreadedSocketService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::active", ...args: any[]): void
    connect(sigName: "notify::listen-backlog", callback: (($obj: ThreadedSocketService, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::listen-backlog", callback: (($obj: ThreadedSocketService, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::listen-backlog", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GThreadedSocketService is a simple subclass of #GSocketService
 * that handles incoming connections by creating a worker thread and
 * dispatching the connection to it by emitting the
 * #GThreadedSocketService::run signal in the new thread.
 * 
 * The signal handler may perform blocking IO and need not return
 * until the connection is closed.
 * 
 * The service is implemented using a thread pool, so there is a
 * limited amount of threads available to serve incoming requests.
 * The service automatically stops the #GSocketService from accepting
 * new connections when all threads are busy.
 * 
 * As with #GSocketService, you may connect to #GThreadedSocketService::run,
 * or subclass and override the default handler.
 * @class 
 */
class ThreadedSocketService extends SocketService {

    // Own properties of Gio-2.0.Gio.ThreadedSocketService

    static name: string
    static $gtype: GObject.GType<ThreadedSocketService>

    // Constructors of Gio-2.0.Gio.ThreadedSocketService

    constructor(config?: ThreadedSocketService.ConstructorProperties) 
    /**
     * Creates a new #GThreadedSocketService with no listeners. Listeners
     * must be added with one of the #GSocketListener "add" methods.
     * @constructor 
     * @param max_threads the maximal number of threads to execute concurrently   handling incoming clients, -1 means no limit
     * @returns a new #GSocketService.
     */
    constructor(max_threads: number) 
    /**
     * Creates a new #GThreadedSocketService with no listeners. Listeners
     * must be added with one of the #GSocketListener "add" methods.
     * @constructor 
     * @param max_threads the maximal number of threads to execute concurrently   handling incoming clients, -1 means no limit
     * @returns a new #GSocketService.
     */
    static new(max_threads: number): ThreadedSocketService

    // Overloads of new

    /**
     * Creates a new #GSocketService with no sockets to listen for.
     * New listeners can be added with e.g. g_socket_listener_add_address()
     * or g_socket_listener_add_inet_port().
     * 
     * New services are created active, there is no need to call
     * g_socket_service_start(), unless g_socket_service_stop() has been
     * called before.
     * @constructor 
     * @returns a new #GSocketService.
     */
    static new(): SocketService
    /**
     * Creates a new #GSocketListener with no sockets to listen for.
     * New listeners can be added with e.g. g_socket_listener_add_address()
     * or g_socket_listener_add_inet_port().
     * @constructor 
     * @returns a new #GSocketListener.
     */
    static new(): SocketListener
    _init(config?: ThreadedSocketService.ConstructorProperties): void
}

module TlsCertificate {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TlsCertificate

        /**
         * The DER (binary) encoded representation of the certificate.
         * This property and the #GTlsCertificate:certificate-pem property
         * represent the same data, just in different forms.
         */
        certificate?: Uint8Array | null
        /**
         * The PEM (ASCII) encoded representation of the certificate.
         * This property and the #GTlsCertificate:certificate
         * property represent the same data, just in different forms.
         */
        certificate_pem?: string | null
        /**
         * A #GTlsCertificate representing the entity that issued this
         * certificate. If %NULL, this means that the certificate is either
         * self-signed, or else the certificate of the issuer is not
         * available.
         * 
         * Beware the issuer certificate may not be the same as the
         * certificate that would actually be used to construct a valid
         * certification path during certificate verification.
         * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
         * why an issuer certificate cannot be naively assumed to be part of the
         * the certification path (though GLib's TLS backends may not follow the
         * path building strategies outlined in this RFC). Due to the complexity
         * of certification path building, GLib does not provide any way to know
         * which certification path will actually be used. Accordingly, this
         * property cannot be used to make security-related decisions. Only
         * GLib itself should make security decisions about TLS certificates.
         */
        issuer?: TlsCertificate | null
        /**
         * An optional password used when constructed with GTlsCertificate:pkcs12-data.
         */
        password?: string | null
        /**
         * A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
         * objects containing an X.509 certificate and optionally a private key.
         * 
         * If %NULL, the certificate is either not backed by PKCS \#11 or the
         * #GTlsBackend does not support PKCS \#11.
         */
        pkcs11_uri?: string | null
        /**
         * The PKCS #12 formatted data used to construct the object.
         * 
         * See also: g_tls_certificate_new_from_pkcs12()
         */
        pkcs12_data?: Uint8Array | null
        /**
         * The DER (binary) encoded representation of the certificate's
         * private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
         * or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
         * PKCS \#8 format is supported since 2.32; earlier releases only
         * support PKCS \#1. You can use the `openssl rsa` tool to convert
         * PKCS \#8 keys to PKCS \#1.
         * 
         * This property (or the #GTlsCertificate:private-key-pem property)
         * can be set when constructing a key (for example, from a file).
         * Since GLib 2.70, it is now also readable; however, be aware that if
         * the private key is backed by a PKCS \#11 URI – for example, if it
         * is stored on a smartcard – then this property will be %NULL. If so,
         * the private key must be referenced via its PKCS \#11 URI,
         * #GTlsCertificate:private-key-pkcs11-uri. You must check both
         * properties to see if the certificate really has a private key.
         * When this property is read, the output format will be unencrypted
         * PKCS \#8.
         */
        private_key?: Uint8Array | null
        /**
         * The PEM (ASCII) encoded representation of the certificate's
         * private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
         * ("`BEGIN RSA PRIVATE KEY`") or unencrypted
         * [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
         * ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
         * earlier releases only support PKCS \#1. You can use the `openssl rsa`
         * tool to convert PKCS \#8 keys to PKCS \#1.
         * 
         * This property (or the #GTlsCertificate:private-key property)
         * can be set when constructing a key (for example, from a file).
         * Since GLib 2.70, it is now also readable; however, be aware that if
         * the private key is backed by a PKCS \#11 URI - for example, if it
         * is stored on a smartcard - then this property will be %NULL. If so,
         * the private key must be referenced via its PKCS \#11 URI,
         * #GTlsCertificate:private-key-pkcs11-uri. You must check both
         * properties to see if the certificate really has a private key.
         * When this property is read, the output format will be unencrypted
         * PKCS \#8.
         */
        private_key_pem?: string | null
        /**
         * A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
         * object containing a private key.
         */
        private_key_pkcs11_uri?: string | null
    }

}

interface TlsCertificate {

    // Own properties of Gio-2.0.Gio.TlsCertificate

    /**
     * The DER (binary) encoded representation of the certificate.
     * This property and the #GTlsCertificate:certificate-pem property
     * represent the same data, just in different forms.
     */
    readonly certificate: Uint8Array
    /**
     * The PEM (ASCII) encoded representation of the certificate.
     * This property and the #GTlsCertificate:certificate
     * property represent the same data, just in different forms.
     */
    readonly certificate_pem: string | null
    /**
     * The DNS names from the certificate's Subject Alternative Names (SANs),
     * %NULL if unavailable.
     */
    readonly dns_names: any[]
    /**
     * The IP addresses from the certificate's Subject Alternative Names (SANs),
     * %NULL if unavailable.
     */
    readonly ip_addresses: any[]
    /**
     * A #GTlsCertificate representing the entity that issued this
     * certificate. If %NULL, this means that the certificate is either
     * self-signed, or else the certificate of the issuer is not
     * available.
     * 
     * Beware the issuer certificate may not be the same as the
     * certificate that would actually be used to construct a valid
     * certification path during certificate verification.
     * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
     * why an issuer certificate cannot be naively assumed to be part of the
     * the certification path (though GLib's TLS backends may not follow the
     * path building strategies outlined in this RFC). Due to the complexity
     * of certification path building, GLib does not provide any way to know
     * which certification path will actually be used. Accordingly, this
     * property cannot be used to make security-related decisions. Only
     * GLib itself should make security decisions about TLS certificates.
     */
    readonly issuer: TlsCertificate
    /**
     * The issuer from the certificate,
     * %NULL if unavailable.
     */
    readonly issuer_name: string | null
    /**
     * The time at which this cert is no longer valid,
     * %NULL if unavailable.
     */
    readonly not_valid_after: GLib.DateTime
    /**
     * The time at which this cert is considered to be valid,
     * %NULL if unavailable.
     */
    readonly not_valid_before: GLib.DateTime
    /**
     * An optional password used when constructed with GTlsCertificate:pkcs12-data.
     */
    readonly password: string | null
    /**
     * A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
     * objects containing an X.509 certificate and optionally a private key.
     * 
     * If %NULL, the certificate is either not backed by PKCS \#11 or the
     * #GTlsBackend does not support PKCS \#11.
     */
    readonly pkcs11_uri: string | null
    /**
     * The PKCS #12 formatted data used to construct the object.
     * 
     * See also: g_tls_certificate_new_from_pkcs12()
     */
    readonly pkcs12_data: Uint8Array
    /**
     * The DER (binary) encoded representation of the certificate's
     * private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
     * or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
     * PKCS \#8 format is supported since 2.32; earlier releases only
     * support PKCS \#1. You can use the `openssl rsa` tool to convert
     * PKCS \#8 keys to PKCS \#1.
     * 
     * This property (or the #GTlsCertificate:private-key-pem property)
     * can be set when constructing a key (for example, from a file).
     * Since GLib 2.70, it is now also readable; however, be aware that if
     * the private key is backed by a PKCS \#11 URI – for example, if it
     * is stored on a smartcard – then this property will be %NULL. If so,
     * the private key must be referenced via its PKCS \#11 URI,
     * #GTlsCertificate:private-key-pkcs11-uri. You must check both
     * properties to see if the certificate really has a private key.
     * When this property is read, the output format will be unencrypted
     * PKCS \#8.
     */
    readonly private_key: Uint8Array
    /**
     * The PEM (ASCII) encoded representation of the certificate's
     * private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
     * ("`BEGIN RSA PRIVATE KEY`") or unencrypted
     * [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
     * ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
     * earlier releases only support PKCS \#1. You can use the `openssl rsa`
     * tool to convert PKCS \#8 keys to PKCS \#1.
     * 
     * This property (or the #GTlsCertificate:private-key property)
     * can be set when constructing a key (for example, from a file).
     * Since GLib 2.70, it is now also readable; however, be aware that if
     * the private key is backed by a PKCS \#11 URI - for example, if it
     * is stored on a smartcard - then this property will be %NULL. If so,
     * the private key must be referenced via its PKCS \#11 URI,
     * #GTlsCertificate:private-key-pkcs11-uri. You must check both
     * properties to see if the certificate really has a private key.
     * When this property is read, the output format will be unencrypted
     * PKCS \#8.
     */
    readonly private_key_pem: string | null
    /**
     * A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
     * object containing a private key.
     */
    readonly private_key_pkcs11_uri: string | null
    /**
     * The subject from the cert,
     * %NULL if unavailable.
     */
    readonly subject_name: string | null

    // Own fields of Gio-2.0.Gio.TlsCertificate

    parent_instance: GObject.Object
    priv: TlsCertificatePrivate

    // Owm methods of Gio-2.0.Gio.TlsCertificate

    /**
     * Gets the value of #GTlsCertificate:dns-names.
     * @returns A #GPtrArray of #GBytes elements, or %NULL if it's not available.
     */
    get_dns_names(): GLib.Bytes[] | null
    /**
     * Gets the value of #GTlsCertificate:ip-addresses.
     * @returns A #GPtrArray of #GInetAddress elements, or %NULL if it's not available.
     */
    get_ip_addresses(): InetAddress[] | null
    /**
     * Gets the #GTlsCertificate representing `cert'`s issuer, if known
     * @returns The certificate of @cert's issuer, or %NULL if @cert is self-signed or signed with an unknown certificate.
     */
    get_issuer(): TlsCertificate | null
    /**
     * Returns the issuer name from the certificate.
     * @returns The issuer name, or %NULL if it's not available.
     */
    get_issuer_name(): string | null
    /**
     * Returns the time at which the certificate became or will become invalid.
     * @returns The not-valid-after date, or %NULL if it's not available.
     */
    get_not_valid_after(): GLib.DateTime | null
    /**
     * Returns the time at which the certificate became or will become valid.
     * @returns The not-valid-before date, or %NULL if it's not available.
     */
    get_not_valid_before(): GLib.DateTime | null
    /**
     * Returns the subject name from the certificate.
     * @returns The subject name, or %NULL if it's not available.
     */
    get_subject_name(): string | null
    /**
     * Check if two #GTlsCertificate objects represent the same certificate.
     * The raw DER byte data of the two certificates are checked for equality.
     * This has the effect that two certificates may compare equal even if
     * their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
     * #GTlsCertificate:private-key-pem properties differ.
     * @param cert_two second certificate to compare
     * @returns whether the same or not
     */
    is_same(cert_two: TlsCertificate): boolean
    /**
     * This verifies `cert` and returns a set of #GTlsCertificateFlags
     * indicating any problems found with it. This can be used to verify a
     * certificate outside the context of making a connection, or to
     * check a certificate against a CA that is not part of the system
     * CA database.
     * 
     * If `cert` is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
     * 
     * If `identity` is not %NULL, `cert'`s name(s) will be compared against
     * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
     * value if it does not match. If `identity` is %NULL, that bit will
     * never be set in the return value.
     * 
     * If `trusted_ca` is not %NULL, then `cert` (or one of the certificates
     * in its chain) must be signed by it, or else
     * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
     * `trusted_ca` is %NULL, that bit will never be set in the return
     * value.
     * 
     * GLib guarantees that if certificate verification fails, at least one
     * error will be set in the return value, but it does not guarantee
     * that all possible errors will be set. Accordingly, you may not safely
     * decide to ignore any particular type of error. For example, it would
     * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
     * expired certificates, because this could potentially be the only
     * error flag set even if other problems exist with the certificate.
     * 
     * Because TLS session context is not used, #GTlsCertificate may not
     * perform as many checks on the certificates as #GTlsConnection would.
     * For example, certificate constraints may not be honored, and
     * revocation checks may not be performed. The best way to verify TLS
     * certificates used by a TLS connection is to let #GTlsConnection
     * handle the verification.
     * @param identity the expected peer identity
     * @param trusted_ca the certificate of a trusted authority
     * @returns the appropriate #GTlsCertificateFlags
     */
    verify(identity: SocketConnectable | null, trusted_ca: TlsCertificate | null): TlsCertificateFlags

    // Own virtual methods of Gio-2.0.Gio.TlsCertificate

    /**
     * This verifies `cert` and returns a set of #GTlsCertificateFlags
     * indicating any problems found with it. This can be used to verify a
     * certificate outside the context of making a connection, or to
     * check a certificate against a CA that is not part of the system
     * CA database.
     * 
     * If `cert` is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
     * 
     * If `identity` is not %NULL, `cert'`s name(s) will be compared against
     * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
     * value if it does not match. If `identity` is %NULL, that bit will
     * never be set in the return value.
     * 
     * If `trusted_ca` is not %NULL, then `cert` (or one of the certificates
     * in its chain) must be signed by it, or else
     * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
     * `trusted_ca` is %NULL, that bit will never be set in the return
     * value.
     * 
     * GLib guarantees that if certificate verification fails, at least one
     * error will be set in the return value, but it does not guarantee
     * that all possible errors will be set. Accordingly, you may not safely
     * decide to ignore any particular type of error. For example, it would
     * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
     * expired certificates, because this could potentially be the only
     * error flag set even if other problems exist with the certificate.
     * 
     * Because TLS session context is not used, #GTlsCertificate may not
     * perform as many checks on the certificates as #GTlsConnection would.
     * For example, certificate constraints may not be honored, and
     * revocation checks may not be performed. The best way to verify TLS
     * certificates used by a TLS connection is to let #GTlsConnection
     * handle the verification.
     * @virtual 
     * @param identity the expected peer identity
     * @param trusted_ca the certificate of a trusted authority
     * @returns the appropriate #GTlsCertificateFlags
     */
    vfunc_verify(identity: SocketConnectable | null, trusted_ca: TlsCertificate | null): TlsCertificateFlags

    // Class property signals of Gio-2.0.Gio.TlsCertificate

    connect(sigName: "notify::certificate", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::certificate", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::certificate", ...args: any[]): void
    connect(sigName: "notify::certificate-pem", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::certificate-pem", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::certificate-pem", ...args: any[]): void
    connect(sigName: "notify::dns-names", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-names", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::dns-names", ...args: any[]): void
    connect(sigName: "notify::ip-addresses", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-addresses", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ip-addresses", ...args: any[]): void
    connect(sigName: "notify::issuer", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::issuer", ...args: any[]): void
    connect(sigName: "notify::issuer-name", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer-name", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::issuer-name", ...args: any[]): void
    connect(sigName: "notify::not-valid-after", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::not-valid-after", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::not-valid-after", ...args: any[]): void
    connect(sigName: "notify::not-valid-before", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::not-valid-before", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::not-valid-before", ...args: any[]): void
    connect(sigName: "notify::password", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password", ...args: any[]): void
    connect(sigName: "notify::pkcs11-uri", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pkcs11-uri", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::pkcs11-uri", ...args: any[]): void
    connect(sigName: "notify::pkcs12-data", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pkcs12-data", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::pkcs12-data", ...args: any[]): void
    connect(sigName: "notify::private-key", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::private-key", ...args: any[]): void
    connect(sigName: "notify::private-key-pem", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key-pem", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::private-key-pem", ...args: any[]): void
    connect(sigName: "notify::private-key-pkcs11-uri", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key-pkcs11-uri", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::private-key-pkcs11-uri", ...args: any[]): void
    connect(sigName: "notify::subject-name", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject-name", callback: (($obj: TlsCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::subject-name", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A certificate used for TLS authentication and encryption.
 * This can represent either a certificate only (eg, the certificate
 * received by a client from a server), or the combination of
 * a certificate and a private key (which is needed when acting as a
 * #GTlsServerConnection).
 * @class 
 */
class TlsCertificate extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TlsCertificate

    static name: string
    static $gtype: GObject.GType<TlsCertificate>

    // Constructors of Gio-2.0.Gio.TlsCertificate

    constructor(config?: TlsCertificate.ConstructorProperties) 
    /**
     * Creates a #GTlsCertificate from the data in `file`.
     * 
     * As of 2.72, if the filename ends in `.p12` or `.pfx` the data is loaded by
     * g_tls_certificate_new_from_pkcs12() otherwise it is loaded by
     * g_tls_certificate_new_from_pem(). See those functions for
     * exact details.
     * 
     * If `file` cannot be read or parsed, the function will return %NULL and
     * set `error`.
     * @constructor 
     * @param file file containing a certificate to import
     * @returns the new certificate, or %NULL on error
     */
    static new_from_file(file: string): TlsCertificate
    /**
     * Creates a #GTlsCertificate from the data in `file`.
     * 
     * If `file` cannot be read or parsed, the function will return %NULL and
     * set `error`.
     * 
     * Any unknown file types will error with %G_IO_ERROR_NOT_SUPPORTED.
     * Currently only `.p12` and `.pfx` files are supported.
     * See g_tls_certificate_new_from_pkcs12() for more details.
     * @constructor 
     * @param file file containing a certificate to import
     * @param password password for PKCS #12 files
     * @returns the new certificate, or %NULL on error
     */
    static new_from_file_with_password(file: string, password: string | null): TlsCertificate
    /**
     * Creates a #GTlsCertificate from the PEM-encoded data in `cert_file`
     * and `key_file`. The returned certificate will be the first certificate
     * found in `cert_file`. As of GLib 2.44, if `cert_file` contains more
     * certificates it will try to load a certificate chain. All
     * certificates will be verified in the order found (top-level
     * certificate should be the last one in the file) and the
     * #GTlsCertificate:issuer property of each certificate will be set
     * accordingly if the verification succeeds. If any certificate in the
     * chain cannot be verified, the first certificate in the file will
     * still be returned.
     * 
     * If either file cannot be read or parsed, the function will return
     * %NULL and set `error`. Otherwise, this behaves like
     * g_tls_certificate_new_from_pem().
     * @constructor 
     * @param cert_file file containing one or more PEM-encoded     certificates to import
     * @param key_file file containing a PEM-encoded private key     to import
     * @returns the new certificate, or %NULL on error
     */
    static new_from_files(cert_file: string, key_file: string): TlsCertificate
    /**
     * Creates a #GTlsCertificate from the PEM-encoded data in `data`. If
     * `data` includes both a certificate and a private key, then the
     * returned certificate will include the private key data as well. (See
     * the #GTlsCertificate:private-key-pem property for information about
     * supported formats.)
     * 
     * The returned certificate will be the first certificate found in
     * `data`. As of GLib 2.44, if `data` contains more certificates it will
     * try to load a certificate chain. All certificates will be verified in
     * the order found (top-level certificate should be the last one in the
     * file) and the #GTlsCertificate:issuer property of each certificate
     * will be set accordingly if the verification succeeds. If any
     * certificate in the chain cannot be verified, the first certificate in
     * the file will still be returned.
     * @constructor 
     * @param data PEM-encoded certificate data
     * @param length the length of `data,` or -1 if it's 0-terminated.
     * @returns the new certificate, or %NULL if @data is invalid
     */
    static new_from_pem(data: string | null, length: number): TlsCertificate
    /**
     * Creates a #GTlsCertificate from a
     * [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.
     * 
     * An example `pkcs1`1_uri would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01`
     * 
     * Where the token’s layout is:
     * 
     * 
     * ```
     * Object 0:
     *   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=private%20key;type=private
     *   Type: Private key (RSA-2048)
     *   ID: 01
     * 
     * Object 1:
     *   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=Certificate%20for%20Authentication;type=cert
     *   Type: X.509 Certificate (RSA-2048)
     *   ID: 01
     * ```
     * 
     * 
     * In this case the certificate and private key would both be detected and used as expected.
     * `pkcs_uri` may also just reference an X.509 certificate object and then optionally
     * `private_key_pkcs1`1_uri allows using a private key exposed under a different URI.
     * 
     * Note that the private key is not accessed until usage and may fail or require a PIN later.
     * @constructor 
     * @param pkcs11_uri A PKCS \#11 URI
     * @param private_key_pkcs11_uri A PKCS \#11 URI
     * @returns the new certificate, or %NULL on error
     */
    static new_from_pkcs11_uris(pkcs11_uri: string | null, private_key_pkcs11_uri: string | null): TlsCertificate
    /**
     * Creates a #GTlsCertificate from the data in `data`. It must contain
     * a certificate and matching private key.
     * 
     * If extra certificates are included they will be verified as a chain
     * and the #GTlsCertificate:issuer property will be set.
     * All other data will be ignored.
     * 
     * You can pass as single password for all of the data which will be
     * used both for the PKCS #12 container as well as encrypted
     * private keys. If decryption fails it will error with
     * %G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD.
     * 
     * This constructor requires support in the current #GTlsBackend.
     * If support is missing it will error with
     * %G_IO_ERROR_NOT_SUPPORTED.
     * 
     * Other parsing failures will error with %G_TLS_ERROR_BAD_CERTIFICATE.
     * @constructor 
     * @param data DER-encoded PKCS #12 format certificate data
     * @param password optional password for encrypted certificate data
     * @returns the new certificate, or %NULL if @data is invalid
     */
    static new_from_pkcs12(data: Uint8Array, password: string | null): TlsCertificate
    _init(config?: TlsCertificate.ConstructorProperties): void
    /**
     * Creates one or more #GTlsCertificates from the PEM-encoded
     * data in `file`. If `file` cannot be read or parsed, the function will
     * return %NULL and set `error`. If `file` does not contain any
     * PEM-encoded certificates, this will return an empty list and not
     * set `error`.
     * @param file file containing PEM-encoded certificates to import
     * @returns a #GList containing #GTlsCertificate objects. You must free the list and its contents when you are done with it.
     */
    static list_new_from_file(file: string): TlsCertificate[]
}

module TlsConnection {

    // Signal callback interfaces

    /**
     * Signal callback interface for `accept-certificate`
     */
    interface AcceptCertificateSignalCallback {
        ($obj: TlsConnection, peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean
    }


    // Constructor properties interface

    interface ConstructorProperties extends IOStream.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TlsConnection

        /**
         * The list of application-layer protocols that the connection
         * advertises that it is willing to speak. See
         * g_tls_connection_set_advertised_protocols().
         */
        advertised_protocols?: string[] | null
        /**
         * The #GIOStream that the connection wraps. The connection holds a reference
         * to this stream, and may run operations on the stream from other threads
         * throughout its lifetime. Consequently, after the #GIOStream has been
         * constructed, application code may only run its own operations on this
         * stream when no #GIOStream operations are running.
         */
        base_io_stream?: IOStream | null
        /**
         * The connection's certificate; see
         * g_tls_connection_set_certificate().
         */
        certificate?: TlsCertificate | null
        /**
         * The certificate database to use when verifying this TLS connection.
         * If no certificate database is set, then the default database will be
         * used. See g_tls_backend_get_default_database().
         * 
         * When using a non-default database, #GTlsConnection must fall back to using
         * the #GTlsDatabase to perform certificate verification using
         * g_tls_database_verify_chain(), which means certificate verification will
         * not be able to make use of TLS session context. This may be less secure.
         * For example, if you create your own #GTlsDatabase that just wraps the
         * default #GTlsDatabase, you might expect that you have not changed anything,
         * but this is not true because you may have altered the behavior of
         * #GTlsConnection by causing it to use g_tls_database_verify_chain(). See the
         * documentation of g_tls_database_verify_chain() for more details on specific
         * security checks that may not be performed. Accordingly, setting a
         * non-default database is discouraged except for specialty applications with
         * unusual security requirements.
         */
        database?: TlsDatabase | null
        /**
         * A #GTlsInteraction object to be used when the connection or certificate
         * database need to interact with the user. This will be used to prompt the
         * user for passwords where necessary.
         */
        interaction?: TlsInteraction | null
        /**
         * The rehandshaking mode. See
         * g_tls_connection_set_rehandshake_mode().
         */
        rehandshake_mode?: TlsRehandshakeMode | null
        /**
         * Whether or not proper TLS close notification is required.
         * See g_tls_connection_set_require_close_notify().
         */
        require_close_notify?: boolean | null
        /**
         * Whether or not the system certificate database will be used to
         * verify peer certificates. See
         * g_tls_connection_set_use_system_certdb().
         */
        use_system_certdb?: boolean | null
    }

}

interface TlsConnection {

    // Own properties of Gio-2.0.Gio.TlsConnection

    /**
     * The list of application-layer protocols that the connection
     * advertises that it is willing to speak. See
     * g_tls_connection_set_advertised_protocols().
     */
    advertised_protocols: string[]
    /**
     * The #GIOStream that the connection wraps. The connection holds a reference
     * to this stream, and may run operations on the stream from other threads
     * throughout its lifetime. Consequently, after the #GIOStream has been
     * constructed, application code may only run its own operations on this
     * stream when no #GIOStream operations are running.
     */
    readonly base_io_stream: IOStream
    /**
     * The connection's certificate; see
     * g_tls_connection_set_certificate().
     */
    certificate: TlsCertificate
    /**
     * The name of the TLS ciphersuite in use. See g_tls_connection_get_ciphersuite_name().
     */
    readonly ciphersuite_name: string | null
    /**
     * The certificate database to use when verifying this TLS connection.
     * If no certificate database is set, then the default database will be
     * used. See g_tls_backend_get_default_database().
     * 
     * When using a non-default database, #GTlsConnection must fall back to using
     * the #GTlsDatabase to perform certificate verification using
     * g_tls_database_verify_chain(), which means certificate verification will
     * not be able to make use of TLS session context. This may be less secure.
     * For example, if you create your own #GTlsDatabase that just wraps the
     * default #GTlsDatabase, you might expect that you have not changed anything,
     * but this is not true because you may have altered the behavior of
     * #GTlsConnection by causing it to use g_tls_database_verify_chain(). See the
     * documentation of g_tls_database_verify_chain() for more details on specific
     * security checks that may not be performed. Accordingly, setting a
     * non-default database is discouraged except for specialty applications with
     * unusual security requirements.
     */
    database: TlsDatabase
    /**
     * A #GTlsInteraction object to be used when the connection or certificate
     * database need to interact with the user. This will be used to prompt the
     * user for passwords where necessary.
     */
    interaction: TlsInteraction
    /**
     * The application-layer protocol negotiated during the TLS
     * handshake. See g_tls_connection_get_negotiated_protocol().
     */
    readonly negotiated_protocol: string | null
    /**
     * The connection's peer's certificate, after the TLS handshake has
     * completed or failed. Note in particular that this is not yet set
     * during the emission of #GTlsConnection::accept-certificate.
     * 
     * (You can watch for a #GObject::notify signal on this property to
     * detect when a handshake has occurred.)
     */
    readonly peer_certificate: TlsCertificate
    /**
     * The errors noticed while verifying
     * #GTlsConnection:peer-certificate. Normally this should be 0, but
     * it may not be if #GTlsClientConnection:validation-flags is not
     * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
     * #GTlsConnection::accept-certificate overrode the default
     * behavior.
     * 
     * GLib guarantees that if certificate verification fails, at least
     * one error will be set, but it does not guarantee that all possible
     * errors will be set. Accordingly, you may not safely decide to
     * ignore any particular type of error. For example, it would be
     * incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
     * expired certificates, because this could potentially be the only
     * error flag set even if other problems exist with the certificate.
     */
    readonly peer_certificate_errors: TlsCertificateFlags
    /**
     * The TLS protocol version in use. See g_tls_connection_get_protocol_version().
     */
    readonly protocol_version: TlsProtocolVersion
    /**
     * The rehandshaking mode. See
     * g_tls_connection_set_rehandshake_mode().
     */
    rehandshake_mode: TlsRehandshakeMode
    /**
     * Whether or not proper TLS close notification is required.
     * See g_tls_connection_set_require_close_notify().
     */
    require_close_notify: boolean
    /**
     * Whether or not the system certificate database will be used to
     * verify peer certificates. See
     * g_tls_connection_set_use_system_certdb().
     */
    use_system_certdb: boolean

    // Own fields of Gio-2.0.Gio.TlsConnection

    parent_instance: IOStream & GObject.Object
    priv: TlsConnectionPrivate

    // Owm methods of Gio-2.0.Gio.TlsConnection

    /**
     * Used by #GTlsConnection implementations to emit the
     * #GTlsConnection::accept-certificate signal.
     * @param peer_cert the peer's #GTlsCertificate
     * @param errors the problems with `peer_cert`
     * @returns %TRUE if one of the signal handlers has returned     %TRUE to accept @peer_cert
     */
    emit_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean
    /**
     * Gets `conn'`s certificate, as set by
     * g_tls_connection_set_certificate().
     * @returns @conn's certificate, or %NULL
     */
    get_certificate(): TlsCertificate | null
    /**
     * Query the TLS backend for TLS channel binding data of `type` for `conn`.
     * 
     * This call retrieves TLS channel binding data as specified in RFC
     * [5056](https://tools.ietf.org/html/rfc5056), RFC
     * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
     * binding data is returned in `data`.  The `data` is resized by the callee
     * using #GByteArray buffer management and will be freed when the `data`
     * is destroyed by g_byte_array_unref(). If `data` is %NULL, it will only
     * check whether TLS backend is able to fetch the data (e.g. whether `type`
     * is supported by the TLS backend). It does not guarantee that the data
     * will be available though.  That could happen if TLS connection does not
     * support `type` or the binding data is not available yet due to additional
     * negotiation or input required.
     * @param type #GTlsChannelBindingType type of data to fetch
     * @returns %TRUE on success, %FALSE otherwise
     */
    get_channel_binding_data(type: TlsChannelBindingType): [ /* returnType */ boolean, /* data */ Uint8Array ]
    /**
     * Returns the name of the current TLS ciphersuite, or %NULL if the
     * connection has not handshaked or has been closed. Beware that the TLS
     * backend may use any of multiple different naming conventions, because
     * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
     * are different from each other and different from the standard, IANA-
     * registered ciphersuite names. The ciphersuite name is intended to be
     * displayed to the user for informative purposes only, and parsing it
     * is not recommended.
     * @returns The name of the current TLS ciphersuite, or %NULL
     */
    get_ciphersuite_name(): string | null
    /**
     * Gets the certificate database that `conn` uses to verify
     * peer certificates. See g_tls_connection_set_database().
     * @returns the certificate database that @conn uses or %NULL
     */
    get_database(): TlsDatabase | null
    /**
     * Get the object that will be used to interact with the user. It will be used
     * for things like prompting the user for passwords. If %NULL is returned, then
     * no user interaction will occur for this connection.
     * @returns The interaction object.
     */
    get_interaction(): TlsInteraction | null
    /**
     * Gets the name of the application-layer protocol negotiated during
     * the handshake.
     * 
     * If the peer did not use the ALPN extension, or did not advertise a
     * protocol that matched one of `conn'`s protocols, or the TLS backend
     * does not support ALPN, then this will be %NULL. See
     * g_tls_connection_set_advertised_protocols().
     * @returns the negotiated protocol, or %NULL
     */
    get_negotiated_protocol(): string | null
    /**
     * Gets `conn'`s peer's certificate after the handshake has completed
     * or failed. (It is not set during the emission of
     * #GTlsConnection::accept-certificate.)
     * @returns @conn's peer's certificate, or %NULL
     */
    get_peer_certificate(): TlsCertificate | null
    /**
     * Gets the errors associated with validating `conn'`s peer's
     * certificate, after the handshake has completed or failed. (It is
     * not set during the emission of #GTlsConnection::accept-certificate.)
     * 
     * See #GTlsConnection:peer-certificate-errors for more information.
     * @returns @conn's peer's certificate errors
     */
    get_peer_certificate_errors(): TlsCertificateFlags
    /**
     * Returns the current TLS protocol version, which may be
     * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
     * has been closed, or if the TLS backend has implemented a protocol version
     * that is not a recognized #GTlsProtocolVersion.
     * @returns The current TLS protocol version
     */
    get_protocol_version(): TlsProtocolVersion
    /**
     * Gets `conn` rehandshaking mode. See
     * g_tls_connection_set_rehandshake_mode() for details.
     * @returns %G_TLS_REHANDSHAKE_SAFELY
     */
    get_rehandshake_mode(): TlsRehandshakeMode
    /**
     * Tests whether or not `conn` expects a proper TLS close notification
     * when the connection is closed. See
     * g_tls_connection_set_require_close_notify() for details.
     * @returns %TRUE if @conn requires a proper TLS close notification.
     */
    get_require_close_notify(): boolean
    /**
     * Gets whether `conn` uses the system certificate database to verify
     * peer certificates. See g_tls_connection_set_use_system_certdb().
     * @returns whether @conn uses the system certificate database
     */
    get_use_system_certdb(): boolean
    /**
     * Attempts a TLS handshake on `conn`.
     * 
     * On the client side, it is never necessary to call this method;
     * although the connection needs to perform a handshake after
     * connecting (or after sending a "STARTTLS"-type command),
     * #GTlsConnection will handle this for you automatically when you try
     * to send or receive data on the connection. You can call
     * g_tls_connection_handshake() manually if you want to know whether
     * the initial handshake succeeded or failed (as opposed to just
     * immediately trying to use `conn` to read or write, in which case,
     * if it fails, it may not be possible to tell if it failed before or
     * after completing the handshake), but beware that servers may reject
     * client authentication after the handshake has completed, so a
     * successful handshake does not indicate the connection will be usable.
     * 
     * Likewise, on the server side, although a handshake is necessary at
     * the beginning of the communication, you do not need to call this
     * function explicitly unless you want clearer error reporting.
     * 
     * Previously, calling g_tls_connection_handshake() after the initial
     * handshake would trigger a rehandshake; however, this usage was
     * deprecated in GLib 2.60 because rehandshaking was removed from the
     * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
     * the initial handshake will no longer do anything.
     * 
     * When using a #GTlsConnection created by #GSocketClient, the
     * #GSocketClient performs the initial handshake, so calling this
     * function manually is not recommended.
     * 
     * #GTlsConnection::accept_certificate may be emitted during the
     * handshake.
     * @param cancellable a #GCancellable, or %NULL
     * @returns success or failure
     */
    handshake(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously performs a TLS handshake on `conn`. See
     * g_tls_connection_handshake() for more information.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the handshake is complete
     */
    handshake_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of handshake_async

    /**
     * Promisified version of {@link handshake_async}
     * 
     * Asynchronously performs a TLS handshake on `conn`. See
     * g_tls_connection_handshake() for more information.
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: %TRUE on success, %FALSE on failure, in which case @error will be set.
     */
    handshake_async(io_priority: number, cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finish an asynchronous TLS handshake operation. See
     * g_tls_connection_handshake() for more information.
     * @param result a #GAsyncResult.
     * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
     */
    handshake_finish(result: AsyncResult): boolean
    /**
     * Sets the list of application-layer protocols to advertise that the
     * caller is willing to speak on this connection. The
     * Application-Layer Protocol Negotiation (ALPN) extension will be
     * used to negotiate a compatible protocol with the peer; use
     * g_tls_connection_get_negotiated_protocol() to find the negotiated
     * protocol after the handshake.  Specifying %NULL for the the value
     * of `protocols` will disable ALPN negotiation.
     * 
     * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
     * for a list of registered protocol IDs.
     * @param protocols a %NULL-terminated   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
     */
    set_advertised_protocols(protocols: string[] | null): void
    /**
     * This sets the certificate that `conn` will present to its peer
     * during the TLS handshake. For a #GTlsServerConnection, it is
     * mandatory to set this, and that will normally be done at construct
     * time.
     * 
     * For a #GTlsClientConnection, this is optional. If a handshake fails
     * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
     * requires a certificate, and if you try connecting again, you should
     * call this method first. You can call
     * g_tls_client_connection_get_accepted_cas() on the failed connection
     * to get a list of Certificate Authorities that the server will
     * accept certificates from.
     * 
     * (It is also possible that a server will allow the connection with
     * or without a certificate; in that case, if you don't provide a
     * certificate, you can tell that the server requested one by the fact
     * that g_tls_client_connection_get_accepted_cas() will return
     * non-%NULL.)
     * @param certificate the certificate to use for `conn`
     */
    set_certificate(certificate: TlsCertificate): void
    /**
     * Sets the certificate database that is used to verify peer certificates.
     * This is set to the default database by default. See
     * g_tls_backend_get_default_database(). If set to %NULL, then
     * peer certificate validation will always set the
     * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
     * #GTlsConnection::accept-certificate will always be emitted on
     * client-side connections, unless that bit is not set in
     * #GTlsClientConnection:validation-flags).
     * 
     * There are nonintuitive security implications when using a non-default
     * database. See #GTlsConnection:database for details.
     * @param database a #GTlsDatabase
     */
    set_database(database: TlsDatabase | null): void
    /**
     * Set the object that will be used to interact with the user. It will be used
     * for things like prompting the user for passwords.
     * 
     * The `interaction` argument will normally be a derived subclass of
     * #GTlsInteraction. %NULL can also be provided if no user interaction
     * should occur for this connection.
     * @param interaction an interaction object, or %NULL
     */
    set_interaction(interaction: TlsInteraction | null): void
    /**
     * Since GLib 2.64, changing the rehandshake mode is no longer supported
     * and will have no effect. With TLS 1.3, rehandshaking has been removed from
     * the TLS protocol, replaced by separate post-handshake authentication and
     * rekey operations.
     * @param mode the rehandshaking mode
     */
    set_rehandshake_mode(mode: TlsRehandshakeMode): void
    /**
     * Sets whether or not `conn` expects a proper TLS close notification
     * before the connection is closed. If this is %TRUE (the default),
     * then `conn` will expect to receive a TLS close notification from its
     * peer before the connection is closed, and will return a
     * %G_TLS_ERROR_EOF error if the connection is closed without proper
     * notification (since this may indicate a network error, or
     * man-in-the-middle attack).
     * 
     * In some protocols, the application will know whether or not the
     * connection was closed cleanly based on application-level data
     * (because the application-level data includes a length field, or is
     * somehow self-delimiting); in this case, the close notify is
     * redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
     * in TLS 1.0 it is technically an error, but often done anyway.) You
     * can use g_tls_connection_set_require_close_notify() to tell `conn`
     * to allow an "unannounced" connection close, in which case the close
     * will show up as a 0-length read, as in a non-TLS
     * #GSocketConnection, and it is up to the application to check that
     * the data has been fully received.
     * 
     * Note that this only affects the behavior when the peer closes the
     * connection; when the application calls g_io_stream_close() itself
     * on `conn,` this will send a close notification regardless of the
     * setting of this property. If you explicitly want to do an unclean
     * close, you can close `conn'`s #GTlsConnection:base-io-stream rather
     * than closing `conn` itself, but note that this may only be done when no other
     * operations are pending on `conn` or the base I/O stream.
     * @param require_close_notify whether or not to require close notification
     */
    set_require_close_notify(require_close_notify: boolean): void
    /**
     * Sets whether `conn` uses the system certificate database to verify
     * peer certificates. This is %TRUE by default. If set to %FALSE, then
     * peer certificate validation will always set the
     * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
     * #GTlsConnection::accept-certificate will always be emitted on
     * client-side connections, unless that bit is not set in
     * #GTlsClientConnection:validation-flags).
     * @param use_system_certdb whether to use the system certificate database
     */
    set_use_system_certdb(use_system_certdb: boolean): void

    // Own virtual methods of Gio-2.0.Gio.TlsConnection

    vfunc_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean
    vfunc_get_binding_data(type: TlsChannelBindingType, data: Uint8Array): boolean
    /**
     * Gets the name of the application-layer protocol negotiated during
     * the handshake.
     * 
     * If the peer did not use the ALPN extension, or did not advertise a
     * protocol that matched one of `conn'`s protocols, or the TLS backend
     * does not support ALPN, then this will be %NULL. See
     * g_tls_connection_set_advertised_protocols().
     * @virtual 
     * @returns the negotiated protocol, or %NULL
     */
    vfunc_get_negotiated_protocol(): string | null
    /**
     * Attempts a TLS handshake on `conn`.
     * 
     * On the client side, it is never necessary to call this method;
     * although the connection needs to perform a handshake after
     * connecting (or after sending a "STARTTLS"-type command),
     * #GTlsConnection will handle this for you automatically when you try
     * to send or receive data on the connection. You can call
     * g_tls_connection_handshake() manually if you want to know whether
     * the initial handshake succeeded or failed (as opposed to just
     * immediately trying to use `conn` to read or write, in which case,
     * if it fails, it may not be possible to tell if it failed before or
     * after completing the handshake), but beware that servers may reject
     * client authentication after the handshake has completed, so a
     * successful handshake does not indicate the connection will be usable.
     * 
     * Likewise, on the server side, although a handshake is necessary at
     * the beginning of the communication, you do not need to call this
     * function explicitly unless you want clearer error reporting.
     * 
     * Previously, calling g_tls_connection_handshake() after the initial
     * handshake would trigger a rehandshake; however, this usage was
     * deprecated in GLib 2.60 because rehandshaking was removed from the
     * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
     * the initial handshake will no longer do anything.
     * 
     * When using a #GTlsConnection created by #GSocketClient, the
     * #GSocketClient performs the initial handshake, so calling this
     * function manually is not recommended.
     * 
     * #GTlsConnection::accept_certificate may be emitted during the
     * handshake.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @returns success or failure
     */
    vfunc_handshake(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously performs a TLS handshake on `conn`. See
     * g_tls_connection_handshake() for more information.
     * @virtual 
     * @param io_priority the [I/O priority][io-priority] of the request
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the handshake is complete
     */
    vfunc_handshake_async(io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finish an asynchronous TLS handshake operation. See
     * g_tls_connection_handshake() for more information.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns %TRUE on success, %FALSE on failure, in which case @error will be set.
     */
    vfunc_handshake_finish(result: AsyncResult): boolean

    // Own signals of Gio-2.0.Gio.TlsConnection

    connect(sigName: "accept-certificate", callback: TlsConnection.AcceptCertificateSignalCallback): number
    connect_after(sigName: "accept-certificate", callback: TlsConnection.AcceptCertificateSignalCallback): number
    emit(sigName: "accept-certificate", peer_cert: TlsCertificate, errors: TlsCertificateFlags, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.TlsConnection

    connect(sigName: "notify::advertised-protocols", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::advertised-protocols", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::advertised-protocols", ...args: any[]): void
    connect(sigName: "notify::base-io-stream", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::base-io-stream", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::base-io-stream", ...args: any[]): void
    connect(sigName: "notify::certificate", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::certificate", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::certificate", ...args: any[]): void
    connect(sigName: "notify::ciphersuite-name", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ciphersuite-name", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::ciphersuite-name", ...args: any[]): void
    connect(sigName: "notify::database", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::database", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::database", ...args: any[]): void
    connect(sigName: "notify::interaction", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::negotiated-protocol", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::negotiated-protocol", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::negotiated-protocol", ...args: any[]): void
    connect(sigName: "notify::peer-certificate", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate", ...args: any[]): void
    connect(sigName: "notify::peer-certificate-errors", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-certificate-errors", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::peer-certificate-errors", ...args: any[]): void
    connect(sigName: "notify::protocol-version", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-version", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol-version", ...args: any[]): void
    connect(sigName: "notify::rehandshake-mode", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rehandshake-mode", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::rehandshake-mode", ...args: any[]): void
    connect(sigName: "notify::require-close-notify", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::require-close-notify", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::require-close-notify", ...args: any[]): void
    connect(sigName: "notify::use-system-certdb", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::use-system-certdb", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::use-system-certdb", ...args: any[]): void
    connect(sigName: "notify::closed", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::closed", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: "notify::input-stream", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::input-stream", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::input-stream", ...args: any[]): void
    connect(sigName: "notify::output-stream", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::output-stream", callback: (($obj: TlsConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::output-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GTlsConnection is the base TLS connection class type, which wraps
 * a #GIOStream and provides TLS encryption on top of it. Its
 * subclasses, #GTlsClientConnection and #GTlsServerConnection,
 * implement client-side and server-side TLS, respectively.
 * 
 * For DTLS (Datagram TLS) support, see #GDtlsConnection.
 * @interface 
 */
class TlsConnection extends IOStream {

    // Own properties of Gio-2.0.Gio.TlsConnection

    static name: string
    static $gtype: GObject.GType<TlsConnection>

    // Constructors of Gio-2.0.Gio.TlsConnection

    constructor(config?: TlsConnection.ConstructorProperties) 
    _init(config?: TlsConnection.ConstructorProperties): void
}

module TlsDatabase {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface TlsDatabase {

    // Own fields of Gio-2.0.Gio.TlsDatabase

    parent_instance: GObject.Object
    priv: TlsDatabasePrivate

    // Owm methods of Gio-2.0.Gio.TlsDatabase

    /**
     * Create a handle string for the certificate. The database will only be able
     * to create a handle for certificates that originate from the database. In
     * cases where the database cannot create a handle for a certificate, %NULL
     * will be returned.
     * 
     * This handle should be stable across various instances of the application,
     * and between applications. If a certificate is modified in the database,
     * then it is not guaranteed that this handle will continue to point to it.
     * @param certificate certificate for which to create a handle.
     * @returns a newly allocated string containing the handle.
     */
    create_certificate_handle(certificate: TlsCertificate): string | null
    /**
     * Look up a certificate by its handle.
     * 
     * The handle should have been created by calling
     * g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
     * the same TLS backend. The handle is designed to remain valid across
     * instantiations of the database.
     * 
     * If the handle is no longer valid, or does not point to a certificate in
     * this database, then %NULL will be returned.
     * 
     * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
     * the lookup operation asynchronously.
     * @param handle a certificate handle
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup.
     * @param cancellable a #GCancellable, or %NULL
     * @returns a newly allocated #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
     */
    lookup_certificate_for_handle(handle: string | null, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): TlsCertificate | null
    /**
     * Asynchronously look up a certificate by its handle in the database. See
     * g_tls_database_lookup_certificate_for_handle() for more information.
     * @param handle a certificate handle
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the operation completes
     */
    lookup_certificate_for_handle_async(handle: string | null, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_certificate_for_handle_async

    /**
     * Promisified version of {@link lookup_certificate_for_handle_async}
     * 
     * Asynchronously look up a certificate by its handle in the database. See
     * g_tls_database_lookup_certificate_for_handle() for more information.
     * @param handle a certificate handle
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup.
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a newly allocated #GTlsCertificate object. Use g_object_unref() to release the certificate.
     */
    lookup_certificate_for_handle_async(handle: string | null, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): globalThis.Promise<TlsCertificate>
    /**
     * Finish an asynchronous lookup of a certificate by its handle. See
     * g_tls_database_lookup_certificate_for_handle() for more information.
     * 
     * If the handle is no longer valid, or does not point to a certificate in
     * this database, then %NULL will be returned.
     * @param result a #GAsyncResult.
     * @returns a newly allocated #GTlsCertificate object. Use g_object_unref() to release the certificate.
     */
    lookup_certificate_for_handle_finish(result: AsyncResult): TlsCertificate
    /**
     * Look up the issuer of `certificate` in the database. The
     * #GTlsCertificate:issuer property of `certificate` is not modified, and
     * the two certificates are not hooked into a chain.
     * 
     * This function can block. Use g_tls_database_lookup_certificate_issuer_async()
     * to perform the lookup operation asynchronously.
     * 
     * Beware this function cannot be used to build certification paths. The
     * issuer certificate returned by this function may not be the same as
     * the certificate that would actually be used to construct a valid
     * certification path during certificate verification.
     * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
     * why an issuer certificate cannot be naively assumed to be part of the
     * the certification path (though GLib's TLS backends may not follow the
     * path building strategies outlined in this RFC). Due to the complexity
     * of certification path building, GLib does not provide any way to know
     * which certification path will actually be used when verifying a TLS
     * certificate. Accordingly, this function cannot be used to make
     * security-related decisions. Only GLib itself should make security
     * decisions about TLS certificates.
     * @param certificate a #GTlsCertificate
     * @param interaction used to interact with the user if necessary
     * @param flags flags which affect the lookup operation
     * @param cancellable a #GCancellable, or %NULL
     * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
     */
    lookup_certificate_issuer(certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): TlsCertificate
    /**
     * Asynchronously look up the issuer of `certificate` in the database. See
     * g_tls_database_lookup_certificate_issuer() for more information.
     * @param certificate a #GTlsCertificate
     * @param interaction used to interact with the user if necessary
     * @param flags flags which affect the lookup operation
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the operation completes
     */
    lookup_certificate_issuer_async(certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_certificate_issuer_async

    /**
     * Promisified version of {@link lookup_certificate_issuer_async}
     * 
     * Asynchronously look up the issuer of `certificate` in the database. See
     * g_tls_database_lookup_certificate_issuer() for more information.
     * @param certificate a #GTlsCertificate
     * @param interaction used to interact with the user if necessary
     * @param flags flags which affect the lookup operation
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
     */
    lookup_certificate_issuer_async(certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): globalThis.Promise<TlsCertificate>
    /**
     * Finish an asynchronous lookup issuer operation. See
     * g_tls_database_lookup_certificate_issuer() for more information.
     * @param result a #GAsyncResult.
     * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
     */
    lookup_certificate_issuer_finish(result: AsyncResult): TlsCertificate
    /**
     * Look up certificates issued by this issuer in the database.
     * 
     * This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
     * the lookup operation asynchronously.
     * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup operation.
     * @param cancellable a #GCancellable, or %NULL
     * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
     */
    lookup_certificates_issued_by(issuer_raw_dn: Uint8Array, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): TlsCertificate[]
    /**
     * Asynchronously look up certificates issued by this issuer in the database. See
     * g_tls_database_lookup_certificates_issued_by() for more information.
     * 
     * The database may choose to hold a reference to the issuer byte array for the duration
     * of of this asynchronous operation. The byte array should not be modified during
     * this time.
     * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup operation.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the operation completes
     */
    lookup_certificates_issued_by_async(issuer_raw_dn: Uint8Array, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of lookup_certificates_issued_by_async

    /**
     * Promisified version of {@link lookup_certificates_issued_by_async}
     * 
     * Asynchronously look up certificates issued by this issuer in the database. See
     * g_tls_database_lookup_certificates_issued_by() for more information.
     * 
     * The database may choose to hold a reference to the issuer byte array for the duration
     * of of this asynchronous operation. The byte array should not be modified during
     * this time.
     * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup operation.
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
     */
    lookup_certificates_issued_by_async(issuer_raw_dn: Uint8Array, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): globalThis.Promise<TlsCertificate[]>
    /**
     * Finish an asynchronous lookup of certificates. See
     * g_tls_database_lookup_certificates_issued_by() for more information.
     * @param result a #GAsyncResult.
     * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
     */
    lookup_certificates_issued_by_finish(result: AsyncResult): TlsCertificate[]
    /**
     * Determines the validity of a certificate chain, outside the context
     * of a TLS session.
     * 
     * `chain` is a chain of #GTlsCertificate objects each pointing to the next
     * certificate in the chain by its #GTlsCertificate:issuer property.
     * 
     * `purpose` describes the purpose (or usage) for which the certificate
     * is being used. Typically `purpose` will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
     * which means that the certificate is being used to authenticate a server
     * (and we are acting as the client).
     * 
     * The `identity` is used to ensure the server certificate is valid for
     * the expected peer identity. If the identity does not match the
     * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
     * return value. If `identity` is %NULL, that bit will never be set in
     * the return value. The peer identity may also be used to check for
     * pinned certificates (trust exceptions) in the database. These may
     * override the normal verification process on a host-by-host basis.
     * 
     * Currently there are no `flags,` and %G_TLS_DATABASE_VERIFY_NONE should be
     * used.
     * 
     * If `chain` is found to be valid, then the return value will be 0. If
     * `chain` is found to be invalid, then the return value will indicate at
     * least one problem found. If the function is unable to determine
     * whether `chain` is valid (for example, because `cancellable` is
     * triggered before it completes) then the return value will be
     * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set accordingly.
     * `error` is not set when `chain` is successfully analyzed but found to
     * be invalid.
     * 
     * GLib guarantees that if certificate verification fails, at least one
     * error will be set in the return value, but it does not guarantee
     * that all possible errors will be set. Accordingly, you may not safely
     * decide to ignore any particular type of error. For example, it would
     * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
     * expired certificates, because this could potentially be the only
     * error flag set even if other problems exist with the certificate.
     * 
     * Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
     * represent the certification path built by #GTlsDatabase during
     * certificate verification by adjusting the #GTlsCertificate:issuer
     * property of each certificate in `chain`. Since GLib 2.48, this no
     * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
     * represent the actual certification path used during certificate
     * verification.
     * 
     * Because TLS session context is not used, #GTlsDatabase may not
     * perform as many checks on the certificates as #GTlsConnection would.
     * For example, certificate constraints may not be honored, and
     * revocation checks may not be performed. The best way to verify TLS
     * certificates used by a TLS connection is to let #GTlsConnection
     * handle the verification.
     * 
     * The TLS backend may attempt to look up and add missing certificates
     * to the chain. This may involve HTTP requests to download missing
     * certificates.
     * 
     * This function can block. Use g_tls_database_verify_chain_async() to
     * perform the verification operation asynchronously.
     * @param chain a #GTlsCertificate chain
     * @param purpose the purpose that this certificate chain will be used for.
     * @param identity the expected peer identity
     * @param interaction used to interact with the user if necessary
     * @param flags additional verify flags
     * @param cancellable a #GCancellable, or %NULL
     * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
     */
    verify_chain(chain: TlsCertificate, purpose: string | null, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable: Cancellable | null): TlsCertificateFlags
    /**
     * Asynchronously determines the validity of a certificate chain after
     * looking up and adding any missing certificates to the chain. See
     * g_tls_database_verify_chain() for more information.
     * @param chain a #GTlsCertificate chain
     * @param purpose the purpose that this certificate chain will be used for.
     * @param identity the expected peer identity
     * @param interaction used to interact with the user if necessary
     * @param flags additional verify flags
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the operation completes
     */
    verify_chain_async(chain: TlsCertificate, purpose: string | null, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of verify_chain_async

    /**
     * Promisified version of {@link verify_chain_async}
     * 
     * Asynchronously determines the validity of a certificate chain after
     * looking up and adding any missing certificates to the chain. See
     * g_tls_database_verify_chain() for more information.
     * @param chain a #GTlsCertificate chain
     * @param purpose the purpose that this certificate chain will be used for.
     * @param identity the expected peer identity
     * @param interaction used to interact with the user if necessary
     * @param flags additional verify flags
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: the appropriate #GTlsCertificateFlags which represents the result of verification.
     */
    verify_chain_async(chain: TlsCertificate, purpose: string | null, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable: Cancellable | null): globalThis.Promise<TlsCertificateFlags>
    /**
     * Finish an asynchronous verify chain operation. See
     * g_tls_database_verify_chain() for more information.
     * 
     * If `chain` is found to be valid, then the return value will be 0. If
     * `chain` is found to be invalid, then the return value will indicate
     * the problems found. If the function is unable to determine whether
     * `chain` is valid or not (eg, because `cancellable` is triggered
     * before it completes) then the return value will be
     * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set
     * accordingly. `error` is not set when `chain` is successfully analyzed
     * but found to be invalid.
     * @param result a #GAsyncResult.
     * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
     */
    verify_chain_finish(result: AsyncResult): TlsCertificateFlags

    // Own virtual methods of Gio-2.0.Gio.TlsDatabase

    /**
     * Create a handle string for the certificate. The database will only be able
     * to create a handle for certificates that originate from the database. In
     * cases where the database cannot create a handle for a certificate, %NULL
     * will be returned.
     * 
     * This handle should be stable across various instances of the application,
     * and between applications. If a certificate is modified in the database,
     * then it is not guaranteed that this handle will continue to point to it.
     * @virtual 
     * @param certificate certificate for which to create a handle.
     * @returns a newly allocated string containing the handle.
     */
    vfunc_create_certificate_handle(certificate: TlsCertificate): string | null
    /**
     * Look up a certificate by its handle.
     * 
     * The handle should have been created by calling
     * g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
     * the same TLS backend. The handle is designed to remain valid across
     * instantiations of the database.
     * 
     * If the handle is no longer valid, or does not point to a certificate in
     * this database, then %NULL will be returned.
     * 
     * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
     * the lookup operation asynchronously.
     * @virtual 
     * @param handle a certificate handle
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup.
     * @param cancellable a #GCancellable, or %NULL
     * @returns a newly allocated #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
     */
    vfunc_lookup_certificate_for_handle(handle: string | null, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): TlsCertificate | null
    /**
     * Asynchronously look up a certificate by its handle in the database. See
     * g_tls_database_lookup_certificate_for_handle() for more information.
     * @virtual 
     * @param handle a certificate handle
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the operation completes
     */
    vfunc_lookup_certificate_for_handle_async(handle: string | null, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finish an asynchronous lookup of a certificate by its handle. See
     * g_tls_database_lookup_certificate_for_handle() for more information.
     * 
     * If the handle is no longer valid, or does not point to a certificate in
     * this database, then %NULL will be returned.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns a newly allocated #GTlsCertificate object. Use g_object_unref() to release the certificate.
     */
    vfunc_lookup_certificate_for_handle_finish(result: AsyncResult): TlsCertificate
    /**
     * Look up the issuer of `certificate` in the database. The
     * #GTlsCertificate:issuer property of `certificate` is not modified, and
     * the two certificates are not hooked into a chain.
     * 
     * This function can block. Use g_tls_database_lookup_certificate_issuer_async()
     * to perform the lookup operation asynchronously.
     * 
     * Beware this function cannot be used to build certification paths. The
     * issuer certificate returned by this function may not be the same as
     * the certificate that would actually be used to construct a valid
     * certification path during certificate verification.
     * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
     * why an issuer certificate cannot be naively assumed to be part of the
     * the certification path (though GLib's TLS backends may not follow the
     * path building strategies outlined in this RFC). Due to the complexity
     * of certification path building, GLib does not provide any way to know
     * which certification path will actually be used when verifying a TLS
     * certificate. Accordingly, this function cannot be used to make
     * security-related decisions. Only GLib itself should make security
     * decisions about TLS certificates.
     * @virtual 
     * @param certificate a #GTlsCertificate
     * @param interaction used to interact with the user if necessary
     * @param flags flags which affect the lookup operation
     * @param cancellable a #GCancellable, or %NULL
     * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
     */
    vfunc_lookup_certificate_issuer(certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): TlsCertificate
    /**
     * Asynchronously look up the issuer of `certificate` in the database. See
     * g_tls_database_lookup_certificate_issuer() for more information.
     * @virtual 
     * @param certificate a #GTlsCertificate
     * @param interaction used to interact with the user if necessary
     * @param flags flags which affect the lookup operation
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the operation completes
     */
    vfunc_lookup_certificate_issuer_async(certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finish an asynchronous lookup issuer operation. See
     * g_tls_database_lookup_certificate_issuer() for more information.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns a newly allocated issuer #GTlsCertificate, or %NULL. Use g_object_unref() to release the certificate.
     */
    vfunc_lookup_certificate_issuer_finish(result: AsyncResult): TlsCertificate
    /**
     * Look up certificates issued by this issuer in the database.
     * 
     * This function can block, use g_tls_database_lookup_certificates_issued_by_async() to perform
     * the lookup operation asynchronously.
     * @virtual 
     * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup operation.
     * @param cancellable a #GCancellable, or %NULL
     * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
     */
    vfunc_lookup_certificates_issued_by(issuer_raw_dn: Uint8Array, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null): TlsCertificate[]
    /**
     * Asynchronously look up certificates issued by this issuer in the database. See
     * g_tls_database_lookup_certificates_issued_by() for more information.
     * 
     * The database may choose to hold a reference to the issuer byte array for the duration
     * of of this asynchronous operation. The byte array should not be modified during
     * this time.
     * @virtual 
     * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
     * @param interaction used to interact with the user if necessary
     * @param flags Flags which affect the lookup operation.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the operation completes
     */
    vfunc_lookup_certificates_issued_by_async(issuer_raw_dn: Uint8Array, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finish an asynchronous lookup of certificates. See
     * g_tls_database_lookup_certificates_issued_by() for more information.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns a newly allocated list of #GTlsCertificate objects. Use g_object_unref() on each certificate, and g_list_free() on the release the list.
     */
    vfunc_lookup_certificates_issued_by_finish(result: AsyncResult): TlsCertificate[]
    /**
     * Determines the validity of a certificate chain, outside the context
     * of a TLS session.
     * 
     * `chain` is a chain of #GTlsCertificate objects each pointing to the next
     * certificate in the chain by its #GTlsCertificate:issuer property.
     * 
     * `purpose` describes the purpose (or usage) for which the certificate
     * is being used. Typically `purpose` will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
     * which means that the certificate is being used to authenticate a server
     * (and we are acting as the client).
     * 
     * The `identity` is used to ensure the server certificate is valid for
     * the expected peer identity. If the identity does not match the
     * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
     * return value. If `identity` is %NULL, that bit will never be set in
     * the return value. The peer identity may also be used to check for
     * pinned certificates (trust exceptions) in the database. These may
     * override the normal verification process on a host-by-host basis.
     * 
     * Currently there are no `flags,` and %G_TLS_DATABASE_VERIFY_NONE should be
     * used.
     * 
     * If `chain` is found to be valid, then the return value will be 0. If
     * `chain` is found to be invalid, then the return value will indicate at
     * least one problem found. If the function is unable to determine
     * whether `chain` is valid (for example, because `cancellable` is
     * triggered before it completes) then the return value will be
     * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set accordingly.
     * `error` is not set when `chain` is successfully analyzed but found to
     * be invalid.
     * 
     * GLib guarantees that if certificate verification fails, at least one
     * error will be set in the return value, but it does not guarantee
     * that all possible errors will be set. Accordingly, you may not safely
     * decide to ignore any particular type of error. For example, it would
     * be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
     * expired certificates, because this could potentially be the only
     * error flag set even if other problems exist with the certificate.
     * 
     * Prior to GLib 2.48, GLib's default TLS backend modified `chain` to
     * represent the certification path built by #GTlsDatabase during
     * certificate verification by adjusting the #GTlsCertificate:issuer
     * property of each certificate in `chain`. Since GLib 2.48, this no
     * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
     * represent the actual certification path used during certificate
     * verification.
     * 
     * Because TLS session context is not used, #GTlsDatabase may not
     * perform as many checks on the certificates as #GTlsConnection would.
     * For example, certificate constraints may not be honored, and
     * revocation checks may not be performed. The best way to verify TLS
     * certificates used by a TLS connection is to let #GTlsConnection
     * handle the verification.
     * 
     * The TLS backend may attempt to look up and add missing certificates
     * to the chain. This may involve HTTP requests to download missing
     * certificates.
     * 
     * This function can block. Use g_tls_database_verify_chain_async() to
     * perform the verification operation asynchronously.
     * @virtual 
     * @param chain a #GTlsCertificate chain
     * @param purpose the purpose that this certificate chain will be used for.
     * @param identity the expected peer identity
     * @param interaction used to interact with the user if necessary
     * @param flags additional verify flags
     * @param cancellable a #GCancellable, or %NULL
     * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
     */
    vfunc_verify_chain(chain: TlsCertificate, purpose: string | null, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable: Cancellable | null): TlsCertificateFlags
    /**
     * Asynchronously determines the validity of a certificate chain after
     * looking up and adding any missing certificates to the chain. See
     * g_tls_database_verify_chain() for more information.
     * @virtual 
     * @param chain a #GTlsCertificate chain
     * @param purpose the purpose that this certificate chain will be used for.
     * @param identity the expected peer identity
     * @param interaction used to interact with the user if necessary
     * @param flags additional verify flags
     * @param cancellable a #GCancellable, or %NULL
     * @param callback callback to call when the operation completes
     */
    vfunc_verify_chain_async(chain: TlsCertificate, purpose: string | null, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Finish an asynchronous verify chain operation. See
     * g_tls_database_verify_chain() for more information.
     * 
     * If `chain` is found to be valid, then the return value will be 0. If
     * `chain` is found to be invalid, then the return value will indicate
     * the problems found. If the function is unable to determine whether
     * `chain` is valid or not (eg, because `cancellable` is triggered
     * before it completes) then the return value will be
     * %G_TLS_CERTIFICATE_GENERIC_ERROR and `error` will be set
     * accordingly. `error` is not set when `chain` is successfully analyzed
     * but found to be invalid.
     * @virtual 
     * @param result a #GAsyncResult.
     * @returns the appropriate #GTlsCertificateFlags which represents the result of verification.
     */
    vfunc_verify_chain_finish(result: AsyncResult): TlsCertificateFlags

    // Class property signals of Gio-2.0.Gio.TlsDatabase

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GTlsDatabase is used to look up certificates and other information
 * from a certificate or key store. It is an abstract base class which
 * TLS library specific subtypes override.
 * 
 * A #GTlsDatabase may be accessed from multiple threads by the TLS backend.
 * All implementations are required to be fully thread-safe.
 * 
 * Most common client applications will not directly interact with
 * #GTlsDatabase. It is used internally by #GTlsConnection.
 * @interface 
 */
class TlsDatabase extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TlsDatabase

    static name: string
    static $gtype: GObject.GType<TlsDatabase>

    // Constructors of Gio-2.0.Gio.TlsDatabase

    constructor(config?: TlsDatabase.ConstructorProperties) 
    _init(config?: TlsDatabase.ConstructorProperties): void
}

module TlsInteraction {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface TlsInteraction {

    // Owm methods of Gio-2.0.Gio.TlsInteraction

    /**
     * Run synchronous interaction to ask the user for a password. In general,
     * g_tls_interaction_invoke_ask_password() should be used instead of this
     * function.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * @param password a #GTlsPassword object
     * @param cancellable an optional #GCancellable cancellation object
     * @returns The status of the ask password interaction.
     */
    ask_password(password: TlsPassword, cancellable: Cancellable | null): TlsInteractionResult
    /**
     * Run asynchronous interaction to ask the user for a password. In general,
     * g_tls_interaction_invoke_ask_password() should be used instead of this
     * function.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * 
     * Certain implementations may not support immediate cancellation.
     * @param password a #GTlsPassword object
     * @param cancellable an optional #GCancellable cancellation object
     * @param callback will be called when the interaction completes
     */
    ask_password_async(password: TlsPassword, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of ask_password_async

    /**
     * Promisified version of {@link ask_password_async}
     * 
     * Run asynchronous interaction to ask the user for a password. In general,
     * g_tls_interaction_invoke_ask_password() should be used instead of this
     * function.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * 
     * Certain implementations may not support immediate cancellation.
     * @param password a #GTlsPassword object
     * @param cancellable an optional #GCancellable cancellation object
     * @returns A Promise of: The status of the ask password interaction.
     */
    ask_password_async(password: TlsPassword, cancellable: Cancellable | null): globalThis.Promise<TlsInteractionResult>
    /**
     * Complete an ask password user interaction request. This should be once
     * the g_tls_interaction_ask_password_async() completion callback is called.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
     * to g_tls_interaction_ask_password() will have its password filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code.
     * @param result the result passed to the callback
     * @returns The status of the ask password interaction.
     */
    ask_password_finish(result: AsyncResult): TlsInteractionResult
    /**
     * Invoke the interaction to ask the user for a password. It invokes this
     * interaction in the main loop, specifically the #GMainContext returned by
     * g_main_context_get_thread_default() when the interaction is created. This
     * is called by called by #GTlsConnection or #GTlsDatabase to ask the user
     * for a password.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * The implementation can either be a synchronous (eg: modal dialog) or an
     * asynchronous one (eg: modeless dialog). This function will take care of
     * calling which ever one correctly.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * @param password a #GTlsPassword object
     * @param cancellable an optional #GCancellable cancellation object
     * @returns The status of the ask password interaction.
     */
    invoke_ask_password(password: TlsPassword, cancellable: Cancellable | null): TlsInteractionResult
    /**
     * Invoke the interaction to ask the user to choose a certificate to
     * use with the connection. It invokes this interaction in the main
     * loop, specifically the #GMainContext returned by
     * g_main_context_get_thread_default() when the interaction is
     * created. This is called by called by #GTlsConnection when the peer
     * requests a certificate during the handshake.
     * 
     * Derived subclasses usually implement a certificate selector,
     * although they may also choose to provide a certificate from
     * elsewhere. Alternatively the user may abort this certificate
     * request, which may or may not abort the TLS connection.
     * 
     * The implementation can either be a synchronous (eg: modal dialog) or an
     * asynchronous one (eg: modeless dialog). This function will take care of
     * calling which ever one correctly.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * @param connection a #GTlsConnection object
     * @param flags flags providing more information about the request
     * @param cancellable an optional #GCancellable cancellation object
     * @returns The status of the certificate request interaction.
     */
    invoke_request_certificate(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | null): TlsInteractionResult
    /**
     * Run synchronous interaction to ask the user to choose a certificate to use
     * with the connection. In general, g_tls_interaction_invoke_request_certificate()
     * should be used instead of this function.
     * 
     * Derived subclasses usually implement a certificate selector, although they may
     * also choose to provide a certificate from elsewhere. Alternatively the user may
     * abort this certificate request, which will usually abort the TLS connection.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
     * passed to g_tls_interaction_request_certificate() will have had its
     * #GTlsConnection:certificate filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * @param connection a #GTlsConnection object
     * @param flags flags providing more information about the request
     * @param cancellable an optional #GCancellable cancellation object
     * @returns The status of the request certificate interaction.
     */
    request_certificate(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | null): TlsInteractionResult
    /**
     * Run asynchronous interaction to ask the user for a certificate to use with
     * the connection. In general, g_tls_interaction_invoke_request_certificate() should
     * be used instead of this function.
     * 
     * Derived subclasses usually implement a certificate selector, although they may
     * also choose to provide a certificate from elsewhere. `callback` will be called
     * when the operation completes. Alternatively the user may abort this certificate
     * request, which will usually abort the TLS connection.
     * @param connection a #GTlsConnection object
     * @param flags flags providing more information about the request
     * @param cancellable an optional #GCancellable cancellation object
     * @param callback will be called when the interaction completes
     */
    request_certificate_async(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of request_certificate_async

    /**
     * Promisified version of {@link request_certificate_async}
     * 
     * Run asynchronous interaction to ask the user for a certificate to use with
     * the connection. In general, g_tls_interaction_invoke_request_certificate() should
     * be used instead of this function.
     * 
     * Derived subclasses usually implement a certificate selector, although they may
     * also choose to provide a certificate from elsewhere. `callback` will be called
     * when the operation completes. Alternatively the user may abort this certificate
     * request, which will usually abort the TLS connection.
     * @param connection a #GTlsConnection object
     * @param flags flags providing more information about the request
     * @param cancellable an optional #GCancellable cancellation object
     * @returns A Promise of: The status of the request certificate interaction.
     */
    request_certificate_async(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | null): globalThis.Promise<TlsInteractionResult>
    /**
     * Complete a request certificate user interaction request. This should be once
     * the g_tls_interaction_request_certificate_async() completion callback is called.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
     * passed to g_tls_interaction_request_certificate_async() will have had its
     * #GTlsConnection:certificate filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code.
     * @param result the result passed to the callback
     * @returns The status of the request certificate interaction.
     */
    request_certificate_finish(result: AsyncResult): TlsInteractionResult

    // Own virtual methods of Gio-2.0.Gio.TlsInteraction

    /**
     * Run synchronous interaction to ask the user for a password. In general,
     * g_tls_interaction_invoke_ask_password() should be used instead of this
     * function.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * @virtual 
     * @param password a #GTlsPassword object
     * @param cancellable an optional #GCancellable cancellation object
     * @returns The status of the ask password interaction.
     */
    vfunc_ask_password(password: TlsPassword, cancellable: Cancellable | null): TlsInteractionResult
    /**
     * Run asynchronous interaction to ask the user for a password. In general,
     * g_tls_interaction_invoke_ask_password() should be used instead of this
     * function.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * 
     * Certain implementations may not support immediate cancellation.
     * @virtual 
     * @param password a #GTlsPassword object
     * @param cancellable an optional #GCancellable cancellation object
     * @param callback will be called when the interaction completes
     */
    vfunc_ask_password_async(password: TlsPassword, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Complete an ask password user interaction request. This should be once
     * the g_tls_interaction_ask_password_async() completion callback is called.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
     * to g_tls_interaction_ask_password() will have its password filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code.
     * @virtual 
     * @param result the result passed to the callback
     * @returns The status of the ask password interaction.
     */
    vfunc_ask_password_finish(result: AsyncResult): TlsInteractionResult
    /**
     * Run synchronous interaction to ask the user to choose a certificate to use
     * with the connection. In general, g_tls_interaction_invoke_request_certificate()
     * should be used instead of this function.
     * 
     * Derived subclasses usually implement a certificate selector, although they may
     * also choose to provide a certificate from elsewhere. Alternatively the user may
     * abort this certificate request, which will usually abort the TLS connection.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
     * passed to g_tls_interaction_request_certificate() will have had its
     * #GTlsConnection:certificate filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * @virtual 
     * @param connection a #GTlsConnection object
     * @param flags flags providing more information about the request
     * @param cancellable an optional #GCancellable cancellation object
     * @returns The status of the request certificate interaction.
     */
    vfunc_request_certificate(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | null): TlsInteractionResult
    /**
     * Run asynchronous interaction to ask the user for a certificate to use with
     * the connection. In general, g_tls_interaction_invoke_request_certificate() should
     * be used instead of this function.
     * 
     * Derived subclasses usually implement a certificate selector, although they may
     * also choose to provide a certificate from elsewhere. `callback` will be called
     * when the operation completes. Alternatively the user may abort this certificate
     * request, which will usually abort the TLS connection.
     * @virtual 
     * @param connection a #GTlsConnection object
     * @param flags flags providing more information about the request
     * @param cancellable an optional #GCancellable cancellation object
     * @param callback will be called when the interaction completes
     */
    vfunc_request_certificate_async(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void
    /**
     * Complete a request certificate user interaction request. This should be once
     * the g_tls_interaction_request_certificate_async() completion callback is called.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
     * passed to g_tls_interaction_request_certificate_async() will have had its
     * #GTlsConnection:certificate filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code.
     * @virtual 
     * @param result the result passed to the callback
     * @returns The status of the request certificate interaction.
     */
    vfunc_request_certificate_finish(result: AsyncResult): TlsInteractionResult

    // Class property signals of Gio-2.0.Gio.TlsInteraction

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GTlsInteraction provides a mechanism for the TLS connection and database
 * code to interact with the user. It can be used to ask the user for passwords.
 * 
 * To use a #GTlsInteraction with a TLS connection use
 * g_tls_connection_set_interaction().
 * 
 * Callers should instantiate a derived class that implements the various
 * interaction methods to show the required dialogs.
 * 
 * Callers should use the 'invoke' functions like
 * g_tls_interaction_invoke_ask_password() to run interaction methods. These
 * functions make sure that the interaction is invoked in the main loop
 * and not in the current thread, if the current thread is not running the
 * main loop.
 * 
 * Derived classes can choose to implement whichever interactions methods they'd
 * like to support by overriding those virtual methods in their class
 * initialization function. Any interactions not implemented will return
 * %G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
 * it must also implement the corresponding finish method.
 * @class 
 */
class TlsInteraction extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TlsInteraction

    static name: string
    static $gtype: GObject.GType<TlsInteraction>

    // Constructors of Gio-2.0.Gio.TlsInteraction

    constructor(config?: TlsInteraction.ConstructorProperties) 
    _init(config?: TlsInteraction.ConstructorProperties): void
}

module TlsPassword {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.TlsPassword

        description?: string | null
        flags?: TlsPasswordFlags | null
        warning?: string | null
    }

}

interface TlsPassword {

    // Own properties of Gio-2.0.Gio.TlsPassword

    description: string | null
    flags: TlsPasswordFlags
    warning: string | null

    // Own fields of Gio-2.0.Gio.TlsPassword

    parent_instance: GObject.Object
    priv: TlsPasswordPrivate

    // Owm methods of Gio-2.0.Gio.TlsPassword

    /**
     * Get a description string about what the password will be used for.
     * @returns The description of the password.
     */
    get_description(): string | null
    /**
     * Get flags about the password.
     * @returns The flags about the password.
     */
    get_flags(): TlsPasswordFlags
    /**
     * Get the password value. If `length` is not %NULL then it will be
     * filled in with the length of the password value. (Note that the
     * password value is not nul-terminated, so you can only pass %NULL
     * for `length` in contexts where you know the password will have a
     * certain fixed length.)
     * @returns The password value (owned by the password object).
     */
    get_value(): Uint8Array
    /**
     * Get a user readable translated warning. Usually this warning is a
     * representation of the password flags returned from
     * g_tls_password_get_flags().
     * @returns The warning.
     */
    get_warning(): string | null
    /**
     * Set a description string about what the password will be used for.
     * @param description The description of the password
     */
    set_description(description: string | null): void
    /**
     * Set flags about the password.
     * @param flags The flags about the password
     */
    set_flags(flags: TlsPasswordFlags): void
    /**
     * Set the value for this password. The `value` will be copied by the password
     * object.
     * 
     * Specify the `length,` for a non-nul-terminated password. Pass -1 as
     * `length` if using a nul-terminated password, and `length` will be
     * calculated automatically. (Note that the terminating nul is not
     * considered part of the password in this case.)
     * @param value the new password value
     */
    set_value(value: Uint8Array): void
    /**
     * Provide the value for this password.
     * 
     * The `value` will be owned by the password object, and later freed using
     * the `destroy` function callback.
     * 
     * Specify the `length,` for a non-nul-terminated password. Pass -1 as
     * `length` if using a nul-terminated password, and `length` will be
     * calculated automatically. (Note that the terminating nul is not
     * considered part of the password in this case.)
     * @param value the value for the password
     * @param destroy a function to use to free the password.
     */
    set_value_full(value: Uint8Array, destroy: GLib.DestroyNotify | null): void
    /**
     * Set a user readable translated warning. Usually this warning is a
     * representation of the password flags returned from
     * g_tls_password_get_flags().
     * @param warning The user readable warning
     */
    set_warning(warning: string | null): void

    // Own virtual methods of Gio-2.0.Gio.TlsPassword

    vfunc_get_default_warning(): string | null
    /**
     * Get the password value. If `length` is not %NULL then it will be
     * filled in with the length of the password value. (Note that the
     * password value is not nul-terminated, so you can only pass %NULL
     * for `length` in contexts where you know the password will have a
     * certain fixed length.)
     * @virtual 
     * @returns The password value (owned by the password object).
     */
    vfunc_get_value(): Uint8Array
    /**
     * Provide the value for this password.
     * 
     * The `value` will be owned by the password object, and later freed using
     * the `destroy` function callback.
     * 
     * Specify the `length,` for a non-nul-terminated password. Pass -1 as
     * `length` if using a nul-terminated password, and `length` will be
     * calculated automatically. (Note that the terminating nul is not
     * considered part of the password in this case.)
     * @virtual 
     * @param value the value for the password
     * @param destroy a function to use to free the password.
     */
    vfunc_set_value(value: Uint8Array, destroy: GLib.DestroyNotify | null): void

    // Class property signals of Gio-2.0.Gio.TlsPassword

    connect(sigName: "notify::description", callback: (($obj: TlsPassword, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: TlsPassword, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::flags", callback: (($obj: TlsPassword, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: TlsPassword, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: "notify::warning", callback: (($obj: TlsPassword, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::warning", callback: (($obj: TlsPassword, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::warning", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Holds a password used in TLS.
 * @class 
 */
class TlsPassword extends GObject.Object {

    // Own properties of Gio-2.0.Gio.TlsPassword

    static name: string
    static $gtype: GObject.GType<TlsPassword>

    // Constructors of Gio-2.0.Gio.TlsPassword

    constructor(config?: TlsPassword.ConstructorProperties) 
    /**
     * Create a new #GTlsPassword object.
     * @constructor 
     * @param flags the password flags
     * @param description description of what the password is for
     * @returns The newly allocated password object
     */
    constructor(flags: TlsPasswordFlags, description: string | null) 
    /**
     * Create a new #GTlsPassword object.
     * @constructor 
     * @param flags the password flags
     * @param description description of what the password is for
     * @returns The newly allocated password object
     */
    static new(flags: TlsPasswordFlags, description: string | null): TlsPassword
    _init(config?: TlsPassword.ConstructorProperties): void
}

module UnixConnection {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnection.ConstructorProperties {
    }

}

interface UnixConnection {

    // Own fields of Gio-2.0.Gio.UnixConnection

    parent_instance: SocketConnection & IOStream & GObject.Object & GObject.Object
    priv: any

    // Owm methods of Gio-2.0.Gio.UnixConnection

    /**
     * Receives credentials from the sending end of the connection.  The
     * sending end has to call g_unix_connection_send_credentials() (or
     * similar) for this to work.
     * 
     * As well as reading the credentials this also reads (and discards) a
     * single byte from the stream, as this is required for credentials
     * passing to work on some implementations.
     * 
     * This method can be expected to be available on the following platforms:
     * 
     * - Linux since GLib 2.26
     * - FreeBSD since GLib 2.26
     * - GNU/kFreeBSD since GLib 2.36
     * - Solaris, Illumos and OpenSolaris since GLib 2.40
     * - GNU/Hurd since GLib 2.40
     * 
     * Other ways to exchange credentials with a foreign peer includes the
     * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
     * @param cancellable A #GCancellable or %NULL.
     * @returns Received credentials on success (free with g_object_unref()), %NULL if @error is set.
     */
    receive_credentials(cancellable: Cancellable | null): Credentials
    /**
     * Asynchronously receive credentials.
     * 
     * For more details, see g_unix_connection_receive_credentials() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_unix_connection_receive_credentials_finish() to get the result of the operation.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    receive_credentials_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of receive_credentials_async

    /**
     * Promisified version of {@link receive_credentials_async}
     * 
     * Asynchronously receive credentials.
     * 
     * For more details, see g_unix_connection_receive_credentials() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_unix_connection_receive_credentials_finish() to get the result of the operation.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: a #GCredentials, or %NULL on error.     Free the returned object with g_object_unref().
     */
    receive_credentials_async(cancellable: Cancellable | null): globalThis.Promise<Credentials>
    /**
     * Finishes an asynchronous receive credentials operation started with
     * g_unix_connection_receive_credentials_async().
     * @param result a #GAsyncResult.
     * @returns a #GCredentials, or %NULL on error.     Free the returned object with g_object_unref().
     */
    receive_credentials_finish(result: AsyncResult): Credentials
    /**
     * Receives a file descriptor from the sending end of the connection.
     * The sending end has to call g_unix_connection_send_fd() for this
     * to work.
     * 
     * As well as reading the fd this also reads a single byte from the
     * stream, as this is required for fd passing to work on some
     * implementations.
     * @param cancellable optional #GCancellable object, %NULL to ignore
     * @returns a file descriptor on success, -1 on error.
     */
    receive_fd(cancellable: Cancellable | null): number
    /**
     * Passes the credentials of the current user the receiving side
     * of the connection. The receiving end has to call
     * g_unix_connection_receive_credentials() (or similar) to accept the
     * credentials.
     * 
     * As well as sending the credentials this also writes a single NUL
     * byte to the stream, as this is required for credentials passing to
     * work on some implementations.
     * 
     * This method can be expected to be available on the following platforms:
     * 
     * - Linux since GLib 2.26
     * - FreeBSD since GLib 2.26
     * - GNU/kFreeBSD since GLib 2.36
     * - Solaris, Illumos and OpenSolaris since GLib 2.40
     * - GNU/Hurd since GLib 2.40
     * 
     * Other ways to exchange credentials with a foreign peer includes the
     * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE on success, %FALSE if @error is set.
     */
    send_credentials(cancellable: Cancellable | null): boolean
    /**
     * Asynchronously send credentials.
     * 
     * For more details, see g_unix_connection_send_credentials() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_unix_connection_send_credentials_finish() to get the result of the operation.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @param callback a #GAsyncReadyCallback to call when the request is satisfied
     */
    send_credentials_async(cancellable: Cancellable | null, callback: AsyncReadyCallback<this> | null): void

    // Overloads of send_credentials_async

    /**
     * Promisified version of {@link send_credentials_async}
     * 
     * Asynchronously send credentials.
     * 
     * For more details, see g_unix_connection_send_credentials() which is
     * the synchronous version of this call.
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * g_unix_connection_send_credentials_finish() to get the result of the operation.
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns A Promise of: %TRUE if the operation was successful, otherwise %FALSE.
     */
    send_credentials_async(cancellable: Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes an asynchronous send credentials operation started with
     * g_unix_connection_send_credentials_async().
     * @param result a #GAsyncResult.
     * @returns %TRUE if the operation was successful, otherwise %FALSE.
     */
    send_credentials_finish(result: AsyncResult): boolean
    /**
     * Passes a file descriptor to the receiving side of the
     * connection. The receiving end has to call g_unix_connection_receive_fd()
     * to accept the file descriptor.
     * 
     * As well as sending the fd this also writes a single byte to the
     * stream, as this is required for fd passing to work on some
     * implementations.
     * @param fd a file descriptor
     * @param cancellable optional #GCancellable object, %NULL to ignore.
     * @returns a %TRUE on success, %NULL on error.
     */
    send_fd(fd: number, cancellable: Cancellable | null): boolean

    // Class property signals of Gio-2.0.Gio.UnixConnection

    connect(sigName: "notify::socket", callback: (($obj: UnixConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::socket", callback: (($obj: UnixConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::socket", ...args: any[]): void
    connect(sigName: "notify::closed", callback: (($obj: UnixConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::closed", callback: (($obj: UnixConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::closed", ...args: any[]): void
    connect(sigName: "notify::input-stream", callback: (($obj: UnixConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::input-stream", callback: (($obj: UnixConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::input-stream", ...args: any[]): void
    connect(sigName: "notify::output-stream", callback: (($obj: UnixConnection, pspec: GObject.ParamSpec) => void)): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: "notify::output-stream", callback: (($obj: UnixConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::output-stream", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number

    // Overloads of connect

    /**
     * Connect `connection` to the specified remote address.
     * @param address a #GSocketAddress specifying the remote address.
     * @param cancellable a %GCancellable or %NULL
     * @returns %TRUE if the connection succeeded, %FALSE on error
     */
    connect(address: SocketAddress, cancellable: Cancellable | null): boolean
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This is the subclass of #GSocketConnection that is created
 * for UNIX domain sockets.
 * 
 * It contains functions to do some of the UNIX socket specific
 * functionality like passing file descriptors.
 * 
 * Since GLib 2.72, #GUnixConnection is available on all platforms. It requires
 * underlying system support (such as Windows 10 with `AF_UNIX`) at run time.
 * 
 * Before GLib 2.72, `<gio/gunixconnection.h>` belonged to the UNIX-specific GIO
 * interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
 * using it. This is no longer necessary since GLib 2.72.
 * @class 
 */
class UnixConnection extends SocketConnection {

    // Own properties of Gio-2.0.Gio.UnixConnection

    static name: string
    static $gtype: GObject.GType<UnixConnection>

    // Constructors of Gio-2.0.Gio.UnixConnection

    constructor(config?: UnixConnection.ConstructorProperties) 
    _init(config?: UnixConnection.ConstructorProperties): void
}

module UnixCredentialsMessage {

    // Constructor properties interface

    interface ConstructorProperties extends SocketControlMessage.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.UnixCredentialsMessage

        /**
         * The credentials stored in the message.
         */
        credentials?: Credentials | null
    }

}

interface UnixCredentialsMessage {

    // Own properties of Gio-2.0.Gio.UnixCredentialsMessage

    /**
     * The credentials stored in the message.
     */
    readonly credentials: Credentials

    // Own fields of Gio-2.0.Gio.UnixCredentialsMessage

    parent_instance: SocketControlMessage & GObject.Object
    priv: any

    // Owm methods of Gio-2.0.Gio.UnixCredentialsMessage

    /**
     * Gets the credentials stored in `message`.
     * @returns A #GCredentials instance. Do not free, it is owned by @message.
     */
    get_credentials(): Credentials

    // Class property signals of Gio-2.0.Gio.UnixCredentialsMessage

    connect(sigName: "notify::credentials", callback: (($obj: UnixCredentialsMessage, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::credentials", callback: (($obj: UnixCredentialsMessage, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::credentials", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This #GSocketControlMessage contains a #GCredentials instance.  It
 * may be sent using g_socket_send_message() and received using
 * g_socket_receive_message() over UNIX sockets (ie: sockets in the
 * %G_SOCKET_FAMILY_UNIX family).
 * 
 * For an easier way to send and receive credentials over
 * stream-oriented UNIX sockets, see
 * g_unix_connection_send_credentials() and
 * g_unix_connection_receive_credentials(). To receive credentials of
 * a foreign process connected to a socket, use
 * g_socket_get_credentials().
 * 
 * Since GLib 2.72, #GUnixCredentialMessage is available on all platforms. It
 * requires underlying system support (such as Windows 10 with `AF_UNIX`) at run
 * time.
 * 
 * Before GLib 2.72, `<gio/gunixcredentialsmessage.h>` belonged to the UNIX-specific
 * GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
 * when using it. This is no longer necessary since GLib 2.72.
 * @class 
 */
class UnixCredentialsMessage extends SocketControlMessage {

    // Own properties of Gio-2.0.Gio.UnixCredentialsMessage

    static name: string
    static $gtype: GObject.GType<UnixCredentialsMessage>

    // Constructors of Gio-2.0.Gio.UnixCredentialsMessage

    constructor(config?: UnixCredentialsMessage.ConstructorProperties) 
    /**
     * Creates a new #GUnixCredentialsMessage with credentials matching the current processes.
     * @constructor 
     * @returns a new #GUnixCredentialsMessage
     */
    constructor() 
    /**
     * Creates a new #GUnixCredentialsMessage with credentials matching the current processes.
     * @constructor 
     * @returns a new #GUnixCredentialsMessage
     */
    static new(): UnixCredentialsMessage
    /**
     * Creates a new #GUnixCredentialsMessage holding `credentials`.
     * @constructor 
     * @param credentials A #GCredentials object.
     * @returns a new #GUnixCredentialsMessage
     */
    static new_with_credentials(credentials: Credentials): UnixCredentialsMessage
    _init(config?: UnixCredentialsMessage.ConstructorProperties): void
    /**
     * Checks if passing #GCredentials on a #GSocket is supported on this platform.
     * @returns %TRUE if supported, %FALSE otherwise
     */
    static is_supported(): boolean
}

module UnixFDList {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface UnixFDList {

    // Own fields of Gio-2.0.Gio.UnixFDList

    parent_instance: GObject.Object
    priv: UnixFDListPrivate

    // Owm methods of Gio-2.0.Gio.UnixFDList

    /**
     * Adds a file descriptor to `list`.
     * 
     * The file descriptor is duplicated using dup(). You keep your copy
     * of the descriptor and the copy contained in `list` will be closed
     * when `list` is finalized.
     * 
     * A possible cause of failure is exceeding the per-process or
     * system-wide file descriptor limit.
     * 
     * The index of the file descriptor in the list is returned.  If you use
     * this index with g_unix_fd_list_get() then you will receive back a
     * duplicated copy of the same file descriptor.
     * @param fd a valid open file descriptor
     * @returns the index of the appended fd in case of success, else -1          (and @error is set)
     */
    append(fd: number): number
    /**
     * Gets a file descriptor out of `list`.
     * 
     * `index_` specifies the index of the file descriptor to get.  It is a
     * programmer error for `index_` to be out of range; see
     * g_unix_fd_list_get_length().
     * 
     * The file descriptor is duplicated using dup() and set as
     * close-on-exec before being returned.  You must call close() on it
     * when you are done.
     * 
     * A possible cause of failure is exceeding the per-process or
     * system-wide file descriptor limit.
     * @param index_ the index into the list
     * @returns the file descriptor, or -1 in case of error
     */
    get(index_: number): number
    /**
     * Gets the length of `list` (ie: the number of file descriptors
     * contained within).
     * @returns the length of @list
     */
    get_length(): number
    /**
     * Returns the array of file descriptors that is contained in this
     * object.
     * 
     * After this call, the descriptors remain the property of `list`.  The
     * caller must not close them and must not free the array.  The array is
     * valid only until `list` is changed in any way.
     * 
     * If `length` is non-%NULL then it is set to the number of file
     * descriptors in the returned array. The returned array is also
     * terminated with -1.
     * 
     * This function never returns %NULL. In case there are no file
     * descriptors contained in `list,` an empty array is returned.
     * @returns an array of file     descriptors
     */
    peek_fds(): number[]
    /**
     * Returns the array of file descriptors that is contained in this
     * object.
     * 
     * After this call, the descriptors are no longer contained in
     * `list`. Further calls will return an empty list (unless more
     * descriptors have been added).
     * 
     * The return result of this function must be freed with g_free().
     * The caller is also responsible for closing all of the file
     * descriptors.  The file descriptors in the array are set to
     * close-on-exec.
     * 
     * If `length` is non-%NULL then it is set to the number of file
     * descriptors in the returned array. The returned array is also
     * terminated with -1.
     * 
     * This function never returns %NULL. In case there are no file
     * descriptors contained in `list,` an empty array is returned.
     * @returns an array of file     descriptors
     */
    steal_fds(): number[]

    // Class property signals of Gio-2.0.Gio.UnixFDList

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GUnixFDList contains a list of file descriptors.  It owns the file
 * descriptors that it contains, closing them when finalized.
 * 
 * It may be wrapped in a #GUnixFDMessage and sent over a #GSocket in
 * the %G_SOCKET_FAMILY_UNIX family by using g_socket_send_message()
 * and received using g_socket_receive_message().
 * 
 * Before 2.74, `<gio/gunixfdlist.h>` belonged to the UNIX-specific GIO
 * interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file when
 * using it.
 * 
 * Since 2.74, the API is available for Windows.
 * @class 
 */
class UnixFDList extends GObject.Object {

    // Own properties of Gio-2.0.Gio.UnixFDList

    static name: string
    static $gtype: GObject.GType<UnixFDList>

    // Constructors of Gio-2.0.Gio.UnixFDList

    constructor(config?: UnixFDList.ConstructorProperties) 
    /**
     * Creates a new #GUnixFDList containing no file descriptors.
     * @constructor 
     * @returns a new #GUnixFDList
     */
    constructor() 
    /**
     * Creates a new #GUnixFDList containing no file descriptors.
     * @constructor 
     * @returns a new #GUnixFDList
     */
    static new(): UnixFDList
    /**
     * Creates a new #GUnixFDList containing the file descriptors given in
     * `fds`.  The file descriptors become the property of the new list and
     * may no longer be used by the caller.  The array itself is owned by
     * the caller.
     * 
     * Each file descriptor in the array should be set to close-on-exec.
     * 
     * If `n_fds` is -1 then `fds` must be terminated with -1.
     * @constructor 
     * @param fds the initial list of file descriptors
     * @returns a new #GUnixFDList
     */
    static new_from_array(fds: number[]): UnixFDList
    _init(config?: UnixFDList.ConstructorProperties): void
}

module UnixFDMessage {

    // Constructor properties interface

    interface ConstructorProperties extends SocketControlMessage.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.UnixFDMessage

        fd_list?: UnixFDList | null
    }

}

interface UnixFDMessage {

    // Own properties of Gio-2.0.Gio.UnixFDMessage

    readonly fd_list: UnixFDList

    // Own fields of Gio-2.0.Gio.UnixFDMessage

    parent_instance: SocketControlMessage & GObject.Object
    priv: any

    // Owm methods of Gio-2.0.Gio.UnixFDMessage

    /**
     * Adds a file descriptor to `message`.
     * 
     * The file descriptor is duplicated using dup(). You keep your copy
     * of the descriptor and the copy contained in `message` will be closed
     * when `message` is finalized.
     * 
     * A possible cause of failure is exceeding the per-process or
     * system-wide file descriptor limit.
     * @param fd a valid open file descriptor
     * @returns %TRUE in case of success, else %FALSE (and @error is set)
     */
    append_fd(fd: number): boolean
    /**
     * Gets the #GUnixFDList contained in `message`.  This function does not
     * return a reference to the caller, but the returned list is valid for
     * the lifetime of `message`.
     * @returns the #GUnixFDList from @message
     */
    get_fd_list(): UnixFDList
    /**
     * Returns the array of file descriptors that is contained in this
     * object.
     * 
     * After this call, the descriptors are no longer contained in
     * `message`. Further calls will return an empty list (unless more
     * descriptors have been added).
     * 
     * The return result of this function must be freed with g_free().
     * The caller is also responsible for closing all of the file
     * descriptors.
     * 
     * If `length` is non-%NULL then it is set to the number of file
     * descriptors in the returned array. The returned array is also
     * terminated with -1.
     * 
     * This function never returns %NULL. In case there are no file
     * descriptors contained in `message,` an empty array is returned.
     * @returns an array of file     descriptors
     */
    steal_fds(): number[]

    // Class property signals of Gio-2.0.Gio.UnixFDMessage

    connect(sigName: "notify::fd-list", callback: (($obj: UnixFDMessage, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fd-list", callback: (($obj: UnixFDMessage, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::fd-list", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This #GSocketControlMessage contains a #GUnixFDList.
 * It may be sent using g_socket_send_message() and received using
 * g_socket_receive_message() over UNIX sockets (ie: sockets in the
 * %G_SOCKET_FAMILY_UNIX family). The file descriptors are copied
 * between processes by the kernel.
 * 
 * For an easier way to send and receive file descriptors over
 * stream-oriented UNIX sockets, see g_unix_connection_send_fd() and
 * g_unix_connection_receive_fd().
 * 
 * Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
 * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
 * file when using it.
 * @class 
 */
class UnixFDMessage extends SocketControlMessage {

    // Own properties of Gio-2.0.Gio.UnixFDMessage

    static name: string
    static $gtype: GObject.GType<UnixFDMessage>

    // Constructors of Gio-2.0.Gio.UnixFDMessage

    constructor(config?: UnixFDMessage.ConstructorProperties) 
    /**
     * Creates a new #GUnixFDMessage containing an empty file descriptor
     * list.
     * @constructor 
     * @returns a new #GUnixFDMessage
     */
    constructor() 
    /**
     * Creates a new #GUnixFDMessage containing an empty file descriptor
     * list.
     * @constructor 
     * @returns a new #GUnixFDMessage
     */
    static new(): UnixFDMessage
    /**
     * Creates a new #GUnixFDMessage containing `list`.
     * @constructor 
     * @param fd_list a #GUnixFDList
     * @returns a new #GUnixFDMessage
     */
    static new_with_fd_list(fd_list: UnixFDList): UnixFDMessage
    _init(config?: UnixFDMessage.ConstructorProperties): void
}

module UnixInputStream {

    // Constructor properties interface

    interface ConstructorProperties extends FileDescriptorBased.ConstructorProperties, PollableInputStream.ConstructorProperties, InputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.UnixInputStream

        /**
         * Whether to close the file descriptor when the stream is closed.
         */
        close_fd?: boolean | null
        /**
         * The file descriptor that the stream reads from.
         */
        fd?: number | null
    }

}

interface UnixInputStream extends FileDescriptorBased, PollableInputStream {

    // Own properties of Gio-2.0.Gio.UnixInputStream

    /**
     * Whether to close the file descriptor when the stream is closed.
     */
    close_fd: boolean
    /**
     * The file descriptor that the stream reads from.
     */
    readonly fd: number

    // Own fields of Gio-2.0.Gio.UnixInputStream

    parent_instance: InputStream & GObject.Object

    // Owm methods of Gio-2.0.Gio.UnixInputStream

    /**
     * Returns whether the file descriptor of `stream` will be
     * closed when the stream is closed.
     * @returns %TRUE if the file descriptor is closed when done
     */
    get_close_fd(): boolean
    /**
     * Return the UNIX file descriptor that the stream reads from.
     * @returns The file descriptor of @stream
     */
    get_fd(): number
    /**
     * Sets whether the file descriptor of `stream` shall be closed
     * when the stream is closed.
     * @param close_fd %TRUE to close the file descriptor when done
     */
    set_close_fd(close_fd: boolean): void

    // Class property signals of Gio-2.0.Gio.UnixInputStream

    connect(sigName: "notify::close-fd", callback: (($obj: UnixInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-fd", callback: (($obj: UnixInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-fd", ...args: any[]): void
    connect(sigName: "notify::fd", callback: (($obj: UnixInputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fd", callback: (($obj: UnixInputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::fd", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GUnixInputStream implements #GInputStream for reading from a UNIX
 * file descriptor, including asynchronous operations. (If the file
 * descriptor refers to a socket or pipe, this will use poll() to do
 * asynchronous I/O. If it refers to a regular file, it will fall back
 * to doing asynchronous I/O in another thread.)
 * 
 * Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
 * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
 * file when using it.
 * @class 
 */
class UnixInputStream extends InputStream {

    // Own properties of Gio-2.0.Gio.UnixInputStream

    static name: string
    static $gtype: GObject.GType<UnixInputStream>

    // Constructors of Gio-2.0.Gio.UnixInputStream

    constructor(config?: UnixInputStream.ConstructorProperties) 
    /**
     * Creates a new #GUnixInputStream for the given `fd`.
     * 
     * If `close_fd` is %TRUE, the file descriptor will be closed
     * when the stream is closed.
     * @constructor 
     * @param fd a UNIX file descriptor
     * @param close_fd %TRUE to close the file descriptor when done
     * @returns a new #GUnixInputStream
     */
    constructor(fd: number, close_fd: boolean) 
    /**
     * Creates a new #GUnixInputStream for the given `fd`.
     * 
     * If `close_fd` is %TRUE, the file descriptor will be closed
     * when the stream is closed.
     * @constructor 
     * @param fd a UNIX file descriptor
     * @param close_fd %TRUE to close the file descriptor when done
     * @returns a new #GUnixInputStream
     */
    static new(fd: number, close_fd: boolean): UnixInputStream
    _init(config?: UnixInputStream.ConstructorProperties): void
}

module UnixMountMonitor {

    // Signal callback interfaces

    /**
     * Signal callback interface for `mountpoints-changed`
     */
    interface MountpointsChangedSignalCallback {
        ($obj: UnixMountMonitor): void
    }

    /**
     * Signal callback interface for `mounts-changed`
     */
    interface MountsChangedSignalCallback {
        ($obj: UnixMountMonitor): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface UnixMountMonitor {

    // Owm methods of Gio-2.0.Gio.UnixMountMonitor

    /**
     * This function does nothing.
     * 
     * Before 2.44, this was a partially-effective way of controlling the
     * rate at which events would be reported under some uncommon
     * circumstances.  Since `mount_monitor` is a singleton, it also meant
     * that calling this function would have side effects for other users of
     * the monitor.
     * @param limit_msec a integer with the limit in milliseconds to     poll for changes.
     */
    set_rate_limit(limit_msec: number): void

    // Own signals of Gio-2.0.Gio.UnixMountMonitor

    connect(sigName: "mountpoints-changed", callback: UnixMountMonitor.MountpointsChangedSignalCallback): number
    connect_after(sigName: "mountpoints-changed", callback: UnixMountMonitor.MountpointsChangedSignalCallback): number
    emit(sigName: "mountpoints-changed", ...args: any[]): void
    connect(sigName: "mounts-changed", callback: UnixMountMonitor.MountsChangedSignalCallback): number
    connect_after(sigName: "mounts-changed", callback: UnixMountMonitor.MountsChangedSignalCallback): number
    emit(sigName: "mounts-changed", ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.UnixMountMonitor

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Watches #GUnixMounts for changes.
 * @class 
 */
class UnixMountMonitor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.UnixMountMonitor

    static name: string
    static $gtype: GObject.GType<UnixMountMonitor>

    // Constructors of Gio-2.0.Gio.UnixMountMonitor

    constructor(config?: UnixMountMonitor.ConstructorProperties) 
    /**
     * Deprecated alias for g_unix_mount_monitor_get().
     * 
     * This function was never a true constructor, which is why it was
     * renamed.
     * @constructor 
     * @returns a #GUnixMountMonitor.
     */
    constructor() 
    /**
     * Deprecated alias for g_unix_mount_monitor_get().
     * 
     * This function was never a true constructor, which is why it was
     * renamed.
     * @constructor 
     * @returns a #GUnixMountMonitor.
     */
    static new(): UnixMountMonitor
    _init(config?: UnixMountMonitor.ConstructorProperties): void
    /**
     * Gets the #GUnixMountMonitor for the current thread-default main
     * context.
     * 
     * The mount monitor can be used to monitor for changes to the list of
     * mounted filesystems as well as the list of mount points (ie: fstab
     * entries).
     * 
     * You must only call g_object_unref() on the return value from under
     * the same main context as you called this function.
     * @returns the #GUnixMountMonitor.
     */
    static get(): UnixMountMonitor
}

module UnixOutputStream {

    // Constructor properties interface

    interface ConstructorProperties extends FileDescriptorBased.ConstructorProperties, PollableOutputStream.ConstructorProperties, OutputStream.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.UnixOutputStream

        /**
         * Whether to close the file descriptor when the stream is closed.
         */
        close_fd?: boolean | null
        /**
         * The file descriptor that the stream writes to.
         */
        fd?: number | null
    }

}

interface UnixOutputStream extends FileDescriptorBased, PollableOutputStream {

    // Own properties of Gio-2.0.Gio.UnixOutputStream

    /**
     * Whether to close the file descriptor when the stream is closed.
     */
    close_fd: boolean
    /**
     * The file descriptor that the stream writes to.
     */
    readonly fd: number

    // Own fields of Gio-2.0.Gio.UnixOutputStream

    parent_instance: OutputStream & GObject.Object

    // Owm methods of Gio-2.0.Gio.UnixOutputStream

    /**
     * Returns whether the file descriptor of `stream` will be
     * closed when the stream is closed.
     * @returns %TRUE if the file descriptor is closed when done
     */
    get_close_fd(): boolean
    /**
     * Return the UNIX file descriptor that the stream writes to.
     * @returns The file descriptor of @stream
     */
    get_fd(): number
    /**
     * Sets whether the file descriptor of `stream` shall be closed
     * when the stream is closed.
     * @param close_fd %TRUE to close the file descriptor when done
     */
    set_close_fd(close_fd: boolean): void

    // Class property signals of Gio-2.0.Gio.UnixOutputStream

    connect(sigName: "notify::close-fd", callback: (($obj: UnixOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::close-fd", callback: (($obj: UnixOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::close-fd", ...args: any[]): void
    connect(sigName: "notify::fd", callback: (($obj: UnixOutputStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fd", callback: (($obj: UnixOutputStream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::fd", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GUnixOutputStream implements #GOutputStream for writing to a UNIX
 * file descriptor, including asynchronous operations. (If the file
 * descriptor refers to a socket or pipe, this will use poll() to do
 * asynchronous I/O. If it refers to a regular file, it will fall back
 * to doing asynchronous I/O in another thread.)
 * 
 * Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
 * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file
 * when using it.
 * @class 
 */
class UnixOutputStream extends OutputStream {

    // Own properties of Gio-2.0.Gio.UnixOutputStream

    static name: string
    static $gtype: GObject.GType<UnixOutputStream>

    // Constructors of Gio-2.0.Gio.UnixOutputStream

    constructor(config?: UnixOutputStream.ConstructorProperties) 
    /**
     * Creates a new #GUnixOutputStream for the given `fd`.
     * 
     * If `close_fd,` is %TRUE, the file descriptor will be closed when
     * the output stream is destroyed.
     * @constructor 
     * @param fd a UNIX file descriptor
     * @param close_fd %TRUE to close the file descriptor when done
     * @returns a new #GOutputStream
     */
    constructor(fd: number, close_fd: boolean) 
    /**
     * Creates a new #GUnixOutputStream for the given `fd`.
     * 
     * If `close_fd,` is %TRUE, the file descriptor will be closed when
     * the output stream is destroyed.
     * @constructor 
     * @param fd a UNIX file descriptor
     * @param close_fd %TRUE to close the file descriptor when done
     * @returns a new #GOutputStream
     */
    static new(fd: number, close_fd: boolean): UnixOutputStream
    _init(config?: UnixOutputStream.ConstructorProperties): void
}

module UnixSocketAddress {

    // Constructor properties interface

    interface ConstructorProperties extends SocketConnectable.ConstructorProperties, SocketAddress.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.UnixSocketAddress

        /**
         * Whether or not this is an abstract address
         */
        abstract?: boolean | null
        address_type?: UnixSocketAddressType | null
        path?: string | null
        path_as_array?: Uint8Array | null
    }

}

interface UnixSocketAddress extends SocketConnectable {

    // Own properties of Gio-2.0.Gio.UnixSocketAddress

    /**
     * Whether or not this is an abstract address
     */
    readonly abstract: boolean
    readonly address_type: UnixSocketAddressType
    readonly path: string | null
    readonly path_as_array: Uint8Array

    // Own fields of Gio-2.0.Gio.UnixSocketAddress

    parent_instance: SocketAddress & GObject.Object

    // Owm methods of Gio-2.0.Gio.UnixSocketAddress

    /**
     * Gets `address'`s type.
     * @returns a #GUnixSocketAddressType
     */
    get_address_type(): UnixSocketAddressType
    /**
     * Tests if `address` is abstract.
     * @returns %TRUE if the address is abstract, %FALSE otherwise
     */
    get_is_abstract(): boolean
    /**
     * Gets `address'`s path, or for abstract sockets the "name".
     * 
     * Guaranteed to be zero-terminated, but an abstract socket
     * may contain embedded zeros, and thus you should use
     * g_unix_socket_address_get_path_len() to get the true length
     * of this string.
     * @returns the path for @address
     */
    get_path(): string | null
    /**
     * Gets the length of `address'`s path.
     * 
     * For details, see g_unix_socket_address_get_path().
     * @returns the length of the path
     */
    get_path_len(): number

    // Class property signals of Gio-2.0.Gio.UnixSocketAddress

    connect(sigName: "notify::abstract", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::abstract", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::abstract", ...args: any[]): void
    connect(sigName: "notify::address-type", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::address-type", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::address-type", ...args: any[]): void
    connect(sigName: "notify::path", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::path", ...args: any[]): void
    connect(sigName: "notify::path-as-array", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path-as-array", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::path-as-array", ...args: any[]): void
    connect(sigName: "notify::family", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: UnixSocketAddress, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::family", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Support for UNIX-domain (also known as local) sockets.
 * 
 * UNIX domain sockets are generally visible in the filesystem.
 * However, some systems support abstract socket names which are not
 * visible in the filesystem and not affected by the filesystem
 * permissions, visibility, etc. Currently this is only supported
 * under Linux. If you attempt to use abstract sockets on other
 * systems, function calls may return %G_IO_ERROR_NOT_SUPPORTED
 * errors. You can use g_unix_socket_address_abstract_names_supported()
 * to see if abstract names are supported.
 * 
 * Since GLib 2.72, #GUnixSocketAddress is available on all platforms. It
 * requires underlying system support (such as Windows 10 with `AF_UNIX`) at
 * run time.
 * 
 * Before GLib 2.72, `<gio/gunixsocketaddress.h>` belonged to the UNIX-specific
 * GIO interfaces, thus you had to use the `gio-unix-2.0.pc` pkg-config file
 * when using it. This is no longer necessary since GLib 2.72.
 * @class 
 */
class UnixSocketAddress extends SocketAddress {

    // Own properties of Gio-2.0.Gio.UnixSocketAddress

    static name: string
    static $gtype: GObject.GType<UnixSocketAddress>

    // Constructors of Gio-2.0.Gio.UnixSocketAddress

    constructor(config?: UnixSocketAddress.ConstructorProperties) 
    /**
     * Creates a new #GUnixSocketAddress for `path`.
     * 
     * To create abstract socket addresses, on systems that support that,
     * use g_unix_socket_address_new_abstract().
     * @constructor 
     * @param path the socket path
     * @returns a new #GUnixSocketAddress
     */
    constructor(path: string | null) 
    /**
     * Creates a new #GUnixSocketAddress for `path`.
     * 
     * To create abstract socket addresses, on systems that support that,
     * use g_unix_socket_address_new_abstract().
     * @constructor 
     * @param path the socket path
     * @returns a new #GUnixSocketAddress
     */
    static new(path: string | null): UnixSocketAddress
    /**
     * Creates a new %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
     * #GUnixSocketAddress for `path`.
     * @constructor 
     * @param path the abstract name
     * @returns a new #GUnixSocketAddress
     */
    static new_abstract(path: number[]): UnixSocketAddress
    /**
     * Creates a new #GUnixSocketAddress of type `type` with name `path`.
     * 
     * If `type` is %G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to
     * calling g_unix_socket_address_new().
     * 
     * If `type` is %G_UNIX_SOCKET_ADDRESS_ANONYMOUS, `path` and `path_len` will be
     * ignored.
     * 
     * If `path_type` is %G_UNIX_SOCKET_ADDRESS_ABSTRACT, then `path_len`
     * bytes of `path` will be copied to the socket's path, and only those
     * bytes will be considered part of the name. (If `path_len` is -1,
     * then `path` is assumed to be NUL-terminated.) For example, if `path`
     * was "test", then calling g_socket_address_get_native_size() on the
     * returned socket would return 7 (2 bytes of overhead, 1 byte for the
     * abstract-socket indicator byte, and 4 bytes for the name "test").
     * 
     * If `path_type` is %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then
     * `path_len` bytes of `path` will be copied to the socket's path, the
     * rest of the path will be padded with 0 bytes, and the entire
     * zero-padded buffer will be considered the name. (As above, if
     * `path_len` is -1, then `path` is assumed to be NUL-terminated.) In
     * this case, g_socket_address_get_native_size() will always return
     * the full size of a `struct sockaddr_un`, although
     * g_unix_socket_address_get_path_len() will still return just the
     * length of `path`.
     * 
     * %G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over
     * %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course,
     * when connecting to a server created by another process, you must
     * use the appropriate type corresponding to how that process created
     * its listening socket.
     * @constructor 
     * @param path the name
     * @param type a #GUnixSocketAddressType
     * @returns a new #GUnixSocketAddress
     */
    static new_with_type(path: number[], type: UnixSocketAddressType): UnixSocketAddress
    _init(config?: UnixSocketAddress.ConstructorProperties): void
    /**
     * Checks if abstract UNIX domain socket names are supported.
     * @returns %TRUE if supported, %FALSE otherwise
     */
    static abstract_names_supported(): boolean
}

module Vfs {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Vfs {

    // Own fields of Gio-2.0.Gio.Vfs

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.Vfs

    /**
     * Gets a #GFile for `path`.
     * @param path a string containing a VFS path.
     * @returns a #GFile.     Free the returned object with g_object_unref().
     */
    get_file_for_path(path: string | null): File
    /**
     * Gets a #GFile for `uri`.
     * 
     * This operation never fails, but the returned object
     * might not support any I/O operation if the URI
     * is malformed or if the URI scheme is not supported.
     * @param uri a string containing a URI
     * @returns a #GFile.     Free the returned object with g_object_unref().
     */
    get_file_for_uri(uri: string | null): File
    /**
     * Gets a list of URI schemes supported by `vfs`.
     * @returns a %NULL-terminated array of strings.     The returned array belongs to GIO and must     not be freed or modified.
     */
    get_supported_uri_schemes(): string[]
    /**
     * Checks if the VFS is active.
     * @returns %TRUE if construction of the @vfs was successful     and it is now active.
     */
    is_active(): boolean
    /**
     * This operation never fails, but the returned object might
     * not support any I/O operations if the `parse_name` cannot
     * be parsed by the #GVfs module.
     * @param parse_name a string to be parsed by the VFS module.
     * @returns a #GFile for the given @parse_name.     Free the returned object with g_object_unref().
     */
    parse_name(parse_name: string | null): File
    /**
     * Registers `uri_func` and `parse_name_func` as the #GFile URI and parse name
     * lookup functions for URIs with a scheme matching `scheme`.
     * Note that `scheme` is registered only within the running application, as
     * opposed to desktop-wide as it happens with GVfs backends.
     * 
     * When a #GFile is requested with an URI containing `scheme` (e.g. through
     * g_file_new_for_uri()), `uri_func` will be called to allow a custom
     * constructor. The implementation of `uri_func` should not be blocking, and
     * must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
     * 
     * When g_file_parse_name() is called with a parse name obtained from such file,
     * `parse_name_func` will be called to allow the #GFile to be created again. In
     * that case, it's responsibility of `parse_name_func` to make sure the parse
     * name matches what the custom #GFile implementation returned when
     * g_file_get_parse_name() was previously called. The implementation of
     * `parse_name_func` should not be blocking, and must not call
     * g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
     * 
     * It's an error to call this function twice with the same scheme. To unregister
     * a custom URI scheme, use g_vfs_unregister_uri_scheme().
     * @param scheme an URI scheme, e.g. "http"
     * @param uri_func a #GVfsFileLookupFunc
     * @param parse_name_func a #GVfsFileLookupFunc
     * @returns %TRUE if @scheme was successfully registered, or %FALSE if a handler     for @scheme already exists.
     */
    register_uri_scheme(scheme: string | null, uri_func: VfsFileLookupFunc | null, parse_name_func: VfsFileLookupFunc | null): boolean
    /**
     * Unregisters the URI handler for `scheme` previously registered with
     * g_vfs_register_uri_scheme().
     * @param scheme an URI scheme, e.g. "http"
     * @returns %TRUE if @scheme was successfully unregistered, or %FALSE if a     handler for @scheme does not exist.
     */
    unregister_uri_scheme(scheme: string | null): boolean

    // Own virtual methods of Gio-2.0.Gio.Vfs

    vfunc_add_writable_namespaces(list: FileAttributeInfoList): void
    /**
     * Gets a #GFile for `path`.
     * @virtual 
     * @param path a string containing a VFS path.
     * @returns a #GFile.     Free the returned object with g_object_unref().
     */
    vfunc_get_file_for_path(path: string | null): File
    /**
     * Gets a #GFile for `uri`.
     * 
     * This operation never fails, but the returned object
     * might not support any I/O operation if the URI
     * is malformed or if the URI scheme is not supported.
     * @virtual 
     * @param uri a string containing a URI
     * @returns a #GFile.     Free the returned object with g_object_unref().
     */
    vfunc_get_file_for_uri(uri: string | null): File
    /**
     * Gets a list of URI schemes supported by `vfs`.
     * @virtual 
     * @returns a %NULL-terminated array of strings.     The returned array belongs to GIO and must     not be freed or modified.
     */
    vfunc_get_supported_uri_schemes(): string[]
    /**
     * Checks if the VFS is active.
     * @virtual 
     * @returns %TRUE if construction of the @vfs was successful     and it is now active.
     */
    vfunc_is_active(): boolean
    vfunc_local_file_add_info(filename: string | null, device: number, attribute_matcher: FileAttributeMatcher, info: FileInfo, cancellable: Cancellable | null, extra_data: any | null, free_extra_data: GLib.DestroyNotify): void
    vfunc_local_file_moved(source: string | null, dest: string | null): void
    vfunc_local_file_removed(filename: string | null): void
    vfunc_local_file_set_attributes(filename: string | null, info: FileInfo, flags: FileQueryInfoFlags, cancellable: Cancellable | null): boolean
    /**
     * This operation never fails, but the returned object might
     * not support any I/O operations if the `parse_name` cannot
     * be parsed by the #GVfs module.
     * @virtual 
     * @param parse_name a string to be parsed by the VFS module.
     * @returns a #GFile for the given @parse_name.     Free the returned object with g_object_unref().
     */
    vfunc_parse_name(parse_name: string | null): File

    // Class property signals of Gio-2.0.Gio.Vfs

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Entry point for using GIO functionality.
 * @class 
 */
class Vfs extends GObject.Object {

    // Own properties of Gio-2.0.Gio.Vfs

    static name: string
    static $gtype: GObject.GType<Vfs>

    // Constructors of Gio-2.0.Gio.Vfs

    constructor(config?: Vfs.ConstructorProperties) 
    _init(config?: Vfs.ConstructorProperties): void
    /**
     * Gets the default #GVfs for the system.
     * @returns a #GVfs, which will be the local     file system #GVfs if no other implementation is available.
     */
    static get_default(): Vfs
    /**
     * Gets the local #GVfs for the system.
     * @returns a #GVfs.
     */
    static get_local(): Vfs
}

module VolumeMonitor {

    // Signal callback interfaces

    /**
     * Signal callback interface for `drive-changed`
     */
    interface DriveChangedSignalCallback {
        ($obj: VolumeMonitor, drive: Drive): void
    }

    /**
     * Signal callback interface for `drive-connected`
     */
    interface DriveConnectedSignalCallback {
        ($obj: VolumeMonitor, drive: Drive): void
    }

    /**
     * Signal callback interface for `drive-disconnected`
     */
    interface DriveDisconnectedSignalCallback {
        ($obj: VolumeMonitor, drive: Drive): void
    }

    /**
     * Signal callback interface for `drive-eject-button`
     */
    interface DriveEjectButtonSignalCallback {
        ($obj: VolumeMonitor, drive: Drive): void
    }

    /**
     * Signal callback interface for `drive-stop-button`
     */
    interface DriveStopButtonSignalCallback {
        ($obj: VolumeMonitor, drive: Drive): void
    }

    /**
     * Signal callback interface for `mount-added`
     */
    interface MountAddedSignalCallback {
        ($obj: VolumeMonitor, mount: Mount): void
    }

    /**
     * Signal callback interface for `mount-changed`
     */
    interface MountChangedSignalCallback {
        ($obj: VolumeMonitor, mount: Mount): void
    }

    /**
     * Signal callback interface for `mount-pre-unmount`
     */
    interface MountPreUnmountSignalCallback {
        ($obj: VolumeMonitor, mount: Mount): void
    }

    /**
     * Signal callback interface for `mount-removed`
     */
    interface MountRemovedSignalCallback {
        ($obj: VolumeMonitor, mount: Mount): void
    }

    /**
     * Signal callback interface for `volume-added`
     */
    interface VolumeAddedSignalCallback {
        ($obj: VolumeMonitor, volume: Volume): void
    }

    /**
     * Signal callback interface for `volume-changed`
     */
    interface VolumeChangedSignalCallback {
        ($obj: VolumeMonitor, volume: Volume): void
    }

    /**
     * Signal callback interface for `volume-removed`
     */
    interface VolumeRemovedSignalCallback {
        ($obj: VolumeMonitor, volume: Volume): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface VolumeMonitor {

    // Own fields of Gio-2.0.Gio.VolumeMonitor

    parent_instance: GObject.Object

    // Owm methods of Gio-2.0.Gio.VolumeMonitor

    /**
     * Gets a list of drives connected to the system.
     * 
     * The returned list should be freed with g_list_free(), after
     * its elements have been unreffed with g_object_unref().
     * @returns a #GList of connected #GDrive objects.
     */
    get_connected_drives(): Drive[]
    /**
     * Finds a #GMount object by its UUID (see g_mount_get_uuid())
     * @param uuid the UUID to look for
     * @returns a #GMount or %NULL if no such mount is available.     Free the returned object with g_object_unref().
     */
    get_mount_for_uuid(uuid: string | null): Mount | null
    /**
     * Gets a list of the mounts on the system.
     * 
     * The returned list should be freed with g_list_free(), after
     * its elements have been unreffed with g_object_unref().
     * @returns a #GList of #GMount objects.
     */
    get_mounts(): Mount[]
    /**
     * Finds a #GVolume object by its UUID (see g_volume_get_uuid())
     * @param uuid the UUID to look for
     * @returns a #GVolume or %NULL if no such volume is available.     Free the returned object with g_object_unref().
     */
    get_volume_for_uuid(uuid: string | null): Volume | null
    /**
     * Gets a list of the volumes on the system.
     * 
     * The returned list should be freed with g_list_free(), after
     * its elements have been unreffed with g_object_unref().
     * @returns a #GList of #GVolume objects.
     */
    get_volumes(): Volume[]

    // Own virtual methods of Gio-2.0.Gio.VolumeMonitor

    vfunc_drive_changed(drive: Drive): void
    vfunc_drive_connected(drive: Drive): void
    vfunc_drive_disconnected(drive: Drive): void
    vfunc_drive_eject_button(drive: Drive): void
    vfunc_drive_stop_button(drive: Drive): void
    /**
     * Gets a list of drives connected to the system.
     * 
     * The returned list should be freed with g_list_free(), after
     * its elements have been unreffed with g_object_unref().
     * @virtual 
     * @returns a #GList of connected #GDrive objects.
     */
    vfunc_get_connected_drives(): Drive[]
    /**
     * Finds a #GMount object by its UUID (see g_mount_get_uuid())
     * @virtual 
     * @param uuid the UUID to look for
     * @returns a #GMount or %NULL if no such mount is available.     Free the returned object with g_object_unref().
     */
    vfunc_get_mount_for_uuid(uuid: string | null): Mount | null
    /**
     * Gets a list of the mounts on the system.
     * 
     * The returned list should be freed with g_list_free(), after
     * its elements have been unreffed with g_object_unref().
     * @virtual 
     * @returns a #GList of #GMount objects.
     */
    vfunc_get_mounts(): Mount[]
    /**
     * Finds a #GVolume object by its UUID (see g_volume_get_uuid())
     * @virtual 
     * @param uuid the UUID to look for
     * @returns a #GVolume or %NULL if no such volume is available.     Free the returned object with g_object_unref().
     */
    vfunc_get_volume_for_uuid(uuid: string | null): Volume | null
    /**
     * Gets a list of the volumes on the system.
     * 
     * The returned list should be freed with g_list_free(), after
     * its elements have been unreffed with g_object_unref().
     * @virtual 
     * @returns a #GList of #GVolume objects.
     */
    vfunc_get_volumes(): Volume[]
    vfunc_mount_added(mount: Mount): void
    vfunc_mount_changed(mount: Mount): void
    vfunc_mount_pre_unmount(mount: Mount): void
    vfunc_mount_removed(mount: Mount): void
    vfunc_volume_added(volume: Volume): void
    vfunc_volume_changed(volume: Volume): void
    vfunc_volume_removed(volume: Volume): void

    // Own signals of Gio-2.0.Gio.VolumeMonitor

    connect(sigName: "drive-changed", callback: VolumeMonitor.DriveChangedSignalCallback): number
    connect_after(sigName: "drive-changed", callback: VolumeMonitor.DriveChangedSignalCallback): number
    emit(sigName: "drive-changed", drive: Drive, ...args: any[]): void
    connect(sigName: "drive-connected", callback: VolumeMonitor.DriveConnectedSignalCallback): number
    connect_after(sigName: "drive-connected", callback: VolumeMonitor.DriveConnectedSignalCallback): number
    emit(sigName: "drive-connected", drive: Drive, ...args: any[]): void
    connect(sigName: "drive-disconnected", callback: VolumeMonitor.DriveDisconnectedSignalCallback): number
    connect_after(sigName: "drive-disconnected", callback: VolumeMonitor.DriveDisconnectedSignalCallback): number
    emit(sigName: "drive-disconnected", drive: Drive, ...args: any[]): void
    connect(sigName: "drive-eject-button", callback: VolumeMonitor.DriveEjectButtonSignalCallback): number
    connect_after(sigName: "drive-eject-button", callback: VolumeMonitor.DriveEjectButtonSignalCallback): number
    emit(sigName: "drive-eject-button", drive: Drive, ...args: any[]): void
    connect(sigName: "drive-stop-button", callback: VolumeMonitor.DriveStopButtonSignalCallback): number
    connect_after(sigName: "drive-stop-button", callback: VolumeMonitor.DriveStopButtonSignalCallback): number
    emit(sigName: "drive-stop-button", drive: Drive, ...args: any[]): void
    connect(sigName: "mount-added", callback: VolumeMonitor.MountAddedSignalCallback): number
    connect_after(sigName: "mount-added", callback: VolumeMonitor.MountAddedSignalCallback): number
    emit(sigName: "mount-added", mount: Mount, ...args: any[]): void
    connect(sigName: "mount-changed", callback: VolumeMonitor.MountChangedSignalCallback): number
    connect_after(sigName: "mount-changed", callback: VolumeMonitor.MountChangedSignalCallback): number
    emit(sigName: "mount-changed", mount: Mount, ...args: any[]): void
    connect(sigName: "mount-pre-unmount", callback: VolumeMonitor.MountPreUnmountSignalCallback): number
    connect_after(sigName: "mount-pre-unmount", callback: VolumeMonitor.MountPreUnmountSignalCallback): number
    emit(sigName: "mount-pre-unmount", mount: Mount, ...args: any[]): void
    connect(sigName: "mount-removed", callback: VolumeMonitor.MountRemovedSignalCallback): number
    connect_after(sigName: "mount-removed", callback: VolumeMonitor.MountRemovedSignalCallback): number
    emit(sigName: "mount-removed", mount: Mount, ...args: any[]): void
    connect(sigName: "volume-added", callback: VolumeMonitor.VolumeAddedSignalCallback): number
    connect_after(sigName: "volume-added", callback: VolumeMonitor.VolumeAddedSignalCallback): number
    emit(sigName: "volume-added", volume: Volume, ...args: any[]): void
    connect(sigName: "volume-changed", callback: VolumeMonitor.VolumeChangedSignalCallback): number
    connect_after(sigName: "volume-changed", callback: VolumeMonitor.VolumeChangedSignalCallback): number
    emit(sigName: "volume-changed", volume: Volume, ...args: any[]): void
    connect(sigName: "volume-removed", callback: VolumeMonitor.VolumeRemovedSignalCallback): number
    connect_after(sigName: "volume-removed", callback: VolumeMonitor.VolumeRemovedSignalCallback): number
    emit(sigName: "volume-removed", volume: Volume, ...args: any[]): void

    // Class property signals of Gio-2.0.Gio.VolumeMonitor

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GVolumeMonitor is for listing the user interesting devices and volumes
 * on the computer. In other words, what a file selector or file manager
 * would show in a sidebar.
 * 
 * #GVolumeMonitor is not
 * [thread-default-context aware][g-main-context-push-thread-default],
 * and so should not be used other than from the main thread, with no
 * thread-default-context active.
 * 
 * In order to receive updates about volumes and mounts monitored through GVFS,
 * a main loop must be running.
 * @class 
 */
class VolumeMonitor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.VolumeMonitor

    static name: string
    static $gtype: GObject.GType<VolumeMonitor>

    // Constructors of Gio-2.0.Gio.VolumeMonitor

    constructor(config?: VolumeMonitor.ConstructorProperties) 
    _init(config?: VolumeMonitor.ConstructorProperties): void
    /**
     * This function should be called by any #GVolumeMonitor
     * implementation when a new #GMount object is created that is not
     * associated with a #GVolume object. It must be called just before
     * emitting the `mount_added` signal.
     * 
     * If the return value is not %NULL, the caller must associate the
     * returned #GVolume object with the #GMount. This involves returning
     * it in its g_mount_get_volume() implementation. The caller must
     * also listen for the "removed" signal on the returned object
     * and give up its reference when handling that signal
     * 
     * Similarly, if implementing g_volume_monitor_adopt_orphan_mount(),
     * the implementor must take a reference to `mount` and return it in
     * its g_volume_get_mount() implemented. Also, the implementor must
     * listen for the "unmounted" signal on `mount` and give up its
     * reference upon handling that signal.
     * 
     * There are two main use cases for this function.
     * 
     * One is when implementing a user space file system driver that reads
     * blocks of a block device that is already represented by the native
     * volume monitor (for example a CD Audio file system driver). Such
     * a driver will generate its own #GMount object that needs to be
     * associated with the #GVolume object that represents the volume.
     * 
     * The other is for implementing a #GVolumeMonitor whose sole purpose
     * is to return #GVolume objects representing entries in the users
     * "favorite servers" list or similar.
     * @param mount a #GMount object to find a parent for
     * @returns the #GVolume object that is the parent for @mount or %NULL if no wants to adopt the #GMount.
     */
    static adopt_orphan_mount(mount: Mount): Volume
    /**
     * Gets the volume monitor used by gio.
     * @returns a reference to the #GVolumeMonitor used by gio. Call    g_object_unref() when done with it.
     */
    static get(): VolumeMonitor
}

module ZlibCompressor {

    // Constructor properties interface

    interface ConstructorProperties extends Converter.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ZlibCompressor

        /**
         * If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
         * %G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
         * and modification time from the file info to the GZIP header.
         */
        file_info?: FileInfo | null
        format?: ZlibCompressorFormat | null
        level?: number | null
    }

}

interface ZlibCompressor extends Converter {

    // Own properties of Gio-2.0.Gio.ZlibCompressor

    /**
     * If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
     * %G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
     * and modification time from the file info to the GZIP header.
     */
    file_info: FileInfo
    readonly format: ZlibCompressorFormat
    readonly level: number

    // Owm methods of Gio-2.0.Gio.ZlibCompressor

    /**
     * Returns the #GZlibCompressor:file-info property.
     * @returns a #GFileInfo, or %NULL
     */
    get_file_info(): FileInfo | null
    /**
     * Sets `file_info` in `compressor`. If non-%NULL, and `compressor'`s
     * #GZlibCompressor:format property is %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
     * it will be used to set the file name and modification time in
     * the GZIP header of the compressed data.
     * 
     * Note: it is an error to call this function while a compression is in
     * progress; it may only be called immediately after creation of `compressor,`
     * or after resetting it with g_converter_reset().
     * @param file_info a #GFileInfo
     */
    set_file_info(file_info: FileInfo | null): void

    // Class property signals of Gio-2.0.Gio.ZlibCompressor

    connect(sigName: "notify::file-info", callback: (($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::file-info", callback: (($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::file-info", ...args: any[]): void
    connect(sigName: "notify::format", callback: (($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::format", callback: (($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::format", ...args: any[]): void
    connect(sigName: "notify::level", callback: (($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::level", callback: (($obj: ZlibCompressor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::level", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GZlibCompressor is an implementation of #GConverter that
 * compresses data using zlib.
 * @class 
 */
class ZlibCompressor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ZlibCompressor

    static name: string
    static $gtype: GObject.GType<ZlibCompressor>

    // Constructors of Gio-2.0.Gio.ZlibCompressor

    constructor(config?: ZlibCompressor.ConstructorProperties) 
    /**
     * Creates a new #GZlibCompressor.
     * @constructor 
     * @param format The format to use for the compressed data
     * @param level compression level (0-9), -1 for default
     * @returns a new #GZlibCompressor
     */
    constructor(format: ZlibCompressorFormat, level: number) 
    /**
     * Creates a new #GZlibCompressor.
     * @constructor 
     * @param format The format to use for the compressed data
     * @param level compression level (0-9), -1 for default
     * @returns a new #GZlibCompressor
     */
    static new(format: ZlibCompressorFormat, level: number): ZlibCompressor
    _init(config?: ZlibCompressor.ConstructorProperties): void
}

module ZlibDecompressor {

    // Constructor properties interface

    interface ConstructorProperties extends Converter.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gio-2.0.Gio.ZlibDecompressor

        format?: ZlibCompressorFormat | null
    }

}

interface ZlibDecompressor extends Converter {

    // Own properties of Gio-2.0.Gio.ZlibDecompressor

    /**
     * A #GFileInfo containing the information found in the GZIP header
     * of the data stream processed, or %NULL if the header was not yet
     * fully processed, is not present at all, or the compressor's
     * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP.
     */
    readonly file_info: FileInfo
    readonly format: ZlibCompressorFormat

    // Owm methods of Gio-2.0.Gio.ZlibDecompressor

    /**
     * Retrieves the #GFileInfo constructed from the GZIP header data
     * of compressed data processed by `compressor,` or %NULL if `decompressor'`s
     * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
     * or the header data was not fully processed yet, or it not present in the
     * data stream at all.
     * @returns a #GFileInfo, or %NULL
     */
    get_file_info(): FileInfo | null

    // Class property signals of Gio-2.0.Gio.ZlibDecompressor

    connect(sigName: "notify::file-info", callback: (($obj: ZlibDecompressor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::file-info", callback: (($obj: ZlibDecompressor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::file-info", ...args: any[]): void
    connect(sigName: "notify::format", callback: (($obj: ZlibDecompressor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::format", callback: (($obj: ZlibDecompressor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::format", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * #GZlibDecompressor is an implementation of #GConverter that
 * decompresses data compressed with zlib.
 * @class 
 */
class ZlibDecompressor extends GObject.Object {

    // Own properties of Gio-2.0.Gio.ZlibDecompressor

    static name: string
    static $gtype: GObject.GType<ZlibDecompressor>

    // Constructors of Gio-2.0.Gio.ZlibDecompressor

    constructor(config?: ZlibDecompressor.ConstructorProperties) 
    /**
     * Creates a new #GZlibDecompressor.
     * @constructor 
     * @param format The format to use for the compressed data
     * @returns a new #GZlibDecompressor
     */
    constructor(format: ZlibCompressorFormat) 
    /**
     * Creates a new #GZlibDecompressor.
     * @constructor 
     * @param format The format to use for the compressed data
     * @returns a new #GZlibDecompressor
     */
    static new(format: ZlibCompressorFormat): ZlibDecompressor
    _init(config?: ZlibDecompressor.ConstructorProperties): void
}

interface ActionEntry {

    // Own fields of Gio-2.0.Gio.ActionEntry

    /**
     * the name of the action
     * @field 
     */
    name: string | null
    activate: (action: SimpleAction, parameter: GLib.Variant) => void
    /**
     * the type of the parameter that must be passed to the
     *                  activate function for this action, given as a single
     *                  GVariant type string (or %NULL for no parameter)
     * @field 
     */
    parameter_type: string | null
    /**
     * the initial state for this action, given in
     *         [GVariant text format][gvariant-text].  The state is parsed
     *         with no extra type information, so type tags must be added to
     *         the string if they are necessary.  Stateless actions should
     *         give %NULL here.
     * @field 
     */
    state: string | null
    change_state: (action: SimpleAction, value: GLib.Variant) => void
}

/**
 * This struct defines a single action.  It is for use with
 * g_action_map_add_action_entries().
 * 
 * The order of the items in the structure are intended to reflect
 * frequency of use.  It is permissible to use an incomplete initialiser
 * in order to leave some of the later values as %NULL.  All values
 * after `name` are optional.  Additional optional fields may be added in
 * the future.
 * 
 * See g_action_map_add_action_entries() for an example.
 * @record 
 */
class ActionEntry {

    // Own properties of Gio-2.0.Gio.ActionEntry

    static name: string
}

interface ActionGroupInterface {

    // Own fields of Gio-2.0.Gio.ActionGroupInterface

    g_iface: GObject.TypeInterface
    has_action: (action_group: ActionGroup, action_name: string | null) => boolean
    list_actions: (action_group: ActionGroup) => string[]
    get_action_enabled: (action_group: ActionGroup, action_name: string | null) => boolean
    get_action_parameter_type: (action_group: ActionGroup, action_name: string | null) => GLib.VariantType | null
    get_action_state_type: (action_group: ActionGroup, action_name: string | null) => GLib.VariantType | null
    get_action_state_hint: (action_group: ActionGroup, action_name: string | null) => GLib.Variant | null
    get_action_state: (action_group: ActionGroup, action_name: string | null) => GLib.Variant | null
    change_action_state: (action_group: ActionGroup, action_name: string | null, value: GLib.Variant) => void
    activate_action: (action_group: ActionGroup, action_name: string | null, parameter: GLib.Variant | null) => void
    action_added: (action_group: ActionGroup, action_name: string | null) => void
    action_removed: (action_group: ActionGroup, action_name: string | null) => void
    action_enabled_changed: (action_group: ActionGroup, action_name: string | null, enabled: boolean) => void
    action_state_changed: (action_group: ActionGroup, action_name: string | null, state: GLib.Variant) => void
    query_action: (action_group: ActionGroup, action_name: string | null) => [ /* returnType */ boolean, /* enabled */ boolean, /* parameter_type */ GLib.VariantType, /* state_type */ GLib.VariantType, /* state_hint */ GLib.Variant, /* state */ GLib.Variant ]
}

/**
 * The virtual function table for #GActionGroup.
 * @record 
 */
abstract class ActionGroupInterface {

    // Own properties of Gio-2.0.Gio.ActionGroupInterface

    static name: string
}

interface ActionInterface {

    // Own fields of Gio-2.0.Gio.ActionInterface

    g_iface: GObject.TypeInterface
    get_name: (action: Action) => string | null
    get_parameter_type: (action: Action) => GLib.VariantType | null
    get_state_type: (action: Action) => GLib.VariantType | null
    get_state_hint: (action: Action) => GLib.Variant | null
    get_enabled: (action: Action) => boolean
    get_state: (action: Action) => GLib.Variant | null
    change_state: (action: Action, value: GLib.Variant) => void
    activate: (action: Action, parameter: GLib.Variant | null) => void
}

/**
 * The virtual function table for #GAction.
 * @record 
 */
abstract class ActionInterface {

    // Own properties of Gio-2.0.Gio.ActionInterface

    static name: string
}

interface ActionMapInterface {

    // Own fields of Gio-2.0.Gio.ActionMapInterface

    g_iface: GObject.TypeInterface
    lookup_action: (action_map: ActionMap, action_name: string | null) => Action | null
    add_action: (action_map: ActionMap, action: Action) => void
    remove_action: (action_map: ActionMap, action_name: string | null) => void
}

/**
 * The virtual function table for #GActionMap.
 * @record 
 */
abstract class ActionMapInterface {

    // Own properties of Gio-2.0.Gio.ActionMapInterface

    static name: string
}

interface AppInfoIface {

    // Own fields of Gio-2.0.Gio.AppInfoIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    dup: (appinfo: AppInfo) => AppInfo
    equal: (appinfo1: AppInfo, appinfo2: AppInfo) => boolean
    get_id: (appinfo: AppInfo) => string | null
    get_name: (appinfo: AppInfo) => string | null
    get_description: (appinfo: AppInfo) => string | null
    get_executable: (appinfo: AppInfo) => string
    get_icon: (appinfo: AppInfo) => Icon | null
    launch: (appinfo: AppInfo, files: File[] | null, context: AppLaunchContext | null) => boolean
    supports_uris: (appinfo: AppInfo) => boolean
    supports_files: (appinfo: AppInfo) => boolean
    launch_uris: (appinfo: AppInfo, uris: string[] | null, context: AppLaunchContext | null) => boolean
    should_show: (appinfo: AppInfo) => boolean
    set_as_default_for_type: (appinfo: AppInfo, content_type: string | null) => boolean
    set_as_default_for_extension: (appinfo: AppInfo, extension: string) => boolean
    add_supports_type: (appinfo: AppInfo, content_type: string | null) => boolean
    can_remove_supports_type: (appinfo: AppInfo) => boolean
    remove_supports_type: (appinfo: AppInfo, content_type: string | null) => boolean
    can_delete: (appinfo: AppInfo) => boolean
    do_delete: (appinfo: AppInfo) => boolean
    get_commandline: (appinfo: AppInfo) => string | null
    get_display_name: (appinfo: AppInfo) => string | null
    set_as_last_used_for_type: (appinfo: AppInfo, content_type: string | null) => boolean
    get_supported_types: (appinfo: AppInfo) => string[]
    launch_uris_async: (appinfo: AppInfo, uris: string[] | null, context: AppLaunchContext | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    launch_uris_finish: (appinfo: AppInfo, result: AsyncResult) => boolean
}

/**
 * Application Information interface, for operating system portability.
 * @record 
 */
abstract class AppInfoIface {

    // Own properties of Gio-2.0.Gio.AppInfoIface

    static name: string
}

interface AppLaunchContextClass {

    // Own fields of Gio-2.0.Gio.AppLaunchContextClass

    parent_class: GObject.ObjectClass
    get_display: (context: AppLaunchContext, info: AppInfo, files: File[]) => string | null
    get_startup_notify_id: (context: AppLaunchContext, info: AppInfo, files: File[]) => string | null
    launch_failed: (context: AppLaunchContext, startup_notify_id: string | null) => void
    launched: (context: AppLaunchContext, info: AppInfo, platform_data: GLib.Variant) => void
    launch_started: (context: AppLaunchContext, info: AppInfo, platform_data: GLib.Variant) => void
}

abstract class AppLaunchContextClass {

    // Own properties of Gio-2.0.Gio.AppLaunchContextClass

    static name: string
}

interface AppLaunchContextPrivate {
}

class AppLaunchContextPrivate {

    // Own properties of Gio-2.0.Gio.AppLaunchContextPrivate

    static name: string
}

interface ApplicationClass {

    // Own fields of Gio-2.0.Gio.ApplicationClass

    startup: (application: Application) => void
    activate: (application: Application) => void
    open: (application: Application, files: File[], hint: string | null) => void
    command_line: (application: Application, command_line: ApplicationCommandLine) => number
    local_command_line: (application: Application, arguments_: string[]) => [ /* returnType */ boolean, /* arguments_ */ string[], /* exit_status */ number ]
    before_emit: (application: Application, platform_data: GLib.Variant) => void
    after_emit: (application: Application, platform_data: GLib.Variant) => void
    add_platform_data: (application: Application, builder: GLib.VariantBuilder) => void
    quit_mainloop: (application: Application) => void
    run_mainloop: (application: Application) => void
    shutdown: (application: Application) => void
    dbus_register: (application: Application, connection: DBusConnection, object_path: string | null) => boolean
    dbus_unregister: (application: Application, connection: DBusConnection, object_path: string | null) => void
    handle_local_options: (application: Application, options: GLib.VariantDict) => number
    name_lost: (application: Application) => boolean
}

/**
 * Virtual function table for #GApplication.
 * @record 
 */
abstract class ApplicationClass {

    // Own properties of Gio-2.0.Gio.ApplicationClass

    static name: string
}

interface ApplicationCommandLineClass {

    // Own fields of Gio-2.0.Gio.ApplicationCommandLineClass

    print_literal: (cmdline: ApplicationCommandLine, message: string | null) => void
    printerr_literal: (cmdline: ApplicationCommandLine, message: string | null) => void
    get_stdin: (cmdline: ApplicationCommandLine) => InputStream | null
}

/**
 * The #GApplicationCommandLineClass-struct
 * contains private data only.
 * @record 
 */
abstract class ApplicationCommandLineClass {

    // Own properties of Gio-2.0.Gio.ApplicationCommandLineClass

    static name: string
}

interface ApplicationCommandLinePrivate {
}

class ApplicationCommandLinePrivate {

    // Own properties of Gio-2.0.Gio.ApplicationCommandLinePrivate

    static name: string
}

interface ApplicationPrivate {
}

class ApplicationPrivate {

    // Own properties of Gio-2.0.Gio.ApplicationPrivate

    static name: string
}

interface AsyncInitableIface {

    // Own fields of Gio-2.0.Gio.AsyncInitableIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    init_async: (initable: AsyncInitable, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    init_finish: (initable: AsyncInitable, res: AsyncResult) => boolean
}

/**
 * Provides an interface for asynchronous initializing object such that
 * initialization may fail.
 * @record 
 */
abstract class AsyncInitableIface {

    // Own properties of Gio-2.0.Gio.AsyncInitableIface

    static name: string
}

interface AsyncResultIface {

    // Own fields of Gio-2.0.Gio.AsyncResultIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    get_user_data: (res: AsyncResult) => any | null
    get_source_object: (res: AsyncResult) => GObject.Object | null
    is_tagged: (res: AsyncResult, source_tag: any | null) => boolean
}

/**
 * Interface definition for #GAsyncResult.
 * @record 
 */
abstract class AsyncResultIface {

    // Own properties of Gio-2.0.Gio.AsyncResultIface

    static name: string
}

interface BufferedInputStreamClass {

    // Own fields of Gio-2.0.Gio.BufferedInputStreamClass

    parent_class: FilterInputStreamClass
    fill: (stream: BufferedInputStream, count: number, cancellable: Cancellable | null) => number
    fill_async: (stream: BufferedInputStream, count: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    fill_finish: (stream: BufferedInputStream, result: AsyncResult) => number
}

abstract class BufferedInputStreamClass {

    // Own properties of Gio-2.0.Gio.BufferedInputStreamClass

    static name: string
}

interface BufferedInputStreamPrivate {
}

class BufferedInputStreamPrivate {

    // Own properties of Gio-2.0.Gio.BufferedInputStreamPrivate

    static name: string
}

interface BufferedOutputStreamClass {

    // Own fields of Gio-2.0.Gio.BufferedOutputStreamClass

    parent_class: FilterOutputStreamClass
}

abstract class BufferedOutputStreamClass {

    // Own properties of Gio-2.0.Gio.BufferedOutputStreamClass

    static name: string
}

interface BufferedOutputStreamPrivate {
}

class BufferedOutputStreamPrivate {

    // Own properties of Gio-2.0.Gio.BufferedOutputStreamPrivate

    static name: string
}

interface CancellableClass {

    // Own fields of Gio-2.0.Gio.CancellableClass

    parent_class: GObject.ObjectClass
    cancelled: (cancellable: Cancellable | null) => void
}

abstract class CancellableClass {

    // Own properties of Gio-2.0.Gio.CancellableClass

    static name: string
}

interface CancellablePrivate {
}

class CancellablePrivate {

    // Own properties of Gio-2.0.Gio.CancellablePrivate

    static name: string
}

interface CharsetConverterClass {

    // Own fields of Gio-2.0.Gio.CharsetConverterClass

    parent_class: GObject.ObjectClass
}

abstract class CharsetConverterClass {

    // Own properties of Gio-2.0.Gio.CharsetConverterClass

    static name: string
}

interface ConverterIface {

    // Own fields of Gio-2.0.Gio.ConverterIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    convert: (converter: Converter, inbuf: Uint8Array | null, outbuf: Uint8Array, flags: ConverterFlags) => [ /* returnType */ ConverterResult, /* bytes_read */ number, /* bytes_written */ number ]
    reset: (converter: Converter) => void
}

/**
 * Provides an interface for converting data from one type
 * to another type. The conversion can be stateful
 * and may fail at any place.
 * @record 
 */
abstract class ConverterIface {

    // Own properties of Gio-2.0.Gio.ConverterIface

    static name: string
}

interface ConverterInputStreamClass {

    // Own fields of Gio-2.0.Gio.ConverterInputStreamClass

    parent_class: FilterInputStreamClass
}

abstract class ConverterInputStreamClass {

    // Own properties of Gio-2.0.Gio.ConverterInputStreamClass

    static name: string
}

interface ConverterInputStreamPrivate {
}

class ConverterInputStreamPrivate {

    // Own properties of Gio-2.0.Gio.ConverterInputStreamPrivate

    static name: string
}

interface ConverterOutputStreamClass {

    // Own fields of Gio-2.0.Gio.ConverterOutputStreamClass

    parent_class: FilterOutputStreamClass
}

abstract class ConverterOutputStreamClass {

    // Own properties of Gio-2.0.Gio.ConverterOutputStreamClass

    static name: string
}

interface ConverterOutputStreamPrivate {
}

class ConverterOutputStreamPrivate {

    // Own properties of Gio-2.0.Gio.ConverterOutputStreamPrivate

    static name: string
}

interface CredentialsClass {
}

/**
 * Class structure for #GCredentials.
 * @record 
 */
abstract class CredentialsClass {

    // Own properties of Gio-2.0.Gio.CredentialsClass

    static name: string
}

interface DBusAnnotationInfo {

    // Own fields of Gio-2.0.Gio.DBusAnnotationInfo

    /**
     * The reference count or -1 if statically allocated.
     * @field 
     */
    ref_count: number
    /**
     * The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
     * @field 
     */
    key: string | null
    /**
     * The value of the annotation.
     * @field 
     */
    value: string | null
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
     * @field 
     */
    annotations: DBusAnnotationInfo[]

    // Owm methods of Gio-2.0.Gio.DBusAnnotationInfo

    /**
     * If `info` is statically allocated does nothing. Otherwise increases
     * the reference count.
     * @returns The same @info.
     */
    ref(): DBusAnnotationInfo
    /**
     * If `info` is statically allocated, does nothing. Otherwise decreases
     * the reference count of `info`. When its reference count drops to 0,
     * the memory used is freed.
     */
    unref(): void
}

/**
 * Information about an annotation.
 * @record 
 */
class DBusAnnotationInfo {

    // Own properties of Gio-2.0.Gio.DBusAnnotationInfo

    static name: string

    // Constructors of Gio-2.0.Gio.DBusAnnotationInfo

    /**
     * Looks up the value of an annotation.
     * 
     * The cost of this function is O(n) in number of annotations.
     * @param annotations A %NULL-terminated array of annotations or %NULL.
     * @param name The name of the annotation to look up.
     * @returns The value or %NULL if not found. Do not free, it is owned by @annotations.
     */
    static lookup(annotations: DBusAnnotationInfo[] | null, name: string | null): string | null
}

interface DBusArgInfo {

    // Own fields of Gio-2.0.Gio.DBusArgInfo

    /**
     * The reference count or -1 if statically allocated.
     * @field 
     */
    ref_count: number
    /**
     * Name of the argument, e.g. `unix_user_id`.
     * @field 
     */
    name: string | null
    /**
     * D-Bus signature of the argument (a single complete type).
     * @field 
     */
    signature: string | null
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
     * @field 
     */
    annotations: DBusAnnotationInfo[]

    // Owm methods of Gio-2.0.Gio.DBusArgInfo

    /**
     * If `info` is statically allocated does nothing. Otherwise increases
     * the reference count.
     * @returns The same @info.
     */
    ref(): DBusArgInfo
    /**
     * If `info` is statically allocated, does nothing. Otherwise decreases
     * the reference count of `info`. When its reference count drops to 0,
     * the memory used is freed.
     */
    unref(): void
}

/**
 * Information about an argument for a method or a signal.
 * @record 
 */
class DBusArgInfo {

    // Own properties of Gio-2.0.Gio.DBusArgInfo

    static name: string
}

interface DBusErrorEntry {

    // Own fields of Gio-2.0.Gio.DBusErrorEntry

    /**
     * An error code.
     * @field 
     */
    error_code: number
    /**
     * The D-Bus error name to associate with `error_code`.
     * @field 
     */
    dbus_error_name: string | null
}

/**
 * Struct used in g_dbus_error_register_error_domain().
 * @record 
 */
class DBusErrorEntry {

    // Own properties of Gio-2.0.Gio.DBusErrorEntry

    static name: string
}

interface DBusInterfaceIface {

    // Own fields of Gio-2.0.Gio.DBusInterfaceIface

    /**
     * The parent interface.
     * @field 
     */
    parent_iface: GObject.TypeInterface
    get_info: (interface_: DBusInterface) => DBusInterfaceInfo
    get_object: (interface_: DBusInterface) => DBusObject | null
    set_object: (interface_: DBusInterface, object: DBusObject | null) => void
    dup_object: (interface_: DBusInterface) => DBusObject | null
}

/**
 * Base type for D-Bus interfaces.
 * @record 
 */
abstract class DBusInterfaceIface {

    // Own properties of Gio-2.0.Gio.DBusInterfaceIface

    static name: string
}

interface DBusInterfaceInfo {

    // Own fields of Gio-2.0.Gio.DBusInterfaceInfo

    /**
     * The reference count or -1 if statically allocated.
     * @field 
     */
    ref_count: number
    /**
     * The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
     * @field 
     */
    name: string | null
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.
     * @field 
     */
    methods: DBusMethodInfo[]
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.
     * @field 
     */
    signals: DBusSignalInfo[]
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.
     * @field 
     */
    properties: DBusPropertyInfo[]
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
     * @field 
     */
    annotations: DBusAnnotationInfo[]

    // Owm methods of Gio-2.0.Gio.DBusInterfaceInfo

    /**
     * Builds a lookup-cache to speed up
     * g_dbus_interface_info_lookup_method(),
     * g_dbus_interface_info_lookup_signal() and
     * g_dbus_interface_info_lookup_property().
     * 
     * If this has already been called with `info,` the existing cache is
     * used and its use count is increased.
     * 
     * Note that `info` cannot be modified until
     * g_dbus_interface_info_cache_release() is called.
     */
    cache_build(): void
    /**
     * Decrements the usage count for the cache for `info` built by
     * g_dbus_interface_info_cache_build() (if any) and frees the
     * resources used by the cache if the usage count drops to zero.
     */
    cache_release(): void
    /**
     * Appends an XML representation of `info` (and its children) to `string_builder`.
     * 
     * This function is typically used for generating introspection XML
     * documents at run-time for handling the
     * `org.freedesktop.DBus.Introspectable.Introspect`
     * method.
     * @param indent Indentation level.
     * @param string_builder A #GString to to append XML data to.
     */
    generate_xml(indent: number, string_builder: GLib.String): void
    /**
     * Looks up information about a method.
     * 
     * The cost of this function is O(n) in number of methods unless
     * g_dbus_interface_info_cache_build() has been used on `info`.
     * @param name A D-Bus method name (typically in CamelCase)
     * @returns A #GDBusMethodInfo or %NULL if not found. Do not free, it is owned by @info.
     */
    lookup_method(name: string | null): DBusMethodInfo | null
    /**
     * Looks up information about a property.
     * 
     * The cost of this function is O(n) in number of properties unless
     * g_dbus_interface_info_cache_build() has been used on `info`.
     * @param name A D-Bus property name (typically in CamelCase).
     * @returns A #GDBusPropertyInfo or %NULL if not found. Do not free, it is owned by @info.
     */
    lookup_property(name: string | null): DBusPropertyInfo | null
    /**
     * Looks up information about a signal.
     * 
     * The cost of this function is O(n) in number of signals unless
     * g_dbus_interface_info_cache_build() has been used on `info`.
     * @param name A D-Bus signal name (typically in CamelCase)
     * @returns A #GDBusSignalInfo or %NULL if not found. Do not free, it is owned by @info.
     */
    lookup_signal(name: string | null): DBusSignalInfo | null
    /**
     * If `info` is statically allocated does nothing. Otherwise increases
     * the reference count.
     * @returns The same @info.
     */
    ref(): DBusInterfaceInfo
    /**
     * If `info` is statically allocated, does nothing. Otherwise decreases
     * the reference count of `info`. When its reference count drops to 0,
     * the memory used is freed.
     */
    unref(): void
}

/**
 * Information about a D-Bus interface.
 * @record 
 */
class DBusInterfaceInfo {

    // Own properties of Gio-2.0.Gio.DBusInterfaceInfo

    static name: string
}

interface DBusInterfaceSkeletonClass {

    // Own fields of Gio-2.0.Gio.DBusInterfaceSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parent_class: GObject.ObjectClass
    get_info: (interface_: DBusInterfaceSkeleton) => DBusInterfaceInfo
    get_properties: (interface_: DBusInterfaceSkeleton) => GLib.Variant
    flush: (interface_: DBusInterfaceSkeleton) => void
    g_authorize_method: (interface_: DBusInterfaceSkeleton, invocation: DBusMethodInvocation) => boolean
}

/**
 * Class structure for #GDBusInterfaceSkeleton.
 * @record 
 */
abstract class DBusInterfaceSkeletonClass {

    // Own properties of Gio-2.0.Gio.DBusInterfaceSkeletonClass

    static name: string
}

interface DBusInterfaceSkeletonPrivate {
}

class DBusInterfaceSkeletonPrivate {

    // Own properties of Gio-2.0.Gio.DBusInterfaceSkeletonPrivate

    static name: string
}

interface DBusInterfaceVTable {

    // Own fields of Gio-2.0.Gio.DBusInterfaceVTable

    /**
     * Function for handling incoming method calls.
     * @field 
     */
    method_call: DBusInterfaceMethodCallFunc
    /**
     * Function for getting a property.
     * @field 
     */
    get_property: DBusInterfaceGetPropertyFunc
    /**
     * Function for setting a property.
     * @field 
     */
    set_property: DBusInterfaceSetPropertyFunc
}

/**
 * Virtual table for handling properties and method calls for a D-Bus
 * interface.
 * 
 * Since 2.38, if you want to handle getting/setting D-Bus properties
 * asynchronously, give %NULL as your get_property() or set_property()
 * function. The D-Bus call will be directed to your `method_call` function,
 * with the provided `interface_name` set to "org.freedesktop.DBus.Properties".
 * 
 * Ownership of the #GDBusMethodInvocation object passed to the
 * method_call() function is transferred to your handler; you must
 * call one of the methods of #GDBusMethodInvocation to return a reply
 * (possibly empty), or an error. These functions also take ownership
 * of the passed-in invocation object, so unless the invocation
 * object has otherwise been referenced, it will be then be freed.
 * Calling one of these functions may be done within your
 * method_call() implementation but it also can be done at a later
 * point to handle the method asynchronously.
 * 
 * The usual checks on the validity of the calls is performed. For
 * `Get` calls, an error is automatically returned if the property does
 * not exist or the permissions do not allow access. The same checks are
 * performed for `Set` calls, and the provided value is also checked for
 * being the correct type.
 * 
 * For both `Get` and `Set` calls, the #GDBusMethodInvocation
 * passed to the `method_call` handler can be queried with
 * g_dbus_method_invocation_get_property_info() to get a pointer
 * to the #GDBusPropertyInfo of the property.
 * 
 * If you have readable properties specified in your interface info,
 * you must ensure that you either provide a non-%NULL `get_property(`)
 * function or provide implementations of both the `Get` and `GetAll`
 * methods on org.freedesktop.DBus.Properties interface in your `method_call`
 * function. Note that the required return type of the `Get` call is
 * `(v)`, not the type of the property. `GetAll` expects a return value
 * of type `a{sv}`.
 * 
 * If you have writable properties specified in your interface info,
 * you must ensure that you either provide a non-%NULL `set_property(`)
 * function or provide an implementation of the `Set` call. If implementing
 * the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
 * @record 
 */
class DBusInterfaceVTable {

    // Own properties of Gio-2.0.Gio.DBusInterfaceVTable

    static name: string
}

interface DBusMethodInfo {

    // Own fields of Gio-2.0.Gio.DBusMethodInfo

    /**
     * The reference count or -1 if statically allocated.
     * @field 
     */
    ref_count: number
    /**
     * The name of the D-Bus method, e.g. `RequestName`.
     * @field 
     */
    name: string | null
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.
     * @field 
     */
    in_args: DBusArgInfo[]
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.
     * @field 
     */
    out_args: DBusArgInfo[]
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
     * @field 
     */
    annotations: DBusAnnotationInfo[]

    // Owm methods of Gio-2.0.Gio.DBusMethodInfo

    /**
     * If `info` is statically allocated does nothing. Otherwise increases
     * the reference count.
     * @returns The same @info.
     */
    ref(): DBusMethodInfo
    /**
     * If `info` is statically allocated, does nothing. Otherwise decreases
     * the reference count of `info`. When its reference count drops to 0,
     * the memory used is freed.
     */
    unref(): void
}

/**
 * Information about a method on an D-Bus interface.
 * @record 
 */
class DBusMethodInfo {

    // Own properties of Gio-2.0.Gio.DBusMethodInfo

    static name: string
}

interface DBusNodeInfo {

    // Own fields of Gio-2.0.Gio.DBusNodeInfo

    /**
     * The reference count or -1 if statically allocated.
     * @field 
     */
    ref_count: number
    /**
     * The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
     * @field 
     */
    path: string | null
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.
     * @field 
     */
    interfaces: DBusInterfaceInfo[]
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.
     * @field 
     */
    nodes: DBusNodeInfo[]
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
     * @field 
     */
    annotations: DBusAnnotationInfo[]

    // Owm methods of Gio-2.0.Gio.DBusNodeInfo

    /**
     * Appends an XML representation of `info` (and its children) to `string_builder`.
     * 
     * This function is typically used for generating introspection XML documents at run-time for
     * handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.
     * @param indent Indentation level.
     * @param string_builder A #GString to to append XML data to.
     */
    generate_xml(indent: number, string_builder: GLib.String): void
    /**
     * Looks up information about an interface.
     * 
     * The cost of this function is O(n) in number of interfaces.
     * @param name A D-Bus interface name.
     * @returns A #GDBusInterfaceInfo or %NULL if not found. Do not free, it is owned by @info.
     */
    lookup_interface(name: string | null): DBusInterfaceInfo | null
    /**
     * If `info` is statically allocated does nothing. Otherwise increases
     * the reference count.
     * @returns The same @info.
     */
    ref(): DBusNodeInfo
    /**
     * If `info` is statically allocated, does nothing. Otherwise decreases
     * the reference count of `info`. When its reference count drops to 0,
     * the memory used is freed.
     */
    unref(): void
}

/**
 * Information about nodes in a remote object hierarchy.
 * @record 
 */
class DBusNodeInfo {

    // Own properties of Gio-2.0.Gio.DBusNodeInfo

    static name: string

    // Constructors of Gio-2.0.Gio.DBusNodeInfo

    /**
     * Parses `xml_data` and returns a #GDBusNodeInfo representing the data.
     * 
     * The introspection XML must contain exactly one top-level
     * <node> element.
     * 
     * Note that this routine is using a
     * [GMarkup][glib-Simple-XML-Subset-Parser.description]-based
     * parser that only accepts a subset of valid XML documents.
     * @constructor 
     * @param xml_data Valid D-Bus introspection XML.
     * @returns A #GDBusNodeInfo structure or %NULL if @error is set. Free with g_dbus_node_info_unref().
     */
    static new_for_xml(xml_data: string | null): DBusNodeInfo
}

interface DBusObjectIface {

    // Own fields of Gio-2.0.Gio.DBusObjectIface

    /**
     * The parent interface.
     * @field 
     */
    parent_iface: GObject.TypeInterface
    get_object_path: (object: DBusObject) => string | null
    get_interfaces: (object: DBusObject) => DBusInterface[]
    get_interface: (object: DBusObject, interface_name: string | null) => DBusInterface | null
    interface_added: (object: DBusObject, interface_: DBusInterface) => void
    interface_removed: (object: DBusObject, interface_: DBusInterface) => void
}

/**
 * Base object type for D-Bus objects.
 * @record 
 */
abstract class DBusObjectIface {

    // Own properties of Gio-2.0.Gio.DBusObjectIface

    static name: string
}

interface DBusObjectManagerClientClass {

    // Own fields of Gio-2.0.Gio.DBusObjectManagerClientClass

    /**
     * The parent class.
     * @field 
     */
    parent_class: GObject.ObjectClass
    interface_proxy_signal: (manager: DBusObjectManagerClient, object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, sender_name: string | null, signal_name: string | null, parameters: GLib.Variant) => void
    interface_proxy_properties_changed: (manager: DBusObjectManagerClient, object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, changed_properties: GLib.Variant, invalidated_properties: string | null) => void
}

/**
 * Class structure for #GDBusObjectManagerClient.
 * @record 
 */
abstract class DBusObjectManagerClientClass {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerClientClass

    static name: string
}

interface DBusObjectManagerClientPrivate {
}

class DBusObjectManagerClientPrivate {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerClientPrivate

    static name: string
}

interface DBusObjectManagerIface {

    // Own fields of Gio-2.0.Gio.DBusObjectManagerIface

    /**
     * The parent interface.
     * @field 
     */
    parent_iface: GObject.TypeInterface
    get_object_path: (manager: DBusObjectManager) => string | null
    get_objects: (manager: DBusObjectManager) => DBusObject[]
    get_object: (manager: DBusObjectManager, object_path: string | null) => DBusObject | null
    get_interface: (manager: DBusObjectManager, object_path: string | null, interface_name: string | null) => DBusInterface | null
    object_added: (manager: DBusObjectManager, object: DBusObject) => void
    object_removed: (manager: DBusObjectManager, object: DBusObject) => void
    interface_added: (manager: DBusObjectManager, object: DBusObject, interface_: DBusInterface) => void
    interface_removed: (manager: DBusObjectManager, object: DBusObject, interface_: DBusInterface) => void
}

/**
 * Base type for D-Bus object managers.
 * @record 
 */
abstract class DBusObjectManagerIface {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerIface

    static name: string
}

interface DBusObjectManagerServerClass {

    // Own fields of Gio-2.0.Gio.DBusObjectManagerServerClass

    /**
     * The parent class.
     * @field 
     */
    parent_class: GObject.ObjectClass
}

/**
 * Class structure for #GDBusObjectManagerServer.
 * @record 
 */
abstract class DBusObjectManagerServerClass {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerServerClass

    static name: string
}

interface DBusObjectManagerServerPrivate {
}

class DBusObjectManagerServerPrivate {

    // Own properties of Gio-2.0.Gio.DBusObjectManagerServerPrivate

    static name: string
}

interface DBusObjectProxyClass {

    // Own fields of Gio-2.0.Gio.DBusObjectProxyClass

    /**
     * The parent class.
     * @field 
     */
    parent_class: GObject.ObjectClass
}

/**
 * Class structure for #GDBusObjectProxy.
 * @record 
 */
abstract class DBusObjectProxyClass {

    // Own properties of Gio-2.0.Gio.DBusObjectProxyClass

    static name: string
}

interface DBusObjectProxyPrivate {
}

class DBusObjectProxyPrivate {

    // Own properties of Gio-2.0.Gio.DBusObjectProxyPrivate

    static name: string
}

interface DBusObjectSkeletonClass {

    // Own fields of Gio-2.0.Gio.DBusObjectSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parent_class: GObject.ObjectClass
    authorize_method: (object: DBusObjectSkeleton, interface_: DBusInterfaceSkeleton, invocation: DBusMethodInvocation) => boolean
}

/**
 * Class structure for #GDBusObjectSkeleton.
 * @record 
 */
abstract class DBusObjectSkeletonClass {

    // Own properties of Gio-2.0.Gio.DBusObjectSkeletonClass

    static name: string
}

interface DBusObjectSkeletonPrivate {
}

class DBusObjectSkeletonPrivate {

    // Own properties of Gio-2.0.Gio.DBusObjectSkeletonPrivate

    static name: string
}

interface DBusPropertyInfo {

    // Own fields of Gio-2.0.Gio.DBusPropertyInfo

    /**
     * The reference count or -1 if statically allocated.
     * @field 
     */
    ref_count: number
    /**
     * The name of the D-Bus property, e.g. "SupportedFilesystems".
     * @field 
     */
    name: string | null
    /**
     * The D-Bus signature of the property (a single complete type).
     * @field 
     */
    signature: string | null
    /**
     * Access control flags for the property.
     * @field 
     */
    flags: DBusPropertyInfoFlags
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
     * @field 
     */
    annotations: DBusAnnotationInfo[]

    // Owm methods of Gio-2.0.Gio.DBusPropertyInfo

    /**
     * If `info` is statically allocated does nothing. Otherwise increases
     * the reference count.
     * @returns The same @info.
     */
    ref(): DBusPropertyInfo
    /**
     * If `info` is statically allocated, does nothing. Otherwise decreases
     * the reference count of `info`. When its reference count drops to 0,
     * the memory used is freed.
     */
    unref(): void
}

/**
 * Information about a D-Bus property on a D-Bus interface.
 * @record 
 */
class DBusPropertyInfo {

    // Own properties of Gio-2.0.Gio.DBusPropertyInfo

    static name: string
}

interface DBusProxyClass {

    // Own fields of Gio-2.0.Gio.DBusProxyClass

    g_properties_changed: (proxy: DBusProxy, changed_properties: GLib.Variant, invalidated_properties: string | null) => void
    g_signal: (proxy: DBusProxy, sender_name: string | null, signal_name: string | null, parameters: GLib.Variant) => void
}

/**
 * Class structure for #GDBusProxy.
 * @record 
 */
abstract class DBusProxyClass {

    // Own properties of Gio-2.0.Gio.DBusProxyClass

    static name: string
}

interface DBusProxyPrivate {
}

class DBusProxyPrivate {

    // Own properties of Gio-2.0.Gio.DBusProxyPrivate

    static name: string
}

interface DBusSignalInfo {

    // Own fields of Gio-2.0.Gio.DBusSignalInfo

    /**
     * The reference count or -1 if statically allocated.
     * @field 
     */
    ref_count: number
    /**
     * The name of the D-Bus signal, e.g. "NameOwnerChanged".
     * @field 
     */
    name: string | null
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.
     * @field 
     */
    args: DBusArgInfo[]
    /**
     * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
     * @field 
     */
    annotations: DBusAnnotationInfo[]

    // Owm methods of Gio-2.0.Gio.DBusSignalInfo

    /**
     * If `info` is statically allocated does nothing. Otherwise increases
     * the reference count.
     * @returns The same @info.
     */
    ref(): DBusSignalInfo
    /**
     * If `info` is statically allocated, does nothing. Otherwise decreases
     * the reference count of `info`. When its reference count drops to 0,
     * the memory used is freed.
     */
    unref(): void
}

/**
 * Information about a signal on a D-Bus interface.
 * @record 
 */
class DBusSignalInfo {

    // Own properties of Gio-2.0.Gio.DBusSignalInfo

    static name: string
}

interface DBusSubtreeVTable {

    // Own fields of Gio-2.0.Gio.DBusSubtreeVTable

    /**
     * Function for enumerating child nodes.
     * @field 
     */
    enumerate: DBusSubtreeEnumerateFunc
    /**
     * Function for introspecting a child node.
     * @field 
     */
    introspect: DBusSubtreeIntrospectFunc
    /**
     * Function for dispatching a remote call on a child node.
     * @field 
     */
    dispatch: DBusSubtreeDispatchFunc
}

/**
 * Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().
 * @record 
 */
class DBusSubtreeVTable {

    // Own properties of Gio-2.0.Gio.DBusSubtreeVTable

    static name: string
}

interface DataInputStreamClass {

    // Own fields of Gio-2.0.Gio.DataInputStreamClass

    parent_class: BufferedInputStreamClass
}

abstract class DataInputStreamClass {

    // Own properties of Gio-2.0.Gio.DataInputStreamClass

    static name: string
}

interface DataInputStreamPrivate {
}

class DataInputStreamPrivate {

    // Own properties of Gio-2.0.Gio.DataInputStreamPrivate

    static name: string
}

interface DataOutputStreamClass {

    // Own fields of Gio-2.0.Gio.DataOutputStreamClass

    parent_class: FilterOutputStreamClass
}

abstract class DataOutputStreamClass {

    // Own properties of Gio-2.0.Gio.DataOutputStreamClass

    static name: string
}

interface DataOutputStreamPrivate {
}

class DataOutputStreamPrivate {

    // Own properties of Gio-2.0.Gio.DataOutputStreamPrivate

    static name: string
}

interface DatagramBasedInterface {

    // Own fields of Gio-2.0.Gio.DatagramBasedInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    receive_messages: (datagram_based: DatagramBased, messages: InputMessage[], flags: number, timeout: number, cancellable: Cancellable | null) => number
    send_messages: (datagram_based: DatagramBased, messages: OutputMessage[], flags: number, timeout: number, cancellable: Cancellable | null) => number
    create_source: (datagram_based: DatagramBased, condition: GLib.IOCondition, cancellable: Cancellable | null) => GLib.Source
    condition_check: (datagram_based: DatagramBased, condition: GLib.IOCondition) => GLib.IOCondition
    condition_wait: (datagram_based: DatagramBased, condition: GLib.IOCondition, timeout: number, cancellable: Cancellable | null) => boolean
}

/**
 * Provides an interface for socket-like objects which have datagram semantics,
 * following the Berkeley sockets API. The interface methods are thin wrappers
 * around the corresponding virtual methods, and no pre-processing of inputs is
 * implemented — so implementations of this API must handle all functionality
 * documented in the interface methods.
 * @record 
 */
abstract class DatagramBasedInterface {

    // Own properties of Gio-2.0.Gio.DatagramBasedInterface

    static name: string
}

interface DebugControllerDBusClass {

    // Own fields of Gio-2.0.Gio.DebugControllerDBusClass

    /**
     * The parent class.
     * @field 
     */
    parent_class: GObject.ObjectClass
    authorize: (controller: DebugControllerDBus, invocation: DBusMethodInvocation) => boolean
    padding: any[]
}

/**
 * The virtual function table for #GDebugControllerDBus.
 * @record 
 */
abstract class DebugControllerDBusClass {

    // Own properties of Gio-2.0.Gio.DebugControllerDBusClass

    static name: string
}

interface DebugControllerInterface {
}

/**
 * The virtual function table for #GDebugController.
 * @record 
 */
abstract class DebugControllerInterface {

    // Own properties of Gio-2.0.Gio.DebugControllerInterface

    static name: string
}

interface DesktopAppInfoClass {

    // Own fields of Gio-2.0.Gio.DesktopAppInfoClass

    parent_class: GObject.ObjectClass
}

abstract class DesktopAppInfoClass {

    // Own properties of Gio-2.0.Gio.DesktopAppInfoClass

    static name: string
}

interface DesktopAppInfoLookupIface {

    // Own fields of Gio-2.0.Gio.DesktopAppInfoLookupIface

    g_iface: GObject.TypeInterface
    get_default_for_uri_scheme: (lookup: DesktopAppInfoLookup, uri_scheme: string | null) => AppInfo | null
}

/**
 * Interface that is used by backends to associate default
 * handlers with URI schemes.
 * @record 
 */
abstract class DesktopAppInfoLookupIface {

    // Own properties of Gio-2.0.Gio.DesktopAppInfoLookupIface

    static name: string
}

interface DriveIface {

    // Own fields of Gio-2.0.Gio.DriveIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    changed: (drive: Drive) => void
    disconnected: (drive: Drive) => void
    eject_button: (drive: Drive) => void
    get_name: (drive: Drive) => string | null
    get_icon: (drive: Drive) => Icon
    has_volumes: (drive: Drive) => boolean
    get_volumes: (drive: Drive) => Volume[]
    is_media_removable: (drive: Drive) => boolean
    has_media: (drive: Drive) => boolean
    is_media_check_automatic: (drive: Drive) => boolean
    can_eject: (drive: Drive) => boolean
    can_poll_for_media: (drive: Drive) => boolean
    eject: (drive: Drive, flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    eject_finish: (drive: Drive, result: AsyncResult) => boolean
    poll_for_media: (drive: Drive, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    poll_for_media_finish: (drive: Drive, result: AsyncResult) => boolean
    get_identifier: (drive: Drive, kind: string | null) => string | null
    enumerate_identifiers: (drive: Drive) => string[]
    get_start_stop_type: (drive: Drive) => DriveStartStopType
    can_start: (drive: Drive) => boolean
    can_start_degraded: (drive: Drive) => boolean
    start: (drive: Drive, flags: DriveStartFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    start_finish: (drive: Drive, result: AsyncResult) => boolean
    can_stop: (drive: Drive) => boolean
    stop: (drive: Drive, flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    stop_finish: (drive: Drive, result: AsyncResult) => boolean
    stop_button: (drive: Drive) => void
    eject_with_operation: (drive: Drive, flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    eject_with_operation_finish: (drive: Drive, result: AsyncResult) => boolean
    get_sort_key: (drive: Drive) => string | null
    get_symbolic_icon: (drive: Drive) => Icon
    is_removable: (drive: Drive) => boolean
}

/**
 * Interface for creating #GDrive implementations.
 * @record 
 */
abstract class DriveIface {

    // Own properties of Gio-2.0.Gio.DriveIface

    static name: string
}

interface DtlsClientConnectionInterface {

    // Own fields of Gio-2.0.Gio.DtlsClientConnectionInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
}

/**
 * vtable for a #GDtlsClientConnection implementation.
 * @record 
 */
abstract class DtlsClientConnectionInterface {

    // Own properties of Gio-2.0.Gio.DtlsClientConnectionInterface

    static name: string
}

interface DtlsConnectionInterface {

    // Own fields of Gio-2.0.Gio.DtlsConnectionInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    accept_certificate: (connection: DtlsConnection, peer_cert: TlsCertificate, errors: TlsCertificateFlags) => boolean
    handshake: (conn: DtlsConnection, cancellable: Cancellable | null) => boolean
    handshake_async: (conn: DtlsConnection, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    handshake_finish: (conn: DtlsConnection, result: AsyncResult) => boolean
    shutdown: (conn: DtlsConnection, shutdown_read: boolean, shutdown_write: boolean, cancellable: Cancellable | null) => boolean
    shutdown_async: (conn: DtlsConnection, shutdown_read: boolean, shutdown_write: boolean, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    shutdown_finish: (conn: DtlsConnection, result: AsyncResult) => boolean
    set_advertised_protocols: (conn: DtlsConnection, protocols: string[] | null) => void
    get_negotiated_protocol: (conn: DtlsConnection) => string | null
    get_binding_data: (conn: DtlsConnection, type: TlsChannelBindingType, data: Uint8Array) => boolean
}

/**
 * Virtual method table for a #GDtlsConnection implementation.
 * @record 
 */
abstract class DtlsConnectionInterface {

    // Own properties of Gio-2.0.Gio.DtlsConnectionInterface

    static name: string
}

interface DtlsServerConnectionInterface {

    // Own fields of Gio-2.0.Gio.DtlsServerConnectionInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
}

/**
 * vtable for a #GDtlsServerConnection implementation.
 * @record 
 */
abstract class DtlsServerConnectionInterface {

    // Own properties of Gio-2.0.Gio.DtlsServerConnectionInterface

    static name: string
}

interface EmblemClass {
}

abstract class EmblemClass {

    // Own properties of Gio-2.0.Gio.EmblemClass

    static name: string
}

interface EmblemedIconClass {

    // Own fields of Gio-2.0.Gio.EmblemedIconClass

    parent_class: GObject.ObjectClass
}

abstract class EmblemedIconClass {

    // Own properties of Gio-2.0.Gio.EmblemedIconClass

    static name: string
}

interface EmblemedIconPrivate {
}

class EmblemedIconPrivate {

    // Own properties of Gio-2.0.Gio.EmblemedIconPrivate

    static name: string
}

interface FileAttributeInfo {

    // Own fields of Gio-2.0.Gio.FileAttributeInfo

    /**
     * the name of the attribute.
     * @field 
     */
    name: string | null
    /**
     * the #GFileAttributeType type of the attribute.
     * @field 
     */
    type: FileAttributeType
    /**
     * a set of #GFileAttributeInfoFlags.
     * @field 
     */
    flags: FileAttributeInfoFlags
}

/**
 * Information about a specific attribute.
 * @record 
 */
class FileAttributeInfo {

    // Own properties of Gio-2.0.Gio.FileAttributeInfo

    static name: string
}

interface FileAttributeInfoList {

    // Own fields of Gio-2.0.Gio.FileAttributeInfoList

    /**
     * an array of #GFileAttributeInfos.
     * @field 
     */
    infos: FileAttributeInfo
    /**
     * the number of values in the array.
     * @field 
     */
    n_infos: number

    // Owm methods of Gio-2.0.Gio.FileAttributeInfoList

    /**
     * Adds a new attribute with `name` to the `list,` setting
     * its `type` and `flags`.
     * @param name the name of the attribute to add.
     * @param type the #GFileAttributeType for the attribute.
     * @param flags #GFileAttributeInfoFlags for the attribute.
     */
    add(name: string | null, type: FileAttributeType, flags: FileAttributeInfoFlags): void
    /**
     * Makes a duplicate of a file attribute info list.
     * @returns a copy of the given @list.
     */
    dup(): FileAttributeInfoList
    /**
     * Gets the file attribute with the name `name` from `list`.
     * @param name the name of the attribute to look up.
     * @returns a #GFileAttributeInfo for the @name, or %NULL if an attribute isn't found.
     */
    lookup(name: string | null): FileAttributeInfo
    /**
     * References a file attribute info list.
     * @returns #GFileAttributeInfoList or %NULL on error.
     */
    ref(): FileAttributeInfoList
    /**
     * Removes a reference from the given `list`. If the reference count
     * falls to zero, the `list` is deleted.
     */
    unref(): void
}

/**
 * Acts as a lightweight registry for possible valid file attributes.
 * The registry stores Key-Value pair formats as #GFileAttributeInfos.
 * @record 
 */
class FileAttributeInfoList {

    // Own properties of Gio-2.0.Gio.FileAttributeInfoList

    static name: string

    // Constructors of Gio-2.0.Gio.FileAttributeInfoList

    /**
     * Creates a new file attribute info list.
     * @constructor 
     * @returns a #GFileAttributeInfoList.
     */
    constructor() 
    /**
     * Creates a new file attribute info list.
     * @constructor 
     * @returns a #GFileAttributeInfoList.
     */
    static new(): FileAttributeInfoList
}

interface FileAttributeMatcher {

    // Owm methods of Gio-2.0.Gio.FileAttributeMatcher

    /**
     * Checks if the matcher will match all of the keys in a given namespace.
     * This will always return %TRUE if a wildcard character is in use (e.g. if
     * matcher was created with "standard::*" and `ns` is "standard", or if matcher was created
     * using "*" and namespace is anything.)
     * 
     * TODO: this is awkwardly worded.
     * @param ns a string containing a file attribute namespace.
     * @returns %TRUE if the matcher matches all of the entries in the given @ns, %FALSE otherwise.
     */
    enumerate_namespace(ns: string | null): boolean
    /**
     * Gets the next matched attribute from a #GFileAttributeMatcher.
     * @returns a string containing the next attribute or, %NULL if no more attribute exist.
     */
    enumerate_next(): string | null
    /**
     * Checks if an attribute will be matched by an attribute matcher. If
     * the matcher was created with the "*" matching string, this function
     * will always return %TRUE.
     * @param attribute a file attribute key.
     * @returns %TRUE if @attribute matches @matcher. %FALSE otherwise.
     */
    matches(attribute: string | null): boolean
    /**
     * Checks if an attribute matcher only matches a given attribute. Always
     * returns %FALSE if "*" was used when creating the matcher.
     * @param attribute a file attribute key.
     * @returns %TRUE if the matcher only matches @attribute. %FALSE otherwise.
     */
    matches_only(attribute: string | null): boolean
    /**
     * References a file attribute matcher.
     * @returns a #GFileAttributeMatcher.
     */
    ref(): FileAttributeMatcher
    /**
     * Subtracts all attributes of `subtract` from `matcher` and returns
     * a matcher that supports those attributes.
     * 
     * Note that currently it is not possible to remove a single
     * attribute when the `matcher` matches the whole namespace - or remove
     * a namespace or attribute when the matcher matches everything. This
     * is a limitation of the current implementation, but may be fixed
     * in the future.
     * @param subtract The matcher to subtract
     * @returns A file attribute matcher matching all attributes of     @matcher that are not matched by @subtract
     */
    subtract(subtract: FileAttributeMatcher | null): FileAttributeMatcher | null
    /**
     * Prints what the matcher is matching against. The format will be
     * equal to the format passed to g_file_attribute_matcher_new().
     * The output however, might not be identical, as the matcher may
     * decide to use a different order or omit needless parts.
     * @returns a string describing the attributes the matcher matches   against or %NULL if @matcher was %NULL.
     */
    to_string(): string | null
    /**
     * Unreferences `matcher`. If the reference count falls below 1,
     * the `matcher` is automatically freed.
     */
    unref(): void
}

/**
 * Determines if a string matches a file attribute.
 * @record 
 */
class FileAttributeMatcher {

    // Own properties of Gio-2.0.Gio.FileAttributeMatcher

    static name: string

    // Constructors of Gio-2.0.Gio.FileAttributeMatcher

    /**
     * Creates a new file attribute matcher, which matches attributes
     * against a given string. #GFileAttributeMatchers are reference
     * counted structures, and are created with a reference count of 1. If
     * the number of references falls to 0, the #GFileAttributeMatcher is
     * automatically destroyed.
     * 
     * The `attributes` string should be formatted with specific keys separated
     * from namespaces with a double colon. Several "namespace::key" strings may be
     * concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
     * The wildcard "*" may be used to match all keys and namespaces, or
     * "namespace::*" will match all keys in a given namespace.
     * 
     * ## Examples of file attribute matcher strings and results
     * 
     * - `"*"`: matches all attributes.
     * - `"standard::is-hidden"`: matches only the key is-hidden in the
     *   standard namespace.
     * - `"standard::type,unix::*"`: matches the type key in the standard
     *   namespace and all keys in the unix namespace.
     * @constructor 
     * @param attributes an attribute string to match.
     * @returns a #GFileAttributeMatcher
     */
    constructor(attributes: string | null) 
    /**
     * Creates a new file attribute matcher, which matches attributes
     * against a given string. #GFileAttributeMatchers are reference
     * counted structures, and are created with a reference count of 1. If
     * the number of references falls to 0, the #GFileAttributeMatcher is
     * automatically destroyed.
     * 
     * The `attributes` string should be formatted with specific keys separated
     * from namespaces with a double colon. Several "namespace::key" strings may be
     * concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
     * The wildcard "*" may be used to match all keys and namespaces, or
     * "namespace::*" will match all keys in a given namespace.
     * 
     * ## Examples of file attribute matcher strings and results
     * 
     * - `"*"`: matches all attributes.
     * - `"standard::is-hidden"`: matches only the key is-hidden in the
     *   standard namespace.
     * - `"standard::type,unix::*"`: matches the type key in the standard
     *   namespace and all keys in the unix namespace.
     * @constructor 
     * @param attributes an attribute string to match.
     * @returns a #GFileAttributeMatcher
     */
    static new(attributes: string | null): FileAttributeMatcher
}

interface FileDescriptorBasedIface {

    // Own fields of Gio-2.0.Gio.FileDescriptorBasedIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    get_fd: (fd_based: FileDescriptorBased) => number
}

/**
 * An interface for file descriptor based io objects.
 * @record 
 */
abstract class FileDescriptorBasedIface {

    // Own properties of Gio-2.0.Gio.FileDescriptorBasedIface

    static name: string
}

interface FileEnumeratorClass {

    // Own fields of Gio-2.0.Gio.FileEnumeratorClass

    parent_class: GObject.ObjectClass
    next_file: (enumerator: FileEnumerator, cancellable: Cancellable | null) => FileInfo | null
    close_fn: (enumerator: FileEnumerator, cancellable: Cancellable | null) => boolean
    next_files_async: (enumerator: FileEnumerator, num_files: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    next_files_finish: (enumerator: FileEnumerator, result: AsyncResult) => FileInfo[]
    close_async: (enumerator: FileEnumerator, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    close_finish: (enumerator: FileEnumerator, result: AsyncResult) => boolean
}

abstract class FileEnumeratorClass {

    // Own properties of Gio-2.0.Gio.FileEnumeratorClass

    static name: string
}

interface FileEnumeratorPrivate {
}

class FileEnumeratorPrivate {

    // Own properties of Gio-2.0.Gio.FileEnumeratorPrivate

    static name: string
}

interface FileIOStreamClass {

    // Own fields of Gio-2.0.Gio.FileIOStreamClass

    parent_class: IOStreamClass
    tell: (stream: FileIOStream) => number
    can_seek: (stream: FileIOStream) => boolean
    seek: (stream: FileIOStream, offset: number, type: GLib.SeekType, cancellable: Cancellable | null) => boolean
    can_truncate: (stream: FileIOStream) => boolean
    truncate_fn: (stream: FileIOStream, size: number, cancellable: Cancellable | null) => boolean
    query_info: (stream: FileIOStream, attributes: string | null, cancellable: Cancellable | null) => FileInfo
    query_info_async: (stream: FileIOStream, attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    query_info_finish: (stream: FileIOStream, result: AsyncResult) => FileInfo
    get_etag: (stream: FileIOStream) => string | null
}

abstract class FileIOStreamClass {

    // Own properties of Gio-2.0.Gio.FileIOStreamClass

    static name: string
}

interface FileIOStreamPrivate {
}

class FileIOStreamPrivate {

    // Own properties of Gio-2.0.Gio.FileIOStreamPrivate

    static name: string
}

interface FileIconClass {
}

abstract class FileIconClass {

    // Own properties of Gio-2.0.Gio.FileIconClass

    static name: string
}

interface FileIface {

    // Own fields of Gio-2.0.Gio.FileIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    dup: (file: File) => File
    hash: (file: File) => number
    equal: (file1: File, file2: File) => boolean
    is_native: (file: File) => boolean
    has_uri_scheme: (file: File, uri_scheme: string | null) => boolean
    get_uri_scheme: (file: File) => string | null
    get_basename: (file: File) => string | null
    get_path: (file: File) => string | null
    get_uri: (file: File) => string | null
    get_parse_name: (file: File) => string | null
    get_parent: (file: File) => File | null
    prefix_matches: (prefix: File, file: File) => boolean
    get_relative_path: (parent: File, descendant: File) => string | null
    resolve_relative_path: (file: File, relative_path: string) => File
    get_child_for_display_name: (file: File, display_name: string | null) => File
    enumerate_children: (file: File, attributes: string | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null) => FileEnumerator
    enumerate_children_async: (file: File, attributes: string | null, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    enumerate_children_finish: (file: File, res: AsyncResult) => FileEnumerator
    query_info: (file: File, attributes: string | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null) => FileInfo
    query_info_async: (file: File, attributes: string | null, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    query_info_finish: (file: File, res: AsyncResult) => FileInfo
    query_filesystem_info: (file: File, attributes: string | null, cancellable: Cancellable | null) => FileInfo
    query_filesystem_info_async: (file: File, attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    query_filesystem_info_finish: (file: File, res: AsyncResult) => FileInfo
    find_enclosing_mount: (file: File, cancellable: Cancellable | null) => Mount
    find_enclosing_mount_async: (file: File, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    find_enclosing_mount_finish: (file: File, res: AsyncResult) => Mount
    set_display_name: (file: File, display_name: string | null, cancellable: Cancellable | null) => File
    set_display_name_async: (file: File, display_name: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    set_display_name_finish: (file: File, res: AsyncResult) => File
    query_settable_attributes: (file: File, cancellable: Cancellable | null) => FileAttributeInfoList
    query_writable_namespaces: (file: File, cancellable: Cancellable | null) => FileAttributeInfoList
    set_attribute: (file: File, attribute: string | null, type: FileAttributeType, value_p: any | null, flags: FileQueryInfoFlags, cancellable: Cancellable | null) => boolean
    set_attributes_from_info: (file: File, info: FileInfo, flags: FileQueryInfoFlags, cancellable: Cancellable | null) => boolean
    set_attributes_async: (file: File, info: FileInfo, flags: FileQueryInfoFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    set_attributes_finish: (file: File, result: AsyncResult) => [ /* returnType */ boolean, /* info */ FileInfo ]
    read_fn: (file: File, cancellable: Cancellable | null) => FileInputStream
    read_async: (file: File, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    read_finish: (file: File, res: AsyncResult) => FileInputStream
    append_to: (file: File, flags: FileCreateFlags, cancellable: Cancellable | null) => FileOutputStream
    append_to_async: (file: File, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    append_to_finish: (file: File, res: AsyncResult) => FileOutputStream
    create: (file: File, flags: FileCreateFlags, cancellable: Cancellable | null) => FileOutputStream
    create_async: (file: File, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    create_finish: (file: File, res: AsyncResult) => FileOutputStream
    replace: (file: File, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null) => FileOutputStream
    replace_async: (file: File, etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    replace_finish: (file: File, res: AsyncResult) => FileOutputStream
    delete_file: (file: File, cancellable: Cancellable | null) => boolean
    delete_file_async: (file: File, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    delete_file_finish: (file: File, result: AsyncResult) => boolean
    trash: (file: File, cancellable: Cancellable | null) => boolean
    trash_async: (file: File, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    trash_finish: (file: File, result: AsyncResult) => boolean
    make_directory: (file: File, cancellable: Cancellable | null) => boolean
    make_directory_async: (file: File, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    make_directory_finish: (file: File, result: AsyncResult) => boolean
    make_symbolic_link: (file: File, symlink_value: string, cancellable: Cancellable | null) => boolean
    make_symbolic_link_async: (file: File, symlink_value: string, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    make_symbolic_link_finish: (file: File, result: AsyncResult) => boolean
    copy: (source: File, destination: File, flags: FileCopyFlags, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null) => boolean
    copy_async: (source: File, destination: File, flags: FileCopyFlags, io_priority: number, cancellable: Cancellable | null) => void
    copy_finish: (file: File, res: AsyncResult) => boolean
    move: (source: File, destination: File, flags: FileCopyFlags, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null) => boolean
    move_async: (source: File, destination: File, flags: FileCopyFlags, io_priority: number, cancellable: Cancellable | null, progress_callback: FileProgressCallback | null, callback: AsyncReadyCallback | null) => void
    move_finish: (file: File, result: AsyncResult) => boolean
    mount_mountable: (file: File, flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    mount_mountable_finish: (file: File, result: AsyncResult) => File
    unmount_mountable: (file: File, flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    unmount_mountable_finish: (file: File, result: AsyncResult) => boolean
    eject_mountable: (file: File, flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    eject_mountable_finish: (file: File, result: AsyncResult) => boolean
    mount_enclosing_volume: (location: File, flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    mount_enclosing_volume_finish: (location: File, result: AsyncResult) => boolean
    monitor_dir: (file: File, flags: FileMonitorFlags, cancellable: Cancellable | null) => FileMonitor
    monitor_file: (file: File, flags: FileMonitorFlags, cancellable: Cancellable | null) => FileMonitor
    open_readwrite: (file: File, cancellable: Cancellable | null) => FileIOStream
    open_readwrite_async: (file: File, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    open_readwrite_finish: (file: File, res: AsyncResult) => FileIOStream
    create_readwrite: (file: File, flags: FileCreateFlags, cancellable: Cancellable | null) => FileIOStream
    create_readwrite_async: (file: File, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    create_readwrite_finish: (file: File, res: AsyncResult) => FileIOStream
    replace_readwrite: (file: File, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null) => FileIOStream
    replace_readwrite_async: (file: File, etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    replace_readwrite_finish: (file: File, res: AsyncResult) => FileIOStream
    start_mountable: (file: File, flags: DriveStartFlags, start_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    start_mountable_finish: (file: File, result: AsyncResult) => boolean
    stop_mountable: (file: File, flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    stop_mountable_finish: (file: File, result: AsyncResult) => boolean
    /**
     * a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.
     * @field 
     */
    supports_thread_contexts: boolean
    unmount_mountable_with_operation: (file: File, flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    unmount_mountable_with_operation_finish: (file: File, result: AsyncResult) => boolean
    eject_mountable_with_operation: (file: File, flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    eject_mountable_with_operation_finish: (file: File, result: AsyncResult) => boolean
    poll_mountable: (file: File, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    poll_mountable_finish: (file: File, result: AsyncResult) => boolean
    measure_disk_usage_finish: (file: File, result: AsyncResult) => [ /* returnType */ boolean, /* disk_usage */ number, /* num_dirs */ number, /* num_files */ number ]
}

/**
 * An interface for writing VFS file handles.
 * @record 
 */
abstract class FileIface {

    // Own properties of Gio-2.0.Gio.FileIface

    static name: string
}

interface FileInfoClass {
}

abstract class FileInfoClass {

    // Own properties of Gio-2.0.Gio.FileInfoClass

    static name: string
}

interface FileInputStreamClass {

    // Own fields of Gio-2.0.Gio.FileInputStreamClass

    parent_class: InputStreamClass
    tell: (stream: FileInputStream) => number
    can_seek: (stream: FileInputStream) => boolean
    seek: (stream: FileInputStream, offset: number, type: GLib.SeekType, cancellable: Cancellable | null) => boolean
    query_info: (stream: FileInputStream, attributes: string | null, cancellable: Cancellable | null) => FileInfo
    query_info_async: (stream: FileInputStream, attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    query_info_finish: (stream: FileInputStream, result: AsyncResult) => FileInfo
}

abstract class FileInputStreamClass {

    // Own properties of Gio-2.0.Gio.FileInputStreamClass

    static name: string
}

interface FileInputStreamPrivate {
}

class FileInputStreamPrivate {

    // Own properties of Gio-2.0.Gio.FileInputStreamPrivate

    static name: string
}

interface FileMonitorClass {

    // Own fields of Gio-2.0.Gio.FileMonitorClass

    parent_class: GObject.ObjectClass
    changed: (monitor: FileMonitor, file: File, other_file: File, event_type: FileMonitorEvent) => void
    cancel: (monitor: FileMonitor) => boolean
}

abstract class FileMonitorClass {

    // Own properties of Gio-2.0.Gio.FileMonitorClass

    static name: string
}

interface FileMonitorPrivate {
}

class FileMonitorPrivate {

    // Own properties of Gio-2.0.Gio.FileMonitorPrivate

    static name: string
}

interface FileOutputStreamClass {

    // Own fields of Gio-2.0.Gio.FileOutputStreamClass

    parent_class: OutputStreamClass
    tell: (stream: FileOutputStream) => number
    can_seek: (stream: FileOutputStream) => boolean
    seek: (stream: FileOutputStream, offset: number, type: GLib.SeekType, cancellable: Cancellable | null) => boolean
    can_truncate: (stream: FileOutputStream) => boolean
    truncate_fn: (stream: FileOutputStream, size: number, cancellable: Cancellable | null) => boolean
    query_info: (stream: FileOutputStream, attributes: string | null, cancellable: Cancellable | null) => FileInfo
    query_info_async: (stream: FileOutputStream, attributes: string | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    query_info_finish: (stream: FileOutputStream, result: AsyncResult) => FileInfo
    get_etag: (stream: FileOutputStream) => string | null
}

abstract class FileOutputStreamClass {

    // Own properties of Gio-2.0.Gio.FileOutputStreamClass

    static name: string
}

interface FileOutputStreamPrivate {
}

class FileOutputStreamPrivate {

    // Own properties of Gio-2.0.Gio.FileOutputStreamPrivate

    static name: string
}

interface FilenameCompleterClass {

    // Own fields of Gio-2.0.Gio.FilenameCompleterClass

    parent_class: GObject.ObjectClass
    got_completion_data: (filename_completer: FilenameCompleter) => void
}

abstract class FilenameCompleterClass {

    // Own properties of Gio-2.0.Gio.FilenameCompleterClass

    static name: string
}

interface FilterInputStreamClass {

    // Own fields of Gio-2.0.Gio.FilterInputStreamClass

    parent_class: InputStreamClass
}

abstract class FilterInputStreamClass {

    // Own properties of Gio-2.0.Gio.FilterInputStreamClass

    static name: string
}

interface FilterOutputStreamClass {

    // Own fields of Gio-2.0.Gio.FilterOutputStreamClass

    parent_class: OutputStreamClass
}

abstract class FilterOutputStreamClass {

    // Own properties of Gio-2.0.Gio.FilterOutputStreamClass

    static name: string
}

interface IOExtension {

    // Owm methods of Gio-2.0.Gio.IOExtension

    /**
     * Gets the name under which `extension` was registered.
     * 
     * Note that the same type may be registered as extension
     * for multiple extension points, under different names.
     * @returns the name of @extension.
     */
    get_name(): string | null
    /**
     * Gets the priority with which `extension` was registered.
     * @returns the priority of @extension
     */
    get_priority(): number
    /**
     * Gets the type associated with `extension`.
     * @returns the type of @extension
     */
    get_type(): GObject.GType
}

/**
 * #GIOExtension is an opaque data structure and can only be accessed
 * using the following functions.
 * @record 
 */
class IOExtension {

    // Own properties of Gio-2.0.Gio.IOExtension

    static name: string
}

interface IOExtensionPoint {

    // Owm methods of Gio-2.0.Gio.IOExtensionPoint

    /**
     * Finds a #GIOExtension for an extension point by name.
     * @param name the name of the extension to get
     * @returns the #GIOExtension for @extension_point that has the    given name, or %NULL if there is no extension with that name
     */
    get_extension_by_name(name: string | null): IOExtension
    /**
     * Gets a list of all extensions that implement this extension point.
     * The list is sorted by priority, beginning with the highest priority.
     * @returns a #GList of     #GIOExtensions. The list is owned by GIO and should not be     modified.
     */
    get_extensions(): IOExtension[]
    /**
     * Gets the required type for `extension_point`.
     * @returns the #GType that all implementations must have,   or %G_TYPE_INVALID if the extension point has no required type
     */
    get_required_type(): GObject.GType
    /**
     * Sets the required type for `extension_point` to `type`.
     * All implementations must henceforth have this type.
     * @param type the #GType to require
     */
    set_required_type(type: GObject.GType): void
}

/**
 * #GIOExtensionPoint is an opaque data structure and can only be accessed
 * using the following functions.
 * @record 
 */
class IOExtensionPoint {

    // Own properties of Gio-2.0.Gio.IOExtensionPoint

    static name: string

    // Constructors of Gio-2.0.Gio.IOExtensionPoint

    /**
     * Registers `type` as extension for the extension point with name
     * `extension_point_name`.
     * 
     * If `type` has already been registered as an extension for this
     * extension point, the existing #GIOExtension object is returned.
     * @param extension_point_name the name of the extension point
     * @param type the #GType to register as extension
     * @param extension_name the name for the extension
     * @param priority the priority for the extension
     * @returns a #GIOExtension object for #GType
     */
    static implement(extension_point_name: string | null, type: GObject.GType, extension_name: string | null, priority: number): IOExtension
    /**
     * Looks up an existing extension point.
     * @param name the name of the extension point
     * @returns the #GIOExtensionPoint, or %NULL if there    is no registered extension point with the given name.
     */
    static lookup(name: string | null): IOExtensionPoint
    /**
     * Registers an extension point.
     * @param name The name of the extension point
     * @returns the new #GIOExtensionPoint. This object is    owned by GIO and should not be freed.
     */
    static register(name: string | null): IOExtensionPoint
}

interface IOModuleClass {
}

abstract class IOModuleClass {

    // Own properties of Gio-2.0.Gio.IOModuleClass

    static name: string
}

interface IOModuleScope {

    // Owm methods of Gio-2.0.Gio.IOModuleScope

    /**
     * Block modules with the given `basename` from being loaded when
     * this scope is used with g_io_modules_scan_all_in_directory_with_scope()
     * or g_io_modules_load_all_in_directory_with_scope().
     * @param basename the basename to block
     */
    block(basename: string | null): void
    /**
     * Free a module scope.
     */
    free(): void
}

/**
 * Represents a scope for loading IO modules. A scope can be used for blocking
 * duplicate modules, or blocking a module you don't want to load.
 * 
 * The scope can be used with g_io_modules_load_all_in_directory_with_scope()
 * or g_io_modules_scan_all_in_directory_with_scope().
 * @record 
 */
class IOModuleScope {

    // Own properties of Gio-2.0.Gio.IOModuleScope

    static name: string
}

interface IOSchedulerJob {

    // Owm methods of Gio-2.0.Gio.IOSchedulerJob

    /**
     * Used from an I/O job to send a callback to be run in the thread
     * that the job was started from, waiting for the result (and thus
     * blocking the I/O job).
     * @param func a #GSourceFunc callback that will be called in the original thread
     * @returns The return value of @func
     */
    send_to_mainloop(func: GLib.SourceFunc): boolean
    /**
     * Used from an I/O job to send a callback to be run asynchronously in
     * the thread that the job was started from. The callback will be run
     * when the main loop is available, but at that time the I/O job might
     * have finished. The return value from the callback is ignored.
     * 
     * Note that if you are passing the `user_data` from g_io_scheduler_push_job()
     * on to this function you have to ensure that it is not freed before
     * `func` is called, either by passing %NULL as `notify` to
     * g_io_scheduler_push_job() or by using refcounting for `user_data`.
     * @param func a #GSourceFunc callback that will be called in the original thread
     */
    send_to_mainloop_async(func: GLib.SourceFunc): void
}

/**
 * Opaque class for defining and scheduling IO jobs.
 * @record 
 */
class IOSchedulerJob {

    // Own properties of Gio-2.0.Gio.IOSchedulerJob

    static name: string
}

interface IOStreamAdapter {
}

class IOStreamAdapter {

    // Own properties of Gio-2.0.Gio.IOStreamAdapter

    static name: string
}

interface IOStreamClass {

    // Own fields of Gio-2.0.Gio.IOStreamClass

    parent_class: GObject.ObjectClass
    get_input_stream: (stream: IOStream) => InputStream
    get_output_stream: (stream: IOStream) => OutputStream
    close_fn: (stream: IOStream, cancellable: Cancellable | null) => boolean
    close_async: (stream: IOStream, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    close_finish: (stream: IOStream, result: AsyncResult) => boolean
}

abstract class IOStreamClass {

    // Own properties of Gio-2.0.Gio.IOStreamClass

    static name: string
}

interface IOStreamPrivate {
}

class IOStreamPrivate {

    // Own properties of Gio-2.0.Gio.IOStreamPrivate

    static name: string
}

interface IconIface {

    // Own fields of Gio-2.0.Gio.IconIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    hash: (icon: Icon) => number
    equal: (icon1: Icon | null, icon2: Icon | null) => boolean
    to_tokens: (icon: Icon) => [ /* returnType */ boolean, /* tokens */ string[], /* out_version */ number ]
    serialize: (icon: Icon) => GLib.Variant | null
}

/**
 * GIconIface is used to implement GIcon types for various
 * different systems. See #GThemedIcon and #GLoadableIcon for
 * examples of how to implement this interface.
 * @record 
 */
abstract class IconIface {

    // Own properties of Gio-2.0.Gio.IconIface

    static name: string
}

interface InetAddressClass {

    // Own fields of Gio-2.0.Gio.InetAddressClass

    parent_class: GObject.ObjectClass
    to_string: (address: InetAddress) => string | null
    to_bytes: (address: InetAddress) => number
}

abstract class InetAddressClass {

    // Own properties of Gio-2.0.Gio.InetAddressClass

    static name: string
}

interface InetAddressMaskClass {

    // Own fields of Gio-2.0.Gio.InetAddressMaskClass

    parent_class: GObject.ObjectClass
}

abstract class InetAddressMaskClass {

    // Own properties of Gio-2.0.Gio.InetAddressMaskClass

    static name: string
}

interface InetAddressMaskPrivate {
}

class InetAddressMaskPrivate {

    // Own properties of Gio-2.0.Gio.InetAddressMaskPrivate

    static name: string
}

interface InetAddressPrivate {
}

class InetAddressPrivate {

    // Own properties of Gio-2.0.Gio.InetAddressPrivate

    static name: string
}

interface InetSocketAddressClass {

    // Own fields of Gio-2.0.Gio.InetSocketAddressClass

    parent_class: SocketAddressClass
}

abstract class InetSocketAddressClass {

    // Own properties of Gio-2.0.Gio.InetSocketAddressClass

    static name: string
}

interface InetSocketAddressPrivate {
}

class InetSocketAddressPrivate {

    // Own properties of Gio-2.0.Gio.InetSocketAddressPrivate

    static name: string
}

interface InitableIface {

    // Own fields of Gio-2.0.Gio.InitableIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    init: (initable: Initable, cancellable: Cancellable | null) => boolean
}

/**
 * Provides an interface for initializing object such that initialization
 * may fail.
 * @record 
 */
abstract class InitableIface {

    // Own properties of Gio-2.0.Gio.InitableIface

    static name: string
}

interface InputMessage {

    // Own fields of Gio-2.0.Gio.InputMessage

    /**
     * return location
     *   for a #GSocketAddress, or %NULL
     * @field 
     */
    address: SocketAddress
    /**
     * pointer to an
     *   array of input vectors
     * @field 
     */
    vectors: InputVector[]
    /**
     * the number of input vectors pointed to by `vectors`
     * @field 
     */
    num_vectors: number
    /**
     * will be set to the number of bytes that have been
     *   received
     * @field 
     */
    bytes_received: number
    /**
     * collection of #GSocketMsgFlags for the received message,
     *   outputted by the call
     * @field 
     */
    flags: number
    /**
     * return location for a
     *   caller-allocated array of #GSocketControlMessages, or %NULL
     * @field 
     */
    control_messages: SocketControlMessage[]
    /**
     * return location for the number of
     *   elements in `control_messages`
     * @field 
     */
    num_control_messages: number
}

/**
 * Structure used for scatter/gather data input when receiving multiple
 * messages or packets in one go. You generally pass in an array of empty
 * #GInputVectors and the operation will use all the buffers as if they
 * were one buffer, and will set `bytes_received` to the total number of bytes
 * received across all #GInputVectors.
 * 
 * This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
 * the POSIX sockets API (see `man 2 recvmmsg`).
 * 
 * If `address` is non-%NULL then it is set to the source address the message
 * was received from, and the caller must free it afterwards.
 * 
 * If `control_messages` is non-%NULL then it is set to an array of control
 * messages received with the message (if any), and the caller must free it
 * afterwards. `num_control_messages` is set to the number of elements in
 * this array, which may be zero.
 * 
 * Flags relevant to this message will be returned in `flags`. For example,
 * `MSG_EOR` or `MSG_TRUNC`.
 * @record 
 */
class InputMessage {

    // Own properties of Gio-2.0.Gio.InputMessage

    static name: string
}

interface InputStreamClass {

    // Own fields of Gio-2.0.Gio.InputStreamClass

    parent_class: GObject.ObjectClass
    read_fn: (stream: InputStream, buffer: any | null, count: number, cancellable: Cancellable | null) => number
    skip: (stream: InputStream, count: number, cancellable: Cancellable | null) => number
    close_fn: (stream: InputStream, cancellable: Cancellable | null) => boolean
    read_async: (stream: InputStream, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => /* buffer */ Uint8Array | null
    read_finish: (stream: InputStream, result: AsyncResult) => number
    skip_async: (stream: InputStream, count: number, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    skip_finish: (stream: InputStream, result: AsyncResult) => number
    close_async: (stream: InputStream, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    close_finish: (stream: InputStream, result: AsyncResult) => boolean
}

abstract class InputStreamClass {

    // Own properties of Gio-2.0.Gio.InputStreamClass

    static name: string
}

interface InputStreamPrivate {
}

class InputStreamPrivate {

    // Own properties of Gio-2.0.Gio.InputStreamPrivate

    static name: string
}

interface InputVector {

    // Own fields of Gio-2.0.Gio.InputVector

    /**
     * Pointer to a buffer where data will be written.
     * @field 
     */
    buffer: any
    /**
     * the available size in `buffer`.
     * @field 
     */
    size: number
}

/**
 * Structure used for scatter/gather data input.
 * You generally pass in an array of #GInputVectors
 * and the operation will store the read data starting in the
 * first buffer, switching to the next as needed.
 * @record 
 */
class InputVector {

    // Own properties of Gio-2.0.Gio.InputVector

    static name: string
}

interface ListModelInterface {

    // Own fields of Gio-2.0.Gio.ListModelInterface

    /**
     * parent #GTypeInterface
     * @field 
     */
    g_iface: GObject.TypeInterface
    get_item_type: (list: ListModel) => GObject.GType
    get_n_items: (list: ListModel) => number
    get_item: (list: ListModel, position: number) => GObject.Object | null
}

/**
 * The virtual function table for #GListModel.
 * @record 
 */
abstract class ListModelInterface {

    // Own properties of Gio-2.0.Gio.ListModelInterface

    static name: string
}

interface ListStoreClass {

    // Own fields of Gio-2.0.Gio.ListStoreClass

    parent_class: GObject.ObjectClass
}

abstract class ListStoreClass {

    // Own properties of Gio-2.0.Gio.ListStoreClass

    static name: string
}

interface LoadableIconIface {

    // Own fields of Gio-2.0.Gio.LoadableIconIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    load: (icon: LoadableIcon, size: number, cancellable: Cancellable | null) => [ /* returnType */ InputStream, /* type */ string | null ]
    load_async: (icon: LoadableIcon, size: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    load_finish: (icon: LoadableIcon, res: AsyncResult) => [ /* returnType */ InputStream, /* type */ string | null ]
}

/**
 * Interface for icons that can be loaded as a stream.
 * @record 
 */
abstract class LoadableIconIface {

    // Own properties of Gio-2.0.Gio.LoadableIconIface

    static name: string
}

interface MemoryInputStreamClass {

    // Own fields of Gio-2.0.Gio.MemoryInputStreamClass

    parent_class: InputStreamClass
}

abstract class MemoryInputStreamClass {

    // Own properties of Gio-2.0.Gio.MemoryInputStreamClass

    static name: string
}

interface MemoryInputStreamPrivate {
}

class MemoryInputStreamPrivate {

    // Own properties of Gio-2.0.Gio.MemoryInputStreamPrivate

    static name: string
}

interface MemoryMonitorInterface {

    // Own fields of Gio-2.0.Gio.MemoryMonitorInterface

    low_memory_warning: (monitor: MemoryMonitor, level: MemoryMonitorWarningLevel) => void
}

/**
 * The virtual function table for #GMemoryMonitor.
 * @record 
 */
abstract class MemoryMonitorInterface {

    // Own properties of Gio-2.0.Gio.MemoryMonitorInterface

    static name: string
}

interface MemoryOutputStreamClass {

    // Own fields of Gio-2.0.Gio.MemoryOutputStreamClass

    parent_class: OutputStreamClass
}

abstract class MemoryOutputStreamClass {

    // Own properties of Gio-2.0.Gio.MemoryOutputStreamClass

    static name: string
}

interface MemoryOutputStreamPrivate {
}

class MemoryOutputStreamPrivate {

    // Own properties of Gio-2.0.Gio.MemoryOutputStreamPrivate

    static name: string
}

interface MenuAttributeIterClass {

    // Own fields of Gio-2.0.Gio.MenuAttributeIterClass

    parent_class: GObject.ObjectClass
    get_next: (iter: MenuAttributeIter) => [ /* returnType */ boolean, /* out_name */ string | null, /* value */ GLib.Variant ]
}

abstract class MenuAttributeIterClass {

    // Own properties of Gio-2.0.Gio.MenuAttributeIterClass

    static name: string
}

interface MenuAttributeIterPrivate {
}

class MenuAttributeIterPrivate {

    // Own properties of Gio-2.0.Gio.MenuAttributeIterPrivate

    static name: string
}

interface MenuLinkIterClass {

    // Own fields of Gio-2.0.Gio.MenuLinkIterClass

    parent_class: GObject.ObjectClass
    get_next: (iter: MenuLinkIter) => [ /* returnType */ boolean, /* out_link */ string | null, /* value */ MenuModel ]
}

abstract class MenuLinkIterClass {

    // Own properties of Gio-2.0.Gio.MenuLinkIterClass

    static name: string
}

interface MenuLinkIterPrivate {
}

class MenuLinkIterPrivate {

    // Own properties of Gio-2.0.Gio.MenuLinkIterPrivate

    static name: string
}

interface MenuModelClass {

    // Own fields of Gio-2.0.Gio.MenuModelClass

    parent_class: GObject.ObjectClass
    is_mutable: (model: MenuModel) => boolean
    get_n_items: (model: MenuModel) => number
    get_item_attributes: (model: MenuModel, item_index: number) => /* attributes */ GLib.HashTable
    iterate_item_attributes: (model: MenuModel, item_index: number) => MenuAttributeIter
    get_item_attribute_value: (model: MenuModel, item_index: number, attribute: string | null, expected_type: GLib.VariantType | null) => GLib.Variant | null
    get_item_links: (model: MenuModel, item_index: number) => /* links */ GLib.HashTable
    iterate_item_links: (model: MenuModel, item_index: number) => MenuLinkIter
    get_item_link: (model: MenuModel, item_index: number, link: string | null) => MenuModel | null
}

abstract class MenuModelClass {

    // Own properties of Gio-2.0.Gio.MenuModelClass

    static name: string
}

interface MenuModelPrivate {
}

class MenuModelPrivate {

    // Own properties of Gio-2.0.Gio.MenuModelPrivate

    static name: string
}

interface MountIface {

    // Own fields of Gio-2.0.Gio.MountIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    changed: (mount: Mount) => void
    unmounted: (mount: Mount) => void
    get_root: (mount: Mount) => File
    get_name: (mount: Mount) => string | null
    get_icon: (mount: Mount) => Icon
    get_uuid: (mount: Mount) => string | null
    get_volume: (mount: Mount) => Volume | null
    get_drive: (mount: Mount) => Drive | null
    can_unmount: (mount: Mount) => boolean
    can_eject: (mount: Mount) => boolean
    unmount: (mount: Mount, flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    unmount_finish: (mount: Mount, result: AsyncResult) => boolean
    eject: (mount: Mount, flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    eject_finish: (mount: Mount, result: AsyncResult) => boolean
    remount: (mount: Mount, flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    remount_finish: (mount: Mount, result: AsyncResult) => boolean
    guess_content_type: (mount: Mount, force_rescan: boolean, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    guess_content_type_finish: (mount: Mount, result: AsyncResult) => string[]
    guess_content_type_sync: (mount: Mount, force_rescan: boolean, cancellable: Cancellable | null) => string[]
    pre_unmount: (mount: Mount) => void
    unmount_with_operation: (mount: Mount, flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    unmount_with_operation_finish: (mount: Mount, result: AsyncResult) => boolean
    eject_with_operation: (mount: Mount, flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    eject_with_operation_finish: (mount: Mount, result: AsyncResult) => boolean
    get_default_location: (mount: Mount) => File
    get_sort_key: (mount: Mount) => string | null
    get_symbolic_icon: (mount: Mount) => Icon
}

/**
 * Interface for implementing operations for mounts.
 * @record 
 */
abstract class MountIface {

    // Own properties of Gio-2.0.Gio.MountIface

    static name: string
}

interface MountOperationClass {

    // Own fields of Gio-2.0.Gio.MountOperationClass

    parent_class: GObject.ObjectClass
    ask_password: (op: MountOperation, message: string | null, default_user: string | null, default_domain: string | null, flags: AskPasswordFlags) => void
    ask_question: (op: MountOperation, message: string | null, choices: string[]) => void
    reply: (op: MountOperation, result: MountOperationResult) => void
    aborted: (op: MountOperation) => void
    show_processes: (op: MountOperation, message: string | null, processes: GLib.Pid[], choices: string[]) => void
    show_unmount_progress: (op: MountOperation, message: string | null, time_left: number, bytes_left: number) => void
}

abstract class MountOperationClass {

    // Own properties of Gio-2.0.Gio.MountOperationClass

    static name: string
}

interface MountOperationPrivate {
}

class MountOperationPrivate {

    // Own properties of Gio-2.0.Gio.MountOperationPrivate

    static name: string
}

interface NativeSocketAddressClass {

    // Own fields of Gio-2.0.Gio.NativeSocketAddressClass

    parent_class: SocketAddressClass
}

abstract class NativeSocketAddressClass {

    // Own properties of Gio-2.0.Gio.NativeSocketAddressClass

    static name: string
}

interface NativeSocketAddressPrivate {
}

class NativeSocketAddressPrivate {

    // Own properties of Gio-2.0.Gio.NativeSocketAddressPrivate

    static name: string
}

interface NativeVolumeMonitorClass {

    // Own fields of Gio-2.0.Gio.NativeVolumeMonitorClass

    parent_class: VolumeMonitorClass
}

abstract class NativeVolumeMonitorClass {

    // Own properties of Gio-2.0.Gio.NativeVolumeMonitorClass

    static name: string
}

interface NetworkAddressClass {

    // Own fields of Gio-2.0.Gio.NetworkAddressClass

    parent_class: GObject.ObjectClass
}

abstract class NetworkAddressClass {

    // Own properties of Gio-2.0.Gio.NetworkAddressClass

    static name: string
}

interface NetworkAddressPrivate {
}

class NetworkAddressPrivate {

    // Own properties of Gio-2.0.Gio.NetworkAddressPrivate

    static name: string
}

interface NetworkMonitorInterface {

    // Own fields of Gio-2.0.Gio.NetworkMonitorInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    network_changed: (monitor: NetworkMonitor, network_available: boolean) => void
    can_reach: (monitor: NetworkMonitor, connectable: SocketConnectable, cancellable: Cancellable | null) => boolean
    can_reach_async: (monitor: NetworkMonitor, connectable: SocketConnectable, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    can_reach_finish: (monitor: NetworkMonitor, result: AsyncResult) => boolean
}

/**
 * The virtual function table for #GNetworkMonitor.
 * @record 
 */
abstract class NetworkMonitorInterface {

    // Own properties of Gio-2.0.Gio.NetworkMonitorInterface

    static name: string
}

interface NetworkServiceClass {

    // Own fields of Gio-2.0.Gio.NetworkServiceClass

    parent_class: GObject.ObjectClass
}

abstract class NetworkServiceClass {

    // Own properties of Gio-2.0.Gio.NetworkServiceClass

    static name: string
}

interface NetworkServicePrivate {
}

class NetworkServicePrivate {

    // Own properties of Gio-2.0.Gio.NetworkServicePrivate

    static name: string
}

interface OutputMessage {

    // Own fields of Gio-2.0.Gio.OutputMessage

    /**
     * a #GSocketAddress, or %NULL
     * @field 
     */
    address: SocketAddress
    /**
     * pointer to an array of output vectors
     * @field 
     */
    vectors: OutputVector
    /**
     * the number of output vectors pointed to by `vectors`.
     * @field 
     */
    num_vectors: number
    /**
     * initialize to 0. Will be set to the number of bytes
     *     that have been sent
     * @field 
     */
    bytes_sent: number
    /**
     * a pointer
     *   to an array of #GSocketControlMessages, or %NULL.
     * @field 
     */
    control_messages: SocketControlMessage[]
    /**
     * number of elements in `control_messages`.
     * @field 
     */
    num_control_messages: number
}

/**
 * Structure used for scatter/gather data output when sending multiple
 * messages or packets in one go. You generally pass in an array of
 * #GOutputVectors and the operation will use all the buffers as if they
 * were one buffer.
 * 
 * If `address` is %NULL then the message is sent to the default receiver
 * (as previously set by g_socket_connect()).
 * @record 
 */
class OutputMessage {

    // Own properties of Gio-2.0.Gio.OutputMessage

    static name: string
}

interface OutputStreamClass {

    // Own fields of Gio-2.0.Gio.OutputStreamClass

    parent_class: GObject.ObjectClass
    write_fn: (stream: OutputStream, buffer: Uint8Array | null, cancellable: Cancellable | null) => number
    splice: (stream: OutputStream, source: InputStream, flags: OutputStreamSpliceFlags, cancellable: Cancellable | null) => number
    flush: (stream: OutputStream, cancellable: Cancellable | null) => boolean
    close_fn: (stream: OutputStream, cancellable: Cancellable | null) => boolean
    write_async: (stream: OutputStream, buffer: Uint8Array | null, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    write_finish: (stream: OutputStream, result: AsyncResult) => number
    splice_async: (stream: OutputStream, source: InputStream, flags: OutputStreamSpliceFlags, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    splice_finish: (stream: OutputStream, result: AsyncResult) => number
    flush_async: (stream: OutputStream, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    flush_finish: (stream: OutputStream, result: AsyncResult) => boolean
    close_async: (stream: OutputStream, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    close_finish: (stream: OutputStream, result: AsyncResult) => boolean
    writev_fn: (stream: OutputStream, vectors: OutputVector[], cancellable: Cancellable | null) => [ /* returnType */ boolean, /* bytes_written */ number ]
    writev_async: (stream: OutputStream, vectors: OutputVector[], io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    writev_finish: (stream: OutputStream, result: AsyncResult) => [ /* returnType */ boolean, /* bytes_written */ number ]
}

abstract class OutputStreamClass {

    // Own properties of Gio-2.0.Gio.OutputStreamClass

    static name: string
}

interface OutputStreamPrivate {
}

class OutputStreamPrivate {

    // Own properties of Gio-2.0.Gio.OutputStreamPrivate

    static name: string
}

interface OutputVector {

    // Own fields of Gio-2.0.Gio.OutputVector

    /**
     * Pointer to a buffer of data to read.
     * @field 
     */
    buffer: any
    /**
     * the size of `buffer`.
     * @field 
     */
    size: number
}

/**
 * Structure used for scatter/gather data output.
 * You generally pass in an array of #GOutputVectors
 * and the operation will use all the buffers as if they were
 * one buffer.
 * @record 
 */
class OutputVector {

    // Own properties of Gio-2.0.Gio.OutputVector

    static name: string
}

interface PermissionClass {

    // Own fields of Gio-2.0.Gio.PermissionClass

    parent_class: GObject.ObjectClass
    acquire: (permission: Permission, cancellable: Cancellable | null) => boolean
    acquire_async: (permission: Permission, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    acquire_finish: (permission: Permission, result: AsyncResult) => boolean
    release: (permission: Permission, cancellable: Cancellable | null) => boolean
    release_async: (permission: Permission, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    release_finish: (permission: Permission, result: AsyncResult) => boolean
    reserved: any[]
}

abstract class PermissionClass {

    // Own properties of Gio-2.0.Gio.PermissionClass

    static name: string
}

interface PermissionPrivate {
}

class PermissionPrivate {

    // Own properties of Gio-2.0.Gio.PermissionPrivate

    static name: string
}

interface PollableInputStreamInterface {

    // Own fields of Gio-2.0.Gio.PollableInputStreamInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    can_poll: (stream: PollableInputStream) => boolean
    is_readable: (stream: PollableInputStream) => boolean
    create_source: (stream: PollableInputStream, cancellable: Cancellable | null) => GLib.Source
    read_nonblocking: (stream: PollableInputStream) => [ /* returnType */ number, /* buffer */ Uint8Array | null ]
}

/**
 * The interface for pollable input streams.
 * 
 * The default implementation of `can_poll` always returns %TRUE.
 * 
 * The default implementation of `read_nonblocking` calls
 * g_pollable_input_stream_is_readable(), and then calls
 * g_input_stream_read() if it returns %TRUE. This means you only need
 * to override it if it is possible that your `is_readable`
 * implementation may return %TRUE when the stream is not actually
 * readable.
 * @record 
 */
abstract class PollableInputStreamInterface {

    // Own properties of Gio-2.0.Gio.PollableInputStreamInterface

    static name: string
}

interface PollableOutputStreamInterface {

    // Own fields of Gio-2.0.Gio.PollableOutputStreamInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    can_poll: (stream: PollableOutputStream) => boolean
    is_writable: (stream: PollableOutputStream) => boolean
    create_source: (stream: PollableOutputStream, cancellable: Cancellable | null) => GLib.Source
    write_nonblocking: (stream: PollableOutputStream, buffer: Uint8Array | null) => number
    writev_nonblocking: (stream: PollableOutputStream, vectors: OutputVector[]) => [ /* returnType */ PollableReturn, /* bytes_written */ number ]
}

/**
 * The interface for pollable output streams.
 * 
 * The default implementation of `can_poll` always returns %TRUE.
 * 
 * The default implementation of `write_nonblocking` calls
 * g_pollable_output_stream_is_writable(), and then calls
 * g_output_stream_write() if it returns %TRUE. This means you only
 * need to override it if it is possible that your `is_writable`
 * implementation may return %TRUE when the stream is not actually
 * writable.
 * 
 * The default implementation of `writev_nonblocking` calls
 * g_pollable_output_stream_write_nonblocking() for each vector, and converts
 * its return value and error (if set) to a #GPollableReturn. You should
 * override this where possible to avoid having to allocate a #GError to return
 * %G_IO_ERROR_WOULD_BLOCK.
 * @record 
 */
abstract class PollableOutputStreamInterface {

    // Own properties of Gio-2.0.Gio.PollableOutputStreamInterface

    static name: string
}

interface PowerProfileMonitorInterface {
}

/**
 * The virtual function table for #GPowerProfileMonitor.
 * @record 
 */
abstract class PowerProfileMonitorInterface {

    // Own properties of Gio-2.0.Gio.PowerProfileMonitorInterface

    static name: string
}

interface ProxyAddressClass {

    // Own fields of Gio-2.0.Gio.ProxyAddressClass

    parent_class: InetSocketAddressClass
}

/**
 * Class structure for #GProxyAddress.
 * @record 
 */
abstract class ProxyAddressClass {

    // Own properties of Gio-2.0.Gio.ProxyAddressClass

    static name: string
}

interface ProxyAddressEnumeratorClass {
}

/**
 * Class structure for #GProxyAddressEnumerator.
 * @record 
 */
abstract class ProxyAddressEnumeratorClass {

    // Own properties of Gio-2.0.Gio.ProxyAddressEnumeratorClass

    static name: string
}

interface ProxyAddressEnumeratorPrivate {
}

class ProxyAddressEnumeratorPrivate {

    // Own properties of Gio-2.0.Gio.ProxyAddressEnumeratorPrivate

    static name: string
}

interface ProxyAddressPrivate {
}

class ProxyAddressPrivate {

    // Own properties of Gio-2.0.Gio.ProxyAddressPrivate

    static name: string
}

interface ProxyInterface {

    // Own fields of Gio-2.0.Gio.ProxyInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    // Has conflict: connect: (proxy: Proxy, connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | null) => IOStream
    connect_async: (proxy: Proxy, connection: IOStream, proxy_address: ProxyAddress, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    connect_finish: (proxy: Proxy, result: AsyncResult) => IOStream
    supports_hostname: (proxy: Proxy) => boolean
}

/**
 * Provides an interface for handling proxy connection and payload.
 * @record 
 */
abstract class ProxyInterface {

    // Own properties of Gio-2.0.Gio.ProxyInterface

    static name: string
}

interface ProxyResolverInterface {

    // Own fields of Gio-2.0.Gio.ProxyResolverInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    is_supported: (resolver: ProxyResolver) => boolean
    lookup: (resolver: ProxyResolver, uri: string | null, cancellable: Cancellable | null) => string[]
    lookup_async: (resolver: ProxyResolver, uri: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_finish: (resolver: ProxyResolver, result: AsyncResult) => string[]
}

/**
 * The virtual function table for #GProxyResolver.
 * @record 
 */
abstract class ProxyResolverInterface {

    // Own properties of Gio-2.0.Gio.ProxyResolverInterface

    static name: string
}

interface RemoteActionGroupInterface {

    // Own fields of Gio-2.0.Gio.RemoteActionGroupInterface

    g_iface: GObject.TypeInterface
    activate_action_full: (remote: RemoteActionGroup, action_name: string | null, parameter: GLib.Variant | null, platform_data: GLib.Variant) => void
    change_action_state_full: (remote: RemoteActionGroup, action_name: string | null, value: GLib.Variant, platform_data: GLib.Variant) => void
}

/**
 * The virtual function table for #GRemoteActionGroup.
 * @record 
 */
abstract class RemoteActionGroupInterface {

    // Own properties of Gio-2.0.Gio.RemoteActionGroupInterface

    static name: string
}

interface ResolverClass {

    // Own fields of Gio-2.0.Gio.ResolverClass

    parent_class: GObject.ObjectClass
    reload: (resolver: Resolver) => void
    lookup_by_name: (resolver: Resolver, hostname: string | null, cancellable: Cancellable | null) => InetAddress[]
    lookup_by_name_async: (resolver: Resolver, hostname: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_by_name_finish: (resolver: Resolver, result: AsyncResult) => InetAddress[]
    lookup_by_address: (resolver: Resolver, address: InetAddress, cancellable: Cancellable | null) => string | null
    lookup_by_address_async: (resolver: Resolver, address: InetAddress, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_by_address_finish: (resolver: Resolver, result: AsyncResult) => string | null
    lookup_service_async: (resolver: Resolver, rrname: string | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_service_finish: (resolver: Resolver, result: AsyncResult) => SrvTarget[]
    lookup_records: (resolver: Resolver, rrname: string | null, record_type: ResolverRecordType, cancellable: Cancellable | null) => GLib.Variant[]
    lookup_records_async: (resolver: Resolver, rrname: string | null, record_type: ResolverRecordType, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_records_finish: (resolver: Resolver, result: AsyncResult) => GLib.Variant[]
    lookup_by_name_with_flags_async: (resolver: Resolver, hostname: string | null, flags: ResolverNameLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_by_name_with_flags_finish: (resolver: Resolver, result: AsyncResult) => InetAddress[]
    lookup_by_name_with_flags: (resolver: Resolver, hostname: string | null, flags: ResolverNameLookupFlags, cancellable: Cancellable | null) => InetAddress[]
}

abstract class ResolverClass {

    // Own properties of Gio-2.0.Gio.ResolverClass

    static name: string
}

interface ResolverPrivate {
}

class ResolverPrivate {

    // Own properties of Gio-2.0.Gio.ResolverPrivate

    static name: string
}

interface Resource {

    // Owm methods of Gio-2.0.Gio.Resource

    /**
     * Registers the resource with the process-global set of resources.
     * Once a resource is registered the files in it can be accessed
     * with the global resource lookup functions like g_resources_lookup_data().
     */
    _register(): void
    /**
     * Unregisters the resource from the process-global set of resources.
     */
    _unregister(): void
    /**
     * Returns all the names of children at the specified `path` in the resource.
     * The return result is a %NULL terminated list of strings which should
     * be released with g_strfreev().
     * 
     * If `path` is invalid or does not exist in the #GResource,
     * %G_RESOURCE_ERROR_NOT_FOUND will be returned.
     * 
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns an array of constant strings
     */
    enumerate_children(path: string | null, lookup_flags: ResourceLookupFlags): string[]
    /**
     * Looks for a file at the specified `path` in the resource and
     * if found returns information about it.
     * 
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns %TRUE if the file was found. %FALSE if there were errors
     */
    get_info(path: string | null, lookup_flags: ResourceLookupFlags): [ /* returnType */ boolean, /* size */ number, /* flags */ number ]
    /**
     * Looks for a file at the specified `path` in the resource and
     * returns a #GBytes that lets you directly access the data in
     * memory.
     * 
     * The data is always followed by a zero byte, so you
     * can safely use the data as a C string. However, that byte
     * is not included in the size of the GBytes.
     * 
     * For uncompressed resource files this is a pointer directly into
     * the resource bundle, which is typically in some readonly data section
     * in the program binary. For compressed files we allocate memory on
     * the heap and automatically uncompress the data.
     * 
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns #GBytes or %NULL on error.     Free the returned object with g_bytes_unref()
     */
    lookup_data(path: string | null, lookup_flags: ResourceLookupFlags): GLib.Bytes
    /**
     * Looks for a file at the specified `path` in the resource and
     * returns a #GInputStream that lets you read the data.
     * 
     * `lookup_flags` controls the behaviour of the lookup.
     * @param path A pathname inside the resource
     * @param lookup_flags A #GResourceLookupFlags
     * @returns #GInputStream or %NULL on error.     Free the returned object with g_object_unref()
     */
    open_stream(path: string | null, lookup_flags: ResourceLookupFlags): InputStream
    /**
     * Atomically increments the reference count of `resource` by one. This
     * function is MT-safe and may be called from any thread.
     * @returns The passed in #GResource
     */
    ref(): Resource
    /**
     * Atomically decrements the reference count of `resource` by one. If the
     * reference count drops to 0, all memory allocated by the resource is
     * released. This function is MT-safe and may be called from any
     * thread.
     */
    unref(): void
}

/**
 * Applications and libraries often contain binary or textual data that is
 * really part of the application, rather than user data. For instance
 * #GtkBuilder .ui files, splashscreen images, GMenu markup XML, CSS files,
 * icons, etc. These are often shipped as files in `$datadir/appname`, or
 * manually included as literal strings in the code.
 * 
 * The #GResource API and the [glib-compile-resources][glib-compile-resources] program
 * provide a convenient and efficient alternative to this which has some nice properties. You
 * maintain the files as normal files, so its easy to edit them, but during the build the files
 * are combined into a binary bundle that is linked into the executable. This means that loading
 * the resource files are efficient (as they are already in memory, shared with other instances) and
 * simple (no need to check for things like I/O errors or locate the files in the filesystem). It
 * also makes it easier to create relocatable applications.
 * 
 * Resource files can also be marked as compressed. Such files will be included in the resource bundle
 * in a compressed form, but will be automatically uncompressed when the resource is used. This
 * is very useful e.g. for larger text files that are parsed once (or rarely) and then thrown away.
 * 
 * Resource files can also be marked to be preprocessed, by setting the value of the
 * `preprocess` attribute to a comma-separated list of preprocessing options.
 * The only options currently supported are:
 * 
 * `xml-stripblanks` which will use the xmllint command
 * to strip ignorable whitespace from the XML file. For this to work,
 * the `XMLLINT` environment variable must be set to the full path to
 * the xmllint executable, or xmllint must be in the `PATH`; otherwise
 * the preprocessing step is skipped.
 * 
 * `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
 * `gdk-pixbuf-pixdata` command to convert images to the #GdkPixdata format,
 * which allows you to create pixbufs directly using the data inside the
 * resource file, rather than an (uncompressed) copy of it. For this, the
 * `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
 * `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
 * `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will abort.
 * `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as #GResource
 * supports embedding modern image formats just as well. Instead of using it,
 * embed a PNG or SVG file in your #GResource.
 * 
 * `json-stripblanks` which will use the `json-glib-format` command to strip
 * ignorable whitespace from the JSON file. For this to work, the
 * `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
 * `json-glib-format` executable, or it must be in the `PATH`;
 * otherwise the preprocessing step is skipped. In addition, at least version
 * 1.6 of `json-glib-format` is required.
 * 
 * Resource files will be exported in the GResource namespace using the
 * combination of the given `prefix` and the filename from the `file` element.
 * The `alias` attribute can be used to alter the filename to expose them at a
 * different location in the resource namespace. Typically, this is used to
 * include files from a different source directory without exposing the source
 * directory in the resource namespace, as in the example below.
 * 
 * Resource bundles are created by the [glib-compile-resources][glib-compile-resources] program
 * which takes an XML file that describes the bundle, and a set of files that the XML references. These
 * are combined into a binary resource bundle.
 * 
 * An example resource description:
 * 
 * ```
 * <?xml version="1.0" encoding="UTF-8"?>
 * <gresources>
 *   <gresource prefix="/org/gtk/Example">
 *     <file>data/splashscreen.png</file>
 *     <file compressed="true">dialog.ui</file>
 *     <file preprocess="xml-stripblanks">menumarkup.xml</file>
 *     <file alias="example.css">data/example.css</file>
 *   </gresource>
 * </gresources>
 * ```
 * 
 * 
 * This will create a resource bundle with the following files:
 * 
 * ```
 * /org/gtk/Example/data/splashscreen.png
 * /org/gtk/Example/dialog.ui
 * /org/gtk/Example/menumarkup.xml
 * /org/gtk/Example/example.css
 * ```
 * 
 * 
 * Note that all resources in the process share the same namespace, so use Java-style
 * path prefixes (like in the above example) to avoid conflicts.
 * 
 * You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
 * binary bundle that you can load with g_resource_load(). However, its more common to use the --generate-source and
 * --generate-header arguments to create a source file and header to link directly into your application.
 * This will generate `get_resource()`, `register_resource()` and
 * `unregister_resource()` functions, prefixed by the `--c-name` argument passed
 * to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
 * the generated #GResource object. The register and unregister functions
 * register the resource so its files can be accessed using
 * g_resources_lookup_data().
 * 
 * Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
 * using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
 * to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
 * the resource data.
 * 
 * Some higher-level APIs, such as #GtkApplication, will automatically load
 * resources from certain well-known paths in the resource namespace as a
 * convenience. See the documentation for those APIs for details.
 * 
 * There are two forms of the generated source, the default version uses the compiler support for constructor
 * and destructor functions (where available) to automatically create and register the #GResource on startup
 * or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
 * instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
 * even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)
 * 
 * Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
 * during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
 * when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
 * are for your own resources, and resource data is often used once, during parsing, and then released.
 * 
 * When debugging a program or testing a change to an installed version, it is often useful to be able to
 * replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
 * purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
 * resources with replacements from the filesystem.  It is a %G_SEARCHPATH_SEPARATOR-separated list of substitutions to perform
 * during resource lookups. It is ignored when running in a setuid process.
 * 
 * A substitution has the form
 * 
 * 
 * ```
 *    /org/gtk/libgtk=/home/desrt/gtk-overlay
 * ```
 * 
 * 
 * The part before the `=` is the resource subpath for which the overlay applies.  The part after is a
 * filesystem path which contains files and subdirectories as you would like to be loaded as resources with the
 * equivalent names.
 * 
 * In the example above, if an application tried to load a resource with the resource path
 * `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check the filesystem path
 * `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was found there, it would be used instead.  This is an
 * overlay, not an outright replacement, which means that if a file is not found at that path, the built-in
 * version will be used instead.  Whiteouts are not currently supported.
 * 
 * Substitutions must start with a slash, and must not contain a trailing slash before the '='.  The path after
 * the slash should ideally be absolute, but this is not strictly required.  It is possible to overlay the
 * location of a single resource with an individual file.
 * @record 
 */
class Resource {

    // Own properties of Gio-2.0.Gio.Resource

    static name: string

    // Constructors of Gio-2.0.Gio.Resource

    /**
     * Creates a GResource from a reference to the binary resource bundle.
     * This will keep a reference to `data` while the resource lives, so
     * the data should not be modified or freed.
     * 
     * If you want to use this resource in the global resource namespace you need
     * to register it with g_resources_register().
     * 
     * Note: `data` must be backed by memory that is at least pointer aligned.
     * Otherwise this function will internally create a copy of the memory since
     * GLib 2.56, or in older versions fail and exit the process.
     * 
     * If `data` is empty or corrupt, %G_RESOURCE_ERROR_INTERNAL will be returned.
     * @constructor 
     * @param data A #GBytes
     * @returns a new #GResource, or %NULL on error
     */
    static new_from_data(data: GLib.Bytes): Resource
    /**
     * Loads a binary resource bundle and creates a #GResource representation of it, allowing
     * you to query it for data.
     * 
     * If you want to use this resource in the global resource namespace you need
     * to register it with g_resources_register().
     * 
     * If `filename` is empty or the data in it is corrupt,
     * %G_RESOURCE_ERROR_INTERNAL will be returned. If `filename` doesn’t exist, or
     * there is an error in reading it, an error from g_mapped_file_new() will be
     * returned.
     * @param filename the path of a filename to load, in the GLib filename encoding
     * @returns a new #GResource, or %NULL on error
     */
    static load(filename: string): Resource
}

interface SeekableIface {

    // Own fields of Gio-2.0.Gio.SeekableIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    tell: (seekable: Seekable) => number
    can_seek: (seekable: Seekable) => boolean
    seek: (seekable: Seekable, offset: number, type: GLib.SeekType, cancellable: Cancellable | null) => boolean
    can_truncate: (seekable: Seekable) => boolean
    truncate_fn: (seekable: Seekable, offset: number, cancellable: Cancellable | null) => boolean
}

/**
 * Provides an interface for implementing seekable functionality on I/O Streams.
 * @record 
 */
abstract class SeekableIface {

    // Own properties of Gio-2.0.Gio.SeekableIface

    static name: string
}

interface SettingsBackendClass {

    // Own fields of Gio-2.0.Gio.SettingsBackendClass

    parent_class: GObject.ObjectClass
    read: (backend: SettingsBackend, key: string | null, expected_type: GLib.VariantType, default_value: boolean) => GLib.Variant
    get_writable: (backend: SettingsBackend, key: string | null) => boolean
    write: (backend: SettingsBackend, key: string | null, value: GLib.Variant, origin_tag: any | null) => boolean
    write_tree: (backend: SettingsBackend, tree: GLib.Tree, origin_tag: any | null) => boolean
    reset: (backend: SettingsBackend, key: string | null, origin_tag: any | null) => void
    subscribe: (backend: SettingsBackend, name: string | null) => void
    unsubscribe: (backend: SettingsBackend, name: string | null) => void
    sync: (backend: SettingsBackend) => void
    read_user_value: (backend: SettingsBackend, key: string | null, expected_type: GLib.VariantType) => GLib.Variant
}

/**
 * Class structure for #GSettingsBackend.
 * @record 
 */
abstract class SettingsBackendClass {

    // Own properties of Gio-2.0.Gio.SettingsBackendClass

    static name: string
}

interface SettingsBackendPrivate {
}

class SettingsBackendPrivate {

    // Own properties of Gio-2.0.Gio.SettingsBackendPrivate

    static name: string
}

interface SettingsClass {

    // Own fields of Gio-2.0.Gio.SettingsClass

    parent_class: GObject.ObjectClass
    writable_changed: (settings: Settings, key: string | null) => void
    changed: (settings: Settings, key: string | null) => void
    writable_change_event: (settings: Settings, key: GLib.Quark) => boolean
    change_event: (settings: Settings, keys: GLib.Quark, n_keys: number) => boolean
    padding: any[]
}

abstract class SettingsClass {

    // Own properties of Gio-2.0.Gio.SettingsClass

    static name: string
}

interface SettingsPrivate {
}

class SettingsPrivate {

    // Own properties of Gio-2.0.Gio.SettingsPrivate

    static name: string
}

interface SettingsSchema {

    // Owm methods of Gio-2.0.Gio.SettingsSchema

    /**
     * Get the ID of `schema`.
     * @returns the ID
     */
    get_id(): string | null
    /**
     * Gets the key named `name` from `schema`.
     * 
     * It is a programmer error to request a key that does not exist.  See
     * g_settings_schema_list_keys().
     * @param name the name of a key
     * @returns the #GSettingsSchemaKey for @name
     */
    get_key(name: string | null): SettingsSchemaKey
    /**
     * Gets the path associated with `schema,` or %NULL.
     * 
     * Schemas may be single-instance or relocatable.  Single-instance
     * schemas correspond to exactly one set of keys in the backend
     * database: those located at the path returned by this function.
     * 
     * Relocatable schemas can be referenced by other schemas and can
     * therefore describe multiple sets of keys at different locations.  For
     * relocatable schemas, this function will return %NULL.
     * @returns the path of the schema, or %NULL
     */
    get_path(): string | null
    /**
     * Checks if `schema` has a key named `name`.
     * @param name the name of a key
     * @returns %TRUE if such a key exists
     */
    has_key(name: string | null): boolean
    /**
     * Gets the list of children in `schema`.
     * 
     * You should free the return value with g_strfreev() when you are done
     * with it.
     * @returns a list of    the children on @settings, in no defined order
     */
    list_children(): string[]
    /**
     * Introspects the list of keys on `schema`.
     * 
     * You should probably not be calling this function from "normal" code
     * (since you should already know what keys are in your schema).  This
     * function is intended for introspection reasons.
     * @returns a list   of the keys on @schema, in no defined order
     */
    list_keys(): string[]
    /**
     * Increase the reference count of `schema,` returning a new reference.
     * @returns a new reference to @schema
     */
    ref(): SettingsSchema
    /**
     * Decrease the reference count of `schema,` possibly freeing it.
     */
    unref(): void
}

/**
 * The #GSettingsSchemaSource and #GSettingsSchema APIs provide a
 * mechanism for advanced control over the loading of schemas and a
 * mechanism for introspecting their content.
 * 
 * Plugin loading systems that wish to provide plugins a way to access
 * settings face the problem of how to make the schemas for these
 * settings visible to GSettings.  Typically, a plugin will want to ship
 * the schema along with itself and it won't be installed into the
 * standard system directories for schemas.
 * 
 * #GSettingsSchemaSource provides a mechanism for dealing with this by
 * allowing the creation of a new 'schema source' from which schemas can
 * be acquired.  This schema source can then become part of the metadata
 * associated with the plugin and queried whenever the plugin requires
 * access to some settings.
 * 
 * Consider the following example:
 * 
 * 
 * ```c
 * typedef struct
 * {
 *    ...
 *    GSettingsSchemaSource *schema_source;
 *    ...
 * } Plugin;
 * 
 * Plugin *
 * initialise_plugin (const gchar *dir)
 * {
 *   Plugin *plugin;
 * 
 *   ...
 * 
 *   plugin->schema_source =
 *     g_settings_schema_source_new_from_directory (dir,
 *       g_settings_schema_source_get_default (), FALSE, NULL);
 * 
 *   ...
 * 
 *   return plugin;
 * }
 * 
 * ...
 * 
 * GSettings *
 * plugin_get_settings (Plugin      *plugin,
 *                      const gchar *schema_id)
 * {
 *   GSettingsSchema *schema;
 * 
 *   if (schema_id == NULL)
 *     schema_id = plugin->identifier;
 * 
 *   schema = g_settings_schema_source_lookup (plugin->schema_source,
 *                                             schema_id, FALSE);
 * 
 *   if (schema == NULL)
 *     {
 *       ... disable the plugin or abort, etc ...
 *     }
 * 
 *   return g_settings_new_full (schema, NULL, NULL);
 * }
 * ```
 * 
 * 
 * The code above shows how hooks should be added to the code that
 * initialises (or enables) the plugin to create the schema source and
 * how an API can be added to the plugin system to provide a convenient
 * way for the plugin to access its settings, using the schemas that it
 * ships.
 * 
 * From the standpoint of the plugin, it would need to ensure that it
 * ships a gschemas.compiled file as part of itself, and then simply do
 * the following:
 * 
 * 
 * ```c
 * {
 *   GSettings *settings;
 *   gint some_value;
 * 
 *   settings = plugin_get_settings (self, NULL);
 *   some_value = g_settings_get_int (settings, "some-value");
 *   ...
 * }
 * ```
 * 
 * 
 * It's also possible that the plugin system expects the schema source
 * files (ie: .gschema.xml files) instead of a gschemas.compiled file.
 * In that case, the plugin loading system must compile the schemas for
 * itself before attempting to create the settings source.
 * @record 
 */
class SettingsSchema {

    // Own properties of Gio-2.0.Gio.SettingsSchema

    static name: string
}

interface SettingsSchemaKey {

    // Owm methods of Gio-2.0.Gio.SettingsSchemaKey

    /**
     * Gets the default value for `key`.
     * 
     * Note that this is the default value according to the schema.  System
     * administrator defaults and lockdown are not visible via this API.
     * @returns the default value for the key
     */
    get_default_value(): GLib.Variant
    /**
     * Gets the description for `key`.
     * 
     * If no description has been provided in the schema for `key,` returns
     * %NULL.
     * 
     * The description can be one sentence to several paragraphs in length.
     * Paragraphs are delimited with a double newline.  Descriptions can be
     * translated and the value returned from this function is is the
     * current locale.
     * 
     * This function is slow.  The summary and description information for
     * the schemas is not stored in the compiled schema database so this
     * function has to parse all of the source XML files in the schema
     * directory.
     * @returns the description for @key, or %NULL
     */
    get_description(): string | null
    /**
     * Gets the name of `key`.
     * @returns the name of @key.
     */
    get_name(): string | null
    /**
     * Queries the range of a key.
     * 
     * This function will return a #GVariant that fully describes the range
     * of values that are valid for `key`.
     * 
     * The type of #GVariant returned is `(sv)`. The string describes
     * the type of range restriction in effect. The type and meaning of
     * the value contained in the variant depends on the string.
     * 
     * If the string is `'type'` then the variant contains an empty array.
     * The element type of that empty array is the expected type of value
     * and all values of that type are valid.
     * 
     * If the string is `'enum'` then the variant contains an array
     * enumerating the possible values. Each item in the array is
     * a possible valid value and no other values are valid.
     * 
     * If the string is `'flags'` then the variant contains an array. Each
     * item in the array is a value that may appear zero or one times in an
     * array to be used as the value for this key. For example, if the
     * variant contained the array `['x', 'y']` then the valid values for
     * the key would be `[]`, `['x']`, `['y']`, `['x', 'y']` and
     * `['y', 'x']`.
     * 
     * Finally, if the string is `'range'` then the variant contains a pair
     * of like-typed values -- the minimum and maximum permissible values
     * for this key.
     * 
     * This information should not be used by normal programs.  It is
     * considered to be a hint for introspection purposes.  Normal programs
     * should already know what is permitted by their own schema.  The
     * format may change in any way in the future -- but particularly, new
     * forms may be added to the possibilities described above.
     * 
     * You should free the returned value with g_variant_unref() when it is
     * no longer needed.
     * @returns a #GVariant describing the range
     */
    get_range(): GLib.Variant
    /**
     * Gets the summary for `key`.
     * 
     * If no summary has been provided in the schema for `key,` returns
     * %NULL.
     * 
     * The summary is a short description of the purpose of the key; usually
     * one short sentence.  Summaries can be translated and the value
     * returned from this function is is the current locale.
     * 
     * This function is slow.  The summary and description information for
     * the schemas is not stored in the compiled schema database so this
     * function has to parse all of the source XML files in the schema
     * directory.
     * @returns the summary for @key, or %NULL
     */
    get_summary(): string | null
    /**
     * Gets the #GVariantType of `key`.
     * @returns the type of @key
     */
    get_value_type(): GLib.VariantType
    /**
     * Checks if the given `value` is within the
     * permitted range for `key`.
     * 
     * It is a programmer error if `value` is not of the correct type — you
     * must check for this first.
     * @param value the value to check
     * @returns %TRUE if @value is valid for @key
     */
    range_check(value: GLib.Variant): boolean
    /**
     * Increase the reference count of `key,` returning a new reference.
     * @returns a new reference to @key
     */
    ref(): SettingsSchemaKey
    /**
     * Decrease the reference count of `key,` possibly freeing it.
     */
    unref(): void
}

/**
 * #GSettingsSchemaKey is an opaque data structure and can only be accessed
 * using the following functions.
 * @record 
 */
class SettingsSchemaKey {

    // Own properties of Gio-2.0.Gio.SettingsSchemaKey

    static name: string
}

interface SettingsSchemaSource {

    // Owm methods of Gio-2.0.Gio.SettingsSchemaSource

    /**
     * Lists the schemas in a given source.
     * 
     * If `recursive` is %TRUE then include parent sources.  If %FALSE then
     * only include the schemas from one source (ie: one directory).  You
     * probably want %TRUE.
     * 
     * Non-relocatable schemas are those for which you can call
     * g_settings_new().  Relocatable schemas are those for which you must
     * use g_settings_new_with_path().
     * 
     * Do not call this function from normal programs.  This is designed for
     * use by database editors, commandline tools, etc.
     * @param recursive if we should recurse
     */
    list_schemas(recursive: boolean): [ /* non_relocatable */ string[], /* relocatable */ string[] ]
    /**
     * Looks up a schema with the identifier `schema_id` in `source`.
     * 
     * This function is not required for normal uses of #GSettings but it
     * may be useful to authors of plugin management systems or to those who
     * want to introspect the content of schemas.
     * 
     * If the schema isn't found directly in `source` and `recursive` is %TRUE
     * then the parent sources will also be checked.
     * 
     * If the schema isn't found, %NULL is returned.
     * @param schema_id a schema ID
     * @param recursive %TRUE if the lookup should be recursive
     * @returns a new #GSettingsSchema
     */
    lookup(schema_id: string | null, recursive: boolean): SettingsSchema | null
    /**
     * Increase the reference count of `source,` returning a new reference.
     * @returns a new reference to @source
     */
    ref(): SettingsSchemaSource
    /**
     * Decrease the reference count of `source,` possibly freeing it.
     */
    unref(): void
}

/**
 * This is an opaque structure type.  You may not access it directly.
 * @record 
 */
class SettingsSchemaSource {

    // Own properties of Gio-2.0.Gio.SettingsSchemaSource

    static name: string

    // Constructors of Gio-2.0.Gio.SettingsSchemaSource

    /**
     * Attempts to create a new schema source corresponding to the contents
     * of the given directory.
     * 
     * This function is not required for normal uses of #GSettings but it
     * may be useful to authors of plugin management systems.
     * 
     * The directory should contain a file called `gschemas.compiled` as
     * produced by the [glib-compile-schemas][glib-compile-schemas] tool.
     * 
     * If `trusted` is %TRUE then `gschemas.compiled` is trusted not to be
     * corrupted. This assumption has a performance advantage, but can result
     * in crashes or inconsistent behaviour in the case of a corrupted file.
     * Generally, you should set `trusted` to %TRUE for files installed by the
     * system and to %FALSE for files in the home directory.
     * 
     * In either case, an empty file or some types of corruption in the file will
     * result in %G_FILE_ERROR_INVAL being returned.
     * 
     * If `parent` is non-%NULL then there are two effects.
     * 
     * First, if g_settings_schema_source_lookup() is called with the
     * `recursive` flag set to %TRUE and the schema can not be found in the
     * source, the lookup will recurse to the parent.
     * 
     * Second, any references to other schemas specified within this
     * source (ie: `child` or `extends`) references may be resolved
     * from the `parent`.
     * 
     * For this second reason, except in very unusual situations, the
     * `parent` should probably be given as the default schema source, as
     * returned by g_settings_schema_source_get_default().
     * @constructor 
     * @param directory the filename of a directory
     * @param parent a #GSettingsSchemaSource, or %NULL
     * @param trusted %TRUE, if the directory is trusted
     */
    static new_from_directory(directory: string, parent: SettingsSchemaSource | null, trusted: boolean): SettingsSchemaSource
    /**
     * Gets the default system schema source.
     * 
     * This function is not required for normal uses of #GSettings but it
     * may be useful to authors of plugin management systems or to those who
     * want to introspect the content of schemas.
     * 
     * If no schemas are installed, %NULL will be returned.
     * 
     * The returned source may actually consist of multiple schema sources
     * from different directories, depending on which directories were given
     * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
     * lookups performed against the default source should probably be done
     * recursively.
     * @returns the default schema source
     */
    static get_default(): SettingsSchemaSource | null
}

interface SimpleActionGroupClass {
}

abstract class SimpleActionGroupClass {

    // Own properties of Gio-2.0.Gio.SimpleActionGroupClass

    static name: string
}

interface SimpleActionGroupPrivate {
}

class SimpleActionGroupPrivate {

    // Own properties of Gio-2.0.Gio.SimpleActionGroupPrivate

    static name: string
}

interface SimpleAsyncResultClass {
}

abstract class SimpleAsyncResultClass {

    // Own properties of Gio-2.0.Gio.SimpleAsyncResultClass

    static name: string
}

interface SimpleProxyResolverClass {

    // Own fields of Gio-2.0.Gio.SimpleProxyResolverClass

    parent_class: GObject.ObjectClass
}

abstract class SimpleProxyResolverClass {

    // Own properties of Gio-2.0.Gio.SimpleProxyResolverClass

    static name: string
}

interface SimpleProxyResolverPrivate {
}

class SimpleProxyResolverPrivate {

    // Own properties of Gio-2.0.Gio.SimpleProxyResolverPrivate

    static name: string
}

interface SocketAddressClass {

    // Own fields of Gio-2.0.Gio.SocketAddressClass

    parent_class: GObject.ObjectClass
    get_family: (address: SocketAddress) => SocketFamily
    get_native_size: (address: SocketAddress) => number
    to_native: (address: SocketAddress, dest: any | null, destlen: number) => boolean
}

abstract class SocketAddressClass {

    // Own properties of Gio-2.0.Gio.SocketAddressClass

    static name: string
}

interface SocketAddressEnumeratorClass {

    // Own fields of Gio-2.0.Gio.SocketAddressEnumeratorClass

    next: (enumerator: SocketAddressEnumerator, cancellable: Cancellable | null) => SocketAddress | null
    next_async: (enumerator: SocketAddressEnumerator, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    next_finish: (enumerator: SocketAddressEnumerator, result: AsyncResult) => SocketAddress | null
}

/**
 * Class structure for #GSocketAddressEnumerator.
 * @record 
 */
abstract class SocketAddressEnumeratorClass {

    // Own properties of Gio-2.0.Gio.SocketAddressEnumeratorClass

    static name: string
}

interface SocketClass {

    // Own fields of Gio-2.0.Gio.SocketClass

    parent_class: GObject.ObjectClass
}

abstract class SocketClass {

    // Own properties of Gio-2.0.Gio.SocketClass

    static name: string
}

interface SocketClientClass {

    // Own fields of Gio-2.0.Gio.SocketClientClass

    parent_class: GObject.ObjectClass
    event: (client: SocketClient, event: SocketClientEvent, connectable: SocketConnectable, connection: IOStream) => void
}

abstract class SocketClientClass {

    // Own properties of Gio-2.0.Gio.SocketClientClass

    static name: string
}

interface SocketClientPrivate {
}

class SocketClientPrivate {

    // Own properties of Gio-2.0.Gio.SocketClientPrivate

    static name: string
}

interface SocketConnectableIface {

    // Own fields of Gio-2.0.Gio.SocketConnectableIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    enumerate: (connectable: SocketConnectable) => SocketAddressEnumerator
    proxy_enumerate: (connectable: SocketConnectable) => SocketAddressEnumerator
    to_string: (connectable: SocketConnectable) => string | null
}

/**
 * Provides an interface for returning a #GSocketAddressEnumerator
 * and #GProxyAddressEnumerator
 * @record 
 */
abstract class SocketConnectableIface {

    // Own properties of Gio-2.0.Gio.SocketConnectableIface

    static name: string
}

interface SocketConnectionClass {

    // Own fields of Gio-2.0.Gio.SocketConnectionClass

    parent_class: IOStreamClass
}

abstract class SocketConnectionClass {

    // Own properties of Gio-2.0.Gio.SocketConnectionClass

    static name: string
}

interface SocketConnectionPrivate {
}

class SocketConnectionPrivate {

    // Own properties of Gio-2.0.Gio.SocketConnectionPrivate

    static name: string
}

interface SocketControlMessageClass {

    // Own fields of Gio-2.0.Gio.SocketControlMessageClass

    parent_class: GObject.ObjectClass
    get_size: (message: SocketControlMessage) => number
    get_level: (message: SocketControlMessage) => number
    get_type: (message: SocketControlMessage) => number
    serialize: (message: SocketControlMessage, data: any) => void
}

/**
 * Class structure for #GSocketControlMessage.
 * @record 
 */
abstract class SocketControlMessageClass {

    // Own properties of Gio-2.0.Gio.SocketControlMessageClass

    static name: string
}

interface SocketControlMessagePrivate {
}

class SocketControlMessagePrivate {

    // Own properties of Gio-2.0.Gio.SocketControlMessagePrivate

    static name: string
}

interface SocketListenerClass {

    // Own fields of Gio-2.0.Gio.SocketListenerClass

    parent_class: GObject.ObjectClass
    changed: (listener: SocketListener) => void
    event: (listener: SocketListener, event: SocketListenerEvent, socket: Socket) => void
}

/**
 * Class structure for #GSocketListener.
 * @record 
 */
abstract class SocketListenerClass {

    // Own properties of Gio-2.0.Gio.SocketListenerClass

    static name: string
}

interface SocketListenerPrivate {
}

class SocketListenerPrivate {

    // Own properties of Gio-2.0.Gio.SocketListenerPrivate

    static name: string
}

interface SocketPrivate {
}

class SocketPrivate {

    // Own properties of Gio-2.0.Gio.SocketPrivate

    static name: string
}

interface SocketServiceClass {

    // Own fields of Gio-2.0.Gio.SocketServiceClass

    parent_class: SocketListenerClass
    incoming: (service: SocketService, connection: SocketConnection, source_object: GObject.Object) => boolean
}

/**
 * Class structure for #GSocketService.
 * @record 
 */
abstract class SocketServiceClass {

    // Own properties of Gio-2.0.Gio.SocketServiceClass

    static name: string
}

interface SocketServicePrivate {
}

class SocketServicePrivate {

    // Own properties of Gio-2.0.Gio.SocketServicePrivate

    static name: string
}

interface SrvTarget {

    // Owm methods of Gio-2.0.Gio.SrvTarget

    /**
     * Copies `target`
     * @returns a copy of @target
     */
    copy(): SrvTarget
    /**
     * Frees `target`
     */
    free(): void
    /**
     * Gets `target'`s hostname (in ASCII form; if you are going to present
     * this to the user, you should use g_hostname_is_ascii_encoded() to
     * check if it contains encoded Unicode segments, and use
     * g_hostname_to_unicode() to convert it if it does.)
     * @returns @target's hostname
     */
    get_hostname(): string | null
    /**
     * Gets `target'`s port
     * @returns @target's port
     */
    get_port(): number
    /**
     * Gets `target'`s priority. You should not need to look at this;
     * #GResolver already sorts the targets according to the algorithm in
     * RFC 2782.
     * @returns @target's priority
     */
    get_priority(): number
    /**
     * Gets `target'`s weight. You should not need to look at this;
     * #GResolver already sorts the targets according to the algorithm in
     * RFC 2782.
     * @returns @target's weight
     */
    get_weight(): number
}

/**
 * SRV (service) records are used by some network protocols to provide
 * service-specific aliasing and load-balancing. For example, XMPP
 * (Jabber) uses SRV records to locate the XMPP server for a domain;
 * rather than connecting directly to "example.com" or assuming a
 * specific server hostname like "xmpp.example.com", an XMPP client
 * would look up the "xmpp-client" SRV record for "example.com", and
 * then connect to whatever host was pointed to by that record.
 * 
 * You can use g_resolver_lookup_service() or
 * g_resolver_lookup_service_async() to find the #GSrvTargets
 * for a given service. However, if you are simply planning to connect
 * to the remote service, you can use #GNetworkService's
 * #GSocketConnectable interface and not need to worry about
 * #GSrvTarget at all.
 * @record 
 */
class SrvTarget {

    // Own properties of Gio-2.0.Gio.SrvTarget

    static name: string

    // Constructors of Gio-2.0.Gio.SrvTarget

    /**
     * Creates a new #GSrvTarget with the given parameters.
     * 
     * You should not need to use this; normally #GSrvTargets are
     * created by #GResolver.
     * @constructor 
     * @param hostname the host that the service is running on
     * @param port the port that the service is running on
     * @param priority the target's priority
     * @param weight the target's weight
     * @returns a new #GSrvTarget.
     */
    constructor(hostname: string | null, port: number, priority: number, weight: number) 
    /**
     * Creates a new #GSrvTarget with the given parameters.
     * 
     * You should not need to use this; normally #GSrvTargets are
     * created by #GResolver.
     * @constructor 
     * @param hostname the host that the service is running on
     * @param port the port that the service is running on
     * @param priority the target's priority
     * @param weight the target's weight
     * @returns a new #GSrvTarget.
     */
    static new(hostname: string | null, port: number, priority: number, weight: number): SrvTarget
}

interface StaticResource {

    // Owm methods of Gio-2.0.Gio.StaticResource

    /**
     * Finalized a GResource initialized by g_static_resource_init().
     * 
     * This is normally used by code generated by
     * [glib-compile-resources][glib-compile-resources]
     * and is not typically used by other code.
     */
    fini(): void
    /**
     * Gets the GResource that was registered by a call to g_static_resource_init().
     * 
     * This is normally used by code generated by
     * [glib-compile-resources][glib-compile-resources]
     * and is not typically used by other code.
     * @returns a #GResource
     */
    get_resource(): Resource
    /**
     * Initializes a GResource from static data using a
     * GStaticResource.
     * 
     * This is normally used by code generated by
     * [glib-compile-resources][glib-compile-resources]
     * and is not typically used by other code.
     */
    init(): void
}

/**
 * #GStaticResource is an opaque data structure and can only be accessed
 * using the following functions.
 * @record 
 */
class StaticResource {

    // Own properties of Gio-2.0.Gio.StaticResource

    static name: string
}

interface TaskClass {
}

abstract class TaskClass {

    // Own properties of Gio-2.0.Gio.TaskClass

    static name: string
}

interface TcpConnectionClass {

    // Own fields of Gio-2.0.Gio.TcpConnectionClass

    parent_class: SocketConnectionClass
}

abstract class TcpConnectionClass {

    // Own properties of Gio-2.0.Gio.TcpConnectionClass

    static name: string
}

interface TcpConnectionPrivate {
}

class TcpConnectionPrivate {

    // Own properties of Gio-2.0.Gio.TcpConnectionPrivate

    static name: string
}

interface TcpWrapperConnectionClass {

    // Own fields of Gio-2.0.Gio.TcpWrapperConnectionClass

    parent_class: TcpConnectionClass
}

abstract class TcpWrapperConnectionClass {

    // Own properties of Gio-2.0.Gio.TcpWrapperConnectionClass

    static name: string
}

interface TcpWrapperConnectionPrivate {
}

class TcpWrapperConnectionPrivate {

    // Own properties of Gio-2.0.Gio.TcpWrapperConnectionPrivate

    static name: string
}

interface ThemedIconClass {
}

abstract class ThemedIconClass {

    // Own properties of Gio-2.0.Gio.ThemedIconClass

    static name: string
}

interface ThreadedSocketServiceClass {

    // Own fields of Gio-2.0.Gio.ThreadedSocketServiceClass

    parent_class: SocketServiceClass
    run: (service: ThreadedSocketService, connection: SocketConnection, source_object: GObject.Object) => boolean
}

abstract class ThreadedSocketServiceClass {

    // Own properties of Gio-2.0.Gio.ThreadedSocketServiceClass

    static name: string
}

interface ThreadedSocketServicePrivate {
}

class ThreadedSocketServicePrivate {

    // Own properties of Gio-2.0.Gio.ThreadedSocketServicePrivate

    static name: string
}

interface TlsBackendInterface {

    // Own fields of Gio-2.0.Gio.TlsBackendInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    supports_tls: (backend: TlsBackend) => boolean
    get_certificate_type: () => GObject.GType
    get_client_connection_type: () => GObject.GType
    get_server_connection_type: () => GObject.GType
    get_file_database_type: () => GObject.GType
    get_default_database: (backend: TlsBackend) => TlsDatabase
    supports_dtls: (backend: TlsBackend) => boolean
    get_dtls_client_connection_type: () => GObject.GType
    get_dtls_server_connection_type: () => GObject.GType
}

/**
 * Provides an interface for describing TLS-related types.
 * @record 
 */
abstract class TlsBackendInterface {

    // Own properties of Gio-2.0.Gio.TlsBackendInterface

    static name: string
}

interface TlsCertificateClass {

    // Own fields of Gio-2.0.Gio.TlsCertificateClass

    parent_class: GObject.ObjectClass
    verify: (cert: TlsCertificate, identity: SocketConnectable | null, trusted_ca: TlsCertificate | null) => TlsCertificateFlags
}

abstract class TlsCertificateClass {

    // Own properties of Gio-2.0.Gio.TlsCertificateClass

    static name: string
}

interface TlsCertificatePrivate {
}

class TlsCertificatePrivate {

    // Own properties of Gio-2.0.Gio.TlsCertificatePrivate

    static name: string
}

interface TlsClientConnectionInterface {

    // Own fields of Gio-2.0.Gio.TlsClientConnectionInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    copy_session_state: (conn: TlsClientConnection, source: TlsClientConnection) => void
}

/**
 * vtable for a #GTlsClientConnection implementation.
 * @record 
 */
abstract class TlsClientConnectionInterface {

    // Own properties of Gio-2.0.Gio.TlsClientConnectionInterface

    static name: string
}

interface TlsConnectionClass {

    // Own fields of Gio-2.0.Gio.TlsConnectionClass

    /**
     * The parent class.
     * @field 
     */
    parent_class: IOStreamClass
    accept_certificate: (connection: TlsConnection, peer_cert: TlsCertificate, errors: TlsCertificateFlags) => boolean
    handshake: (conn: TlsConnection, cancellable: Cancellable | null) => boolean
    handshake_async: (conn: TlsConnection, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    handshake_finish: (conn: TlsConnection, result: AsyncResult) => boolean
    get_binding_data: (conn: TlsConnection, type: TlsChannelBindingType, data: Uint8Array) => boolean
    get_negotiated_protocol: (conn: TlsConnection) => string | null
}

/**
 * The class structure for the #GTlsConnection type.
 * @record 
 */
abstract class TlsConnectionClass {

    // Own properties of Gio-2.0.Gio.TlsConnectionClass

    static name: string
}

interface TlsConnectionPrivate {
}

class TlsConnectionPrivate {

    // Own properties of Gio-2.0.Gio.TlsConnectionPrivate

    static name: string
}

interface TlsDatabaseClass {

    // Own fields of Gio-2.0.Gio.TlsDatabaseClass

    parent_class: GObject.ObjectClass
    verify_chain: (self: TlsDatabase, chain: TlsCertificate, purpose: string | null, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable: Cancellable | null) => TlsCertificateFlags
    verify_chain_async: (self: TlsDatabase, chain: TlsCertificate, purpose: string | null, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    verify_chain_finish: (self: TlsDatabase, result: AsyncResult) => TlsCertificateFlags
    create_certificate_handle: (self: TlsDatabase, certificate: TlsCertificate) => string | null
    lookup_certificate_for_handle: (self: TlsDatabase, handle: string | null, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null) => TlsCertificate | null
    lookup_certificate_for_handle_async: (self: TlsDatabase, handle: string | null, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_certificate_for_handle_finish: (self: TlsDatabase, result: AsyncResult) => TlsCertificate
    lookup_certificate_issuer: (self: TlsDatabase, certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null) => TlsCertificate
    lookup_certificate_issuer_async: (self: TlsDatabase, certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_certificate_issuer_finish: (self: TlsDatabase, result: AsyncResult) => TlsCertificate
    lookup_certificates_issued_by: (self: TlsDatabase, issuer_raw_dn: Uint8Array, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null) => TlsCertificate[]
    lookup_certificates_issued_by_async: (self: TlsDatabase, issuer_raw_dn: Uint8Array, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    lookup_certificates_issued_by_finish: (self: TlsDatabase, result: AsyncResult) => TlsCertificate[]
}

/**
 * The class for #GTlsDatabase. Derived classes should implement the various
 * virtual methods. _async and _finish methods have a default
 * implementation that runs the corresponding sync method in a thread.
 * @record 
 */
abstract class TlsDatabaseClass {

    // Own properties of Gio-2.0.Gio.TlsDatabaseClass

    static name: string
}

interface TlsDatabasePrivate {
}

class TlsDatabasePrivate {

    // Own properties of Gio-2.0.Gio.TlsDatabasePrivate

    static name: string
}

interface TlsFileDatabaseInterface {

    // Own fields of Gio-2.0.Gio.TlsFileDatabaseInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
}

/**
 * Provides an interface for #GTlsFileDatabase implementations.
 * @record 
 */
abstract class TlsFileDatabaseInterface {

    // Own properties of Gio-2.0.Gio.TlsFileDatabaseInterface

    static name: string
}

interface TlsInteractionClass {

    // Own fields of Gio-2.0.Gio.TlsInteractionClass

    ask_password: (interaction: TlsInteraction, password: TlsPassword, cancellable: Cancellable | null) => TlsInteractionResult
    ask_password_async: (interaction: TlsInteraction, password: TlsPassword, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    ask_password_finish: (interaction: TlsInteraction, result: AsyncResult) => TlsInteractionResult
    request_certificate: (interaction: TlsInteraction, connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | null) => TlsInteractionResult
    request_certificate_async: (interaction: TlsInteraction, connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    request_certificate_finish: (interaction: TlsInteraction, result: AsyncResult) => TlsInteractionResult
}

/**
 * The class for #GTlsInteraction. Derived classes implement the various
 * virtual interaction methods to handle TLS interactions.
 * 
 * Derived classes can choose to implement whichever interactions methods they'd
 * like to support by overriding those virtual methods in their class
 * initialization function. If a derived class implements an async method,
 * it must also implement the corresponding finish method.
 * 
 * The synchronous interaction methods should implement to display modal dialogs,
 * and the asynchronous methods to display modeless dialogs.
 * 
 * If the user cancels an interaction, then the result should be
 * %G_TLS_INTERACTION_FAILED and the error should be set with a domain of
 * %G_IO_ERROR and code of %G_IO_ERROR_CANCELLED.
 * @record 
 */
abstract class TlsInteractionClass {

    // Own properties of Gio-2.0.Gio.TlsInteractionClass

    static name: string
}

interface TlsInteractionPrivate {
}

class TlsInteractionPrivate {

    // Own properties of Gio-2.0.Gio.TlsInteractionPrivate

    static name: string
}

interface TlsPasswordClass {

    // Own fields of Gio-2.0.Gio.TlsPasswordClass

    parent_class: GObject.ObjectClass
    get_value: (password: TlsPassword) => Uint8Array
    set_value: (password: TlsPassword, value: Uint8Array, destroy: GLib.DestroyNotify | null) => void
    get_default_warning: (password: TlsPassword) => string | null
}

/**
 * Class structure for #GTlsPassword.
 * @record 
 */
abstract class TlsPasswordClass {

    // Own properties of Gio-2.0.Gio.TlsPasswordClass

    static name: string
}

interface TlsPasswordPrivate {
}

class TlsPasswordPrivate {

    // Own properties of Gio-2.0.Gio.TlsPasswordPrivate

    static name: string
}

interface TlsServerConnectionInterface {

    // Own fields of Gio-2.0.Gio.TlsServerConnectionInterface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
}

/**
 * vtable for a #GTlsServerConnection implementation.
 * @record 
 */
abstract class TlsServerConnectionInterface {

    // Own properties of Gio-2.0.Gio.TlsServerConnectionInterface

    static name: string
}

interface UnixConnectionClass {

    // Own fields of Gio-2.0.Gio.UnixConnectionClass

    parent_class: SocketConnectionClass
}

abstract class UnixConnectionClass {

    // Own properties of Gio-2.0.Gio.UnixConnectionClass

    static name: string
}

interface UnixConnectionPrivate {
}

class UnixConnectionPrivate {

    // Own properties of Gio-2.0.Gio.UnixConnectionPrivate

    static name: string
}

interface UnixCredentialsMessageClass {

    // Own fields of Gio-2.0.Gio.UnixCredentialsMessageClass

    parent_class: SocketControlMessageClass
}

/**
 * Class structure for #GUnixCredentialsMessage.
 * @record 
 */
abstract class UnixCredentialsMessageClass {

    // Own properties of Gio-2.0.Gio.UnixCredentialsMessageClass

    static name: string
}

interface UnixCredentialsMessagePrivate {
}

class UnixCredentialsMessagePrivate {

    // Own properties of Gio-2.0.Gio.UnixCredentialsMessagePrivate

    static name: string
}

interface UnixFDListClass {

    // Own fields of Gio-2.0.Gio.UnixFDListClass

    parent_class: GObject.ObjectClass
}

abstract class UnixFDListClass {

    // Own properties of Gio-2.0.Gio.UnixFDListClass

    static name: string
}

interface UnixFDListPrivate {
}

class UnixFDListPrivate {

    // Own properties of Gio-2.0.Gio.UnixFDListPrivate

    static name: string
}

interface UnixFDMessageClass {

    // Own fields of Gio-2.0.Gio.UnixFDMessageClass

    parent_class: SocketControlMessageClass
}

abstract class UnixFDMessageClass {

    // Own properties of Gio-2.0.Gio.UnixFDMessageClass

    static name: string
}

interface UnixFDMessagePrivate {
}

class UnixFDMessagePrivate {

    // Own properties of Gio-2.0.Gio.UnixFDMessagePrivate

    static name: string
}

interface UnixInputStreamClass {

    // Own fields of Gio-2.0.Gio.UnixInputStreamClass

    parent_class: InputStreamClass
}

abstract class UnixInputStreamClass {

    // Own properties of Gio-2.0.Gio.UnixInputStreamClass

    static name: string
}

interface UnixInputStreamPrivate {
}

class UnixInputStreamPrivate {

    // Own properties of Gio-2.0.Gio.UnixInputStreamPrivate

    static name: string
}

interface UnixMountEntry {
}

/**
 * Defines a Unix mount entry (e.g. <filename>/media/cdrom</filename>).
 * This corresponds roughly to a mtab entry.
 * @record 
 */
class UnixMountEntry {

    // Own properties of Gio-2.0.Gio.UnixMountEntry

    static name: string
}

interface UnixMountMonitorClass {
}

abstract class UnixMountMonitorClass {

    // Own properties of Gio-2.0.Gio.UnixMountMonitorClass

    static name: string
}

interface UnixMountPoint {

    // Owm methods of Gio-2.0.Gio.UnixMountPoint

    /**
     * Compares two unix mount points.
     * @param mount2 a #GUnixMount.
     * @returns 1, 0 or -1 if @mount1 is greater than, equal to, or less than @mount2, respectively.
     */
    compare(mount2: UnixMountPoint): number
    /**
     * Makes a copy of `mount_point`.
     * @returns a new #GUnixMountPoint
     */
    copy(): UnixMountPoint
    /**
     * Frees a unix mount point.
     */
    free(): void
    /**
     * Gets the device path for a unix mount point.
     * @returns a string containing the device path.
     */
    get_device_path(): string
    /**
     * Gets the file system type for the mount point.
     * @returns a string containing the file system type.
     */
    get_fs_type(): string | null
    /**
     * Gets the mount path for a unix mount point.
     * @returns a string containing the mount path.
     */
    get_mount_path(): string
    /**
     * Gets the options for the mount point.
     * @returns a string containing the options.
     */
    get_options(): string | null
    /**
     * Guesses whether a Unix mount point can be ejected.
     * @returns %TRUE if @mount_point is deemed to be ejectable.
     */
    guess_can_eject(): boolean
    /**
     * Guesses the icon of a Unix mount point.
     * @returns a #GIcon
     */
    guess_icon(): Icon
    /**
     * Guesses the name of a Unix mount point.
     * The result is a translated string.
     * @returns A newly allocated string that must     be freed with g_free()
     */
    guess_name(): string | null
    /**
     * Guesses the symbolic icon of a Unix mount point.
     * @returns a #GIcon
     */
    guess_symbolic_icon(): Icon
    /**
     * Checks if a unix mount point is a loopback device.
     * @returns %TRUE if the mount point is a loopback. %FALSE otherwise.
     */
    is_loopback(): boolean
    /**
     * Checks if a unix mount point is read only.
     * @returns %TRUE if a mount point is read only.
     */
    is_readonly(): boolean
    /**
     * Checks if a unix mount point is mountable by the user.
     * @returns %TRUE if the mount point is user mountable.
     */
    is_user_mountable(): boolean
}

/**
 * Defines a Unix mount point (e.g. <filename>/dev</filename>).
 * This corresponds roughly to a fstab entry.
 * @record 
 */
class UnixMountPoint {

    // Own properties of Gio-2.0.Gio.UnixMountPoint

    static name: string

    // Constructors of Gio-2.0.Gio.UnixMountPoint

    /**
     * Gets a #GUnixMountPoint for a given mount path. If `time_read` is set, it
     * will be filled with a unix timestamp for checking if the mount points have
     * changed since with g_unix_mount_points_changed_since().
     * 
     * If more mount points have the same mount path, the last matching mount point
     * is returned.
     * @param mount_path path for a possible unix mount point.
     * @returns a #GUnixMountPoint, or %NULL if no match is found.
     */
    static at(mount_path: string): [ /* returnType */ UnixMountPoint | null, /* time_read */ number ]
}

interface UnixOutputStreamClass {

    // Own fields of Gio-2.0.Gio.UnixOutputStreamClass

    parent_class: OutputStreamClass
}

abstract class UnixOutputStreamClass {

    // Own properties of Gio-2.0.Gio.UnixOutputStreamClass

    static name: string
}

interface UnixOutputStreamPrivate {
}

class UnixOutputStreamPrivate {

    // Own properties of Gio-2.0.Gio.UnixOutputStreamPrivate

    static name: string
}

interface UnixSocketAddressClass {

    // Own fields of Gio-2.0.Gio.UnixSocketAddressClass

    parent_class: SocketAddressClass
}

abstract class UnixSocketAddressClass {

    // Own properties of Gio-2.0.Gio.UnixSocketAddressClass

    static name: string
}

interface UnixSocketAddressPrivate {
}

class UnixSocketAddressPrivate {

    // Own properties of Gio-2.0.Gio.UnixSocketAddressPrivate

    static name: string
}

interface VfsClass {

    // Own fields of Gio-2.0.Gio.VfsClass

    parent_class: GObject.ObjectClass
    is_active: (vfs: Vfs) => boolean
    get_file_for_path: (vfs: Vfs, path: string | null) => File
    get_file_for_uri: (vfs: Vfs, uri: string | null) => File
    get_supported_uri_schemes: (vfs: Vfs) => string[]
    parse_name: (vfs: Vfs, parse_name: string | null) => File
    local_file_add_info: (vfs: Vfs, filename: string | null, device: number, attribute_matcher: FileAttributeMatcher, info: FileInfo, cancellable: Cancellable | null, extra_data: any | null, free_extra_data: GLib.DestroyNotify) => void
    add_writable_namespaces: (vfs: Vfs, list: FileAttributeInfoList) => void
    local_file_set_attributes: (vfs: Vfs, filename: string | null, info: FileInfo, flags: FileQueryInfoFlags, cancellable: Cancellable | null) => boolean
    local_file_removed: (vfs: Vfs, filename: string | null) => void
    local_file_moved: (vfs: Vfs, source: string | null, dest: string | null) => void
}

abstract class VfsClass {

    // Own properties of Gio-2.0.Gio.VfsClass

    static name: string
}

interface VolumeIface {

    // Own fields of Gio-2.0.Gio.VolumeIface

    /**
     * The parent interface.
     * @field 
     */
    g_iface: GObject.TypeInterface
    changed: (volume: Volume) => void
    removed: (volume: Volume) => void
    get_name: (volume: Volume) => string | null
    get_icon: (volume: Volume) => Icon
    get_uuid: (volume: Volume) => string | null
    get_drive: (volume: Volume) => Drive | null
    get_mount: (volume: Volume) => Mount | null
    can_mount: (volume: Volume) => boolean
    can_eject: (volume: Volume) => boolean
    mount_fn: (volume: Volume, flags: MountMountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    mount_finish: (volume: Volume, result: AsyncResult) => boolean
    eject: (volume: Volume, flags: MountUnmountFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    eject_finish: (volume: Volume, result: AsyncResult) => boolean
    get_identifier: (volume: Volume, kind: string | null) => string | null
    enumerate_identifiers: (volume: Volume) => string[]
    should_automount: (volume: Volume) => boolean
    get_activation_root: (volume: Volume) => File | null
    eject_with_operation: (volume: Volume, flags: MountUnmountFlags, mount_operation: MountOperation | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null) => void
    eject_with_operation_finish: (volume: Volume, result: AsyncResult) => boolean
    get_sort_key: (volume: Volume) => string | null
    get_symbolic_icon: (volume: Volume) => Icon
}

/**
 * Interface for implementing operations for mountable volumes.
 * @record 
 */
abstract class VolumeIface {

    // Own properties of Gio-2.0.Gio.VolumeIface

    static name: string
}

interface VolumeMonitorClass {

    // Own fields of Gio-2.0.Gio.VolumeMonitorClass

    parent_class: GObject.ObjectClass
    volume_added: (volume_monitor: VolumeMonitor, volume: Volume) => void
    volume_removed: (volume_monitor: VolumeMonitor, volume: Volume) => void
    volume_changed: (volume_monitor: VolumeMonitor, volume: Volume) => void
    mount_added: (volume_monitor: VolumeMonitor, mount: Mount) => void
    mount_removed: (volume_monitor: VolumeMonitor, mount: Mount) => void
    mount_pre_unmount: (volume_monitor: VolumeMonitor, mount: Mount) => void
    mount_changed: (volume_monitor: VolumeMonitor, mount: Mount) => void
    drive_connected: (volume_monitor: VolumeMonitor, drive: Drive) => void
    drive_disconnected: (volume_monitor: VolumeMonitor, drive: Drive) => void
    drive_changed: (volume_monitor: VolumeMonitor, drive: Drive) => void
    is_supported: () => boolean
    get_connected_drives: (volume_monitor: VolumeMonitor) => Drive[]
    get_volumes: (volume_monitor: VolumeMonitor) => Volume[]
    get_mounts: (volume_monitor: VolumeMonitor) => Mount[]
    get_volume_for_uuid: (volume_monitor: VolumeMonitor, uuid: string | null) => Volume | null
    get_mount_for_uuid: (volume_monitor: VolumeMonitor, uuid: string | null) => Mount | null
    drive_eject_button: (volume_monitor: VolumeMonitor, drive: Drive) => void
    drive_stop_button: (volume_monitor: VolumeMonitor, drive: Drive) => void
}

abstract class VolumeMonitorClass {

    // Own properties of Gio-2.0.Gio.VolumeMonitorClass

    static name: string
}

interface ZlibCompressorClass {

    // Own fields of Gio-2.0.Gio.ZlibCompressorClass

    parent_class: GObject.ObjectClass
}

abstract class ZlibCompressorClass {

    // Own properties of Gio-2.0.Gio.ZlibCompressorClass

    static name: string
}

interface ZlibDecompressorClass {

    // Own fields of Gio-2.0.Gio.ZlibDecompressorClass

    parent_class: GObject.ObjectClass
}

abstract class ZlibDecompressorClass {

    // Own properties of Gio-2.0.Gio.ZlibDecompressorClass

    static name: string
}

/**
 * Name of the imported GIR library
 * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
 */
const __name__: string
/**
 * Version of the imported GIR library
 * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
 */
const __version__: string
}

export default Gio;
// END